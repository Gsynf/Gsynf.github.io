<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;6&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/2019-05-16-Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/2019-05-16-Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA_3/" itemprop="url">Python数据分析与展示_3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-16T00:00:00+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-1001870002?tid=1206192225#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="单元7：Pandas库入门"><a href="#单元7：Pandas库入门" class="headerlink" title="单元7：Pandas库入门"></a>单元7：Pandas库入门</h1><p>Pandas是提供高性能易用数据类型和分析工具的第三方python库，可以说是基于Numpy库。<br>import pandas as pd<br>Pandas提供两个数据类型：Series(一维)、DataFrame(二维及多维)，基于这两种数据类型，可以进行基本操作、运算操作、特征类操作、关联类操作等。</p>
<h2 id="Series数据类型"><a href="#Series数据类型" class="headerlink" title="Series数据类型"></a>Series数据类型</h2><p>Series类型由一组数据及与之相关的数据索引组成，索引与数据一一对应，索引可以自定义。</p>
<h3 id="Series类型的创建"><a href="#Series类型的创建" class="headerlink" title="Series类型的创建"></a>Series类型的创建</h3><ol>
<li>从Python列表创建，index与列表元素个数一致；</li>
<li>从标量值创建，此时不能省略index；</li>
<li>从字典类型创建，将字典直接赋给series；</li>
<li>从adarray类型创建；</li>
</ol>
<h3 id="Series类型的基本操作"><a href="#Series类型的基本操作" class="headerlink" title="Series类型的基本操作"></a>Series类型的基本操作</h3><p>由index和values两部分构成，操作类似于ndarray类型，也类似于Python字典类型。需要注意的是，numpy是基于维度的运算，而series是基于索引的运算。</p>
<h2 id="DataFrame数据类型"><a href="#DataFrame数据类型" class="headerlink" title="DataFrame数据类型"></a>DataFrame数据类型</h2><p>DataFrame类型是由共同相同索引的一组列组成。其实是一个表格型的数据类型，每列值类型可以不同。其中既有行索引（index,axis=0），也有列索引(column,axis=1)。常用来表达二维数据。</p>
<h3 id="DataFrame类型的创建"><a href="#DataFrame类型的创建" class="headerlink" title="DataFrame类型的创建"></a>DataFrame类型的创建</h3><ol>
<li>从二维ndarray创建；</li>
<li>从一维ndarray对象字典创建；</li>
<li>从列表类型的字典创建；</li>
</ol>
<h2 id="Pandas库数据类型操作"><a href="#Pandas库数据类型操作" class="headerlink" title="Pandas库数据类型操作"></a>Pandas库数据类型操作</h2><h3 id="改变Series和DataFrame对象"><a href="#改变Series和DataFrame对象" class="headerlink" title="改变Series和DataFrame对象"></a>改变Series和DataFrame对象</h3><p>增加或者重排：重新索引，通过.reindex()函数实现<br>删除：.drop()</p>
<h2 id="Pandas库数据类型运算"><a href="#Pandas库数据类型运算" class="headerlink" title="Pandas库数据类型运算"></a>Pandas库数据类型运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>算术运算根据行列索引，补齐后运算，补齐时缺项填充NaN(空值)，运算默认产生浮点数，采用+-*/符号进行运算的二元运算将会产生新的对象，还可以使用方法形式进行运算，如.add()、.sub()、.mul()、.div()，这些均可以选择参数。<br>不同维度间的运算采用广播运算，默认在1轴。</p>
<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p>比较运算只能比较相同索引的元素，不进行补齐，采用&gt;&lt;&gt;=&lt;=!=等符号进行运算的二元运算将会产生布尔对象。<br>不同维度间的运算采用广播运算，默认在1轴。</p>
<h1 id="单元8：Pandas数据特征分析"><a href="#单元8：Pandas数据特征分析" class="headerlink" title="单元8：Pandas数据特征分析"></a>单元8：Pandas数据特征分析</h1><h2 id="数据的排序"><a href="#数据的排序" class="headerlink" title="数据的排序"></a>数据的排序</h2><p>.sort_index(axis=0,ascending=True)方法在指定轴上根据<strong>索引</strong>进行排序，默认升序。<br>.sort_values(axis=0,ascending=True)方法在指定轴上根据<strong>数值</strong>进行排序，默认升序。</p>
<h2 id="数据的基本统计分析"><a href="#数据的基本统计分析" class="headerlink" title="数据的基本统计分析"></a>数据的基本统计分析</h2><p>基本同numpy相同。<br>.describe()方法可以针对0轴（各列）做统计汇总，包括非空计数、均值、方差等。</p>
<h2 id="数据的累计统计分析"><a href="#数据的累计统计分析" class="headerlink" title="数据的累计统计分析"></a>数据的累计统计分析</h2><p>.cumsum()、.cumprod()、.cummax()、.cummin()，分别为依次给出前1、2、……、n个数的和、积、最大值、最小值。</p>
<p>滚动计算（窗口计算）：<br>.rolling(w).sum()、.rolling(w).mean()、.rolling(w).var()、.rolling(w).std()、.rolling(w).min()、.rolling(w).max(),分别为依次给出x相邻w个元素的和、平均值、方差、标准差、最大值、最小值。</p>
<h2 id="数据的相关分析"><a href="#数据的相关分析" class="headerlink" title="数据的相关分析"></a>数据的相关分析</h2><p>.cov()，计算协方差矩阵；<br>.corr()，计算相关系数矩阵，Pearson、Spearman、Kendall等系数；</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/2019-05-16-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/2019-05-16-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_2/" itemprop="url">Python语言程序设计_2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-16T00:00:00+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="turtle库"><a href="#turtle库" class="headerlink" title="turtle库"></a>turtle库</h1><p>turtle（海龟）是turtle绘图体系的Python实现，是Python的标准库之一，使用RGB色彩模式。</p>
<h2 id="空间坐标系"><a href="#空间坐标系" class="headerlink" title="空间坐标系"></a>空间坐标系</h2><p>画布上以中心为原点的空间坐标系：绝对坐标&amp;海龟坐标。</p>
<h2 id="角度坐标系"><a href="#角度坐标系" class="headerlink" title="角度坐标系"></a>角度坐标系</h2><p>画布上以空间x轴为0度的角度坐标系：绝对角度&amp;海龟角度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#PythonDraw.py，绘制“蟒蛇”</span><br><span class="line">import turtle</span><br><span class="line">turtle.setup(650, 350, 200, 200)</span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.fd(-250)</span><br><span class="line">turtle.pendown()</span><br><span class="line">turtle.pensize(25)</span><br><span class="line">turtle.pencolor(&quot;purple&quot;)</span><br><span class="line">turtle.seth(-40)</span><br><span class="line">for i in range(4):</span><br><span class="line">    turtle.circle(40, 80)</span><br><span class="line">    turtle.circle(-40, 80)</span><br><span class="line">turtle.circle(40, 80/2)</span><br><span class="line">turtle.fd(40)</span><br><span class="line">turtle.circle(16, 180)</span><br><span class="line">turtle.fd(40 * 2/3)</span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<h1 id="库引用"><a href="#库引用" class="headerlink" title="库引用"></a>库引用</h1><p>扩充Python程序功能的方式。</p>
<ol>
<li>使用import保留字完成</li>
</ol>
<pre><code>import &lt;库名&gt;
&lt;库名&gt;.&lt;函数名&gt;（&lt;函数参数&gt;）</code></pre><ol start="2">
<li>使用from和import保留字完成</li>
</ol>
<pre><code>from &lt;库名&gt; import &lt;函数名&gt;
from &lt;库名&gt; import *
&lt;函数名&gt;（&lt;函数参数&gt;）</code></pre><ol start="3">
<li>使用as和import保留字完成</li>
</ol>
<pre><code>import &lt;库名&gt; as &lt;库别名&gt;
&lt;库别名&gt;.&lt;函数名&gt;（&lt;函数参数&gt;）</code></pre><p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/2019-05-15-Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/2019-05-15-Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA_2/" itemprop="url">Python数据分析与展示_2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-15T00:00:00+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-1001870002?tid=1206192225#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="单元4：matplotlib库入门"><a href="#单元4：matplotlib库入门" class="headerlink" title="单元4：matplotlib库入门"></a>单元4：matplotlib库入门</h1><p>matplotlib是python优秀的数据可视化第三方库，想法源于matlab(所以个人感觉用法也很像)。<br>matplotlib.pyplot是绘制各类可视化图像的命令子库，相当于快捷方式。import matplotlib.pyplot as plt。</p>
<h2 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a>plot函数</h2><p>plt.plot(x,y,format_string,**kwargs)<br>x:X轴数据，列表或数组，可选。<br>y:Y轴数据，列表或数组.<br>format_string:控制曲线的格式化字符串，可选，由颜色字符color、风格字符linestyle、标记字符marker组成。</p>
<p>**kwargs：第二组或者多组(x,y,format_string）</p>
<h2 id="pyplot的中文显示"><a href="#pyplot的中文显示" class="headerlink" title="pyplot的中文显示"></a>pyplot的中文显示</h2><p>pyplot默认并不支持中文显示，</p>
<ol>
<li>改变全局字体，需要rcParams修改字体实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">matplotlib.rcParams[&apos;font.family&apos;]=&apos;SimHei&apos;</span><br><span class="line">matplotlib.rcParams[&apos;font.size&apos;]=20</span><br><span class="line">plt.xlabel(&apos;横轴：时间&apos;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>font.family:字体名称；<br>font.style:字体风格，斜体’italie’;<br>font.size:字体大小，整数字号或者’large’、’x-small’;</p>
<ol start="2">
<li>改变局部字体，在有中文输出的地方，增加一个属性：fontproperties<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(&apos;横轴：时间&apos;，fontproperties=&apos;SimHei&apos;,fontsize=20)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="pyplot的文本显示"><a href="#pyplot的文本显示" class="headerlink" title="pyplot的文本显示"></a>pyplot的文本显示</h2><p>plt.xlable/plt.ylable/plt.title/plt.text/plt.annotate(在图形中增加戴箭头的注释)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.annotate(s,xy=arrow_crd,xytext=text_crd,arrowprops=dict)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/05/15/5cdb7cc11ecc069534.png" alt="annotate"></p>
<h2 id="pyplot的子绘图区域"><a href="#pyplot的子绘图区域" class="headerlink" title="pyplot的子绘图区域"></a>pyplot的子绘图区域</h2><p><img src="https://i.loli.net/2019/05/15/5cdb8182cc74b24680.png" alt="subplot2gird"></p>
<p><img src="https://i.loli.net/2019/05/15/5cdb81c122aee50154.png" alt="girdspec"></p>
<h1 id="单元5：matplotlib库基础绘图函数示例"><a href="#单元5：matplotlib库基础绘图函数示例" class="headerlink" title="单元5：matplotlib库基础绘图函数示例"></a>单元5：matplotlib库基础绘图函数示例</h1><h2 id="pyplot饼图的绘制"><a href="#pyplot饼图的绘制" class="headerlink" title="pyplot饼图的绘制"></a>pyplot饼图的绘制</h2><p>函数：plt.pie<br><img src="https://i.loli.net/2019/05/15/5cdbc2efb6e9181159.png" alt="饼图"></p>
<h2 id="pyplot直方图的绘制"><a href="#pyplot直方图的绘制" class="headerlink" title="pyplot直方图的绘制"></a>pyplot直方图的绘制</h2><p>函数：plt.hist<br><img src="https://i.loli.net/2019/05/15/5cdbc63b4486b28677.png" alt="直方图"></p>
<h2 id="pyplot极坐标图的绘制"><a href="#pyplot极坐标图的绘制" class="headerlink" title="pyplot极坐标图的绘制"></a>pyplot极坐标图的绘制</h2><p><img src="https://i.loli.net/2019/05/15/5cdbc69b4bc6355879.png" alt="极坐标图"></p>
<h2 id="pyplot散点图的绘制"><a href="#pyplot散点图的绘制" class="headerlink" title="pyplot散点图的绘制"></a>pyplot散点图的绘制</h2><p><img src="https://i.loli.net/2019/05/15/5cdbc6e79836f32001.png" alt="散点图"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/14/2019-05-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/2019-05-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10/" itemprop="url">数据结构_10</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-14T00:00:00+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h1><p>查找对象时，静态查找可以用二分查找，动态查找可以建树，但是比对的过程是数的话可以，如果是字符串的话就比较费时，那么能否把字符串映射为数字呢？这就是散列表。</p>
<p>查找的本质：已知对象找位置。</p>
<ul>
<li>有序安排对象：全序、半序；</li>
<li>直接”算出”对象位置：散列；</li>
</ul>
<p>散列查找的两项基本工作：</p>
<ul>
<li>计算位置：构造散列函数确定关键词存储位置；</li>
<li>解决冲突：应用某种策略解决多个关键字位置相同的问题；</li>
</ul>
<p>“散列（Hashing）”的基本思想：<br>1）以关键字key为自变量，通过一个确定的函数h计算出对应的函数值h(key)，作为数据对象的存储地址。<br>2）可能不同的关键字会映射到同一个散列地址上，称为”冲突”，需要冲突解决策略。</p>
<h1 id="散列函数构造方法"><a href="#散列函数构造方法" class="headerlink" title="散列函数构造方法"></a>散列函数构造方法</h1><p>考虑因素：</p>
<ol>
<li>计算简单，以便提高转换效率</li>
<li>关键字对应的地址空间分布均匀，以尽量减少冲突</li>
</ol>
<h2 id="数字关键字"><a href="#数字关键字" class="headerlink" title="数字关键字"></a>数字关键字</h2><ol>
<li>直接定制法</li>
<li>除留余数法</li>
<li>数字分析法</li>
<li>折叠法</li>
<li>平方取中法</li>
</ol>
<h2 id="字符关键字"><a href="#字符关键字" class="headerlink" title="字符关键字"></a>字符关键字</h2><ol>
<li>简单方法-ASCII码加和法</li>
<li>简单改进法-前三个字符移位法</li>
<li>好的方法-全部字符移位法</li>
</ol>
<h1 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h1><p>常见思路：</p>
<ul>
<li>换个位置：开放地址法</li>
<li>同一位置的冲突对象组织在一起：链地址法</li>
</ul>
<h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><ol>
<li>线性探测法</li>
<li>平方探测法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#define MAXTABLESIZE 100000 /* 允许开辟的最大散列表长度 */</span><br><span class="line">typedef int ElementType;    /* 关键词类型用整型 */</span><br><span class="line">typedef int Index;          /* 散列地址类型 */</span><br><span class="line">typedef Index Position;     /* 数据所在位置与散列地址是同一类型 */</span><br><span class="line">/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */</span><br><span class="line">typedef enum &#123; Legitimate, Empty, Deleted &#125; EntryType;</span><br><span class="line"> </span><br><span class="line">typedef struct HashEntry Cell; /* 散列表单元类型 */</span><br><span class="line">struct HashEntry&#123;</span><br><span class="line">    ElementType Data; /* 存放元素 */</span><br><span class="line">    EntryType Info;   /* 单元状态 */</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">typedef struct TblNode *HashTable; /* 散列表类型 */</span><br><span class="line">struct TblNode &#123;   /* 散列表结点定义 */</span><br><span class="line">    int TableSize; /* 表的最大长度 */</span><br><span class="line">    Cell *Cells;   /* 存放散列单元数据的数组 */</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int NextPrime( int N )</span><br><span class="line">&#123; /* 返回大于N且不超过MAXTABLESIZE的最小素数 */</span><br><span class="line">    int i, p = (N%2)? N+2 : N+1; /*从大于N的下一个奇数开始 */</span><br><span class="line"> </span><br><span class="line">    while( p &lt;= MAXTABLESIZE ) &#123;</span><br><span class="line">        for( i=(int)sqrt(p); i&gt;2; i-- )</span><br><span class="line">            if ( !(p%i) ) break; /* p不是素数 */</span><br><span class="line">        if ( i==2 ) break; /* for正常结束，说明p是素数 */</span><br><span class="line">        else  p += 2; /* 否则试探下一个奇数 */</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">HashTable CreateTable( int TableSize )</span><br><span class="line">&#123;</span><br><span class="line">    HashTable H;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    H = (HashTable)malloc(sizeof(struct TblNode));</span><br><span class="line">    /* 保证散列表最大长度是素数 */</span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">    /* 声明单元数组 */</span><br><span class="line">    H-&gt;Cells = (Cell *)malloc(H-&gt;TableSize*sizeof(Cell));</span><br><span class="line">    /* 初始化单元状态为“空单元” */</span><br><span class="line">    for( i=0; i&lt;H-&gt;TableSize; i++ )</span><br><span class="line">        H-&gt;Cells[i].Info = Empty;</span><br><span class="line"> </span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Position Find( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position CurrentPos, NewPos;</span><br><span class="line">    int CNum = 0; /* 记录冲突次数 */</span><br><span class="line"> </span><br><span class="line">    NewPos = CurrentPos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */</span><br><span class="line">    /* 当该位置的单元非空，并且不是要找的元素时，发生冲突 */</span><br><span class="line">    while( H-&gt;Cells[NewPos].Info!=Empty &amp;&amp; H-&gt;Cells[NewPos].Data!=Key ) &#123;</span><br><span class="line">                                           /* 字符串类型的关键词需要 strcmp 函数!! */</span><br><span class="line">        /* 统计1次冲突，并判断奇偶次 */</span><br><span class="line">        if( ++CNum%2 )&#123; /* 奇数次冲突 */</span><br><span class="line">            NewPos = CurrentPos + (CNum+1)*(CNum+1)/4; /* 增量为+[(CNum+1)/2]^2 */</span><br><span class="line">            if ( NewPos &gt;= H-&gt;TableSize )</span><br><span class="line">                NewPos = NewPos % H-&gt;TableSize; /* 调整为合法地址 */</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; /* 偶数次冲突 */</span><br><span class="line">            NewPos = CurrentPos - CNum*CNum/4; /* 增量为-(CNum/2)^2 */</span><br><span class="line">            while( NewPos &lt; 0 )</span><br><span class="line">                NewPos += H-&gt;TableSize; /* 调整为合法地址 */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NewPos; /* 此时NewPos或者是Key的位置，或者是一个空单元的位置（表示找不到）*/</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool Insert( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position Pos = Find( H, Key ); /* 先检查Key是否已经存在 */</span><br><span class="line"> </span><br><span class="line">    if( H-&gt;Cells[Pos].Info != Legitimate ) &#123; /* 如果这个单元没有被占，说明Key可以插入在此 */</span><br><span class="line">        H-&gt;Cells[Pos].Info = Legitimate;</span><br><span class="line">        H-&gt;Cells[Pos].Data = Key;</span><br><span class="line">        /*字符串类型的关键词需要 strcpy 函数!! */</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;键值已存在&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>双散列探测法</li>
<li>再散列</li>
</ol>
<h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>将相同位置上冲突的所有关键词存储在同一个单链表中。</p>
<h1 id="散列表性能分析"><a href="#散列表性能分析" class="headerlink" title="散列表性能分析"></a>散列表性能分析</h1><p>指标：平均查找长度（ASL）用来衡量散列表的查找效率：成功、不成功<br>关键词的比较次数，取决于产生冲突的多少，影响产生冲突多少有以下三个因素：</p>
<ol>
<li>散列函数是否均匀</li>
<li>处理冲突的方法</li>
<li>散列表的装填因子α，应在0.5-0.85之间</li>
</ol>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/2019-05-13-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/2019-05-13-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9/" itemprop="url">数据结构_9</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-13T00:00:00+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。<br>这里只讨论内部排序，即默认内存空间足够大，可以存放下所有需要排序的数据。</p>
</blockquote>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>策略：分而治之<br>步骤：从待排数组中找一个主元pivot，按照比主元大和比主元小将数组分为两个数集再分别递归调用，进行排序。<br>最好情况：每次选的主元都正好是中分，T(N)=O(N logN)<br>选主元：方法很多，例如取头中尾三个数的中位数等<br>适用情况：大规模数据，如果是小规模数据，使用递归可能更费时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/* 快速排序 - 直接调用库函数 */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">/*---------------简单整数排序--------------------*/</span><br><span class="line">int compare(const void *a, const void *b)</span><br><span class="line">&#123; /* 比较两整数。非降序排列 */</span><br><span class="line">    return (*(int*)a - *(int*)b);</span><br><span class="line">&#125;</span><br><span class="line">/* 调用接口 */ </span><br><span class="line">qsort(A, N, sizeof(int), compare);</span><br><span class="line">/*---------------简单整数排序--------------------*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*/</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key1, key2;</span><br><span class="line">&#125; A[MAXN];</span><br><span class="line">  </span><br><span class="line">int compare2keys(const void *a, const void *b)</span><br><span class="line">&#123; /* 比较两种键值：按key1非升序排列；如果key1相等，则按key2非降序排列 */</span><br><span class="line">    int k;</span><br><span class="line">    if ( ((const struct Node*)a)-&gt;key1 &lt; ((const struct Node*)b)-&gt;key1 )</span><br><span class="line">        k = 1;</span><br><span class="line">    else if ( ((const struct Node*)a)-&gt;key1 &gt; ((const struct Node*)b)-&gt;key1 )</span><br><span class="line">        k = -1;</span><br><span class="line">    else &#123; /* 如果key1相等 */</span><br><span class="line">        if ( ((const struct Node*)a)-&gt;key2 &lt; ((const struct Node*)b)-&gt;key2 )</span><br><span class="line">            k = -1;</span><br><span class="line">        else</span><br><span class="line">            k = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">/* 调用接口 */ </span><br><span class="line">qsort(A, N, sizeof(struct Node), compare2keys);</span><br><span class="line">/*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* 快速排序 */</span><br><span class="line"> </span><br><span class="line">ElementType Median3( ElementType A[], int Left, int Right )</span><br><span class="line">&#123; </span><br><span class="line">    int Center = (Left+Right) / 2;</span><br><span class="line">    if ( A[Left] &gt; A[Center] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Center] );</span><br><span class="line">    if ( A[Left] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Right] );</span><br><span class="line">    if ( A[Center] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Center], &amp;A[Right] );</span><br><span class="line">    /* 此时A[Left] &lt;= A[Center] &lt;= A[Right] */</span><br><span class="line">    Swap( &amp;A[Center], &amp;A[Right-1] ); /* 将基准Pivot藏到右边*/</span><br><span class="line">    /* 只需要考虑A[Left+1] … A[Right-2] */</span><br><span class="line">    return  A[Right-1];  /* 返回基准Pivot */</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Qsort( ElementType A[], int Left, int Right )</span><br><span class="line">&#123; /* 核心递归函数 */ </span><br><span class="line">     int Pivot, Cutoff, Low, High;</span><br><span class="line">       </span><br><span class="line">     if ( Cutoff &lt;= Right-Left ) &#123; /* 如果序列元素充分多，进入快排 */</span><br><span class="line">          Pivot = Median3( A, Left, Right ); /* 选基准 */ </span><br><span class="line">          Low = Left; High = Right-1;</span><br><span class="line">          while (1) &#123; /*将序列中比基准小的移到基准左边，大的移到右边*/</span><br><span class="line">               while ( A[++Low] &lt; Pivot ) ;</span><br><span class="line">               while ( A[--High] &gt; Pivot ) ;</span><br><span class="line">               if ( Low &lt; High ) Swap( &amp;A[Low], &amp;A[High] );</span><br><span class="line">               else break;</span><br><span class="line">          &#125;</span><br><span class="line">          Swap( &amp;A[Low], &amp;A[Right-1] );   /* 将基准换到正确的位置 */ </span><br><span class="line">          Qsort( A, Left, Low-1 );    /* 递归解决左边 */ </span><br><span class="line">          Qsort( A, Low+1, Right );   /* 递归解决右边 */  </span><br><span class="line">     &#125;</span><br><span class="line">     else InsertionSort( A+Left, Right-Left+1 ); /* 元素太少，用简单排序 */ </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void QuickSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 统一接口 */</span><br><span class="line">     Qsort( A, 0, N-1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h1><p>表排序是一种间接排序算法，定义一个指针数组作为“表”（table）<br><img src="https://i.loli.net/2019/05/14/5cda2bcef36b512015.png" alt="表排序"></p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p><img src="https://i.loli.net/2019/05/14/5cda2dfbcc17e29869.png" alt="基数排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序 - 次位优先 */</span><br><span class="line"> </span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"> </span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line">  </span><br><span class="line">int GetDigit ( int X, int D )</span><br><span class="line">&#123; /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line">     </span><br><span class="line">    for (i=1; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void LSDRadixSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 基数排序 - 次位优先 */</span><br><span class="line">     int D, Di, i;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = NULL; </span><br><span class="line">      </span><br><span class="line">     for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">         B[i].head = B[i].tail = NULL;</span><br><span class="line">     for (i=0; i&lt;N; i++) &#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">         tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面开始排序 */ </span><br><span class="line">     for (D=1; D&lt;=MaxDigit; D++) &#123; /* 对数据的每一位循环处理 */</span><br><span class="line">         /* 下面是分配的过程 */</span><br><span class="line">         p = List;</span><br><span class="line">         while (p) &#123;</span><br><span class="line">             Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */</span><br><span class="line">             /* 从List中摘除 */</span><br><span class="line">             tmp = p; p = p-&gt;next;</span><br><span class="line">             /* 插入B[Di]号桶尾 */</span><br><span class="line">             tmp-&gt;next = NULL;</span><br><span class="line">             if (B[Di].head == NULL)</span><br><span class="line">                 B[Di].head = B[Di].tail = tmp;</span><br><span class="line">             else &#123;</span><br><span class="line">                 B[Di].tail-&gt;next = tmp;</span><br><span class="line">                 B[Di].tail = tmp;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         /* 下面是收集的过程 */</span><br><span class="line">         List = NULL; </span><br><span class="line">         for (Di=Radix-1; Di&gt;=0; Di--) &#123; /* 将每个桶的元素顺序收集入List */</span><br><span class="line">             if (B[Di].head) &#123; /* 如果桶不为空 */</span><br><span class="line">                 /* 整桶插入List表头 */</span><br><span class="line">                 B[Di].tail-&gt;next = List;</span><br><span class="line">                 List = B[Di].head;</span><br><span class="line">                 B[Di].head = B[Di].tail = NULL; /* 清空桶 */</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 将List倒入A[]并释放空间 */</span><br><span class="line">     for (i=0; i&lt;N; i++) &#123;</span><br><span class="line">        tmp = List;</span><br><span class="line">        List = List-&gt;next;</span><br><span class="line">        A[i] = tmp-&gt;key;</span><br><span class="line">        free(tmp);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序 - 主位优先 */</span><br><span class="line"> </span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line"> </span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"> </span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line">  </span><br><span class="line">int GetDigit ( int X, int D )</span><br><span class="line">&#123; /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line">     </span><br><span class="line">    for (i=1; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X%Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MSD( ElementType A[], int L, int R, int D )</span><br><span class="line">&#123; /* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */</span><br><span class="line">     int Di, i, j;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = NULL; </span><br><span class="line">     if (D==0) return; /* 递归终止条件 */</span><br><span class="line">      </span><br><span class="line">     for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">         B[i].head = B[i].tail = NULL;</span><br><span class="line">     for (i=L; i&lt;=R; i++) &#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">         tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面是分配的过程 */</span><br><span class="line">     p = List;</span><br><span class="line">     while (p) &#123;</span><br><span class="line">         Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */</span><br><span class="line">         /* 从List中摘除 */</span><br><span class="line">         tmp = p; p = p-&gt;next;</span><br><span class="line">         /* 插入B[Di]号桶 */</span><br><span class="line">         if (B[Di].head == NULL) B[Di].tail = tmp;</span><br><span class="line">         tmp-&gt;next = B[Di].head;</span><br><span class="line">         B[Di].head = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面是收集的过程 */</span><br><span class="line">     i = j = L; /* i, j记录当前要处理的A[]的左右端下标 */</span><br><span class="line">     for (Di=0; Di&lt;Radix; Di++) &#123; /* 对于每个桶 */</span><br><span class="line">         if (B[Di].head) &#123; /* 将非空的桶整桶倒入A[], 递归排序 */</span><br><span class="line">             p = B[Di].head;</span><br><span class="line">             while (p) &#123;</span><br><span class="line">                 tmp = p;</span><br><span class="line">                 p = p-&gt;next;</span><br><span class="line">                 A[j++] = tmp-&gt;key;</span><br><span class="line">                 free(tmp);</span><br><span class="line">             &#125;</span><br><span class="line">             /* 递归对该桶数据排序, 位数减1 */</span><br><span class="line">             MSD(A, i, j-1, D-1);</span><br><span class="line">             i = j; /* 为下一个桶对应的A[]左端 */</span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MSDRadixSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 统一接口 */</span><br><span class="line">    MSD(A, 0, N-1, MaxDigit); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h1><p><img src="https://i.loli.net/2019/05/14/5cda2f24f15e577385.png" alt="排序算法比较"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/2019-05-12-R-CNN%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/2019-05-12-R-CNN%E7%B3%BB%E5%88%97/" itemprop="url">R-CNN系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-12T00:00:00+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在解析Mask R-CNN之前，不得不告诉大家一个事实，Mask R-CNN是继承于Faster R-CNN (2016)的，Mask R-CNN只是在Faster R-CNN上面加了一个Mask Prediction Branch (Mask 预测分支)，并且改良了ROI Pooling，提出了ROI Align。所以，在解析Mask R-CNN之前，先给大家分析一下Faster R-CNN。<br>在给大家解析Faster R-CNN之前，又要告诉大家，Faster R-CNN是继承于Fast R-CNN (2015)，Fast R-CNN继承于R-CNN (2014)。因此，索性破釜沉舟，在本篇博文中，就按照R-CNN, Fast R-CNN，Faster R-CNN再到Mask R-CNN的发展顺序全部解析。</p>
</blockquote>
<h1 id="1-R-CNN"><a href="#1-R-CNN" class="headerlink" title="1. R-CNN"></a>1. R-CNN</h1><p>简单来说，R-CNN首先模型输入为一张图片，然后在图片上提出了约2000个待检测区域，然后这2000个待检测区域一个一个地(串联方式)通过卷积神经网络提取特征，然后这些被提取的特征通过一个支持向量机(SVM)进行分类，得到物体的类别，并通过一个bounding box regression调整目标包围框的大小。<br>具体步骤分为四步：</p>
<ol>
<li>候选区域提出阶段（Proposal）：采用selective-search方法，从一幅图像生成1K~2K个候选区域；</li>
<li>特征提取：对每个候选区域，使用CNN进行特征提取；</li>
<li>分类：每个候选区域的特征放入分类器SVM，得到该候选区域的分类结果；</li>
<li>回归：候选区域的特征放入回归器，得到bbox的修正量。</li>
</ol>
<h2 id="1-1-候选区域提出阶段所产生的结果尺寸不同？"><a href="#1-1-候选区域提出阶段所产生的结果尺寸不同？" class="headerlink" title="1.1 候选区域提出阶段所产生的结果尺寸不同？"></a>1.1 候选区域提出阶段所产生的结果尺寸不同？</h2><p>由于RCNN特征提取阶段采用的是AlexNet，其最后两层是全连接层fc6和fc7，所以必须保证输入的图片尺寸相同。</p>
<p>而候选区域所产生的结果尺寸是不相同的。为此，论文中作者采用了多种方式对图片进行放缩（各向同性、各向异性、加padding），最后经过对比实验确定各向异性加padding的放缩方式效果最好。各向同性、各向异性、加padding的具体效果可以看上面链接中的文章。</p>
<h2 id="1-2-分类器SVM使用的是二分类？"><a href="#1-2-分类器SVM使用的是二分类？" class="headerlink" title="1.2 分类器SVM使用的是二分类？"></a>1.2 分类器SVM使用的是二分类？</h2><p>论文中，单个SVM实现的是二分类，分类器阶段由多个SVM组合而成。比如总共有20种不同的物体（加1种背景），那么分类阶段必须要有21个SVM：第1个SVM的输出是该候选区域属于分类1的概率；第2个SVM的输出是该候选区域属于分类2的概率；……；第21个SVM的输出是该候选区域属于背景的概率。</p>
<p>对21个SVM的输出结果进行排序，哪个输出最大，候选区域就属于哪一类。比如，对于某个候选区域，第21个SVM的输出最大，那么就将该候选区域标为背景。</p>
<h2 id="1-3-分类器的输入是？回归器的输入是？"><a href="#1-3-分类器的输入是？回归器的输入是？" class="headerlink" title="1.3 分类器的输入是？回归器的输入是？"></a>1.3 分类器的输入是？回归器的输入是？</h2><p>分类器的输入是特征提取器AlexNet的fc6的输出结果，回归器的输入是特征提取器AlexNet的pool5的输出结果。</p>
<p>之所以这样取输入，是因为，分类器不依赖坐标信息，所以取fc6全连接层的结果是没有问题的。但是回归器依赖坐标信息（要输出坐标的修正量），必须取坐标信息还没有丢失前的层。而fc6全连接层已经丢失了坐标信息。</p>
<h2 id="1-4-正负样本的选择？"><a href="#1-4-正负样本的选择？" class="headerlink" title="1.4 正负样本的选择？"></a>1.4 正负样本的选择？</h2><p>正负样本是必须要考虑的问题。论文的做法是每个batch所采样的正负样本比为1：3。当然这个比例是可以变化的，这个系列的后续改进就把正负样本比变为了1：1。</p>
<p>如果之前没有接触过类似问题的话，是比较容易想当然地认为训练特征提取器、分类器、回归器时，就是把候选区域生成阶段的所有候选区域都放入训练。这样的思路是错的。一张图片中，背景占了绝大多数地方，这样就导致训练用的正样本远远少于负样本，对训练不利。</p>
<p>正确的做法是对所有候选区域进行随机采样，要求采样的结果中正样本有x张，负样本y张，且保证x与y在数值上相近。（对于一些问题，不大容易做到x:y = 1:1，但至少x与y应该在同一数量级下）</p>
<h2 id="1-5-如何训练？"><a href="#1-5-如何训练？" class="headerlink" title="1.5 如何训练？"></a>1.5 如何训练？</h2><p>RCNN的网络架构，注定了它不能像其他网络那样进行端到端（end-to-end）的训练。</p>
<p>前面提到RCNN分为4个阶段：Proposal阶段、特征提取阶段、分类阶段、回归阶段。这4个阶段都是相互独立训练的。</p>
<p>首先，特征提取器是AlexNet，将它的最后一层fc7进行改造，使得fc7能够输出分类结果。Proposal阶段对每张图片产生了1k~2k个候选区域，把这些图片依照正负样本比例喂给特征提取器，特征提取器fc7输出的分类结果与标签结果进行比对，完成特征提取器的训练。特征提取器的训练完成后，fc7层的使命也完成了，后面的分类器和回归器只会用到fc6、pool5的输出。</p>
<p>然后，Proposal和特征提取器已经训练完毕了。把它们的结果fc6，输入到分类器SVM中，SVM输出与标签结果比对，完成SVM的训练。</p>
<p>最后，回归器的训练也和SVM类似，只不过回归器取的是pool5的结果。</p>
<p>为什么不能同时进行上面3步的训练？因为特征提取器是CNN，分类器是SVM，回归器是脊回归器，不属于同一体系，无法共同训练。甚至在测试时，也需要把每一阶段的结果先保存到磁盘，再喂入下一阶段。这是非常麻烦的一件事。</p>
<p>聪明的你可能已经想到了：CNN不就能完成分类器和回归器的任务嘛？为什么不只用CNN？这就是RCNN系列后续做的改进之一，我们在下面会讲到。但由于某些原因，在RCNN这篇论文发表时，采用的是特征提取、分类器、回归器相互独立的结构。</p>
<h2 id="1-6-Proposal的每个候选区域单独提取特征，是不是很慢？"><a href="#1-6-Proposal的每个候选区域单独提取特征，是不是很慢？" class="headerlink" title="1.6 Proposal的每个候选区域单独提取特征，是不是很慢？"></a>1.6 Proposal的每个候选区域单独提取特征，是不是很慢？</h2><p>是的，很慢。Proposal阶段会产生1k<del>2k个候选区域，每个候选区域都独立提取特征的话，那相当于每幅图片都要进行1k</del>2k次CNN。（当然由于有正负样本采样，实际并没有有这么多）</p>
<p>有没有什么好方法？聪明的你应该能想到：既然候选区域都是图片的一部分，那么先对整张图片进行特征提取，然后根据每个候选区域在原图上的位置选择相应的特征不就行了。</p>
<p>这种方式正是RCNN系列的后续改进之一，只不过在实现上要动点脑筋。（这种方式得到的每个区域的特征数目是不同的，如何把不同特征数目变为相同数目？）</p>
<h1 id="2-Fast-RCNN"><a href="#2-Fast-RCNN" class="headerlink" title="2. Fast-RCNN"></a>2. Fast-RCNN</h1><p>首先还是采用selective search提取2000个候选框，然后，使用一个神经网络对全图进行特征提取。接着，使用一个RoI Pooling Layer在全图特征上摘取每一个RoI对应的特征，再通过全连接层(FC Layer)进行分类与包围框的修正。Fast R-CNN的贡献可以主要分为两个方面：</p>
<p>1) 取代R-CNN的串行特征提取方式，直接采用一个神经网络对全图提取特征(这也是为什么需要RoI Pooling的原因)。<br>2) 除了selective search，其他部分都可以合在一起训练。</p>
<h2 id="2-1-为什么叫Fast？"><a href="#2-1-为什么叫Fast？" class="headerlink" title="2.1 为什么叫Fast？"></a>2.1 为什么叫Fast？</h2><p>将特征提取器、分类器、回归器合并，使得训练过程不需要再将每阶段结果保存磁盘单独训练，可以一次性完成训练，加快了训练速度。这是Fast之一。</p>
<p>对整张图片进行特征提取，用ROI层处理候选区域的特征，使得原本每一个候选区域都要做一次特征提取，变为了现在一整张图片做一次特征提取。训练速度（8.8倍）和测试速度（146倍）都大大加快，这是Fast之二。</p>
<h2 id="2-2-分类器和回归器的实现细节？"><a href="#2-2-分类器和回归器的实现细节？" class="headerlink" title="2.2 分类器和回归器的实现细节？"></a>2.2 分类器和回归器的实现细节？</h2><p>分类器应该都能想到，用的softmax代替SVM。</p>
<p>回归器求出（x,y,w,h）4个量，分别代表定位框左上角的坐标xy、宽度w、高度h，损失函数用的是Smooth-L1。</p>
<h2 id="2-3-Proposal阶段看上去有点违和？"><a href="#2-3-Proposal阶段看上去有点违和？" class="headerlink" title="2.3 Proposal阶段看上去有点违和？"></a>2.3 Proposal阶段看上去有点违和？</h2><p>发展到Fast-RCNN，后续3个阶段都是CNN完成的了，只剩下Proposal阶段还没有用CNN方式解决。Proposal阶段的结果还是需要先保存到磁盘，再喂入后续阶段，有点违和。</p>
<p>RCNN系列后续的改进，将把Proposal阶段也用CNN实现，真正做到端到端（end-to-end）。</p>
<h1 id="3-Faster-RCNN"><a href="#3-Faster-RCNN" class="headerlink" title="3.Faster-RCNN"></a>3.Faster-RCNN</h1><p>Faster-RCNN引入了RPN网络（region proposal network）来代替selective-search。这使得整个网络实现了端到端。</p>
<h2 id="3-1-RPN网络是如何工作的？"><a href="#3-1-RPN网络是如何工作的？" class="headerlink" title="3.1 RPN网络是如何工作的？"></a>3.1 RPN网络是如何工作的？</h2><p>整张图片经过特征提取，得到FeatureMap；将FeatureMap中的每一点按照视野域找到原图中对应的位置，称为Anchor；每个Anchor生成不同大小不同长宽比的多个候选区域。</p>
<p>回忆下selective-search的候选区域生成方式，它是按照颜色和纹理不断合并得到候选区域的，候选区域的产生没有规律，而RPN是每个Anchor都有对应的固定数量的候选区域，规律很明显。</p>
<p>理论上说，selective-search生成候选区域的方式更符合我们的直觉，而实验结果，在Faster-RCNN中RPN并不比selective-search差</p>
<h2 id="3-2-为什么是Faster？"><a href="#3-2-为什么是Faster？" class="headerlink" title="3.2 为什么是Faster？"></a>3.2 为什么是Faster？</h2><p>容易想到，现在RPN网络可以与其他3个阶段共用同一个特征提取结果了，省掉了selective-search的时间。而事实上，selective-search是非常慢的，所以叫Faster。</p>
<h1 id="4-Mask-RCNN"><a href="#4-Mask-RCNN" class="headerlink" title="4.Mask-RCNN"></a>4.Mask-RCNN</h1><h2 id="4-1-为什么叫mask？"><a href="#4-1-为什么叫mask？" class="headerlink" title="4.1 为什么叫mask？"></a>4.1 为什么叫mask？</h2><p>Faster-RCNN网络的最后分别是分类网络和回归网络两条路并行，Mask-RCNN则是再加一条Mask网络与它们并行。</p>
<p>Mask网络的实现是FCN网络，这也是语义分割领域中非常经典的网络结构。</p>
<p>由于Mask网络的加入，Mask-RCNN不仅能处理物体检测问题，还能处理语义分割问题。</p>
<h2 id="4-2-还有哪些细节上的变化？"><a href="#4-2-还有哪些细节上的变化？" class="headerlink" title="4.2 还有哪些细节上的变化？"></a>4.2 还有哪些细节上的变化？</h2><p>首先是ROI层变为了ROIAlign，目的是一样的。那为什么要加入ROIAlign呢？这是因为ROI层会有对齐问题，对齐问题在分类和框选时影响不大，但在语义分割需要严格依赖每个像素点的坐标时，影响会很大。ROIAlign能够解决对齐问题。</p>
<p>然后是特征提取网络改为了ResNet101+FPN；FPN建议对语义分割或者关键点定位感兴趣的同学了解下，FPN是这两个领域中非常经典的结构。</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/2019-05-07-Mask%20R-CNN%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/07/2019-05-07-Mask%20R-CNN%E6%80%BB%E7%BB%93/" itemprop="url">Mask R-CNN总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-07T00:00:00+08:00">
                2019-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文链接：<a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">https://arxiv.org/abs/1703.06870</a><br>目前找到了非常好的一位博客：<a href="https://blog.csdn.net/WZZ18191171661/article/details/79453780，" target="_blank" rel="noopener">https://blog.csdn.net/WZZ18191171661/article/details/79453780，</a> 感谢！<br><a href="https://blog.csdn.net/jiongnima/article/details/79094159，" target="_blank" rel="noopener">https://blog.csdn.net/jiongnima/article/details/79094159，</a> 这个也不错。<br>相关知识介绍：<br>R-CNN-<a href="https://www.jianshu.com/p/5056e6143ed5" target="_blank" rel="noopener">https://www.jianshu.com/p/5056e6143ed5</a>;<br>Faster R-CNN-<a href="https://blog.csdn.net/qq_17448289/article/details/52871461" target="_blank" rel="noopener">https://blog.csdn.net/qq_17448289/article/details/52871461</a><br><a href="https://blog.csdn.net/u011974639/article/details/78053203" target="_blank" rel="noopener">https://blog.csdn.net/u011974639/article/details/78053203</a>, 个人感觉这两篇讲的很好。</p>
</blockquote>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul>
<li>Mask RCNN可以看做是一个通用实例分割架构。</li>
<li>Mask RCNN以Faster RCNN原型，增加了一个分支用于分割任务。</li>
<li>Mask RCNN比Faster RCNN速度慢一些，达到了5fps。</li>
<li>可用于人的姿态估计等其他任务</li>
</ul>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><ul>
<li>实例分割不仅要正确的找到图像中的objects，还要对其精确的分割。所以Instance Segmentation可以看做object dection和semantic segmentation的结合。</li>
<li>Mask RCNN是Faster RCNN的扩展，对于Faster RCNN的每个Proposal Box都要使用FCN进行语义分割，分割任务与定位、分类任务是同时进行的。</li>
<li>引入了RoI Align代替Faster RCNN中的RoI Pooling。因为RoI Pooling并不是按照像素一一对齐的（pixel-to-pixel alignment），也许这对bbox的影响不是很大，但对于mask的精度却有很大影响。使用RoI Align后mask的精度从10%显著提高到50%，第3节将会仔细说明。</li>
<li>引入语义分割分支，实现了mask和class预测的关系的解耦，mask分支只做语义分割，类型预测的任务交给另一个分支。这与原本的FCN网络是不同的，原始的FCN在预测mask时还用同时预测mask所属的种类。</li>
<li>没有使用什么花哨的方法，Mask RCNN就超过了当时所有的state-of-the-art模型。</li>
<li>使用8-GPU的服务器训练了两天。</li>
</ul>
<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2.Related Work"></a>2.Related Work</h1><ul>
<li>相比于FCIS，FCIS使用全卷机网络，同时预测物体classes、boxes、masks，速度更快，但是对于重叠物体的分割效果不好。</li>
</ul>
<h1 id="3-Mask-R-CNN"><a href="#3-Mask-R-CNN" class="headerlink" title="3.Mask R-CNN"></a>3.Mask R-CNN</h1><ul>
<li>Mask R-CNN基本结构：与Faster RCNN采用了相同的two-state步骤：首先是找出RPN，然后对RPN找到的每个RoI进行分类、定位、并找到binary mask。这与当时其他先找到mask然后在进行分类的网络是不同的。</li>
<li>Mask R-CNN的损失函数：L = L<sub>cls</sub> + L<sub>box</sub> + L<sub>mask</sub></li>
<li>Mask的表现形式(Mask Representation)：因为没有采用全连接层并且使用了RoIAlign，可以实现输出与输入的像素一一对应。</li>
<li>RoIAlign：RoIPool的目的是为了从RPN网络确定的ROI中导出较小的特征图(a small feature map，eg 7x7)，ROI的大小各不相同，但是RoIPool后都变成了7x7大小。RPN网络会提出若干RoI的坐标以[x,y,w,h]表示，然后输入RoI Pooling，输出7x7大小的特征图供分类和定位使用。问题就出在RoI Pooling的输出大小是7x7上，如果RON网络输出的RoI大小是8*8的，那么无法保证输入像素和输出像素是一一对应，首先他们包含的信息量不同（有的是1对1，有的是1对2），其次他们的坐标无法和输入对应起来（1对2的那个RoI输出像素该对应哪个输入像素的坐标？）。这对分类没什么影响，但是对分割却影响很大。RoIAlign的输出坐标使用插值算法得到，不再量化；每个grid中的值也不再使用max，同样使用差值算法。</li>
<li>Network Architecture: 为了表述清晰，有两种分类方法</li>
</ul>
<ol>
<li>使用了不同的backbone：resnet-50，resnet-101，resnext-50，resnext-101；</li>
<li>使用了不同的head Architecture：Faster RCNN使用resnet50时，从CONV4导出特征供RPN使用，这种叫做ResNet-50-C4</li>
<li>作者使用除了使用上述这些结构外，还使用了一种更加高效的backbone——FPN</li>
</ol>
<h2 id="3-1-Implementation-Details"><a href="#3-1-Implementation-Details" class="headerlink" title="3.1.Implementation Details"></a>3.1.Implementation Details</h2><p>使用Fast/Faster相同的超参数，同样适用于Mask RCNN</p>
<ul>
<li>Training:<br>1、与之前相同，当IoU与Ground Truth的IoU大于0.5时才会被认为有效的RoI，L{_{mask}}只把有效RoI计算进去。<br>2、采用image-centric training，图像短边resize到800，每个GPU的mini-batch设置为2，每个图像生成N个RoI，对于C4 backbone的N=64，对于FPN作为backbone的，N=512。作者服务器中使用了8块GPU，所以总的minibatch是16，迭代了160k次，初始lr=0.02，在迭代到120k次时，将lr设定到 lr=0.002，另外学习率的weight_decay=0.0001，momentum = 0.9。如果是resnext，初始lr=0.01,每个GPU的mini-batch是1。<br>3、RPN的anchors有5种scale，3种ratios。为了方便剥离、如果没有特别指出，则RPN网络是单独训练的且不与Mask R-CNN共享权重。但是在本论文中，RPN和Mask R-CNN使用一个backbone，所以他们的权重是共享的。<br>（Ablation Experiments 为了方便研究整个网络中哪个部分其的作用到底有多大，需要把各部分剥离开）</li>
</ul>
<ul>
<li>Inference：<br>在测试时，使用C4 backbone情况下proposal number=300，使用FPN时proposal number=1000。然后在这些proposal上运行bbox预测，接着进行非极大值抑制。mask分支只应用在得分最高的100个proposal上。顺序和train是不同的，但这样做可以提高速度和精度。mask 分支对于每个roi可以预测k个类别，但是我们只要背景和前景两种，所以只用k-th mask，k是根据分类分支得到的类型。然后把k-th mask resize成roi大小，同时使用阈值分割(threshold=0.5)二值化</li>
</ul>
<h1 id="4-Experiments-Instance-Segmentation"><a href="#4-Experiments-Instance-Segmentation" class="headerlink" title="4.Experiments: Instance Segmentation"></a>4.Experiments: Instance Segmentation</h1><h2 id="4-1-Main-Results"><a href="#4-1-Main-Results" class="headerlink" title="4.1.Main Results"></a>4.1.Main Results</h2><p>在下图中可以明显看出，FCIS的分割结果中都会出现一条竖着的线(systematic artifacts)，这线主要出现在物体重的部分，作者认为这是FCIS架构的问题，无法解决的。但是在Mask RCNN中没有出现。<br><img src="https://i.loli.net/2019/04/29/5cc65cc9ecfc3.png" alt="figure6&amp;table2"></p>
<h2 id="4-2-Ablation-Experiments"><a href="#4-2-Ablation-Experiments" class="headerlink" title="4.2. Ablation Experiments"></a>4.2. Ablation Experiments</h2><ul>
<li>Architecture:<br>从table 2a中看出，Mask RCNN随着增加网络的深度、采用更先进的网络，都可以提高效果。注意：并不是所有的网络都是这样。</li>
<li>Multinomial vs. Independent Masks:(mask分支是否进行类别预测)                                                                                    从table 2b中可以看出，使用sigmoid(二分类)和使用softmax(多类别分类)的AP相差很大，证明了分离类别和mask的预测是很有必要的</li>
<li>Class-Specific vs. Class-Agnostic Masks:                                                                                                                            目前使用的mask rcnn都使用class-specific masks，即每个类别都会预测出一个mxm的mask，然后根据类别选取对应的类别的mask。但是使用Class-Agnostic Masks，即分割网络只输出一个mxm的mask，可以取得相似的成绩29.7vs30.3</li>
<li>RoIAlign:                                                                                                                                                                                    tabel 2c证明了RoIAlign的性能</li>
<li>Mask Branch:<br>tabel 2e，FCN比MLP性能更好</li>
</ul>
<h2 id="4-3-Bounding-Box-Detection-Results"><a href="#4-3-Bounding-Box-Detection-Results" class="headerlink" title="4.3.Bounding Box Detection Results"></a>4.3.Bounding Box Detection Results</h2><ul>
<li>Mask RCNN精度高于Faster RCNN</li>
<li>Faster RCNN使用RoI Align的精度更高</li>
<li>Mask RCNN的分割任务得分与定位任务得分相近，说明Mask RCNN已经缩小了这部分差距。</li>
</ul>
<h2 id="4-4-Timing"><a href="#4-4-Timing" class="headerlink" title="4.4.Timing"></a>4.4.Timing</h2><ul>
<li>Inference：195ms一张图片，显卡Nvidia Tesla M40。其实还有速度提升的空间，比如减少proposal的数量等。</li>
<li>Training：ResNet-50-FPN on COCO trainval35k takes 32 hours  in our synchronized 8-GPU implementation (0.72s per 16-image mini-batch)，and 44 hours with ResNet-101-FPN。</li>
</ul>
<h1 id="5-Mask-R-CNN-for-Human-Pose-Estimation"><a href="#5-Mask-R-CNN-for-Human-Pose-Estimation" class="headerlink" title="5. Mask R-CNN for Human Pose Estimation"></a>5. Mask R-CNN for Human Pose Estimation</h1><p>让Mask R-CNN预测k个masks，每个mask对应一个关键点的类型，比如左肩、右肘，可以理解为one-hot形式。</p>
<ul>
<li>使用cross entropy loss，可以鼓励网络只检测一个关键点;</li>
<li>ResNet-FPN结构</li>
<li>训练了90k次，最开始lr=0.02，在迭代60k次时，lr=0.002,80k次时变为0.0002</li>
</ul>
<p><img src="https://i.loli.net/2019/04/29/5cc65f4085801.png" alt="figure7"><br><em>图7.使用Mask R-CNN（ResNet-50-FPN）在COCO测试中的关键点检测结果，以及从相同模型预测的人分割掩码。该模型的关键点AP为63.1，运行速度为5 fps。</em></p>
<p><img src="https://i.loli.net/2019/04/29/5cc6605e29496.png" alt="table4/5/6"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/2019-04-29-Mask%20R-CNN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/29/2019-04-29-Mask%20R-CNN/" itemprop="url">Mask R-CNN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-29T00:00:00+08:00">
                2019-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文链接：<a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">https://arxiv.org/abs/1703.06870</a><br>Mask R-CNN是ICCV 2017的best paper，彰显了机器学习计算机视觉领域在2017年的最新成果。在机器学习2017年的最新发展中，单任务的网络结构已经逐渐不再引人瞩目，取而代之的是集成，复杂，一石多鸟的多任务网络模型。Mask R-CNN就是典型的代表。本篇大作的一作是何凯明，在该篇论文发表的时候，何凯明已经去了FaceBook。</p>
</blockquote>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p><em>我们提出了一个概念上简单，灵活和通用的对象实例分割框架。我们的方法有效地检测图像中的对象，同时为每个实例生成高质量的分割蒙版。这种称为Mask R-CNN的方法通过添加一个用于预测对象掩码的分支来扩展更快的R-CNN，该分支与现有的用于边界框识别的分支并行。掩码R-CNN训练简单，只增加了一小部分开销，以更快的R-CNN，以5fps运行。此外，Mask R-CNN很容易推广到其他任务，例如允许我们在相同的框架中估计人的姿势。我们在COCO全套挑战的所有三个轨道中展示了最佳结果，包括实例分段，边界盒对象检测和人员关键点检测。Mask R-CNN无需花费大量时间就可胜任所有现有的单一模型作品，包括COCO 2016挑战获胜者。我们希望我们简单有效的方法将成为一个坚实的基线，并有助于缓解未来实例级别识别的研究。代码已在：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> facebookresearch / Detectron上提供。</em></p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><p>视觉社区在短时间内迅速改进了对象检测和语义分割结果。在很大程度上，这些进步是由强大的基线系统驱动的，例如分别用于对象检测和语义分割的快速/更快RCNN [12,36]和全卷积网络（FCN）[30]框架。这些方法在概念上是直观的，并且具有灵活性和鲁棒性，以及快速训练和推理时间。我们在这项工作中的目标是为实例分割开发一个相对有利的框架。实例分割具有挑战性，因为它需要正确检测图像中的所有对象，同时也精确地分割每个实例。因此，它将经典的目标检测计算机视觉任务的元素进行了组合，其目标是对各个对象进行分类并使用边界框对每个对象进行本地化，然后进行语义分割，其目的是将每个像素分类为固定的一组类别，而不区分对象实例.1鉴于此，人们可能期望需要一个复杂的方法才能取得好的结果。然而，我们表明，一个令人惊讶的简单，灵活和快速的系统可以超越先前的最新实例分割结果。<br>我们的方法称为Mask R-CNN，可以使R-CNN更快。<br><img src="https://i.loli.net/2019/04/29/5cc657a3425e5.png" alt="figure1"><br><em>图1.用于实例分段的Mask R-CNN框架。</em></p>
<p>[36]通过添加一个分支来预测每个感兴趣区域（RoI）上的分割掩模，并与现有分支进行分类和边界框回归（图1）。掩模分支是应用于每个RoI的小FCN，以像素 - 顶像素方式预测分割掩模。由于R-CNN框架更加快速，面罩R-CNN的实施和训练变得非常简单，这有助于广泛的灵活架构设计。另外，掩码分支只会增加一个小的计算开销，从而实现快速系统和快速实验。<br>原则上，Mask R-CNN是R-CNN的直观扩展，但正确构建掩模分支对于获得好的结果至关重要。最重要的是，更快的RCNN并非针对网络输入和输出之间的像素对像素对齐而设计的。RoIPool [18,12]是参与实例的事实核心操作，为特征提取执行粗略的空间量化，这一点最为明显。为了找到错位，我们提出了一个简单的，无量化的图层，称为RoIAlign，忠实地保留了确切的空间位置。尽管1遵循通用术语，但我们使用对象检测来表示通过边界框而不是掩码进行检测，并使用语义分割来表示每像素分类而不区分实例。但是我们注意到，实例分割既是语义的，也是一种检测形式。<br><img src="https://i.loli.net/2019/04/29/5cc658728ff4e.png" alt="figure2"><br><em>图2.掩盖COCO测试集上的R-CNN结果。这些结果基于ResNet-101 [19]，实现了35.7的掩模AP，并以5 fps运行。面具以彩色显示，还显示了边界框，类别和置信度。</em></p>
<p>一个看似微小的变化，RoIAlign具有很大的影响：它将掩模精度提高了10％到50％，在更严格的本地化指标下显示出更大的收益。其次，我们发现解耦模板和类别预测至关重要：我们独立预测每个类别的二进制掩码，而不需要在类别间进行竞争，并依靠网络的RoI分类分支来预测类别。相比之下，FCNs通常执行每像素多类别分类，结合分割和分类，并基于我们的实验在分割实例方面效果不佳。<br>没有花里胡哨之力，Mask R-CNN超越了COCO实例分割任务中所有先前的最新单模型结果[28]，其中包括来自2016年竞赛冠军的大量工程项目。作为副产品，我们的方法也擅长COCO物体检测任务。在消融实验中，我们评估了多个基本实例，这使我们能够展示其强大性并分析核心因素的影响。<br>我们的模型可以在GPU上以每帧200毫秒的速度运行，并且在单个8 GPU计算机上进行COCO培训需要一到两天。我们相信，快速训练和测试速度，以及框架的灵活性和准确性，将会对实例分割的未来研究起到一定的作用。<br>最后，我们通过COCO关键点数据集上的人体姿态估计任务展示了我们框架的一般性[28]。通过将每个关键点视为一个热门的二进制掩码，只需进行最少的修改Mask R-CNN可用于检测实例特定的姿势。Mask R-CNN超越2016年COCO关键点竞赛的冠军，同时运行速度为5 fps。因此，面膜R-CNN可以更广泛地视为实例级别识别的灵活框架，并且可以很容易地扩展到更复杂的任务。<br>我们已发布代码以促进未来的研究。</p>
<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2.Related Work"></a>2.Related Work</h1><p>R-CNN：基于区域的CNN（R-CNN）方法[13]对边界框对象进行检测是为了关注可管理数量的候选目标区域[42,20]并独立评估卷积网络[25,24]在每个RoI上。R-CNN得到了扩展[18,12]，允许使用RoIPool在功能地图上参与RoI，从而实现更快的速度和更高的准确性。更快的R-CNN [36]通过学习区域建议网络（RPN）的注意机制来推进这一流程。更快速的R-CNN灵活性强，适用于许多后续改进（例如[38,27,21]），并且是几个基准测试中的当前领先框架。<br>实例细分：在RCNN的有效性的推动下，许多实例细分的方法都基于细分提案。早期的方法[13,15,16,9]采用了自下而上的方法[42,2]。DeepMask [33]和以下着作[34,8]学会提出片段候选者，然后由Fast R-CNN进行分类。在这些方法中，分割先于识别，这是缓慢的并且不太准确。同样，戴等人。 [10]提出了一个复杂的多级级联，从包围盒提议中预测段提议，然后进行分类。相反，我们的方法基于面具和类标签的并行预测，它更简单，更灵活。<br>最近，李等人。 [26]将[8]中的段提议系统和[11]中的对象检测系统合并为“完全卷积实例分段”（FCIS）。[8,11,26]中的共同想法是预测一组完全卷积的位置敏感输出通道。这些通道同时处理对象类，框和掩码，使系统更快。但是FCIS在重叠实例上表现出系统性错误并产生虚假边缘（图6），表明它受到分割实例的根本困难的挑战。<br>另一个解决方案家族[23,4,3,29]实例分割是由语义分割的成功驱动的。从每像素分类结果（例如，FCN输出）开始，这些方法试图将相同类别的像素切割成不同的实例。与这些方法的分段第一策略相比，Mask R-CNN基于实例第一策略。我们预计未来将研究更深入的两种战略。</p>
<h1 id="3-Mask-R-CNN"><a href="#3-Mask-R-CNN" class="headerlink" title="3.Mask R-CNN"></a>3.Mask R-CNN</h1><p>掩码R-CNN在概念上是简单的：更快的R-CNN对于每个候选对象具有两个输出，一个类别标签和一个边界框偏移;为此，我们添加一个输出对象掩码的第三个分支。面具R-CNN因此是一个自然而直观的想法。但是额外的掩码输出与类和盒输出不同，需要提取对象的更精细的空间布局。接下来，我们介绍Mask R-CNN的关键元素，包括像素对像素对齐，这是Fast / Faster R-CNN的主要缺失部分。<br>更快的R-CNN：我们首先回顾一下更快的R-CNN探测器[36]。更快的R-CNN由两个阶段组成。第一阶段称为区域提议网络（RPN），提出候选对象边界框。第二阶段本质上是Fast R-CNN [12]，使用每个候选框中的RoIPool提取特征，并执行分类和边界框回归。两个阶段使用的功能可以共享以加快推断速度。我们引用读者[21]对Faster R-CNN和其他框架进行最新，全面的比较。<br>掩码R-CNN：掩码R-CNN采用相同的两阶段过程，具有相同的第一阶段（即RPN）。在第二阶段，与预测类和盒子偏移并行，Mask R-CNN也为每个RoI输出一个二进制掩码。这与大多数最近的系统形成对比，其中分类依赖于掩模预测（例如[33,10,26]）。我们的方法遵循Fast R-CNN [12]的精神，它并行地应用了边界框分类和回归（其原来大大简化了原始R-CNN的多级流水线[13]）。<br>形式上，在训练期间，我们将每个抽样的RoI的多任务丢失定义为L = Lcls + Lbox + Lmask。分类损失Lcls和边界框损失Lbox与[12]中定义的相同。掩码分支对每个RoI都有一个Km<sup>2</sup>维输出，它编码分辨率为m*m的K个二进制掩码，每个K类一个掩码。为此，我们应用每像素S形，并将Lmask定义为平均二叉交叉熵损失。对于与地面实况类别k相关的RoI，Lmask仅在第k个掩模上定义（其他掩模输出不会造成损失）。<br>我们对Lmask的定义允许网络为每个班级生成口罩，而不需要在班级间进行竞争;我们依靠专用分类分支来预测用于选择输出掩码的类别标签。这样可以将掩码和类别预测分开。这与将FCN [30]应用于语义分割时的常见做法不同，后者通常使用每像素softmax和多项叉熵损失。在这种情况下，跨班级的面具竞争;在我们的例子中，每像素S形和二进制丢失，他们不。我们通过实验显示这个公式对于良好的实例分割结果是关键的。<br><img src="https://i.loli.net/2019/04/29/5cc65a2a8366b.png" alt="figure3"></p>
<p>掩码表示法：掩码编码输入对象的空间布局。因此，与通过完全连接（fc）层不可避免地折叠成短输出矢量的类标签或框偏移不同，提取掩模的空间结构可以通过卷积提供的像素到像素对应自然地解决。<br>具体而言，我们使用FCN预测每个RoI的m<em>m掩码[30]。这允许掩码分支中的每个层保持显式m*m对象空间布局，而不将其折叠成缺少空间维度的向量表示。与之前采用fc层进行掩模预测的方法不同[33,34,10]，我们的完全卷积表示需要更少的参数，并且如实验所证明的那样更精确。<br>这种像素到像素的行为要求我们的RoI特征（它们本身是小特征图）能够很好地对齐以忠实地保留显式的每像素空间对应关系。这促使我们开发了以下RoAlign图层，该图层在遮罩预测中发挥关键作用。<br>RoIlign：RoIPool [12]是从每个RoI提取小特征映射（例如7×7）的标准操作。RoIPool首先将浮点数RoI量化为特征映射的离散粒度，然后将这个量化的RoI细分为自身量化的空间仓，最后汇总每个仓所涵盖的特征值（通常通过最大池）。例如，通过计算在连续坐标x上执行量化，其中16是特征映射步长并且是舍入;同样地，当分成分箱（例如，7×7）时执行量化。这些量化引入了RoI和提取的特征之间的错位。虽然这可能不会影响分类，这对于小型翻译很有用，但它对预测像素精确的蒙版有很大的负面影响。<br>为了解决这个问题，我们提出一个RoIlign层，它可以消除RoIPool的严格量化，正确地将提取的特征与输入对齐。我们提出的改变很简单：我们避免任何RoI边界或分区的量化（即，我们使用x/16而不是|x/16|）。我们使用双线性插值[22]来计算每个RoI bin中四个有规律采样位置的输入特征的精确值，并汇总结果（使用最大值或平均值），详细信息请参见图3。我们注意到，只要未执行量化，结果对精确的采样位置不敏感，或者采样了多少个点。<br>正如我们在§4.2中所展示的，RoIAlign带来了巨大的改进。我们也比较了[10]中提出的RoIWarp操作。与RoIlign不同，RoIWarp忽略了对齐问题，并在[10]中将RoI与RoIPool一样量化为RoI。所以即使RoIWarp也采用[22]激励的双线性重采样，它可以像RoIPool一样实验（表2c中的更多细节），证明了对齐的关键作用。<br>网络体系结构：为了演示我们的方法的一般性，我们实例化具有多种体系结构的Mask R-CNN。为了清楚起见，我们区分：（i）用于整个图像上的特征提取的卷积骨干架构，以及（ii）用于边界框识别（分类和回归）的网络头和分别应用于每个RoI的掩模预测。我们用命名网络深度特征来表示骨干架构。我们评估深度为50或101层的ResNet [19]和ResNeXt [45]网络。带ResNets的更快的R-CNN的原始实施。<br>[19]从第四阶段的最后卷积层提取特征，我们称之为C4。例如，ResNet-50的骨干用ResNet-50-C4表示。这是[19,10,21,39]中常用的选择。<br>我们还探索了Lin等人最近提出的另一种更有效的骨干。 [27]，称为特征金字塔网络（FPN）。FPN使用具有横向连接的自顶向下架构从单一比例输入构建网络内特征金字塔。更快的R-CNN和FPN骨干网根据其规模从不同层次的特征金字塔中提取RoI特征，但其他方法与vanilla ResNet类似。使用ResNet-FPN主干进行MaskNRCNN特征提取，可以提高精度和速度。有关FPN的更多详细信息，请参阅[27]。<br>对于网络负责人，我们密切关注以前工作中提出的架构，并在其中添加完全卷积掩码预测分支。具体而言，我们从ResNet [19]和FPN [27]论文中扩展了更快的R-CNN盒头。详细情况如图4所示。ResNet-C4主干上包含ResNet的第5级（即9层’res5’[19]），它是计算密集型的。对于FPN，骨干已经包含res5，因此可以使用更少的滤波器来提高效率。我们注意到我们的面具分支有一个简单的结构。更复杂的设计有提高性能的潜力，但不是这项工作的重点。<br><img src="https://i.loli.net/2019/04/29/5cc65b1069756.png" alt="figure4"><br>*图4.头架构：我们扩展了两个现有的更快的RCNN头[19,27]。左/右面板分别显示来自[19]和[27]的ResNet C4和FPN骨干的头部，其中添加了掩膜分支。数字表示空间分辨率和频道。箭头表示可以从上下文推断的conv，deconv或fc图层（conv会保留空间维度，而deconv会增加它）。所有的转换都是3×3，除了输出转换为1×1，解压缩为2×2和步长2，并且我们在隐藏层中使用了ReLU [31]。左：res5表示ResNet的第五阶段，为了简单起见，我们改变了第一阶段的第一阶段，以步幅1（而不是14×14 /步幅2，如[19]中的7×7阶段）操作。右：“×4”表示一连串四次转换。</em></p>
<h2 id="3-1-Implementation-Details"><a href="#3-1-Implementation-Details" class="headerlink" title="3.1.Implementation Details"></a>3.1.Implementation Details</h2><p>我们在现有的快速/更快的R-CNN工作之后设置超参数[12,36,27]。尽管这些决策是在原始文件中进行对象检测的[12,36,27]，但我们发现我们的实例分割系统对它们是强健的。<br>培训：与Fast R-CNN一样，如果RoI的IoU的地面实况框至少为0.5，则认为是正面的，否则为负面。掩模损失Lmask仅在正向RoI上定义。掩码目标是RoI与其关联的地面实况蒙版之间的交集。<br>我们采用图像中心训练[12]。调整图像的大小以使其比例（较短的边缘）为800像素[27]。每个微型批次每个GPU有2个图像，每个图像具有N个采样的RoI，比例为1：3的正负极[12]。C4骨架的N为64（如[12,36]），FPN为512（如[27]）。我们在8个GPU（有效小批量大小为16）上进行160k次迭代训练，学习率为0.02，在120k迭代时减少10。我们使用0.0001的重量衰减和0.9的动量。使用ResNeXt [45]，我们每个GPU训练1个图像，迭代次数相同，初始学习率为0.01。RPN锚点跨越5个尺度和3个纵横比，见[27]。为了方便消融，除非另有说明，否则RPN将单独进行培训并且不会与Mask R-CNN共享特征。对于本文中的每个条目，RPN和Mask R-CNN具有相同的主干，因此它们可共享。<br>推论：在测试时，C4主干的提案编号为300（如[36]），FPN的提案编号为1000（如[27]）。我们对这些提议运行盒子预测分支，然后是非最大抑制[14]。然后将掩码分支应用于得分最高的100个检测框。虽然这与训练中使用的并行计算不同，但它加快了推理速度并提高了准确性（由于使用了更少，更准确的RoI）。掩模分支可以预测每个RoI的K个掩模，但我们只使用第k个掩模，其中k是分类分支预测的类。然后将m×m浮点数掩码输出调整为RoI大小，并在阈值0.5下进行二进制化。<br><img src="https://i.loli.net/2019/04/29/5cc65b990f59b.png" alt="figure5"><br><em>图5.在COCO测试图像上使用ResNet-101-FPN并以5 fps运行并带有35.7掩模AP（表1）的Mask R-CNN的更多结果。</em></p>
<p><img src="https://i.loli.net/2019/04/29/5cc65bd2acd59.png" alt="table1"><br><em>表1. COCO test-dev上的实例分段掩码AP。跨国公司[10]和FCIS [26]分别是2015年和2016年分类挑战的赢家。没有花里胡哨的，Mask R-CNN胜过了更复杂的FCIS +++，其中包括多尺度训练/测试，水平测试和OHEM [38]。所有条目都是单模型结果。</em></p>
<p>请注意，由于我们仅计算前100个检测框中的掩码，Mask R-CNN为其较快的R-CNN对象（例如典型模型上的约20％）增加了一个小的开销。</p>
<h1 id="4-Experiments-Instance-Segmentation"><a href="#4-Experiments-Instance-Segmentation" class="headerlink" title="4.Experiments: Instance Segmentation"></a>4.Experiments: Instance Segmentation</h1><p>我们对Mask R-CNN进行了彻底的比较，并对COCO数据集进行了全面的消融[28]。我们报告标准的COCO指标，包括AP（平均在IoU阈值上），AP50，AP75和APS，APM，APL（AP在不同尺度上）。除非另有说明，否则AP正在使用掩膜IoU进行评估。和以前的工作[5,27]一样，我们训练使用80k列车图像和val图像的35k子集（trainval35k）的联合，并报告其余5k val图像（微型）上的消融。我们还在测试开发中报告结果[28]。</p>
<h2 id="4-1-Main-Results"><a href="#4-1-Main-Results" class="headerlink" title="4.1.Main Results"></a>4.1.Main Results</h2><p>我们将Mask R-CNN与表1中实例分割中的最新方法进行了比较。我们模型的所有实例都优于先前最先进的模型的基线变体。其中包括MNC [10]和FCIS [26]，分别是2015年和2016年分类挑战的获胜者。ResNet-101-FPN骨干网掩码R-CNN的性能优于FCIS +++ [26]，其中包括多尺度训练/测试，水平流测试和在线硬示例挖掘（OHEM）[38]。虽然超出了本工作的范围，但我们预计许多此类改进将适用于我们的工作。图2和图5中显示了掩膜R-CNN输出。面具R-CNN即使在具有挑战性的条件下也能取得良好效果。在图6中，我们比较了我们的Mask R-CNN基线和FCIS +++ [26]。FCIS +++在重叠的实例中展现出系统性的人为因素，这表明它受到实例分割根本困难的挑战。掩码R-CNN没有显示这样的文物。<br><img src="https://i.loli.net/2019/04/29/5cc65cc9ecfc3.png" alt="figure6&amp;table2"></p>
<h2 id="4-2-Ablation-Experiments"><a href="#4-2-Ablation-Experiments" class="headerlink" title="4.2. Ablation Experiments"></a>4.2. Ablation Experiments</h2><p>我们运行一些消融来分析Mask R-CNN。结果显示在表2中并在下面详细讨论。<br>架构：表2a显示了具有各种骨架的Mask R-CNN。它受益于更深的网络（50对101）和先进的设计，包括FPN和ResNeXt。我们注意到并非所有框架都自动从更深或更高级的网络中获益（参见[21]中的基准测试）。<br>多项式与独立式掩码：掩码R-CNN分离掩码和类别预测：由于现有的分支预测类别标签，因此我们为每个类别生成一个掩码，而不会在类别间进行竞争（按像素S形和二进制丢失）。在表2b中，我们将其与使用每像素softmax和多项损失（如FCN [30]中常用的）进行比较。这种替代方案将掩模和类别预测的任务相结合，并导致掩模AP（5.5分）的严重损失。这表明一旦实例被整体分类（通过盒子分支），预测二进制掩码就足够了，而不用考虑类别，这使得模型更易于训练。<br>Class-Speci fi c与Class-Agnostic Masks：我们的默认实例化预测了类特定的掩码，即一个m<em>m每个班级的面具。有趣的是，具有分类掩码的掩码R-CNN（即预测单个m*m输出而不管类别）几乎同样有效：它具有29.7掩码AP，而对于ResNet-50-C4上的类别特定对应字符，掩码AP为30.3。这进一步突出了我们的方法中的分工，这种分工在很大程度上将分类和分割分开。<br>Roialign：我们建议的RoIlign层的评估如表2c所示。在这个实验中，我们使用了跨度为16的ResNet50-C4主干。RoIAlign比RoIPool提高了约3个点，其中很大的收益来自高IoU（AP75）。RoIlign对最大/平均水池不敏感;我们在本文的其余部分使用平均值。另外，我们与在MNC [10]中提出的RoIWarp进行比较，该方法也采用双线性采样。正如§3所讨论的那样，RoIWarp仍然量化了RoI，失去了与输入的一致性。从表2c可以看出，RoIWarp的表现与RoIPool相当，比RoIAlign差很多。这突出表明正确的对齐是关键。<br>我们还用一个ResNet-50-C5骨干来评估RoIlign，这个骨干有32个像素的更大步幅。我们使用与图4（右）相同的头，因为res5头不适用。表2d显示RoIAlign提高了掩模AP的7.3点，掩盖AP75 10.5点（相对提高50％）。此外，我们注意到使用RoIAlign，使用步幅-32 C5功能（30.9 AP）比使用步幅-16 C4功能（30.3 AP，表2c）更准确。RoIAlign在很大程度上解决了使用大步功能进行检测和分割的长期挑战。最后，与FPN一起使用时，RoIAlign显示1.5掩模AP和0.5盒AP的增益，FPN具有更精细的多级步幅。对于需要精细对齐的关键点检测，RoIAlign即使使用FPN也显示出较大的增益（表6）。<br><img src="https://i.loli.net/2019/04/29/5cc65e0ebda46.png" alt="table3"><br>*遮罩分支：分割是一个像素到像素的任务，我们通过使用FCN来利用遮罩的空间布局。在表2e中，我们使用ResNet-50-FPN主干比较了多层感知器（MLP）和FCN。使用FCN可以提供2.1 Mbps的AP掩码。我们注意到，我们选择了这个骨干，这样FCN头部的conv层没有经过预先训练，与MLP进行公平比较。</em></p>
<h2 id="4-3-Bounding-Box-Detection-Results"><a href="#4-3-Bounding-Box-Detection-Results" class="headerlink" title="4.3.Bounding Box Detection Results"></a>4.3.Bounding Box Detection Results</h2><p>我们将Mask R-CNN与表3中的最新COCO包围盒对象检测进行比较。对于这个结果，即使训练完整的Mask R-CNN模型，只有分类和框输出用于推理（掩码输出被忽略）。使用ResNet-101FPN的面罩R-CNN优于以前所有先进模型的基础变体，其中包括COMI 2016检测挑战赛获胜者GRMI [21]的单模型变体。使用ResNeXt-101-FPN，Mask R-CNN进一步改进了结果，与[39]（使用Inception-ResNet-v2-TDM）的最佳单一模型条目相比，框AP的余量为3.0分。<br>作为进一步的比较，我们训练了一个版本的掩模R-CNN，但没有掩模分支，表3中的“Faster R-CNN，RoIlign”表示。由于RoIlign的原因，该模型的性能比[27]中介绍的模型要好。另一方面，比面具R-CNN低0.9个盒子AP。因此掩模R-CNN在盒子检测上的差距仅仅是由于多任务训练的好处。<br>最后，我们注意到Mask R-CNN在其掩模和盒AP之间获得了一个小间隙：例如，在37.1（掩模，表1）和39.8（框3）之间的2.7个点。这表明我们的方法在很大程度上缩小了对象检测与更具挑战性的实例分割任务之间的差距。</p>
<h2 id="4-4-Timing"><a href="#4-4-Timing" class="headerlink" title="4.4.Timing"></a>4.4.Timing</h2><p>推论：我们训练了一个ResNet-101-FPN模型，该模型在R-CNN更快的四步训练之后训练RPN和Mask R-CNN阶段之间的特征[36]。Nvidia Tesla M40 GPU（加上15ms CPU时间，将输出调整为原始分辨率）时，该模型以195ms的速度运行，并实现与非共享模式相同的掩模AP。我们还报告说ResNet-101-C4变体需要400毫秒，因为它有一个较重的盒子头（图4），所以我们不建议在实践中使用C4变体。<br>尽管掩模R-CNN速度很快，但我们注意到我们的设计并未针对速度进行优化，并且可以实现更好的速度/精度折衷[21]，例如，通过改变图像尺寸和提案编号，这超出了本白皮书的范围。<br>训练：面具R-CNN训练也很快。在COCO trainval35k上使用ResNet-50-FPN进行培训的同步8 GPU实现需要32小时（每16图像微型批次0.72s），使用ResNet-101-FPN需要44小时。实际上，快速原型设计可以在不到一天的时间内在火车上进行训练时完成。我们希望这种快速培训能够消除该领域的一个主要障碍，并鼓励更多的人对这个具有挑战性的话题进行研究。</p>
<h1 id="5-Mask-R-CNN-for-Human-Pose-Estimation"><a href="#5-Mask-R-CNN-for-Human-Pose-Estimation" class="headerlink" title="5. Mask R-CNN for Human Pose Estimation"></a>5. Mask R-CNN for Human Pose Estimation</h1><p>我们的框架可以很容易地扩展到人体姿态估计。我们将一个关键点的位置建模为一个单独的热掩模，并采用掩模R-CNN预测K个掩模，每个K个关键点类型（例如左肩，右肘）各一个。这项任务有助于展示Mask R-CNN的灵活性。我们注意到，我们的系统利用了人类姿态的最小领域知识，因为实验主要是为了展示Mask R-CNN框架的一般性。我们期望领域知识（例如，建模结构[6]）将与我们简单的方法相辅相成。<br>实施细节：对关键点进行调整时，我们对细分系统进行细微修改。对于实例的每个K关键点，训练目标是一个热点二进制掩码，其中只有一个像素标记为前景。在训练过程中，对于每个可见的地面真值关键点，我们将 -way softmax输出的交叉熵损失最小化（鼓励[6]是2016年竞赛获胜者，使用多尺度测试，CPM后处理[使用两种模型（Inception-ResNet-1）对G-RMI进行COCO加MPII [1]（25k图像）的训练，并用目标检测器进行滤波，累加约5个点（在个人通信中加以澄清） v2用于边界框检测，ResNet-101用于关键点）。<br><img src="https://i.loli.net/2019/04/29/5cc65f4085801.png" alt="figure7"><br><em>图7.使用Mask R-CNN（ResNet-50-FPN）在COCO测试中的关键点检测结果，以及从相同模型预测的人分割掩码。该模型的关键点AP为63.1，运行速度为5 fps。</em></p>
<p>单点待检测）。我们注意到，与实例分割一样，K关键点仍然是独立处理的。我们采用ResNet-FPN变体，关键点头结构与图4（右）相似。关键点头由8个3×3 512-d的conv层组成，其后是去卷积层和2倍双线性放大，产生56×56的输出分辨率。我们发现对于关键点级别的定位精度需要相对较高的分辨率输出（与掩模相比）。<br>模型在所有包含注释关键点的COCO trainval35k图像上进行训练。为减少过度训练，由于训练集较小，我们使用从[640,800]像素中随机采样的图像比例进行训练;推断是在800像素的单一尺度上进行的。我们训练90k迭代，从0.02的学习率开始，在60k和80k迭代时将其减少10。我们使用边界框NMS，阈值为0.5。其他细节与§3.1中的相同。<br>主要结果和消融：我们评估人员关键点AP（APkp）并尝试使用ResNet-50-FPN主干;附录中将研究更多骨干。表4显示我们的结果（62.7 APkp）比使用多级处理管道的COCO 2016关键点检测获胜者[6]高0.9个点（见表4的标题）。我们的方法相当简单快捷。<br>更重要的是，我们有一个统一的模型，可以在5 fps下运行时同时预测盒子，分段和关键点。添加段分支（针对人员类别）将test-dev上的APkp值提高到63.1（表4）。表5中更多关于微型多任务学习的消除。将掩码分支添加到仅包装盒（即更快的R-CNN）或仅有关键点的版本可以持续改进这些任务。但是，添加关键点分支会略微减少盒/掩码AP，这表明虽然多任务训练可以实现关键点检测，但它不会帮助其他任务。不过，联合学习所有三项任务可以使统一系统同时有效地预测所有输出（图7）。我们还调查RoIAlign对关键点检测的影响（表6）。尽管ResNet-50-FPN骨干网有很大的进展（例如，在嵌套层面上有4个像素），但RoIAlign仍然显示出比RoIPool有显着的提高，APkp增加4.4点。这是因为关键点检测对定位精度更敏感。这再次表明，对齐对像素级本地化至关重要，包括掩码和关键点。<br><img src="https://i.loli.net/2019/04/29/5cc6605e29496.png" alt="table4/5/6"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/26/2019-04-26-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/26/2019-04-26-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8/" itemprop="url">数据结构_8</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-26T00:00:00+08:00">
                2019-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。<br>这里只讨论内部排序，即默认内存空间足够大，可以存放下所有需要排序的数据。</p>
</blockquote>
<h1 id="简单排序（冒泡、插入）"><a href="#简单排序（冒泡、插入）" class="headerlink" title="简单排序（冒泡、插入）#"></a>简单排序（冒泡、插入）#</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从上到下比较两个相邻的泡泡，小在上，大在下则不动，否则交换顺序。这为第一趟冒泡，保证将最大的元素放到最下边，然后重复冒泡，直到所有元素均排好序。<br>最好情况：顺序T=O(N)<br>最坏情况：倒序T=O(N<sup>2</sup>)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>类比于打牌时抓牌的过程。<br>最好情况：顺序T=O(N)<br>最坏情况：倒序T=O(N<sup>2</sup>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void InsertionSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 插入排序 */</span><br><span class="line">     int P, i;</span><br><span class="line">     ElementType Tmp;</span><br><span class="line">      </span><br><span class="line">     for ( P=1; P&lt;N; P++ ) &#123;</span><br><span class="line">         Tmp = A[P]; /* 取出未排序序列中的第一个元素*/</span><br><span class="line">         for ( i=P; i&gt;0 &amp;&amp; A[i-1]&gt;Tmp; i-- )</span><br><span class="line">             A[i] = A[i-1]; /*依次与已排序序列中元素比较并右移*/</span><br><span class="line">         A[i] = Tmp; /* 放进合适的位置 */</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h2><p>对于下标i&lt;j，如果A[i]&gt;A[j]，则称（i,j）是一对逆序对。<br>冒泡排序和插入排序中需要交换的次数即逆序对数，也就是每次交换消除一个逆序对。</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><img src="https://i.loli.net/2019/04/26/5cc2bed0950e0.png" alt="希尔排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 希尔排序 - 用Sedgewick增量序列 */</span><br><span class="line">     int Si, D, P, i;</span><br><span class="line">     ElementType Tmp;</span><br><span class="line">     /* 这里只列出一小部分增量 */</span><br><span class="line">     int Sedgewick[] = &#123;929, 505, 209, 109, 41, 19, 5, 1, 0&#125;;</span><br><span class="line">      </span><br><span class="line">     for ( Si=0; Sedgewick[Si]&gt;=N; Si++ ) </span><br><span class="line">         ; /* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span><br><span class="line"> </span><br><span class="line">     for ( D=Sedgewick[Si]; D&gt;0; D=Sedgewick[++Si] )</span><br><span class="line">         for ( P=D; P&lt;N; P++ ) &#123; /* 插入排序*/</span><br><span class="line">             Tmp = A[P];</span><br><span class="line">             for ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )</span><br><span class="line">                 A[i] = A[i-D];</span><br><span class="line">             A[i] = Tmp;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>在i从0到N的循环里，从A[i]到A[i-1]中找到最小元，并将其位置赋给MinPostion，将未排序部分的最小元换到有序部分的最后位置，即交换A[i]和A[MinPostion]。</p>
<h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><p>将找最小元用最小堆来解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void Swap( ElementType *a, ElementType *b )</span><br><span class="line">&#123;</span><br><span class="line">     ElementType t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">void PercDown( ElementType A[], int p, int N )</span><br><span class="line">&#123; /* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span><br><span class="line">  /* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    X = A[p]; /* 取出根结点存放的值 */</span><br><span class="line">    for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2 + 1;</span><br><span class="line">        if( (Child!=N-1) &amp;&amp; (A[Child]&lt;A[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= A[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            A[Parent] = A[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    A[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void HeapSort( ElementType A[], int N ) </span><br><span class="line">&#123; /* 堆排序 */</span><br><span class="line">     int i;</span><br><span class="line">       </span><br><span class="line">     for ( i=N/2-1; i&gt;=0; i-- )/* 建立最大堆 */</span><br><span class="line">         PercDown( A, i, N );</span><br><span class="line">      </span><br><span class="line">     for ( i=N-1; i&gt;0; i-- ) &#123;</span><br><span class="line">         /* 删除最大堆顶 */</span><br><span class="line">         Swap( &amp;A[0], &amp;A[i] ); /* 见代码7.1 */</span><br><span class="line">         PercDown( A, 0, i );</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>核心：有序子列的归并</p>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>分而治之，T(N)=O(NlogN)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/* 归并排序 - 递归实现 */</span><br><span class="line"> </span><br><span class="line">/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/</span><br><span class="line">void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd )</span><br><span class="line">&#123; /* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */</span><br><span class="line">     int LeftEnd, NumElements, Tmp;</span><br><span class="line">     int i;</span><br><span class="line">      </span><br><span class="line">     LeftEnd = R - 1; /* 左边终点位置 */</span><br><span class="line">     Tmp = L;         /* 有序序列的起始位置 */</span><br><span class="line">     NumElements = RightEnd - L + 1;</span><br><span class="line">      </span><br><span class="line">     while( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) &#123;</span><br><span class="line">         if ( A[L] &lt;= A[R] )</span><br><span class="line">             TmpA[Tmp++] = A[L++]; /* 将左边元素复制到TmpA */</span><br><span class="line">         else</span><br><span class="line">             TmpA[Tmp++] = A[R++]; /* 将右边元素复制到TmpA */</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     while( L &lt;= LeftEnd )</span><br><span class="line">         TmpA[Tmp++] = A[L++]; /* 直接复制左边剩下的 */</span><br><span class="line">     while( R &lt;= RightEnd )</span><br><span class="line">         TmpA[Tmp++] = A[R++]; /* 直接复制右边剩下的 */</span><br><span class="line">          </span><br><span class="line">     for( i = 0; i &lt; NumElements; i++, RightEnd -- )</span><br><span class="line">         A[RightEnd] = TmpA[RightEnd]; /* 将有序的TmpA[]复制回A[] */</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Msort( ElementType A[], ElementType TmpA[], int L, int RightEnd )</span><br><span class="line">&#123; /* 核心递归排序函数 */ </span><br><span class="line">     int Center;</span><br><span class="line">      </span><br><span class="line">     if ( L &lt; RightEnd ) &#123;</span><br><span class="line">          Center = (L+RightEnd) / 2;</span><br><span class="line">          Msort( A, TmpA, L, Center );              /* 递归解决左边 */ </span><br><span class="line">          Msort( A, TmpA, Center+1, RightEnd );     /* 递归解决右边 */  </span><br><span class="line">          Merge( A, TmpA, L, Center+1, RightEnd );  /* 合并两段有序序列 */ </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MergeSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 归并排序 */</span><br><span class="line">     ElementType *TmpA;</span><br><span class="line">     TmpA = (ElementType *)malloc(N*sizeof(ElementType));</span><br><span class="line">      </span><br><span class="line">     if ( TmpA != NULL ) &#123;</span><br><span class="line">          Msort( A, TmpA, 0, N-1 );</span><br><span class="line">          free( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     else printf( &quot;空间不足&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* 归并排序 - 循环实现 */</span><br><span class="line">/* 这里Merge函数在递归版本中给出 */</span><br><span class="line"> </span><br><span class="line">/* length = 当前有序子列的长度*/</span><br><span class="line">void Merge_pass( ElementType A[], ElementType TmpA[], int N, int length )</span><br><span class="line">&#123; /* 两两归并相邻有序子列 */</span><br><span class="line">     int i, j;</span><br><span class="line">       </span><br><span class="line">     for ( i=0; i &lt;= N-2*length; i += 2*length )</span><br><span class="line">         Merge( A, TmpA, i, i+length, i+2*length-1 );</span><br><span class="line">     if ( i+length &lt; N ) /* 归并最后2个子列*/</span><br><span class="line">         Merge( A, TmpA, i, i+length, N-1);</span><br><span class="line">     else /* 最后只剩1个子列*/</span><br><span class="line">         for ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Merge_Sort( ElementType A[], int N )</span><br><span class="line">&#123; </span><br><span class="line">     int length; </span><br><span class="line">     ElementType *TmpA;</span><br><span class="line">      </span><br><span class="line">     length = 1; /* 初始化子序列长度*/</span><br><span class="line">     TmpA = malloc( N * sizeof( ElementType ) );</span><br><span class="line">     if ( TmpA != NULL ) &#123;</span><br><span class="line">          while( length &lt; N ) &#123;</span><br><span class="line">              Merge_pass( A, TmpA, N, length );</span><br><span class="line">              length *= 2;</span><br><span class="line">              Merge_pass( TmpA, A, N, length );</span><br><span class="line">              length *= 2;</span><br><span class="line">          &#125;</span><br><span class="line">          free( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     else printf( &quot;空间不足&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/2019-04-25-%E4%B8%AD%E5%85%B3%E6%9D%91%E7%A7%91%E5%AD%A6%E5%9F%8E%E7%9A%84%E5%85%B4%E8%B5%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/2019-04-25-%E4%B8%AD%E5%85%B3%E6%9D%91%E7%A7%91%E5%AD%A6%E5%9F%8E%E7%9A%84%E5%85%B4%E8%B5%B7/" itemprop="url">中关村科学城的兴起(1953-1966)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T00:00:00+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>《中关村科学城的兴起(1953-1966)》由胡亚东/郑哲敏/严陆光等口述/杨小林访问整理，湖南教育出版社出版，是20世纪中国科学口述史中其中一部，在此感谢！<br>《中关村科学城的兴起(1953-1966)》选择亲历中国20世纪科学技术发展史的中国著名科学家作为主要访谈对象，本求真之原则，记录其亲历亲闻的史实，并按大致统一的编例整理成书稿。</p>
</blockquote>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本书有意只说1953一1966年这一段，涉及中关村的前史很少，涉及“文革”以后的文字也不多。受访者们，从当年的老乡长到当年的小学生，都曾经是中关衬里的“村民”，是中关村历史变迁约见证人。看访问整理者的编排，书中大体上是循着历史变迁的顺序，讲述一座座科研大楼，一个个研究所，是何时和怎样在这块土地上出现的。其中也讲述了在这里工作和栖居过那些著名的科学家，还捎带着提及与人们日常生活息息相关的基础生活设施的建设，但重点不在系统叙述这里发生过的科研活动和作出的科学贡献。总起来说，是通过亲历者的回忆，让人们认识到科学城中建筑物的布局、研究所的兴革和社区的变迁，以此来展现这座“城“的发展轨迹。</p>
<h1 id="第一篇-村与城"><a href="#第一篇-村与城" class="headerlink" title="第一篇 村与城"></a>第一篇 村与城</h1><h2 id="1-老乡长话中关"><a href="#1-老乡长话中关" class="headerlink" title="1.老乡长话中关"></a>1.老乡长话中关</h2><p>受访人：邓启祥，1954年担任保福寺乡乡长，1955年在中科院化学所工作。<br>主要回顾了保福寺附近区域当年的一些行政、地理情况。</p>
<h2 id="2-蓝图中的科学宫和科学城"><a href="#2-蓝图中的科学宫和科学城" class="headerlink" title="2.蓝图中的科学宫和科学城"></a>2.蓝图中的科学宫和科学城</h2><p>受访人：姜虎文，1954年调入中科院。<br>主要阐述了中科院的选址规划。</p>
<h1 id="第二篇-早期奠基"><a href="#第二篇-早期奠基" class="headerlink" title="第二篇 早期奠基"></a>第二篇 早期奠基</h1><h2 id="3-入住中关村的科学院第一人"><a href="#3-入住中关村的科学院第一人" class="headerlink" title="3.入住中关村的科学院第一人"></a>3.入住中关村的科学院第一人</h2><p>受访人：丘宝剑，中国科学院地理研究所研究员。<br>调入《中华地理志》编辑部，编辑部刚成立时没有地方办公，后来在西郊给社科四所（社会所，近代史所，考古所，语言所）造的房子建好，就搬过去。此地原本叫“中官屯”，编辑部调来一个老文书，负责对外联系，是上海人，听不太懂北京话，问周围老百姓，听成了“中关村”，打印了一批信封、信纸，当时搞“三反”，怕落下“反浪费”罪名，就没改，后来陆续搬来其他所也就都跟着叫了。<br>关于“中官”：有说指太监，有说指中小官员，皇帝在圆明园办公，大员不敢住太远，在附近造房子，剩下的中小官员就在此等着召见，搭个房子之类的。</p>
<h2 id="4-原子能楼"><a href="#4-原子能楼" class="headerlink" title="4.原子能楼"></a>4.原子能楼</h2><p>受访人：叶铭汉，中国工程院院士。<br>清华毕业后在中国科学院近代物理所参加工作，53年改名为物理所，58年改称“原子能研究所”。在中关村建大楼52年开始，53年底54年陆续搬了进来。</p>
<h2 id="5-地球物理研究所"><a href="#5-地球物理研究所" class="headerlink" title="5.地球物理研究所"></a>5.地球物理研究所</h2><p>受访人：朱岗崑，中国科学院地球物理研究所研究员。<br>原为中央研究院气象研究所，气象所在1950年改名为地球物理研究所，所长赵九章，1954年下半年大楼盖好，本部从南京搬来。<br>受访人：吴智诚，曾任中国科学院空间物理研究所党委书记。<br>赵九章先生从事气象、地震、海浪，58年之后主要负责了人造卫星，成立“581”领导小组。<br>空间中心的前身大部分是空间物理所，许多学科骨干都是赵九章带出来的。1997年，42位院士联名为赵九章树立铜像，目前在空间中心大厅内。</p>
<h2 id="6-化学研究所"><a href="#6-化学研究所" class="headerlink" title="6.化学研究所"></a>6.化学研究所</h2><h2 id="7-生物楼：昆虫研究所与动物研究所"><a href="#7-生物楼：昆虫研究所与动物研究所" class="headerlink" title="7.生物楼：昆虫研究所与动物研究所"></a>7.生物楼：昆虫研究所与动物研究所</h2><h2 id="8-力学研究所"><a href="#8-力学研究所" class="headerlink" title="8.力学研究所"></a>8.力学研究所</h2><h1 id="第三篇-“火车头”时代"><a href="#第三篇-“火车头”时代" class="headerlink" title="第三篇 “火车头”时代"></a>第三篇 “火车头”时代</h1><h2 id="9-数学研究所与计算技术研究所"><a href="#9-数学研究所与计算技术研究所" class="headerlink" title="9.数学研究所与计算技术研究所"></a>9.数学研究所与计算技术研究所</h2><p>受访人：许孔时，曾任计算技术研究所副所长，软件研究所所长。<br>数学所筹备处是1950年6月成立的，1952年数学所正式成立，所址在清华园内。1953年数学所成立了一个计算组，1956年在这个组的基础上成立了计算技术研究所，计算所正式成立是1959年，1965年又成立了计算所二部，66年分了出去，成立了微电子学研究所，1985年又有一部分调出，成立了软件所。<br>科学院的头一台就是1958年的103机，苏联援助中国的第一台计算机的资料叫M3，电子管，每秒运算8次，中国人真是聪明，拿过图纸，稍微把电路改进、设计一下，每秒就200次了，这就是103机。</p>
<h2 id="10-化工冶金研究所"><a href="#10-化工冶金研究所" class="headerlink" title="10.化工冶金研究所"></a>10.化工冶金研究所</h2><h2 id="11-电子学研究所"><a href="#11-电子学研究所" class="headerlink" title="11.电子学研究所"></a>11.电子学研究所</h2><h2 id="12-声学研究所"><a href="#12-声学研究所" class="headerlink" title="12.声学研究所"></a>12.声学研究所</h2><h2 id="13-生物物理研究所"><a href="#13-生物物理研究所" class="headerlink" title="13.生物物理研究所"></a>13.生物物理研究所</h2><h2 id="14-微生物研究所"><a href="#14-微生物研究所" class="headerlink" title="14.微生物研究所"></a>14.微生物研究所</h2><h2 id="15-生物物理研究所"><a href="#15-生物物理研究所" class="headerlink" title="15.生物物理研究所"></a>15.生物物理研究所</h2><h2 id="16-自动化研究所"><a href="#16-自动化研究所" class="headerlink" title="16.自动化研究所"></a>16.自动化研究所</h2><h2 id="17-物理研究所"><a href="#17-物理研究所" class="headerlink" title="17.物理研究所"></a>17.物理研究所</h2><h2 id="18-电工研究所"><a href="#18-电工研究所" class="headerlink" title="18.电工研究所"></a>18.电工研究所</h2><h1 id="第四篇-社区与“特楼”"><a href="#第四篇-社区与“特楼”" class="headerlink" title="第四篇 社区与“特楼”"></a>第四篇 社区与“特楼”</h1><h2 id="19-回忆早年的中关村"><a href="#19-回忆早年的中关村" class="headerlink" title="19.回忆早年的中关村"></a>19.回忆早年的中关村</h2><p>受访人：李佩，曾任中科院西郊办公室第一任副主任，中国科学院研究生院英语系主任。<br>当时西郊办公室，都是一些公共事务，管的时期很多。比如请派出所到中关村办公，建粮店，半合作社，建中关村医院等。<br>这一代人，已经走了不少了。活着的也都在八九十岁。我们人与人之间有深厚的感情，对这块地儿也有深厚的感情。住事历历在目，这块地儿住过这么一些人，那么多年发生了那么多的事，若能放到一起，可能够装一个博物馆的。</p>
<h2 id="20-早年中关村的一些服务设施"><a href="#20-早年中关村的一些服务设施" class="headerlink" title="20.早年中关村的一些服务设施"></a>20.早年中关村的一些服务设施</h2><h2 id="21-“特楼”往事"><a href="#21-“特楼”往事" class="headerlink" title="21.“特楼”往事"></a>21.“特楼”往事</h2><p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">89</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
