<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="没有个性，不签名！">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;19&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="没有个性，不签名！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/19/"/>





  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/2019-05-13-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gsynf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/13/2019-05-13-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9/" itemprop="url">
                  数据结构_9
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T00:00:00+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。<br>这里只讨论内部排序，即默认内存空间足够大，可以存放下所有需要排序的数据。</p>
</blockquote>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>策略：分而治之<br>步骤：从待排数组中找一个主元pivot，按照比主元大和比主元小将数组分为两个数集再分别递归调用，进行排序。<br>最好情况：每次选的主元都正好是中分，T(N)=O(N logN)<br>选主元：方法很多，例如取头中尾三个数的中位数等<br>适用情况：大规模数据，如果是小规模数据，使用递归可能更费时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/* 快速排序 - 直接调用库函数 */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">/*---------------简单整数排序--------------------*/</span><br><span class="line">int compare(const void *a, const void *b)</span><br><span class="line">&#123; /* 比较两整数。非降序排列 */</span><br><span class="line">    return (*(int*)a - *(int*)b);</span><br><span class="line">&#125;</span><br><span class="line">/* 调用接口 */ </span><br><span class="line">qsort(A, N, sizeof(int), compare);</span><br><span class="line">/*---------------简单整数排序--------------------*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*/</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key1, key2;</span><br><span class="line">&#125; A[MAXN];</span><br><span class="line">  </span><br><span class="line">int compare2keys(const void *a, const void *b)</span><br><span class="line">&#123; /* 比较两种键值：按key1非升序排列；如果key1相等，则按key2非降序排列 */</span><br><span class="line">    int k;</span><br><span class="line">    if ( ((const struct Node*)a)-&gt;key1 &lt; ((const struct Node*)b)-&gt;key1 )</span><br><span class="line">        k = 1;</span><br><span class="line">    else if ( ((const struct Node*)a)-&gt;key1 &gt; ((const struct Node*)b)-&gt;key1 )</span><br><span class="line">        k = -1;</span><br><span class="line">    else &#123; /* 如果key1相等 */</span><br><span class="line">        if ( ((const struct Node*)a)-&gt;key2 &lt; ((const struct Node*)b)-&gt;key2 )</span><br><span class="line">            k = -1;</span><br><span class="line">        else</span><br><span class="line">            k = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">/* 调用接口 */ </span><br><span class="line">qsort(A, N, sizeof(struct Node), compare2keys);</span><br><span class="line">/*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* 快速排序 */</span><br><span class="line"> </span><br><span class="line">ElementType Median3( ElementType A[], int Left, int Right )</span><br><span class="line">&#123; </span><br><span class="line">    int Center = (Left+Right) / 2;</span><br><span class="line">    if ( A[Left] &gt; A[Center] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Center] );</span><br><span class="line">    if ( A[Left] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Right] );</span><br><span class="line">    if ( A[Center] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Center], &amp;A[Right] );</span><br><span class="line">    /* 此时A[Left] &lt;= A[Center] &lt;= A[Right] */</span><br><span class="line">    Swap( &amp;A[Center], &amp;A[Right-1] ); /* 将基准Pivot藏到右边*/</span><br><span class="line">    /* 只需要考虑A[Left+1] … A[Right-2] */</span><br><span class="line">    return  A[Right-1];  /* 返回基准Pivot */</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Qsort( ElementType A[], int Left, int Right )</span><br><span class="line">&#123; /* 核心递归函数 */ </span><br><span class="line">     int Pivot, Cutoff, Low, High;</span><br><span class="line">       </span><br><span class="line">     if ( Cutoff &lt;= Right-Left ) &#123; /* 如果序列元素充分多，进入快排 */</span><br><span class="line">          Pivot = Median3( A, Left, Right ); /* 选基准 */ </span><br><span class="line">          Low = Left; High = Right-1;</span><br><span class="line">          while (1) &#123; /*将序列中比基准小的移到基准左边，大的移到右边*/</span><br><span class="line">               while ( A[++Low] &lt; Pivot ) ;</span><br><span class="line">               while ( A[--High] &gt; Pivot ) ;</span><br><span class="line">               if ( Low &lt; High ) Swap( &amp;A[Low], &amp;A[High] );</span><br><span class="line">               else break;</span><br><span class="line">          &#125;</span><br><span class="line">          Swap( &amp;A[Low], &amp;A[Right-1] );   /* 将基准换到正确的位置 */ </span><br><span class="line">          Qsort( A, Left, Low-1 );    /* 递归解决左边 */ </span><br><span class="line">          Qsort( A, Low+1, Right );   /* 递归解决右边 */  </span><br><span class="line">     &#125;</span><br><span class="line">     else InsertionSort( A+Left, Right-Left+1 ); /* 元素太少，用简单排序 */ </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void QuickSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 统一接口 */</span><br><span class="line">     Qsort( A, 0, N-1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h1><p>表排序是一种间接排序算法，定义一个指针数组作为“表”（table）<br><img src="https://i.loli.net/2019/05/14/5cda2bcef36b512015.png" alt="表排序"></p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p><img src="https://i.loli.net/2019/05/14/5cda2dfbcc17e29869.png" alt="基数排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序 - 次位优先 */</span><br><span class="line"> </span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"> </span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line">  </span><br><span class="line">int GetDigit ( int X, int D )</span><br><span class="line">&#123; /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line">     </span><br><span class="line">    for (i=1; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void LSDRadixSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 基数排序 - 次位优先 */</span><br><span class="line">     int D, Di, i;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = NULL; </span><br><span class="line">      </span><br><span class="line">     for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">         B[i].head = B[i].tail = NULL;</span><br><span class="line">     for (i=0; i&lt;N; i++) &#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">         tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面开始排序 */ </span><br><span class="line">     for (D=1; D&lt;=MaxDigit; D++) &#123; /* 对数据的每一位循环处理 */</span><br><span class="line">         /* 下面是分配的过程 */</span><br><span class="line">         p = List;</span><br><span class="line">         while (p) &#123;</span><br><span class="line">             Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */</span><br><span class="line">             /* 从List中摘除 */</span><br><span class="line">             tmp = p; p = p-&gt;next;</span><br><span class="line">             /* 插入B[Di]号桶尾 */</span><br><span class="line">             tmp-&gt;next = NULL;</span><br><span class="line">             if (B[Di].head == NULL)</span><br><span class="line">                 B[Di].head = B[Di].tail = tmp;</span><br><span class="line">             else &#123;</span><br><span class="line">                 B[Di].tail-&gt;next = tmp;</span><br><span class="line">                 B[Di].tail = tmp;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         /* 下面是收集的过程 */</span><br><span class="line">         List = NULL; </span><br><span class="line">         for (Di=Radix-1; Di&gt;=0; Di--) &#123; /* 将每个桶的元素顺序收集入List */</span><br><span class="line">             if (B[Di].head) &#123; /* 如果桶不为空 */</span><br><span class="line">                 /* 整桶插入List表头 */</span><br><span class="line">                 B[Di].tail-&gt;next = List;</span><br><span class="line">                 List = B[Di].head;</span><br><span class="line">                 B[Di].head = B[Di].tail = NULL; /* 清空桶 */</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 将List倒入A[]并释放空间 */</span><br><span class="line">     for (i=0; i&lt;N; i++) &#123;</span><br><span class="line">        tmp = List;</span><br><span class="line">        List = List-&gt;next;</span><br><span class="line">        A[i] = tmp-&gt;key;</span><br><span class="line">        free(tmp);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序 - 主位优先 */</span><br><span class="line"> </span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line"> </span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"> </span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line">  </span><br><span class="line">int GetDigit ( int X, int D )</span><br><span class="line">&#123; /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line">     </span><br><span class="line">    for (i=1; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X%Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MSD( ElementType A[], int L, int R, int D )</span><br><span class="line">&#123; /* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */</span><br><span class="line">     int Di, i, j;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = NULL; </span><br><span class="line">     if (D==0) return; /* 递归终止条件 */</span><br><span class="line">      </span><br><span class="line">     for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">         B[i].head = B[i].tail = NULL;</span><br><span class="line">     for (i=L; i&lt;=R; i++) &#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">         tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面是分配的过程 */</span><br><span class="line">     p = List;</span><br><span class="line">     while (p) &#123;</span><br><span class="line">         Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */</span><br><span class="line">         /* 从List中摘除 */</span><br><span class="line">         tmp = p; p = p-&gt;next;</span><br><span class="line">         /* 插入B[Di]号桶 */</span><br><span class="line">         if (B[Di].head == NULL) B[Di].tail = tmp;</span><br><span class="line">         tmp-&gt;next = B[Di].head;</span><br><span class="line">         B[Di].head = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面是收集的过程 */</span><br><span class="line">     i = j = L; /* i, j记录当前要处理的A[]的左右端下标 */</span><br><span class="line">     for (Di=0; Di&lt;Radix; Di++) &#123; /* 对于每个桶 */</span><br><span class="line">         if (B[Di].head) &#123; /* 将非空的桶整桶倒入A[], 递归排序 */</span><br><span class="line">             p = B[Di].head;</span><br><span class="line">             while (p) &#123;</span><br><span class="line">                 tmp = p;</span><br><span class="line">                 p = p-&gt;next;</span><br><span class="line">                 A[j++] = tmp-&gt;key;</span><br><span class="line">                 free(tmp);</span><br><span class="line">             &#125;</span><br><span class="line">             /* 递归对该桶数据排序, 位数减1 */</span><br><span class="line">             MSD(A, i, j-1, D-1);</span><br><span class="line">             i = j; /* 为下一个桶对应的A[]左端 */</span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MSDRadixSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 统一接口 */</span><br><span class="line">    MSD(A, 0, N-1, MaxDigit); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h1><p><img src="https://i.loli.net/2019/05/14/5cda2f24f15e577385.png" alt="排序算法比较"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/2019-05-12-R-CNN%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gsynf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/12/2019-05-12-R-CNN%E7%B3%BB%E5%88%97/" itemprop="url">
                  R-CNN系列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T00:00:00+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在解析Mask R-CNN之前，不得不告诉大家一个事实，Mask R-CNN是继承于Faster R-CNN (2016)的，Mask R-CNN只是在Faster R-CNN上面加了一个Mask Prediction Branch (Mask 预测分支)，并且改良了ROI Pooling，提出了ROI Align。所以，在解析Mask R-CNN之前，先给大家分析一下Faster R-CNN。<br>在给大家解析Faster R-CNN之前，又要告诉大家，Faster R-CNN是继承于Fast R-CNN (2015)，Fast R-CNN继承于R-CNN (2014)。因此，索性破釜沉舟，在本篇博文中，就按照R-CNN, Fast R-CNN，Faster R-CNN再到Mask R-CNN的发展顺序全部解析。</p>
</blockquote>
<h1 id="1-R-CNN"><a href="#1-R-CNN" class="headerlink" title="1. R-CNN"></a>1. R-CNN</h1><p>简单来说，R-CNN首先模型输入为一张图片，然后在图片上提出了约2000个待检测区域，然后这2000个待检测区域一个一个地(串联方式)通过卷积神经网络提取特征，然后这些被提取的特征通过一个支持向量机(SVM)进行分类，得到物体的类别，并通过一个bounding box regression调整目标包围框的大小。<br>具体步骤分为四步：</p>
<ol>
<li>候选区域提出阶段（Proposal）：采用selective-search方法，从一幅图像生成1K~2K个候选区域；</li>
<li>特征提取：对每个候选区域，使用CNN进行特征提取；</li>
<li>分类：每个候选区域的特征放入分类器SVM，得到该候选区域的分类结果；</li>
<li>回归：候选区域的特征放入回归器，得到bbox的修正量。</li>
</ol>
<h2 id="1-1-候选区域提出阶段所产生的结果尺寸不同？"><a href="#1-1-候选区域提出阶段所产生的结果尺寸不同？" class="headerlink" title="1.1 候选区域提出阶段所产生的结果尺寸不同？"></a>1.1 候选区域提出阶段所产生的结果尺寸不同？</h2><p>由于RCNN特征提取阶段采用的是AlexNet，其最后两层是全连接层fc6和fc7，所以必须保证输入的图片尺寸相同。</p>
<p>而候选区域所产生的结果尺寸是不相同的。为此，论文中作者采用了多种方式对图片进行放缩（各向同性、各向异性、加padding），最后经过对比实验确定各向异性加padding的放缩方式效果最好。各向同性、各向异性、加padding的具体效果可以看上面链接中的文章。</p>
<h2 id="1-2-分类器SVM使用的是二分类？"><a href="#1-2-分类器SVM使用的是二分类？" class="headerlink" title="1.2 分类器SVM使用的是二分类？"></a>1.2 分类器SVM使用的是二分类？</h2><p>论文中，单个SVM实现的是二分类，分类器阶段由多个SVM组合而成。比如总共有20种不同的物体（加1种背景），那么分类阶段必须要有21个SVM：第1个SVM的输出是该候选区域属于分类1的概率；第2个SVM的输出是该候选区域属于分类2的概率；……；第21个SVM的输出是该候选区域属于背景的概率。</p>
<p>对21个SVM的输出结果进行排序，哪个输出最大，候选区域就属于哪一类。比如，对于某个候选区域，第21个SVM的输出最大，那么就将该候选区域标为背景。</p>
<h2 id="1-3-分类器的输入是？回归器的输入是？"><a href="#1-3-分类器的输入是？回归器的输入是？" class="headerlink" title="1.3 分类器的输入是？回归器的输入是？"></a>1.3 分类器的输入是？回归器的输入是？</h2><p>分类器的输入是特征提取器AlexNet的fc6的输出结果，回归器的输入是特征提取器AlexNet的pool5的输出结果。</p>
<p>之所以这样取输入，是因为，分类器不依赖坐标信息，所以取fc6全连接层的结果是没有问题的。但是回归器依赖坐标信息（要输出坐标的修正量），必须取坐标信息还没有丢失前的层。而fc6全连接层已经丢失了坐标信息。</p>
<h2 id="1-4-正负样本的选择？"><a href="#1-4-正负样本的选择？" class="headerlink" title="1.4 正负样本的选择？"></a>1.4 正负样本的选择？</h2><p>正负样本是必须要考虑的问题。论文的做法是每个batch所采样的正负样本比为1：3。当然这个比例是可以变化的，这个系列的后续改进就把正负样本比变为了1：1。</p>
<p>如果之前没有接触过类似问题的话，是比较容易想当然地认为训练特征提取器、分类器、回归器时，就是把候选区域生成阶段的所有候选区域都放入训练。这样的思路是错的。一张图片中，背景占了绝大多数地方，这样就导致训练用的正样本远远少于负样本，对训练不利。</p>
<p>正确的做法是对所有候选区域进行随机采样，要求采样的结果中正样本有x张，负样本y张，且保证x与y在数值上相近。（对于一些问题，不大容易做到x:y = 1:1，但至少x与y应该在同一数量级下）</p>
<h2 id="1-5-如何训练？"><a href="#1-5-如何训练？" class="headerlink" title="1.5 如何训练？"></a>1.5 如何训练？</h2><p>RCNN的网络架构，注定了它不能像其他网络那样进行端到端（end-to-end）的训练。</p>
<p>前面提到RCNN分为4个阶段：Proposal阶段、特征提取阶段、分类阶段、回归阶段。这4个阶段都是相互独立训练的。</p>
<p>首先，特征提取器是AlexNet，将它的最后一层fc7进行改造，使得fc7能够输出分类结果。Proposal阶段对每张图片产生了1k~2k个候选区域，把这些图片依照正负样本比例喂给特征提取器，特征提取器fc7输出的分类结果与标签结果进行比对，完成特征提取器的训练。特征提取器的训练完成后，fc7层的使命也完成了，后面的分类器和回归器只会用到fc6、pool5的输出。</p>
<p>然后，Proposal和特征提取器已经训练完毕了。把它们的结果fc6，输入到分类器SVM中，SVM输出与标签结果比对，完成SVM的训练。</p>
<p>最后，回归器的训练也和SVM类似，只不过回归器取的是pool5的结果。</p>
<p>为什么不能同时进行上面3步的训练？因为特征提取器是CNN，分类器是SVM，回归器是脊回归器，不属于同一体系，无法共同训练。甚至在测试时，也需要把每一阶段的结果先保存到磁盘，再喂入下一阶段。这是非常麻烦的一件事。</p>
<p>聪明的你可能已经想到了：CNN不就能完成分类器和回归器的任务嘛？为什么不只用CNN？这就是RCNN系列后续做的改进之一，我们在下面会讲到。但由于某些原因，在RCNN这篇论文发表时，采用的是特征提取、分类器、回归器相互独立的结构。</p>
<h2 id="1-6-Proposal的每个候选区域单独提取特征，是不是很慢？"><a href="#1-6-Proposal的每个候选区域单独提取特征，是不是很慢？" class="headerlink" title="1.6 Proposal的每个候选区域单独提取特征，是不是很慢？"></a>1.6 Proposal的每个候选区域单独提取特征，是不是很慢？</h2><p>是的，很慢。Proposal阶段会产生1k<del>2k个候选区域，每个候选区域都独立提取特征的话，那相当于每幅图片都要进行1k</del>2k次CNN。（当然由于有正负样本采样，实际并没有有这么多）</p>
<p>有没有什么好方法？聪明的你应该能想到：既然候选区域都是图片的一部分，那么先对整张图片进行特征提取，然后根据每个候选区域在原图上的位置选择相应的特征不就行了。</p>
<p>这种方式正是RCNN系列的后续改进之一，只不过在实现上要动点脑筋。（这种方式得到的每个区域的特征数目是不同的，如何把不同特征数目变为相同数目？）</p>
<h1 id="2-Fast-RCNN"><a href="#2-Fast-RCNN" class="headerlink" title="2. Fast-RCNN"></a>2. Fast-RCNN</h1><p>首先还是采用selective search提取2000个候选框，然后，使用一个神经网络对全图进行特征提取。接着，使用一个RoI Pooling Layer在全图特征上摘取每一个RoI对应的特征，再通过全连接层(FC Layer)进行分类与包围框的修正。Fast R-CNN的贡献可以主要分为两个方面：</p>
<p>1) 取代R-CNN的串行特征提取方式，直接采用一个神经网络对全图提取特征(这也是为什么需要RoI Pooling的原因)。<br>2) 除了selective search，其他部分都可以合在一起训练。</p>
<h2 id="2-1-为什么叫Fast？"><a href="#2-1-为什么叫Fast？" class="headerlink" title="2.1 为什么叫Fast？"></a>2.1 为什么叫Fast？</h2><p>将特征提取器、分类器、回归器合并，使得训练过程不需要再将每阶段结果保存磁盘单独训练，可以一次性完成训练，加快了训练速度。这是Fast之一。</p>
<p>对整张图片进行特征提取，用ROI层处理候选区域的特征，使得原本每一个候选区域都要做一次特征提取，变为了现在一整张图片做一次特征提取。训练速度（8.8倍）和测试速度（146倍）都大大加快，这是Fast之二。</p>
<h2 id="2-2-分类器和回归器的实现细节？"><a href="#2-2-分类器和回归器的实现细节？" class="headerlink" title="2.2 分类器和回归器的实现细节？"></a>2.2 分类器和回归器的实现细节？</h2><p>分类器应该都能想到，用的softmax代替SVM。</p>
<p>回归器求出（x,y,w,h）4个量，分别代表定位框左上角的坐标xy、宽度w、高度h，损失函数用的是Smooth-L1。</p>
<h2 id="2-3-Proposal阶段看上去有点违和？"><a href="#2-3-Proposal阶段看上去有点违和？" class="headerlink" title="2.3 Proposal阶段看上去有点违和？"></a>2.3 Proposal阶段看上去有点违和？</h2><p>发展到Fast-RCNN，后续3个阶段都是CNN完成的了，只剩下Proposal阶段还没有用CNN方式解决。Proposal阶段的结果还是需要先保存到磁盘，再喂入后续阶段，有点违和。</p>
<p>RCNN系列后续的改进，将把Proposal阶段也用CNN实现，真正做到端到端（end-to-end）。</p>
<h1 id="3-Faster-RCNN"><a href="#3-Faster-RCNN" class="headerlink" title="3.Faster-RCNN"></a>3.Faster-RCNN</h1><p>Faster-RCNN引入了RPN网络（region proposal network）来代替selective-search。这使得整个网络实现了端到端。</p>
<h2 id="3-1-RPN网络是如何工作的？"><a href="#3-1-RPN网络是如何工作的？" class="headerlink" title="3.1 RPN网络是如何工作的？"></a>3.1 RPN网络是如何工作的？</h2><p>整张图片经过特征提取，得到FeatureMap；将FeatureMap中的每一点按照视野域找到原图中对应的位置，称为Anchor；每个Anchor生成不同大小不同长宽比的多个候选区域。</p>
<p>回忆下selective-search的候选区域生成方式，它是按照颜色和纹理不断合并得到候选区域的，候选区域的产生没有规律，而RPN是每个Anchor都有对应的固定数量的候选区域，规律很明显。</p>
<p>理论上说，selective-search生成候选区域的方式更符合我们的直觉，而实验结果，在Faster-RCNN中RPN并不比selective-search差</p>
<h2 id="3-2-为什么是Faster？"><a href="#3-2-为什么是Faster？" class="headerlink" title="3.2 为什么是Faster？"></a>3.2 为什么是Faster？</h2><p>容易想到，现在RPN网络可以与其他3个阶段共用同一个特征提取结果了，省掉了selective-search的时间。而事实上，selective-search是非常慢的，所以叫Faster。</p>
<h1 id="4-Mask-RCNN"><a href="#4-Mask-RCNN" class="headerlink" title="4.Mask-RCNN"></a>4.Mask-RCNN</h1><h2 id="4-1-为什么叫mask？"><a href="#4-1-为什么叫mask？" class="headerlink" title="4.1 为什么叫mask？"></a>4.1 为什么叫mask？</h2><p>Faster-RCNN网络的最后分别是分类网络和回归网络两条路并行，Mask-RCNN则是再加一条Mask网络与它们并行。</p>
<p>Mask网络的实现是FCN网络，这也是语义分割领域中非常经典的网络结构。</p>
<p>由于Mask网络的加入，Mask-RCNN不仅能处理物体检测问题，还能处理语义分割问题。</p>
<h2 id="4-2-还有哪些细节上的变化？"><a href="#4-2-还有哪些细节上的变化？" class="headerlink" title="4.2 还有哪些细节上的变化？"></a>4.2 还有哪些细节上的变化？</h2><p>首先是ROI层变为了ROIAlign，目的是一样的。那为什么要加入ROIAlign呢？这是因为ROI层会有对齐问题，对齐问题在分类和框选时影响不大，但在语义分割需要严格依赖每个像素点的坐标时，影响会很大。ROIAlign能够解决对齐问题。</p>
<p>然后是特征提取网络改为了ResNet101+FPN；FPN建议对语义分割或者关键点定位感兴趣的同学了解下，FPN是这两个领域中非常经典的结构。</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/2019-05-07-Mask%20R-CNN%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gsynf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/07/2019-05-07-Mask%20R-CNN%E6%80%BB%E7%BB%93/" itemprop="url">
                  Mask R-CNN总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-07T00:00:00+08:00">
                2019-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文链接：<a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">https://arxiv.org/abs/1703.06870</a><br>目前找到了非常好的一位博客：<a href="https://blog.csdn.net/WZZ18191171661/article/details/79453780，" target="_blank" rel="noopener">https://blog.csdn.net/WZZ18191171661/article/details/79453780，</a> 感谢！<br><a href="https://blog.csdn.net/jiongnima/article/details/79094159，" target="_blank" rel="noopener">https://blog.csdn.net/jiongnima/article/details/79094159，</a> 这个也不错。<br>相关知识介绍：<br>R-CNN-<a href="https://www.jianshu.com/p/5056e6143ed5" target="_blank" rel="noopener">https://www.jianshu.com/p/5056e6143ed5</a>;<br>Faster R-CNN-<a href="https://blog.csdn.net/qq_17448289/article/details/52871461" target="_blank" rel="noopener">https://blog.csdn.net/qq_17448289/article/details/52871461</a><br><a href="https://blog.csdn.net/u011974639/article/details/78053203" target="_blank" rel="noopener">https://blog.csdn.net/u011974639/article/details/78053203</a>, 个人感觉这两篇讲的很好。</p>
</blockquote>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul>
<li>Mask RCNN可以看做是一个通用实例分割架构。</li>
<li>Mask RCNN以Faster RCNN原型，增加了一个分支用于分割任务。</li>
<li>Mask RCNN比Faster RCNN速度慢一些，达到了5fps。</li>
<li>可用于人的姿态估计等其他任务</li>
</ul>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><ul>
<li>实例分割不仅要正确的找到图像中的objects，还要对其精确的分割。所以Instance Segmentation可以看做object dection和semantic segmentation的结合。</li>
<li>Mask RCNN是Faster RCNN的扩展，对于Faster RCNN的每个Proposal Box都要使用FCN进行语义分割，分割任务与定位、分类任务是同时进行的。</li>
<li>引入了RoI Align代替Faster RCNN中的RoI Pooling。因为RoI Pooling并不是按照像素一一对齐的（pixel-to-pixel alignment），也许这对bbox的影响不是很大，但对于mask的精度却有很大影响。使用RoI Align后mask的精度从10%显著提高到50%，第3节将会仔细说明。</li>
<li>引入语义分割分支，实现了mask和class预测的关系的解耦，mask分支只做语义分割，类型预测的任务交给另一个分支。这与原本的FCN网络是不同的，原始的FCN在预测mask时还用同时预测mask所属的种类。</li>
<li>没有使用什么花哨的方法，Mask RCNN就超过了当时所有的state-of-the-art模型。</li>
<li>使用8-GPU的服务器训练了两天。</li>
</ul>
<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2.Related Work"></a>2.Related Work</h1><ul>
<li>相比于FCIS，FCIS使用全卷机网络，同时预测物体classes、boxes、masks，速度更快，但是对于重叠物体的分割效果不好。</li>
</ul>
<h1 id="3-Mask-R-CNN"><a href="#3-Mask-R-CNN" class="headerlink" title="3.Mask R-CNN"></a>3.Mask R-CNN</h1><ul>
<li>Mask R-CNN基本结构：与Faster RCNN采用了相同的two-state步骤：首先是找出RPN，然后对RPN找到的每个RoI进行分类、定位、并找到binary mask。这与当时其他先找到mask然后在进行分类的网络是不同的。</li>
<li>Mask R-CNN的损失函数：L = L<sub>cls</sub> + L<sub>box</sub> + L<sub>mask</sub></li>
<li>Mask的表现形式(Mask Representation)：因为没有采用全连接层并且使用了RoIAlign，可以实现输出与输入的像素一一对应。</li>
<li>RoIAlign：RoIPool的目的是为了从RPN网络确定的ROI中导出较小的特征图(a small feature map，eg 7x7)，ROI的大小各不相同，但是RoIPool后都变成了7x7大小。RPN网络会提出若干RoI的坐标以[x,y,w,h]表示，然后输入RoI Pooling，输出7x7大小的特征图供分类和定位使用。问题就出在RoI Pooling的输出大小是7x7上，如果RON网络输出的RoI大小是8*8的，那么无法保证输入像素和输出像素是一一对应，首先他们包含的信息量不同（有的是1对1，有的是1对2），其次他们的坐标无法和输入对应起来（1对2的那个RoI输出像素该对应哪个输入像素的坐标？）。这对分类没什么影响，但是对分割却影响很大。RoIAlign的输出坐标使用插值算法得到，不再量化；每个grid中的值也不再使用max，同样使用差值算法。</li>
<li>Network Architecture: 为了表述清晰，有两种分类方法</li>
</ul>
<ol>
<li>使用了不同的backbone：resnet-50，resnet-101，resnext-50，resnext-101；</li>
<li>使用了不同的head Architecture：Faster RCNN使用resnet50时，从CONV4导出特征供RPN使用，这种叫做ResNet-50-C4</li>
<li>作者使用除了使用上述这些结构外，还使用了一种更加高效的backbone——FPN</li>
</ol>
<h2 id="3-1-Implementation-Details"><a href="#3-1-Implementation-Details" class="headerlink" title="3.1.Implementation Details"></a>3.1.Implementation Details</h2><p>使用Fast/Faster相同的超参数，同样适用于Mask RCNN</p>
<ul>
<li>Training:<br>1、与之前相同，当IoU与Ground Truth的IoU大于0.5时才会被认为有效的RoI，L{_{mask}}只把有效RoI计算进去。<br>2、采用image-centric training，图像短边resize到800，每个GPU的mini-batch设置为2，每个图像生成N个RoI，对于C4 backbone的N=64，对于FPN作为backbone的，N=512。作者服务器中使用了8块GPU，所以总的minibatch是16，迭代了160k次，初始lr=0.02，在迭代到120k次时，将lr设定到 lr=0.002，另外学习率的weight_decay=0.0001，momentum = 0.9。如果是resnext，初始lr=0.01,每个GPU的mini-batch是1。<br>3、RPN的anchors有5种scale，3种ratios。为了方便剥离、如果没有特别指出，则RPN网络是单独训练的且不与Mask R-CNN共享权重。但是在本论文中，RPN和Mask R-CNN使用一个backbone，所以他们的权重是共享的。<br>（Ablation Experiments 为了方便研究整个网络中哪个部分其的作用到底有多大，需要把各部分剥离开）</li>
</ul>
<ul>
<li>Inference：<br>在测试时，使用C4 backbone情况下proposal number=300，使用FPN时proposal number=1000。然后在这些proposal上运行bbox预测，接着进行非极大值抑制。mask分支只应用在得分最高的100个proposal上。顺序和train是不同的，但这样做可以提高速度和精度。mask 分支对于每个roi可以预测k个类别，但是我们只要背景和前景两种，所以只用k-th mask，k是根据分类分支得到的类型。然后把k-th mask resize成roi大小，同时使用阈值分割(threshold=0.5)二值化</li>
</ul>
<h1 id="4-Experiments-Instance-Segmentation"><a href="#4-Experiments-Instance-Segmentation" class="headerlink" title="4.Experiments: Instance Segmentation"></a>4.Experiments: Instance Segmentation</h1><h2 id="4-1-Main-Results"><a href="#4-1-Main-Results" class="headerlink" title="4.1.Main Results"></a>4.1.Main Results</h2><p>在下图中可以明显看出，FCIS的分割结果中都会出现一条竖着的线(systematic artifacts)，这线主要出现在物体重的部分，作者认为这是FCIS架构的问题，无法解决的。但是在Mask RCNN中没有出现。<br><img src="https://i.loli.net/2019/04/29/5cc65cc9ecfc3.png" alt="figure6&amp;table2"></p>
<h2 id="4-2-Ablation-Experiments"><a href="#4-2-Ablation-Experiments" class="headerlink" title="4.2. Ablation Experiments"></a>4.2. Ablation Experiments</h2><ul>
<li>Architecture:<br>从table 2a中看出，Mask RCNN随着增加网络的深度、采用更先进的网络，都可以提高效果。注意：并不是所有的网络都是这样。</li>
<li>Multinomial vs. Independent Masks:(mask分支是否进行类别预测)                                                                                    从table 2b中可以看出，使用sigmoid(二分类)和使用softmax(多类别分类)的AP相差很大，证明了分离类别和mask的预测是很有必要的</li>
<li>Class-Specific vs. Class-Agnostic Masks:                                                                                                                            目前使用的mask rcnn都使用class-specific masks，即每个类别都会预测出一个mxm的mask，然后根据类别选取对应的类别的mask。但是使用Class-Agnostic Masks，即分割网络只输出一个mxm的mask，可以取得相似的成绩29.7vs30.3</li>
<li>RoIAlign:                                                                                                                                                                                    tabel 2c证明了RoIAlign的性能</li>
<li>Mask Branch:<br>tabel 2e，FCN比MLP性能更好</li>
</ul>
<h2 id="4-3-Bounding-Box-Detection-Results"><a href="#4-3-Bounding-Box-Detection-Results" class="headerlink" title="4.3.Bounding Box Detection Results"></a>4.3.Bounding Box Detection Results</h2><ul>
<li>Mask RCNN精度高于Faster RCNN</li>
<li>Faster RCNN使用RoI Align的精度更高</li>
<li>Mask RCNN的分割任务得分与定位任务得分相近，说明Mask RCNN已经缩小了这部分差距。</li>
</ul>
<h2 id="4-4-Timing"><a href="#4-4-Timing" class="headerlink" title="4.4.Timing"></a>4.4.Timing</h2><ul>
<li>Inference：195ms一张图片，显卡Nvidia Tesla M40。其实还有速度提升的空间，比如减少proposal的数量等。</li>
<li>Training：ResNet-50-FPN on COCO trainval35k takes 32 hours  in our synchronized 8-GPU implementation (0.72s per 16-image mini-batch)，and 44 hours with ResNet-101-FPN。</li>
</ul>
<h1 id="5-Mask-R-CNN-for-Human-Pose-Estimation"><a href="#5-Mask-R-CNN-for-Human-Pose-Estimation" class="headerlink" title="5. Mask R-CNN for Human Pose Estimation"></a>5. Mask R-CNN for Human Pose Estimation</h1><p>让Mask R-CNN预测k个masks，每个mask对应一个关键点的类型，比如左肩、右肘，可以理解为one-hot形式。</p>
<ul>
<li>使用cross entropy loss，可以鼓励网络只检测一个关键点;</li>
<li>ResNet-FPN结构</li>
<li>训练了90k次，最开始lr=0.02，在迭代60k次时，lr=0.002,80k次时变为0.0002</li>
</ul>
<p><img src="https://i.loli.net/2019/04/29/5cc65f4085801.png" alt="figure7"><br><em>图7.使用Mask R-CNN（ResNet-50-FPN）在COCO测试中的关键点检测结果，以及从相同模型预测的人分割掩码。该模型的关键点AP为63.1，运行速度为5 fps。</em></p>
<p><img src="https://i.loli.net/2019/04/29/5cc6605e29496.png" alt="table4/5/6"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/">&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/20/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Gsynf" />
          <p class="site-author-name" itemprop="name">Gsynf</p>
           
              <p class="site-description motion-element" itemprop="description">没有个性，不签名！</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">89</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gsynf</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
