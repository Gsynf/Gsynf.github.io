<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hadoop基本概念</title>
    <url>/2020/10/30/2020-10-30-Hadoop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h1><p>Apache为可靠、可伸缩、分布式计算提供的开源软件。</p>
<ul>
<li><p>解决问题：</p>
<ul>
<li>海量数据的存储（HDFS）</li>
<li>海量数据的分析（MapReduce）</li>
<li>资源管理调度（YARN）</li>
</ul>
</li>
<li><p>作者：Doug Cutting</p>
</li>
<li><p>受谷歌三篇论文启发（GFS，MapReduce，BigTable）</p>
</li>
<li><p>擅长海量离线日志分析</p>
</li>
</ul>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li><p>Apache</p>
<p>官方版本</p>
</li>
<li><p>Cloudera(CDH)</p>
<p>使用下载最多的版本，稳定，有商业支持，在Apache的基础上打上了一些patch。推荐使用。</p>
</li>
<li><p>HDP(Hortonworks Data Platform)</p>
<p>Hortonworks公司发行版本。</p>
</li>
</ul>
<h2 id="伪分布式安装"><a href="#伪分布式安装" class="headerlink" title="伪分布式安装"></a>伪分布式安装</h2><ul>
<li><p>vmware安装centos虚拟机，内存改大（2G以上），网络适配器选择自定义Vmnet8(NAT)模式。</p>
<ul>
<li>NAT:vmvare建立一个虚拟网关，使cetos里的虚拟网卡和windows下的虚拟网卡处于同一网段下（和windows下的物理网卡无关）</li>
</ul>
</li>
<li><p>centos系统设置虚拟网关</p>
<p><img src="https://i.loli.net/2020/11/03/NtFbSHYh78raZWU.png" alt="centos系统设置虚拟网关"></p>
<p>修改完成之后需要重启服务器(reboot)或者重启network服务(sudo service network restart)才可以使用。</p>
</li>
<li><p>windows设置虚拟网关</p>
<p><img src="https://i.loli.net/2020/11/03/aPzsy9M3G6BgQFr.png" alt="windows设置虚拟网关"></p>
</li>
<li><p>远程连接，<code>sudo vi /etc/inittab</code>将<code>initdefault</code>的id由5改为3，这样每次启动centos就无需启动图形界面，节约内存；</p>
</li>
<li><p>上述操作前需要先将hadoop用户添加到sudoer中才可以有权限:</p>
<ul>
<li><code>su</code>进入root;</li>
<li><code>vi /etc/sudoers</code>打开，添加一行<code>hadoop ALL=(ALL) ALL</code>;</li>
</ul>
</li>
</ul>
<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><h2 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h2><p><strong>主从结构</strong></p>
<ul>
<li>主节点， <em>namenode</em></li>
<li>从节点，有很多个: <em>datanode</em></li>
</ul>
<p><strong>namenode负责</strong>：</p>
<ul>
<li>接收用户操作请求</li>
<li>维护文件系统的目录结构</li>
<li>管理文件与block之间关系，block与datanode之间关系</li>
</ul>
<p><strong>datanode负责</strong>：</p>
<ul>
<li>存储文件</li>
<li>文件被分成block存储在磁盘上</li>
<li>为保证数据安全，文件会有多个副本</li>
</ul>
<p><img src="https://i.loli.net/2020/10/31/H8UzSigRbE2Pn74.png" alt="HDFS架构"></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet中的forward和redirect区别</title>
    <url>/2020/09/06/2020-09-06-Servlet%E4%B8%AD%E7%9A%84forward%E5%92%8Credirect%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h1><p>在设计Web应用时，需要把一个系统进行结构化设计，即按照模块化进行划分，让不同的Servlet实现不同的功能，例如让其中一个Servlet负责接收用户的请求，另一个Servlet负责处理用户的请求。为了实现这种程序的模块化，就需要保证在不同的Servlet之间可以相互跳转，而Servlet中主要有两种跳转的方式：forward方式和redirect方式。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>forward：（转发）指服务器内部的重定向，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，而客户端并不知道，因此在客户端的地址栏中不会显示转向后的地址，还是原来的地址。由于整个重定向的过程用的是同一个Request，因此forward会将Request的信息带到被定向的JSP或Servlet中使用。</p>
<p>redirect：（重定向）客户端的重定向，是完全的跳转，即客户端浏览器会获取到跳转后的地址，然后重新发送请求，因此浏览器中显示跳转后的地址。同时，这种方式比forward方式多了一次网络请求，因此效率要低于forward方式。</p>
<p>因此，一般当一个forward方式可以满足要求时，尽可能地使用forward方式。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO流</title>
    <url>/2020/09/05/2020-09-05-Java%20IO%E6%B5%81/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdn.net/20180127210359151" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190418184716728.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODc1NTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180127210410630" alt="这里写图片描述"></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>TopK问题算法</title>
    <url>/2020/08/19/2020-08-22-TopK%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>Top K 问题有两种不同的解法，一种解法使用堆（优先队列），另一种解法使用类似快速排序的分治法。这两种方法各有优劣，最好都掌握。</p>
<ul>
<li><p>方法一：堆，时间复杂度 O(<em>n</em> log k)；</p>
</li>
<li><p>方法二：快排变形，（平均）时间复杂度 O(n)；</p>
</li>
</ul>
<h1 id="方法一：堆（优先队列）"><a href="#方法一：堆（优先队列）" class="headerlink" title="方法一：堆（优先队列）"></a>方法一：堆（优先队列）</h1><p> 比较直观的想法是使用堆数据结构来辅助得到最小的 k 个数。堆的性质是每次可以找出最大或最小的元素。我们可以使用一个大小为 k 的最大堆（大顶堆），将数组中的元素依次入堆，当堆的大小超过 k 时，便将多出的元素从堆顶弹出。这样，由于每次从堆顶弹出的数都是堆中最大的，最小的 k 个元素一定会留在堆里。这样，把数组中的元素全部入堆之后，堆中剩下的 k 个元素就是最大的 k 个数了。</p>
<p>其实这里堆的内部结构这部分内容并不重要。我们只需要知道堆每次会弹出最大的元素即可。在写代码的时候，我们使用的也是库函数中的优先队列数据结构，如 Java 中的 PriorityQueue。在面试中，我们不需要实现堆的内部结构，把数据结构使用好，会分析其复杂度即可。</p>
<p><strong>题解代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">    <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (i1, i2) -&gt; Integer.compare(i2, i1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">        <span class="comment">// 当前数字小于堆顶元素才会入堆</span></span><br><span class="line">        <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &lt; heap.peek()) &#123;</span><br><span class="line">            heap.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">            heap.poll(); <span class="comment">// 删除堆顶最大元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">        res[j++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>算法的复杂度分析：</strong></p>
<p>由于使用了一个大小为 k 的堆，空间复杂度为 O(k)；</p>
<p>入堆和出堆操作的时间复杂度均为 O(logk)，每个元素都需要进行一次入堆操作，故算法的时间复杂度为 O(<em>n</em>log k))。</p>
<h1 id="方法二：快排变形"><a href="#方法二：快排变形" class="headerlink" title="方法二：快排变形"></a>方法二：快排变形</h1><p>Top K 问题的另一个解法就比较难想到，需要在平时有算法的积累。实际上，“查找第 k 大的元素”是一类算法问题，称为选择问题。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p>
<p>让我们回顾快速排序的思路。快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，这个 partition 操作是原地进行的，需要 O(n)的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p>
<p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p>
<ul>
<li>若 k = m，我们就找到了最小的 k个数，就是左侧的数组；</li>
<li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 partition即可；</li>
<li>若 k&gt;m，则左侧数组中的 mm 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m 个数，对右侧数组递归地 partition 即可。</li>
</ul>
<p>这种方法需要多加领会思想，如果你对快速排序掌握得很好，那么稍加推导应该不难掌握 quick select 的要领。</p>
<p><strong>题解代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr.length &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原地不断划分数组</span></span><br><span class="line">    partitionArray(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组的前 k 个数此时就是最小的 k 个数，将其存入结果</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次 partition 操作</span></span><br><span class="line">    <span class="keyword">int</span> m = partition(arr, lo, hi);</span><br><span class="line">    <span class="comment">// 此时数组前 m 个数，就是最小的 m 个数</span></span><br><span class="line">    <span class="keyword">if</span> (k == m) &#123;</span><br><span class="line">        <span class="comment">// 正好找到最小的 k(m) 个数</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; m) &#123;</span><br><span class="line">        <span class="comment">// 最小的 k 个数一定在前 m 个数中，递归划分</span></span><br><span class="line">        partitionArray(arr, lo, m-<span class="number">1</span>, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在右侧数组中寻找最小的 k-m 个数</span></span><br><span class="line">        partitionArray(arr, m+<span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partition 函数和快速排序中相同，具体可参考快速排序相关的资料</span></span><br><span class="line"><span class="comment">// 代码参考 Sedgewick 的《算法4》</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v = a[lo];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == hi) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a[--j] &gt; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, lo, j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上述代码中需要注意一个细节：</p>
<p>partitionArray 函数中，两次递归调用传入的参数为什么都是 k？特别是第二个调用，我们在右侧数组中寻找最小的 k-m 个数，但是对于整个数组而言，这是最小的 k 个数。所以说，函数调用传入的参数应该为 k。</p>
<p><strong>算法的复杂度分析：</strong></p>
<p>空间复杂度 O(1)，不需要额外空间。<br>时间复杂度的分析方法和快速排序类似。由于快速选择只需要递归一边的数组，时间复杂度小于快速排序，期望时间复杂度为 O(n)，最坏情况下的时间复杂度为 O(n^2)。</p>
<h1 id="两种方法的优劣性比较"><a href="#两种方法的优劣性比较" class="headerlink" title="两种方法的优劣性比较"></a>两种方法的优劣性比较</h1><p>在面试中，另一个常常问的问题就是这两种方法有何优劣。看起来分治法的快速选择算法的时间、空间复杂度都优于使用堆的方法，但是要注意到快速选择算法的几点局限性：</p>
<p>第一，算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</p>
<p>第二，算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis中的#和$的区别</title>
    <url>/2020/08/19/2020-08-18-mybatis%E4%B8%AD%E7%9A%84#%E5%92%8C$%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>电磁加热中需要用到根据IOT平台传来的属性动态拼接SQL进行写入数据库，在此记录一下解决办法。</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>  MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。  </p>
<p>  动态 sql 是 mybatis 的主要特性之一，在mybatis中我们可以把参数传到xml文件，由mybatis对sql及其语法进行解析，mybatis支持使用${}和#{}。可能有些人没有留意到，认为${}和#{}的作用一样，其实他们的功能相似，但还是有区别的。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a><strong>对比</strong></h1><p>1、使用${}方式传入的参数，mybatis不会对它进行特殊处理，而使用#{}传进来的参数，mybatis默认会将其当成字符串。可能在赋值给如id=#{id}和id=${id}看不出多大区别，但是作为表名或字段参数时可以明显看出，可以看看下面的例子：</p>
<p>假设传入的参数为表名test</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">selec * from #&#123;table&#125;;</span><br></pre></td></tr></table></figure>



<p>解析后是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure>

<p>而</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> $&#123;<span class="keyword">table</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>解析后是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>

<p>很明显，前者多了字符串的引号，会失败，后者正常查询会成功；</p>
<p>所以对于传入分组(order)字段或者排序字段(order)，应使用${},避免出现order  by “id” 等情况。</p>
<p>2、#和$在预编译处理中是不一样的。#类似jdbc中的PreparedStatement，对于传入的参数，在预处理阶段会使用?代替，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = ?;</span><br></pre></td></tr></table></figure>

<p>待真正查询的时候即在数据库管理系统中（DBMS）才会代入参数。</p>
<p>而${}则是简单的替换，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>1、能使用#{}的地方应尽量使用#{}</p>
<p>2、像PreparedStatement ，#{}可以有效防止sql注入，${}则可能导致sql注入成功。</p>
<p>所谓sql注入，就是指把用户输入的数据拼接到sql语句后面作为sql语句的一部分执行，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">' "+name+" '</span> <span class="keyword">and</span> <span class="keyword">password</span>=<span class="string">' "+password+" '</span></span><br></pre></td></tr></table></figure>

<p>那么只要用户输入用户名admin和密码123456’ or  ‘abc’ = ‘abc’,那么拼接出来的语句就为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">' admin '</span> <span class="keyword">and</span> <span class="keyword">password</span>=<span class="string">'123456'</span> <span class="keyword">or</span> <span class="string">'abc'</span>= <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure>

<p>这样只要user表有数据，就会返回结果，达到sql注入的目的。同样，用户输入用户名a’则 and password=’ “+password+” ‘就会被注释掉，也达到注入sql的目的。</p>
<p><strong>附：</strong></p>
<p>这里顺带提下防止sql注入的几种方式(可能不止这几种):</p>
<p>(1)、jdbc使用 PreparedStatement代替Statement， PreparedStatement 不仅提高了代码的可读性和可维护性.而且也提高了安全性，有效防止sql注入；</p>
<p>(2)、在程序代码中使用正则表达式过滤参数。使用正则表达式过滤可能造成注入的符号，如’ –等</p>
<p>(3)、在页面输入参数时也进行字符串检测和提交时进行参数检查，同样可以使用正则表达式，不允许特殊符号出现。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于http无状态</title>
    <url>/2020/08/18/2020-08-18-%E5%85%B3%E4%BA%8Ehttp%E6%97%A0%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>首先对于标准的HTTP来说，是无状态的。<strong>而Cookie、Session则是为了方便数据的处理，从而维护服务器和用户的状态</strong>，它们不是标准的HTTP协议的一部分，使用Cookie和Session的HTTP可以被认为是有状态的。</p>
<p>这个<strong>无状态，</strong>即<strong>每一次请求之间是没有联系的，都是独立的，因此服务器不知道请求两次之间是否是同一个用户。</strong></p>
<p>例如一个购物网站的例子：</p>
<p>对于标准的HTTP，用户登录一个购物网站，第一次请求携带账号密码登录，服务器验证后响应服务。第二次请求也需要携带账号密码，才能进行服务。但是有了Session、Cookie这些手段，可以在B-S之间维护会话状态，从而无需每次携带密码登录。</p>
<p>Session、Cookie分别是服务器和浏览器上的一小块缓存，Session和Cookie通过SessionId进行匹配，在Cookie以及Session之中存储信息可以维护用户和服务器之间的状态，这样可以将HTTP请求联系起来。这样的HTTP存在很多方便性，但是它们不属于HTTP的标准，仅仅会话技术。</p>
<p><strong>理解了HTTP无状态的含义。就需要理解为什么HTTP是基于TCP的，但是HTTP是无状态</strong>。</p>
<p>首先TCP是有状态的，在一次TCP连接之中，每一次的数据交换都和上一次紧密相关的，TCP报文存在ACK字段用于确认上次接收的报文，并且TCP在建立连接时交换了很多的连接配置信息，例如收、发缓存大小，报文序号等。所以，每一次TCP数据交换两方都是能够确切知道对方的信息的。</p>
<p><strong>为什么基于TCP的HTTP是无状态呢？</strong></p>
<p>因为HTTP是短连接，即每次“请求-响应”都是一次TCP连接。比如用户一次请求就是一次TCP连接，服务器响应结束后断开连接。而每次TCP连接是没有关联的，因此HTTP是无状态的<strong>。如果想要使得每次TCP连接之间有关联，服务器和浏览器就得存储相关的信息，这个就是Cookie和Session的作用。</strong></p>
<p><strong>但是又出现新的问题，HTTP 1.1后支持了keep-alive，即长连接，那么每次HTTP请求还是无状态吗？</strong></p>
<p>答案是是的。虽然HTTP 1.1为了效率，支持了keep-alive，但是这个keep-alive是有时间限制的。这个时间可以通过设置HTTP进程的配置文件来修改，这个时间很短，是以秒来计算的，例如10秒。因此在这10秒内的HTTP请求是使用同一个TCP连接，但是10秒后又重新进行连接。这个时间可以被认为是无状态的。例如那个购物的例子，不可能10s内的HTTP请求无需密码来验证，首先这个时间很短，并且还得记录每次HTTP请求的时间是否在10秒内，这样记录的方式和Session又有什么区别。</p>
<p><strong>还有一个误区，有些人说TCP是长连接、有状态的？</strong></p>
<p>这个“长连接”不够准确，因为TCP是传输层协议，它没有“长、短”的区分，“长、短”的区别仅仅是看上层协议的使用。例如HTTP使用的TCP就是短连接，而FTP使用的TCP就是长连接。虽然TCP有个“keep-alive”的概念，但是这和HTTP的“keep-alive”没有一点关系，TCP的“keep-alive”仅仅是为了维持连接的正常，保证连接不被断开，因此TCP会间隔的发送数据包检测是否连接正常，这个间隔的时间就是“keep-alive”的作用。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中创建线程的三种方式</title>
    <url>/2020/07/14/2020-07-14-Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h1><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。Java可以用三种方式来创建线程，如下所示：</p>
<p>1）继承Thread类创建线程</p>
<p>2）实现Runnable接口创建线程</p>
<p>3）使用Callable和Future创建线程</p>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p>通过继承Thread类来创建并启动多线程的一般步骤如下</p>
<p>1】定义Thread类的子类，并重写该类的<strong>run()</strong>方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
<p>2】创建Thread子类的实例，也就是创建了线程对象</p>
<p>3】启动线程，即调用线程的<strong>start()</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　　<span class="keyword">new</span> MyThread().start();<span class="comment">//创建并启动线程</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>通过实现Runnable接口创建并启动线程一般步骤如下：</p>
<p>1】定义Runnable接口的实现类，一样要重写run()方法，这个run()方法和Thread中的run()方法一样是线程的执行体</p>
<p>2】创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
<p>3】第三步依然是通过调用线程对象的start()方法来启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> MyThread2();</span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myThread);</span><br><span class="line">　　　　thread().start();</span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Callable和Future"><a href="#使用Callable和Future" class="headerlink" title="使用Callable和Future"></a>使用Callable和Future</h2><p>1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p>
<p>2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<p>3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p>
<p>4】调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> MyThread3();</span><br><span class="line">　　　<span class="comment">//使用Lambda表达式创建Callable对象</span></span><br><span class="line">　　  <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(</span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　  );</span><br><span class="line">　　　<span class="keyword">new</span> Thread(task,<span class="string">"有返回值的线程"</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line">　　  <span class="keyword">try</span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"子线程的返回值："</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：</p>
<p>1、线程只是实现Runnable或实现Callable接口，还可以继承其他类。</p>
<p>2、这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</p>
<p>3、但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。</p>
<p>4、继承Thread类的线程类不能再继承其他父类（Java单继承决定）。</p>
<p>注：一般推荐采用实现接口的方式来创建多线程</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>spring中bean的配置和注入</title>
    <url>/2020/07/12/2020-07-12-spring%E4%B8%ADbean%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/wuchanming/p/5426746.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuchanming/p/5426746.html</a></p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Integer.parseInt()和Integer.valueOf()的区别</title>
    <url>/2020/07/12/2020-07-12-Java%E4%B8%ADInteger.parseInt()%E5%92%8CInteger.valueOf()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>设有下面两个赋值语句：<br>  a = Integer.parseInt(“123”);<br>  b = Integer.valueOf(“123”).intValue();<br>  下述说法正确的是（ d ）。<br>  A、a是整数类型变量，b是整数类对象。<br>  B、a是整数类对象，b是整数类型变量。<br>  C、a和b都是整数类对象并且值相等。<br>  D、a和b都是整数类型变量并且值相等。</p>
<h1 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h1><p>  parseInt(String s )方法是类Integer的静态方法，它的作用就是将形参 s 转化为整数，比如：<br>  Interger.parseInt(“1”)=1;<br>  Integer.parseInt(“20”)=20;<br>  Integer.parseInt(“324”)=324;<br>  当然，s 表示的整数必须合法，不然是会抛异常的。<br>  valueOf(String s )也是Integer类的静态方法，它的作用是将形参 s 转化为Integer对象，<br>  什么是Integer对象，Integer就是基本数据类型int型包装类，就是将int包装成一个类，这样在很多场合下是必须的。如果理解不了</p>
<p>  你就认为int是Integer的mini版，好用了很多，但也丢失了一些功能，好了，看代码：<br>   Interger.valueOf(“123”)=Integer(123)<br>  这时候Integer（123）就是整数123的对象表示形式，它再调用intValue()方法，就是将123的对象表示形式转化为基本数据123<br>  所以，选择D</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中n&(n-1)和n&(-n)</title>
    <url>/2020/07/04/2020-07-04-Java%E4%B8%ADn&amp;(n-1)%E5%92%8Cn&amp;(-n)/</url>
    <content><![CDATA[<h1 id="n-amp-n-1"><a href="#n-amp-n-1" class="headerlink" title="n&amp;(n-1)"></a>n&amp;(n-1)</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>将n的二进制表示中的最低位为1的改为0。</p>
<p>举例：</p>
<p>n = 10100(二进制），则(n-1) = 10011 ==》n&amp;(n-1) = 10000，可见n中从右数第一个1变为了0。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li><p>求某一个数的二进制表示中1的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (n ！= <span class="number">0</span>) &#123;</span><br><span class="line">	count ++;</span><br><span class="line">	n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断一个数是否是2的方幂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n &gt; <span class="number">0</span> &amp;&amp; ((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> )  <span class="comment">// 若为2的某次方幂，则其二进制表示中只有一个1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算N!的质因数2的个数</p>
<p>N!的质因数2的个数为<code>N - (N二进制表示中1的个数)</code>，简单推理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">N = <span class="number">10101</span>(二进制表示）</span><br><span class="line">现在我们跟踪最高位的<span class="number">1</span>，不考虑其他位假定为<span class="number">0</span>，</span><br><span class="line">则在</span><br><span class="line">[N / <span class="number">2</span>] <span class="number">01000</span></span><br><span class="line">[N / <span class="number">4</span>] <span class="number">00100</span></span><br><span class="line">[N / <span class="number">8</span>] <span class="number">00010</span></span><br><span class="line">[N / <span class="number">16</span>] <span class="number">00001</span></span><br><span class="line">则所有相加等于<span class="number">01111</span> = <span class="number">10000</span> - <span class="number">1</span></span><br><span class="line">由此推及其他位可得：(<span class="number">10101</span>)!的质因数<span class="number">2</span>的个数为<span class="number">10000</span> - <span class="number">1</span> + <span class="number">00100</span> - <span class="number">1</span> + <span class="number">00001</span> - <span class="number">1</span> = <span class="number">10101</span> - <span class="number">3</span>(二进制表示中<span class="number">1</span>的个数)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="n-amp-n"><a href="#n-amp-n" class="headerlink" title="n&amp;(-n)"></a>n&amp;(-n)</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>获得从右数第一个1的位置。</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>一个数的因子中形如2^k的数为多少，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10: 0000 1010</span><br><span class="line"></span><br><span class="line">-10: 1111 0110</span><br><span class="line"></span><br><span class="line">10&amp;(-10)为 0010 = 2 所以10的因子中为2的有一个，2^k的形式的为 2^1</span><br><span class="line"></span><br><span class="line">8&amp;(-8) = [1000] = 8 所以8的因子中为2的有3个，2^k的形式为2^3</span><br></pre></td></tr></table></figure>



<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>利用postman进行接口调试调用</title>
    <url>/2020/07/01/2020-07-01-%E5%88%A9%E7%94%A8postman%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li><p>谷歌浏览器安装插件：Postman  Interceptor；</p>
</li>
<li><p>本地安装：Postman App，官网即可，需要注意一下APP和插件版本要匹配，否则可能会出现无法连接的情况，个人没有遇到过，但看到其他人有此种问题，均保持最新版本即可；</p>
</li>
<li><p>Postman  Interceptor插件打开打开<code>capture request</code>；</p>
<p><img src="https://i.loli.net/2020/07/01/aoOMHZBTvI4eUsg.png" alt="插件打开capture request"></p>
</li>
<li><p>Postman App右上角卫星小图标，点击安装 Interceptor Bridge；</p>
</li>
<li><p>Postman App右上角卫星小图标，Request中打开Interceptor ，可选择request保存位置;Cookie中打开cookie，可输入要保存cookie的域名，可能需要额外设置一个超过10位的密码，设置后在浏览器插件中也输入即可；</p>
</li>
<li><p>在浏览器进行访问，在上一步设置的request保存位置中可以找到刚才浏览器的请求，这样可以直接在刚才浏览器请求的基础上进行参数的修改再次发起请求即可；</p>
</li>
<li><p>我这里有些问题，上述过程之后发起请求并不可以，需要自己手动再输入Cookie，浏览器-&gt;右键“检查”/F12-&gt;NetWork-&gt;找到刚才的请求-&gt;Request Header中拿到Cookie-&gt;Postman App的Header中新建key为<code>Cookie</code>，value为刚才从浏览器拷贝的Cookie内容；能够自动携带Cookie的方法目前还没有找到。</p>
</li>
</ol>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java死锁示例</title>
    <url>/2020/06/24/2020-06-24-Java%E6%AD%BB%E9%94%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>面试过程中遇到，手写一个Java死锁的示例</p>
</blockquote>
<p>如果线程A持有锁L并且想获得锁M，线程B持有锁M并且想获得锁L，那么这两个线程将永远等待下去，这种情况就是最简单的死锁形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (left)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (right)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"leftRight end!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (right)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (left)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"rightLeft end!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里一定要有”Thread.sleep(2000)”让线程睡一觉，不然一个线程运行了，另一个线程还没有运行，先运行的线程很有可能就已经连续获得两个锁了。写两个线程分别调用它们：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread0</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DeadLock dl;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread0</span><span class="params">(DeadLock dl)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dl = dl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            dl.leftRight();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DeadLock dl;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(DeadLock dl)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dl = dl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            dl.rightLeft();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写个main函数调用一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeadLock dl = <span class="keyword">new</span> DeadLock();</span><br><span class="line">    Thread0 t0 = <span class="keyword">new</span> Thread0(dl);</span><br><span class="line">    Thread1 t1 = <span class="keyword">new</span> Thread1(dl);</span><br><span class="line">    t0.start();</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>避免死锁的方式</strong></p>
<p>既然可能产生死锁，那么接下来，讲一下如何避免死锁。</p>
<p>1、让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实</p>
<p>2、设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量</p>
<p>3、既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后变回返回一个失败信息</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis注解-通过provider类实现动态SQL语句</title>
    <url>/2020/06/23/2020-06-23-Mybatis%E6%B3%A8%E8%A7%A3-%E9%80%9A%E8%BF%87provider%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>电磁加热中需要用到根据IOT平台传来的属性动态拼接SQL进行写入数据库，在此记录一下解决办法。</p>
</blockquote>
<h1 id="新增provider类"><a href="#新增provider类" class="headerlink" title="新增provider类"></a>新增provider类</h1><p>提供CRUD对应的SQL语句。这里的SQL语句使用SQL类的方式构建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.jdbc.SQL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryDynaSqlProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                 .SELECT(<span class="string">"*"</span>)</span><br><span class="line">                 .FROM(<span class="string">"category_"</span>)</span><br><span class="line">                 .toString();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .SELECT(<span class="string">"*"</span>)</span><br><span class="line">                .FROM(<span class="string">"category_"</span>)</span><br><span class="line">                .WHERE(<span class="string">"id=#&#123;id&#125;"</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .INSERT_INTO(<span class="string">"category_"</span>)</span><br><span class="line">                .VALUES(<span class="string">"name"</span>, <span class="string">"#&#123;name&#125;"</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .UPDATE(<span class="string">"category_"</span>)</span><br><span class="line">                .SET(<span class="string">"name=#&#123;name&#125;"</span>)</span><br><span class="line">                .WHERE(<span class="string">"id=#&#123;id&#125;"</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .DELETE_FROM(<span class="string">"category_"</span>)</span><br><span class="line">                .WHERE(<span class="string">"id=#&#123;id&#125;"</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态拼接SQL"><a href="#动态拼接SQL" class="headerlink" title="动态拼接SQL"></a>动态拼接SQL</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryOrderByParam</span><span class="params">(OrderPara param)</span> </span>&#123;</span><br><span class="line">        SQL sql = <span class="keyword">new</span> SQL().SELECT(<span class="string">"*"</span>).FROM(TBL_ORDER);</span><br><span class="line">        String room = param.getRoom();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(room)) &#123;</span><br><span class="line">            sql.WHERE(<span class="string">"room LIKE #&#123;room&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date myDate = param.getMyDate();</span><br><span class="line">        <span class="keyword">if</span> (myDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sql.WHERE(<span class="string">"mydate LIKE #&#123;mydate&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sql.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于SQL类"><a href="#关于SQL类" class="headerlink" title="关于SQL类"></a>关于SQL类</h2><p>SQL类是用于进行动态SQL生成的，如下代码是一个相对复杂的SQL类的使用举例，以后需要用到的时候，再来参考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">selectPersonSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">    SELECT(<span class="string">"P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME"</span>);</span><br><span class="line">    SELECT(<span class="string">"P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON"</span>);</span><br><span class="line">    FROM(<span class="string">"PERSON P"</span>);</span><br><span class="line">    FROM(<span class="string">"ACCOUNT A"</span>);</span><br><span class="line">    INNER_JOIN(<span class="string">"DEPARTMENT D on D.ID = P.DEPARTMENT_ID"</span>);</span><br><span class="line">    INNER_JOIN(<span class="string">"COMPANY C on D.COMPANY_ID = C.ID"</span>);</span><br><span class="line">    WHERE(<span class="string">"P.ID = A.ID"</span>);</span><br><span class="line">    WHERE(<span class="string">"P.FIRST_NAME like ?"</span>);</span><br><span class="line">    OR();</span><br><span class="line">    WHERE(<span class="string">"P.LAST_NAME like ?"</span>);</span><br><span class="line">    GROUP_BY(<span class="string">"P.ID"</span>);</span><br><span class="line">    HAVING(<span class="string">"P.LAST_NAME like ?"</span>);</span><br><span class="line">    OR();</span><br><span class="line">    HAVING(<span class="string">"P.FIRST_NAME like ?"</span>);</span><br><span class="line">    ORDER_BY(<span class="string">"P.ID"</span>);</span><br><span class="line">    ORDER_BY(<span class="string">"P.FULL_NAME"</span>);</span><br><span class="line">  &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="修改mapper"><a href="#修改mapper" class="headerlink" title="修改mapper"></a>修改mapper</h1><p>原手写SQL语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">" insert into category_ ( name ) values (#&#123;name&#125;) "</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;</span><br></pre></td></tr></table></figure>

<p>改为通过注解配合provider类中对应的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InsertProvider</span>(type=CategoryDynaSqlProvider.class,method=<span class="string">"add"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其他注解包括：<code>@SelectProvider</code>、<code>@UpdateProvider</code>、<code>@DeleteProvider</code>等</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中>>和>>>的区别</title>
    <url>/2020/06/19/2020-06-19-Java%E4%B8%AD%E3%80%8B%E3%80%8B%E5%92%8C%E3%80%8B%E3%80%8B%E3%80%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Java中的位运算符：</p>
<p>&gt;&gt; 表示右移，如果该数为正，则高位补0，若为负数，则高位补1；</p>
<p>&gt;&gt;&gt; 表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。</p>
<p>表达式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = exp1 &gt;&gt; exp2;</span><br><span class="line"></span><br><span class="line">result = exp2 &gt;&gt;&gt; exp2;</span><br></pre></td></tr></table></figure>

<p>表示把数exp1向右移动exp2位。</p>
<p>例如：</p>
<p>res = 20 &gt;&gt; 2; </p>
<p>20的二进制为 0001 0100，右移2位后为 0000 0101，则结果就为 res = 5;</p>
<p>res = -20 &gt;&gt; 2;</p>
<p>-20的二进制为其正数的补码加1，即 1110 1100，右移2位高位补1为 1111 1011，结果为 res = -5;</p>
<p>而对于&gt;&gt;&gt;符号而言：</p>
<p>res = 20 &gt;&gt;&gt; 2; 的结果与 &gt;&gt; 相同；</p>
<p>res = -20 &gt;&gt;&gt; 2;</p>
<p>-20的二进制为 1110 1100，右移2位高位补0，即 0011 1011，结果为 res = 59;</p>
<p>补充：</p>
<p>&lt;&lt; 是与&gt;&gt;对应的左移运算符，表示将exp1向左移动exp2位，在低位补0。其实，向左移动n位，就相当于乘以2^n。</p>
<p>左移没有&lt;&lt;&lt;运算符！</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于工程中一些问题的解决</title>
    <url>/2020/06/15/2020-06-15-%E5%85%B3%E4%BA%8E%E5%B7%A5%E7%A8%8B%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<blockquote>
<p>解决电磁加热工程中的问题。</p>
</blockquote>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p><strong>问题：</strong></p>
<p>项目启动时需要启动AmqpReceive的initAmqp方法，所以涉及到SpringBoot项目启动时自动执行指定方法，我最初是直接在启动类上调用，这样不太好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaterApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(HeaterApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">       	<span class="comment">// AmqpReceive amqpReceive = new AmqpReceive();</span></span><br><span class="line">        <span class="comment">//amqpReceive.initAmqp();</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 2.</span></span><br><span class="line">        <span class="comment">//AmqpReceive amqpReceive = (AmqpReceive) StartupEvent.getBean(AmqpReceive.class);</span></span><br><span class="line">        <span class="comment">//amqpReceive.initAmqp();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：</strong></p>
<p><a href="https://blog.csdn.net/rui15111/article/details/80996342" target="_blank" rel="noopener">https://blog.csdn.net/rui15111/article/details/80996342</a></p>
<p>我这里选择了前者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmqpReceive</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;   <span class="comment">// 覆盖原来initAmqp方法</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p><strong>问题：</strong></p>
<p>此问题，解决了好久。AmqpReceive中自动注入之后运行为null，报空指针异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> DeviceMapper deviceMapper;   <span class="comment">// 或者deviceServiceImpl</span></span><br></pre></td></tr></table></figure>

<p>如上，在AmqpReceive类中进行了自动注入，在<code>processMessage</code>中调用了<code>deviceMapper.updateDeviceShow(deviceShow);</code>，结果运行报NPE，<code>deviceShow</code>为<code>processMessage</code>方法内new，控制台打印不为空，<code>deviceMapper</code>为空。</p>
<p><strong>解决方案：</strong></p>
<p>针对自动注入的问题，试了很多方法，反射、初始化等等，都不行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  DeviceServiceImpl deviceServiceImpl = (DeviceServiceImpl) StartupEvent.getBean(DeviceServiceImpl.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static AmqpReceive amqpReceive;</span></span><br><span class="line"><span class="comment">//    @PostConstruct</span></span><br><span class="line"><span class="comment">//    public void init() &#123;</span></span><br><span class="line"><span class="comment">//        amqpReceive = this;</span></span><br><span class="line"><span class="comment">//        amqpReceive.deviceServiceImpl = this.deviceServiceImpl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure>

<p>最终解决为和其他Controller一一对比，改成了如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> DeviceMapper deviceMapper;</span><br></pre></td></tr></table></figure>

<p>可以了。</p>
<p>原因分析<a href="https://blog.csdn.net/RogueFist/article/details/79575665" target="_blank" rel="noopener">看这里</a>。因为当类加载器加载静态变量时，Spring上下文尚未加载。所以类加载器不会在bean中正确注入静态类，并且会失败。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p><strong>问题：</strong></p>
<p>如上解决方案，自动注入mapper，有报错红线提示无法注入（我就说因为报错才把注入的mapper修改成static导致一直NPE），但其实不影响运行。</p>
<p><strong>解决方案：</strong></p>
<p><a href="https://blog.csdn.net/qq_21853607/article/details/72802080" target="_blank" rel="noopener">https://blog.csdn.net/qq_21853607/article/details/72802080</a></p>
<p>解决方法，在mapper加一个注解。<code>@Component(value = “deviceMapper”)</code></p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>通过属性名反射获取get和set方法</title>
    <url>/2020/06/14/2020-06-14-%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E5%90%8D%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96get%E5%92%8Cset%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/weixin_39800144/article/details/79012369" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39800144/article/details/79012369</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> everyDay.Person;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lightClouds917</span></span><br><span class="line"><span class="comment"> * Date 2017/12/29</span></span><br><span class="line"><span class="comment"> * Description:根据属性名反射获取get和set方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect3</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//test removeLine</span></span><br><span class="line">		System.out.println(removeLine(<span class="string">"abg_dwr"</span>));</span><br><span class="line">		System.out.println(removeLine(<span class="string">"ab_wr"</span>));</span><br><span class="line">		System.out.println(removeLine(<span class="string">"abgwr"</span>));</span><br><span class="line">		System.out.println(removeLine(<span class="keyword">null</span>));</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//test get</span></span><br><span class="line">		Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">		person1.setAge(<span class="number">11</span>);</span><br><span class="line">		person1.setName(<span class="string">"旺旺"</span>);</span><br><span class="line">		Object ob = getGetMethod(person1, <span class="string">"name"</span>);</span><br><span class="line">		System.out.println(ob);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//test set</span></span><br><span class="line">		Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">		String field2 = <span class="string">"name"</span>;</span><br><span class="line">		setValue(person2, person2.getClass(), field2, Person.class.getDeclaredField(field2).getType(), <span class="string">"汪汪"</span>);</span><br><span class="line">		System.out.println(person2);</span><br><span class="line">		<span class="comment">//获取某个属性的类型</span></span><br><span class="line">		System.out.println(Person.class.getDeclaredField(<span class="string">"age"</span>).getType());</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据属性，获取get方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ob 对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getGetMethod</span><span class="params">(Object ob , String name)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Method[] m = ob.getClass().getMethods();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((<span class="string">"get"</span>+name).toLowerCase().equals(m[i].getName().toLowerCase()))&#123;</span><br><span class="line">				<span class="keyword">return</span> m[i].invoke(ob);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据属性，拿到set方法，并把值set到对象中</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj 对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> clazz 对象的class</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fileName 需要设置值得属性</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> typeClass </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object obj,Class&lt;?&gt; clazz,String filedName,Class&lt;?&gt; typeClass,Object value)</span></span>&#123;</span><br><span class="line">		filedName = removeLine(filedName);</span><br><span class="line">		String methodName = <span class="string">"set"</span> + filedName.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()+filedName.substring(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Method method =  clazz.getDeclaredMethod(methodName, <span class="keyword">new</span> Class[]&#123;typeClass&#125;);</span><br><span class="line">			method.invoke(obj, <span class="keyword">new</span> Object[]&#123;getClassTypeValue(typeClass, value)&#125;);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过class类型获取获取对应类型的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeClass class类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getClassTypeValue</span><span class="params">(Class&lt;?&gt; typeClass, Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeClass == <span class="keyword">int</span>.class  || value <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(typeClass == <span class="keyword">short</span>.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(typeClass == <span class="keyword">byte</span>.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(typeClass == <span class="keyword">double</span>.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(typeClass == <span class="keyword">long</span>.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(typeClass == String.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(typeClass == <span class="keyword">boolean</span>.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(typeClass == BigDecimal.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(value+<span class="string">""</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> typeClass.cast(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理字符串  如：  abc_dex ---&gt; abcDex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">removeLine</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> != str &amp;&amp; str.contains(<span class="string">"_"</span>))&#123;</span><br><span class="line">			<span class="keyword">int</span> i = str.indexOf(<span class="string">"_"</span>);</span><br><span class="line">			<span class="keyword">char</span> ch = str.charAt(i+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">char</span> newCh = (ch+<span class="string">""</span>).substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase().toCharArray()[<span class="number">0</span>];</span><br><span class="line">			String newStr = str.replace(str.charAt(i+<span class="number">1</span>), newCh);</span><br><span class="line">			String newStr2 = newStr.replace(<span class="string">"_"</span>, <span class="string">""</span>);</span><br><span class="line">			<span class="keyword">return</span> newStr2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中concat()-'+'-append()三者区别</title>
    <url>/2020/06/12/2020-06-12-java%E4%B8%ADconcat()-&#39;+&#39;-append()%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>三者区别，记录一下。</p>
<p><a href="https://blog.csdn.net/weixin_42950079/article/details/83515713" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42950079/article/details/83515713</a></p>
</blockquote>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>concat()方法：String类的concat()方法（只能用于拼接字符串，不能拼接其他类型的数据）将指定的字符串拼接到该字符串的末尾。并且字符串本身和拼接的字符串都不能为null，否则运行程序后会报空指针异常NullPointerException（编译时没有报错）。</p>
<p>“+”：可以对字符，数字，字符串等数据类型的拼接</p>
<p>append()方法：可以对字符，数字，字符串等数据类型的拼接，结果返回一个StringBuffer类型的对象</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 练习题29 </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Object&gt; list=<span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">		list.add(<span class="number">100</span>);</span><br><span class="line">		list.add(<span class="string">'日'</span>);</span><br><span class="line">		list.add(<span class="string">"冲刺,决胜高考!"</span>);</span><br><span class="line">		</span><br><span class="line">		StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">			sb.append(list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.err.println(sb);</span><br><span class="line">		</span><br><span class="line">		String s1=<span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">			s1=s1+list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.err.println(s1);</span><br><span class="line">		</span><br><span class="line">		String s2=<span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">			s2=s2.concat( list.get(i).toString());</span><br><span class="line">		&#125;</span><br><span class="line">		System.err.println(s2);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		String str1=<span class="string">""</span>;</span><br><span class="line">		System.err.println(str1.concat(<span class="keyword">null</span>)); <span class="comment">//运行后报空指针异常NullPointerException</span></span><br><span class="line">		String str2=<span class="keyword">null</span>;</span><br><span class="line">		System.err.println(str2.concat(<span class="string">"asdf"</span>));<span class="comment">//运行后报空指针异常NullPointerException</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">100</span>日冲刺,决胜高考!</span><br><span class="line"><span class="number">100</span>日冲刺,决胜高考!</span><br><span class="line"><span class="number">100</span>日冲刺,决胜高考!</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br></pre></td></tr></table></figure>





<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>stream流</title>
    <url>/2020/06/12/2020-06-12-stream%E6%B5%81/</url>
    <content><![CDATA[<blockquote>
<p>Leetcode1333题用到。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/06/12/HSnNF4ayXog5bQd.png" alt="关于stream"></p>
<h1 id="stream特性"><a href="#stream特性" class="headerlink" title="stream特性"></a>stream特性</h1><p>​    stream主要具有如下三点特性，在之后我们会对照着详细说明</p>
<p>　　　　（1）stream不存储数据</p>
<p>　　　　（2）stream不改变源数据</p>
<p>　　　　（3）stream的延迟执行特性</p>
<p> 　通常我们在数组或集合的基础上创建stream，stream不会专门存储数据，对stream的操作也不会影响到创建它的数组和集合，对于stream的聚合、消费或收集操作只能进行一次，再次操作会报错，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.generate(()-&gt;<span class="string">"user"</span>).limit(<span class="number">3</span>);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user</span><br><span class="line">user</span><br><span class="line">user</span><br><span class="line"></span><br><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure>

<h1 id="创建sream"><a href="#创建sream" class="headerlink" title="创建sream"></a>创建sream</h1><h2 id="通过数组创建"><a href="#通过数组创建" class="headerlink" title="通过数组创建"></a>通过数组创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基本类型</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    IntStream stream = Arrays.stream(arr);</span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    Student[] studentArr = <span class="keyword">new</span> Student[]&#123;<span class="keyword">new</span> Student(<span class="string">"s1"</span>,<span class="number">29</span>),<span class="keyword">new</span> Student(<span class="string">"s2"</span>,<span class="number">27</span>)&#125;;</span><br><span class="line">    Stream&lt;Student&gt; studentStream = Arrays.stream(studentArr);</span><br><span class="line">    <span class="comment">//通过Stream.of</span></span><br><span class="line">    Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过集合创建"><a href="#通过集合创建" class="headerlink" title="通过集合创建"></a>通过集合创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strs = Arrays.asList(<span class="string">"11212"</span>,<span class="string">"dfd"</span>,<span class="string">"2323"</span>,<span class="string">"dfhgf"</span>);</span><br><span class="line">        <span class="comment">//创建普通流</span></span><br><span class="line">        Stream&lt;String&gt; stream  = strs.stream();</span><br><span class="line">        <span class="comment">//创建并行流（即多个线程处理）</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = strs.parallelStream();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建空的流"><a href="#创建空的流" class="headerlink" title="创建空的流"></a>创建空的流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmptyStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream  = Stream.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a>创建无限流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//generate:创建无限流</span></span><br><span class="line">        Stream.generate(()-&gt;<span class="string">"number"</span>+<span class="keyword">new</span> Random().nextInt())</span><br><span class="line">                .limit(<span class="number">100</span>).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">-------------------------------------------</span><br><span class="line">number1248181585</span><br><span class="line">number384976035</span><br><span class="line">number1716213474</span><br><span class="line">number-<span class="number">1389767666</span></span><br><span class="line">number670931654</span><br><span class="line">………………</span><br></pre></td></tr></table></figure>

<h2 id="创建规则的无限流"><a href="#创建规则的无限流" class="headerlink" title="创建规则的无限流"></a>创建规则的无限流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//iterate:创建无限流</span></span><br><span class="line">        <span class="comment">//              初始值，生成函数的规则</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>,x-&gt;x+<span class="number">1</span>)</span><br><span class="line">                .limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h1 id="Stream操作"><a href="#Stream操作" class="headerlink" title="Stream操作"></a>Stream操作</h1><h3 id="map：转换流，将一种类型的流转换为另外一种流"><a href="#map：转换流，将一种类型的流转换为另外一种流" class="headerlink" title="map：转换流，将一种类型的流转换为另外一种流"></a>map：转换流，将一种类型的流转换为另外一种流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * map把一种类型的流转换为另外一种类型的流</span></span><br><span class="line"><span class="comment">         * 将String数组中字母转换为大写</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"yes"</span>, <span class="string">"YES"</span>, <span class="string">"no"</span>, <span class="string">"NO"</span>&#125;;</span><br><span class="line">        Arrays.stream(arr).map(x -&gt; x.toLowerCase()).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">no</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<h3 id="filter：过滤流，过滤流中的元素"><a href="#filter：过滤流，过滤流中的元素" class="headerlink" title="filter：过滤流，过滤流中的元素"></a><strong>filter：过滤流，过滤流中的元素</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        Arrays.stream(arr).filter(x-&gt;x&gt;<span class="number">3</span>&amp;&amp;x&lt;<span class="number">8</span>)</span><br><span class="line">                .forEach(System.out::println);<span class="comment">//4,5,6,7这是找出大于3小于8的数</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="sorted：对流进行排序"><a href="#sorted：对流进行排序" class="headerlink" title="sorted：对流进行排序"></a><strong>sorted：对流进行排序</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comparator.comparing是一个键提取的功能</span></span><br><span class="line"><span class="comment"> * 以下两个语句表示相同意义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSorted1_</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照字符长度排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Arrays.stream(arr1).sorted((x,y)-&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.length()&gt;y.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.length()&lt;y.length())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">    Arrays.stream(arr1).sorted(Comparator.comparing(String::length)).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于git中的tag</title>
    <url>/2020/06/09/2020-06-09-%E5%85%B3%E4%BA%8Egit%E4%B8%AD%E7%9A%84tag/</url>
    <content><![CDATA[<blockquote>
<p>实习项目进行备机部署和线上部署，使用到tag，记录一下。</p>
</blockquote>
<h1 id="什么是tag"><a href="#什么是tag" class="headerlink" title="什么是tag"></a>什么是tag</h1><p>tag：分支的另一种形式，针对某个分支上的某一个次提交打一个tag（标签），根据这个tag可以精确快速的找个某一次具体的提交时间以及提交内容；目的是为了与下一次的代码提交区分开。</p>
<h1 id="btag和rtag"><a href="#btag和rtag" class="headerlink" title="btag和rtag"></a>btag和rtag</h1><p>（1）btag：</p>
<p>用途：用来记录一次测试环境打包的产物名称，可以用来作为查找某一次功能打包的时间点，用作备机时发布的tag_name。</p>
<p>使用方法：在bds系统的配置tag_name中填入，部署在测试环境时则为当前功能为生成btag的分支功能；部署在线上环境时，生成rtag，则线上功能为当前功能为生成btag的分支功能。</p>
<p>（2）rtag：</p>
<p>用途：用来记录线上环境打包的产物名称，可以用来作为查找某一次功能打包的时间点，用作上线时发布的的tag_name。</p>
<p>使用方法：在bds系统的配置tag_name中填入，部署在测试环境时则为与线上功能保持一致；部署在线上环境时，为回滚线上功能到当前rtag的功能。</p>
<h1 id="怎么确认线上发布rtag是正确的？"><a href="#怎么确认线上发布rtag是正确的？" class="headerlink" title="怎么确认线上发布rtag是正确的？"></a>怎么确认线上发布rtag是正确的？</h1><p>rtag产生的过程：分支部署 → 生成btag  → 发布线上，生成rtag</p>
<p>首先确认需要上线分支的已经是最新代码，btag是由已经diff过的最新代码打包生成，并且在测试环境验证无其他问题，再确认发布上线的btag是正确的，来确保rtag是正确的。</p>
<p>备注：若为回滚的rtag，一定要与开发确认该rtag的正确性（一般使用上一次线上发布的rtag）。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>关于KafkaⅡ</title>
    <url>/2020/06/08/2020-06-08-%E5%85%B3%E4%BA%8EKafka%E2%85%A1/</url>
    <content><![CDATA[<blockquote>
<p>实习项目中使用到，学习一下。</p>
</blockquote>
<h1 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h1><p><img src="https://i.loli.net/2020/06/08/QTKhVLevAdcun2J.png" alt="生产者组件图"></p>
<p>从创建一个ProducerRecord 对象开始， Producer Record 对象需要包含目标主题和要发送的内容。还可以指定键或分区。在发送ProducerReco rd 对象时，生产者要先把键和值对象序列化成字节数组，这样它们才能够在网络上传输。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Kafka</title>
    <url>/2020/06/05/2020-06-05-%E5%85%B3%E4%BA%8EKafka/</url>
    <content><![CDATA[<blockquote>
<p>实习项目中使用到，学习一下。</p>
</blockquote>
<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>Kafka 的数据单元被称为<strong>消息</strong>。<em>（理解上类似于数据库中的一条记录）</em>消息由字节数组组成，本身对于Kafka来说没有特殊含义。</p>
<h2 id="键"><a href="#键" class="headerlink" title="键"></a>键</h2><p>消息可有一个可选的元数据，也就是<strong>键</strong>。键同样也是一个字节数组，对Kafka来说也没有特殊含义。当消息以一种可控的方式写入不同分区时，会用到键。最简单的例子就是为键生成一个一致性散列值，然后使用散列值对主题分区进行取模，为消息选取分区。这样可以保证具有相同键的消息被写到相同的的分区。<em>（理解上类似于HashMap中put的过程）</em></p>
<h2 id="批次"><a href="#批次" class="headerlink" title="批次"></a>批次</h2><p>为了提高效率，消息分批写入Kafka。每一个<strong>批次</strong>就是一组消息，这些消息属于同一个Topic和Partition。如果每一条消息都单独穿行于网络，会导致大量网络开销，造成网络拥塞。不过，这也要在时间延迟和吞吐量之间作出权衡：一个批次内消息数目越多，单位时间内要处理的消息就越多，单个消息的传输时间就越长。批次数据被压缩，可以提升数据的传输和存储能力，但要做额外的计算处理。<em>（理解上类似于TCP发送端的优化算法，将多个数据包合在一起发生，那么Kafka是否也会导致粘包问题？？）</em></p>
<h2 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h2><p>由于对于Kafka来说，消息是晦涩难懂的字节数组，所以用一些额外的结构来定义消息内容，更容易理解，根据应用程序的需要，<strong>消息模式</strong>有很多选项可选。例如JSON、XML、Avro(Apache提供，一种紧凑的序列化格式，模式和消息体分开，模式发生变化，不需要重新生成代码；还支持强类型和模式进化，版本向前向后均兼容)等。</p>
<h2 id="主题-Topic-和分区-Partition"><a href="#主题-Topic-和分区-Partition" class="headerlink" title="主题(Topic)和分区(Partition)"></a>主题(Topic)和分区(Partition)</h2><p>消息通过<strong>主题</strong>进行分类。<em>（理解上就是数据库中的表）</em>主题被分为若干个<strong>分区</strong>，一个分区就是一个提交日志。消息以追加的方式写入分区，先入先出的顺序读取，但是无法保证在整个Topic上的顺序。每一个分区都可以分布在不同的服务器上，这样，一个主题就可以横跨多个服务器，提供更强大的性能。</p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>一般将一个主题不管有多少分区，都将其数据作为一个<strong>流</strong>。流是一组从生产者移动到消费者的数据。与Hadoop被设计用于在稍后某个时刻离线处理大量数据不同，流式处理用于实时处理。</p>
<h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><p>Kafka的客户端就是Kafka系统的用户，被分为两种基本类型，生产者和消费者。</p>
<p><strong>生产者</strong>创建消息，一般情况下，生产者默认会把消息均衡地分布到主题地所有分区上，而不关心特定消息会被写到哪个分区。当然，通过消息键和分区器可以将消息映射到指定的分区上。</p>
<p><strong>消费者</strong>读取消息，消费者订阅一个或多个主题，并按照消息生成的顺序读取它们。消费者通过检验消息的偏移量来区分已经读取过的消息。<strong>偏移量</strong>是另一种元数据，是一个不断递增的整数值，创建消息时，Kafka会将偏移量添加到消息中，在给定的分区中，每个消息的偏移量都是唯一的。消费者将每个分区最后读取的消息的偏移量保存在ZK或者Kafka上，如果消费者重启或者关闭，消息的读取状态也不会丢失。<em>（这也是Kafka高可靠性的一点，即使一个主分片宕机后，Kafka客户端可以从副分片相应位移后继续消费，不会有重复消费的情况）</em></p>
<h2 id="消费者群组-Group"><a href="#消费者群组-Group" class="headerlink" title="消费者群组(Group)"></a>消费者群组(Group)</h2><p>消费者是<strong>消费者组群</strong>的一部分，也就是存在多个消费者读取同一个Topic的情况。需要注意的是，一个Topic内的每个分区只能被同一个Group内的一个消费者使用，这种映射关系被称为消费者对分区的所有权关系。</p>
<p>通过这种方式，消费者可以消费包含大量消息的主题。而且，如果一个消费者失效，群组里的其他消费者可以接管失效悄费者的工作。</p>
<h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>Kafka 集群包含一个或多个服务器，一个独立的服务器节点被称为<strong>broker</strong>。</p>
<p>broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。broker 为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。根据特定的硬件及其性能特征，单个broker 可以轻松处理数千个分区以及每秒百万级的消息量。</p>
<p>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</p>
<p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p>
<p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>
<p>broker 是集群的组成部分。每个集群都有一个broker 同时充当了集群控制器的角色（自动从集群的活跃成员中选举出来）。控制器负责管理工作，包括将分区分配给broker 和监控broker。在集群中， 一个分区从属于一个broker, i亥broker 被称为分区的首领。</p>
<h2 id="保留消息"><a href="#保留消息" class="headerlink" title="保留消息"></a>保留消息</h2><p>Kafka broker 默认的消息保留策略是这样的：要么保留一段时间（比如7 天），要么保留到消息达到一定大小的字节数（比如1GB ）。当消息数量达到这些上限时，旧消息就会过期井被删除，所以在任何时刻， 可用消息的总量都不会超过配置参数所指定的大小。主题可以配置自己的保留策略，可以将悄息保留到不再使用它们为止。例如，用于跟踪用户活动的数据可能需要保留几天，而应用程序的度量指标可能只需要保留几个小时。可以通过配置把主题当作紧凑型日志， 只有最后一个带有特定键的消息会被保留下来。这种情况对于变更日志类型的数据来说比较适用，因为人们只关心最后时刻发生的那个变更。<em>（这也是与RabbitMq不同之处之一，RabbitMq消息被消费完之后直接删除）</em></p>
<h2 id="多集群"><a href="#多集群" class="headerlink" title="多集群"></a>多集群</h2><p>随着Kafka 部署数量的增加，基于以下几点原因，最好使用多个集群。</p>
<ul>
<li>数据类型分离</li>
<li>安全需求隔离</li>
<li>多数据中心（灾难恢复）</li>
</ul>
<p>如果使用多个数据中心，就需要在它们之间复制消息。不过， Kafka 的消息复制机制只能在单个集群里进行，不能在多<br>个集群之间进行。<br>Kafka 提供了一个叫作Mirror Maker 的工具，可以用它来实现集群间的消息复制。<br>Mirror Maker 的核心组件包含了一个生产者和一个消费者，两者之间通过一个队列相连。消费者从一个集群读取消息，生产者把消息发送到另一个集群上</p>
<h1 id="Kafka优势"><a href="#Kafka优势" class="headerlink" title="Kafka优势"></a>Kafka优势</h1><h2 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h2><p>Kafka 可以无缝地支持多个生产者，不管客户端在使用单个主题还是多个主题。</p>
<h2 id="多个消费者"><a href="#多个消费者" class="headerlink" title="多个消费者"></a>多个消费者</h2><p>Kafka 也支持多个消费者从一个单独的消息流上读取数据，而且消费者之间直不影响。这与其他队列系统不同，其他队列系统的消息一旦被一个客户端读取，其他客户端就无法再读取它。另外，多个消费者可以组成一个群组，它们共享一个消息流，并保证整个群组对每个给定的消息只处理一次。</p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>这要归功于Kafka 的数据保留特性。消息被提交到磁盘，根据设置的保留规则进行保存。每个主题可以设置单独的保留规则，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。</p>
<ul>
<li>消费者可能会因为处理速度慢或突发的流量高峰导致无陆及时读取消息，而持久化数据可以保证数据<br>不会丢失。</li>
<li>消费者可以在进行应用程序维护时离线一小段时间，而无需担心消息丢失或堵塞在生产者端。</li>
<li>消费者可以被关闭，但消息会继续保留在Kafka 里。消费者可以从上次中<br>断的地方继续处理消息。</li>
</ul>
<h2 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h2><p>Kafka 从一开始就被设计成一个具有灵活伸缩性的系统。随着需求不断增长，可以灵活方便增加broker。</p>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>通过横向扩展生产者、消费者和broker, Kafka 可以轻松处理巨大的消息流。在处理大量数据的同时，它还能保证亚秒级的消息延迟。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ与Kafka</title>
    <url>/2020/06/04/2020-06-04-RabbitMQ%E4%B8%8EKafka/</url>
    <content><![CDATA[<blockquote>
<p>实习项目中使用到，学习一下。</p>
<p>原博客：<a href="https://www.cnblogs.com/haolujun/p/9632835.html、https://www.cnblogs.com/haolujun/p/9641840.html" target="_blank" rel="noopener">https://www.cnblogs.com/haolujun/p/9632835.html、https://www.cnblogs.com/haolujun/p/9641840.html</a></p>
</blockquote>
<h1 id="RabbitMQ架构"><a href="#RabbitMQ架构" class="headerlink" title="RabbitMQ架构"></a>RabbitMQ架构</h1><p>RabbitMQ是一个分布式系统，这里面有几个抽象概念。</p>
<ul>
<li>broker：每个节点运行的服务程序，功能为维护该节点的队列的增删以及转发队列操作请求。</li>
<li>master queue：每个队列都分为一个主队列和若干个镜像队列。</li>
<li>mirror queue：镜像队列，作为master queue的备份。在master queue所在节点挂掉之后，系统把mirror queue提升为master queue，负责处理客户端队列操作请求。注意，mirror queue只做镜像，设计目的不是为了承担客户端读写压力。</li>
</ul>
<p><img src="https://i.loli.net/2020/06/04/s748z2SRgLhamI6.png" alt="rabbitMq架构"></p>
<p>如上图所示，集群中有两个节点，每个节点上有一个broker，每个broker负责本机上队列的维护，并且borker之间可以互相通信。集群中有两个队列A和B，每个队列都分为master queue和mirror queue（备份）。那么队列上的生产消费怎么实现的呢？</p>
<h2 id="队列消费"><a href="#队列消费" class="headerlink" title="队列消费"></a>队列消费</h2><p><img src="https://i.loli.net/2020/06/04/yljz3FIkHDa7hK8.png" alt="队列消费"></p>
<p>如上图有两个consumer消费队列A，这两个consumer连在了集群的不同机器上。RabbitMQ集群中的任何一个节点都拥有集群上所有队列的元信息，所以连接到集群中的任何一个节点都可以，主要区别在于有的consumer连在master queue所在节点，有的连在非master queue节点上。</p>
<p>因为mirror queue要和master queue保持一致，故需要同步机制，正因为一致性的限制，导致所有的读写操作都必须都操作在master queue上（想想，为啥读也要从master queue中读？和数据库读写分离是不一样的。），然后由master节点同步操作到mirror queue所在的节点。即使consumer连接到了非master queue节点，该consumer的操作也会被路由到master queue所在的节点上，这样才能进行消费。</p>
<h2 id="队列生产"><a href="#队列生产" class="headerlink" title="队列生产"></a>队列生产</h2><p><img src="https://i.loli.net/2020/06/04/pz5veKg1OU2NMHm.png" alt="队列生产"></p>
<p>原理和消费一样，如果连接到非 master queue 节点，则路由过去。</p>
<p>所以，到这里小伙伴们就可以看到 RabbitMQ的不足：由于master queue单节点，导致性能瓶颈，吞吐量受限。虽然为了提高性能，内部使用了Erlang这个语言实现，但是终究摆脱不了架构设计上的致命缺陷。</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>RabbitMq的mirror queue 在master queue宕机之后，会被提升为master queue，如下图所示。</p>
<p><img src="https://i.loli.net/2020/06/04/SpX43Y8rjU9hgLT.png" alt="rabbitMq宕机"></p>
<p>队列A的consumer在消费的时候，机器宕机，此时客户端和服务端分别做如下动作：</p>
<ul>
<li>服务端：把mirror queue提升为master queue</li>
<li>客户端：连接到新的master queue 所在的节点进行消费或者生产</li>
</ul>
<p>当master queue 所在节点宕机后，其正在被消费的消息的相关信息全部丢失，即服务端不知道消费者对那一瞬间消费的消息是否进行了ACK，所以在mirror queue被提升为master queue时，会把宕机前正在进行消费的的消息全部重新发送一遍，即客户端重连后，消息可能被重复消费，这个时候就必须依靠应用层逻辑来判断来避免重复消费。</p>
<p>在持久化方面，RabbitMQ的master queue每次收到新消息后，都会立刻写入磁盘，并把消息同步给mirror queue。假设在master queue 收到消息后，消息未同步到mirror queue 之前master queue 宕机，则此时mirror queue中就没有刚刚master queue收到的那条消息，当这个mirror queue被提升为master queue时，消费者连接到新的master queue上进行消费时就丢了一条消息。所以，RabbitMQ也会丢消息，只不过这个丢消息的概率非常低。</p>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="队列机制"><a href="#队列机制" class="headerlink" title="队列机制"></a>队列机制</h2><p>针对RabbitMQ这个缺陷，Kafka改进的点就是：把一个队列的单一master变成多个master，即一台机器扛不住qps，那么我就用多台机器扛qps，把一个队列的流量均匀分散在多台机器上不就可以了么？注意，多个master之间的数据没有交集，即一条消息要么发送到这个master queue，要么发送到另外一个master queue。</p>
<p>这里面的每个master queue 在Kafka中叫做Partition，即一个分片。一个队列有多个主分片，每个主分片又有若干副分片做备份，同步机制类似于RabbitMQ。</p>
<p><img src="https://i.loli.net/2020/06/04/Ds8N35eIjHgAbEk.png" alt="Kafka架构"></p>
<p>如上图，我们省略了不同的queue，假设集群上只有一个queue（Kafka中叫Topic）。每个生产者随机把消息发送到主分片上，之后主分片再同步给副分片。</p>
<p><img src="https://i.loli.net/2020/06/04/vxSE98jqmoWH43z.png" alt="Kafka队列消费"></p>
<p>队列读取的时候虚拟出一个Group的概念，一个Topic内部的消息，只会路由到同Group内的一个consumer上，不会同时和同一Group内多个consumer进行路由，同一个Group中的consumer消费的消息是不一样的；Group之间共享一个Topic，看起来就是一个队列的多个拷贝。所以，为了达到多个Group共享一个Topic数据，Kafka并不会像RabbitMQ那样消息消费完毕立马删除，而是必须在后台配置保存日期，即只保存最近一段时间的消息，超过这个时间的消息就会从磁盘删除，这样就保证了在一个时间段内，Topic数据对所有Group可见（这个特性使得Kafka非常适合做一个公司的数据总线）。队列读同样是读主分片，并且为了优化性能，<strong>消费者与主分片有一一的对应关系</strong>，如果消费者数目大于分片数，则存在某些消费者得不到消息。</p>
<p>由此可见，Kafka绝对是为了高吞吐量设计的，比如设置分片数为100，那么就有100台机器去扛一个Topic的流量，当然比RabbitMQ的单机性能好。</p>
<h2 id="可靠性-1"><a href="#可靠性-1" class="headerlink" title="可靠性"></a>可靠性</h2><p>Kafka当主分片所在机器宕机后，服务端会把一个副分片提升为主分片，如下图所示。</p>
<p><img src="https://i.loli.net/2020/06/04/ZmcSfzVxaBWEFpM.png" alt="Kafka宕机"></p>
<p>服务端和客户端会有如下动作：</p>
<ul>
<li>服务端：把副分片提升为主分片</li>
<li>客户端：连接到新的主分片</li>
</ul>
<p>Kafka同样有主从同步，所以也必定存在与RabbitMQ同样丢消息的问题。但是Kafka的每个客户端保存了读取消息的偏移信息，故当一个主分片宕机后，Kafka客户端可以从副分片相应位移后继续消费，不会有重复消费的情况。</p>
<p>持久化方面，Kafka默认把消息直接写文件，但是由于操作系统的cache原因，消息可能不会立马写到磁盘上，这个时候就需要刷新文件到磁盘。由于刷新文件到磁盘是一个比较耗时的操作，故Kafka提供了两种不同的刷新配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每接收多少条消息刷一下磁盘</span><br><span class="line">log.flush.interval.messages=10000</span><br><span class="line">#每隔多少ms刷一下磁盘</span><br><span class="line">log.flush.interval.ms=1000</span><br></pre></td></tr></table></figure>

<p>我们完全可以把log.flush.interval.messages设置为1，这样Kafka就能在持久化方面达到和RabbitMQ同样的安全级别。</p>
<p><img src="https://i.loli.net/2020/06/04/OjHQtV4Jh79A6Rl.png" alt="Kafka与ZK"></p>
<p>但是Kafka集群依赖ZK，如上图所示，所以对于Kafka稳定性的评估必须考虑ZK集群的稳定性，而一般我们认为任何分布式集群的稳定性都小于1，故两个集群的串联稳定性会下降一些，维护更复杂一些，这点没有RabbitMQ有优势。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实好多开源组件随着时间推移，往往都进行了各种改进。就比如Kafka虽然是为了日志而生，给人第一印象是容易丢消息，但是经过这么多年的改进，其可靠性可能并不逊色RabbitMQ了，只需要你根据不同的业务场景配置不同的配置参数，即可达到适合自己的安全级别。</p>
<ul>
<li>从吞吐量上看，在不要求消息顺序情况下，Kafka完胜；在要求消息先后顺序的场景，性能应该稍逊RabbitMQ（此时Kafka的分片数只能为1）。</li>
<li>从稳定性来看，RabbitMQ胜出，但是Kafka也并不逊色多少。</li>
</ul>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>redis中哈希hash</title>
    <url>/2020/06/02/2020-06-02-redis%E4%B8%AD%E5%93%88%E5%B8%8Chash/</url>
    <content><![CDATA[<blockquote>
<p>实习项目中使用到，学习一下，作为对自己项目中只用过string和list的补充。</p>
</blockquote>
<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）。</p>
<p><strong>常用命令</strong></p>
<ol>
<li><p><code>hset(key, field, value)</code>：向名称为key的hash中添加元素field&lt;—&gt;value</p>
</li>
<li><p><code>hget(key, field)</code>：返回名称为key的hash中field对应的value</p>
</li>
<li><p><code>hmget(key, field1, …,field N)</code>：返回名称为key的hash中field i对应的value</p>
</li>
<li><p><code>hmset(key, field1, value1,…,field N, value N)</code>：向名称为key的hash中添加元素field i&lt;—&gt;value i</p>
</li>
<li><p><code>hexists(key, field)</code>：名称为key的hash中是否存在键为field的域</p>
</li>
<li><p>hdel(key, field)：删除名称为key的hash中键为field的域</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HSET key field value</span><br><span class="line">HGET key field</span><br><span class="line">将一组field-value(域-值)对设置到哈希表key中。</span><br><span class="line">此命令会覆盖已经存在的域，如果key</span><br><span class="line">不存在，一个新的哈希表被创建并进行[HSET]操作。</span><br><span class="line"></span><br><span class="line">redis&gt; HSET blaise blog &quot;http://www.jianshu.com/u/08b68953dd14&quot;</span><br><span class="line">redis&gt; HGET blaise blog</span><br><span class="line">&quot;http://www.jianshu.com/u/08b68953dd14&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMSET key field value [field value ...]</span><br><span class="line">HMGET key field [field ...]</span><br><span class="line">同时将多个field - value(域-值)对设置到哈希表key中。</span><br><span class="line">此命令会覆盖已经存在的域，如果key不存在，一个新的哈希表被创建并执行[HMSET]操作。</span><br><span class="line"></span><br><span class="line">redis&gt; HMSET webside google &quot;www.google.com&quot; bing &quot;www.bing.com&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">redis&gt; HGET webside google</span><br><span class="line">&quot;www.google.com&quot;</span><br><span class="line">redis&gt; HGET webside google bing</span><br><span class="line">1) &quot;www.google.com&quot;</span><br><span class="line">2) &quot;www.bing.com&quot;</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt;HDEL webside google</span><br><span class="line">(integer) 1</span><br><span class="line">删除webside key可以使用DEL</span><br><span class="line">redis&gt;DEL webside</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>





<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>关于工程中一些问题的解决</title>
    <url>/2020/06/01/2020-06-01-%E5%85%B3%E4%BA%8E%E5%B7%A5%E7%A8%8B%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<blockquote>
<p>解决工程中的问题。</p>
</blockquote>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p><strong>问题：</strong></p>
<p>IDEA中导入工程，有些java文件左下角出现小黄色的J。</p>
<p><strong>解决方案：</strong></p>
<p>File里打开<code>project structure</code>找到<code>Modules</code>，把还没有添加进来的进行添加，或者全部删去，去掉Root路径后，重新添加。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p><strong>问题：</strong></p>
<p>控制台报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objc[<span class="number">999</span>]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin/java (<span class="number">0x1087204c0</span>) and /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/jre/lib/libinstrument.dylib (<span class="number">0x10972a4e0</span>). One of the two will be used. Which one is undefined.</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：</strong></p>
<p>这是一个java在Mac上的一个系统bug；java9或者java8 update 152 后已经修复。</p>
<ol>
<li><p>打开IEDA；</p>
</li>
<li><p>Help –&gt; Edit Custom Properties<br>即（帮助 -&gt; 编辑自定义属性。如果提示没有，可新建）</p>
</li>
<li><p>在配置文件中添加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#custom IntelliJ IDEA properties</span></span><br><span class="line"><span class="attr">idea_rt</span></span><br><span class="line"><span class="meta">idea.no.launcher</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启IDEA。</p>
</li>
</ol>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p><strong>问题：</strong></p>
<p>控制台报错<code>Prohibited package name: java.xxx...</code>异常错误</p>
<p><strong>解决方案：</strong></p>
<p>禁止的包名。引入的包名以<code>java</code>开头，如<code>package java.com.xxxx</code>。原因貌似是和双亲委派机制有关，在双亲委派模型中，由父加载类加载的类，下层加载器是不能加载的。最高层加载器BootstrapClassLoader加载了classpath路径下所定义的java.包内的类，而java.research包就不能由BootstrapClassLoader的下层加载器AppClassLoader加载了。这也是java安全机制中对于恶意代码所采取的防护措施。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis @SelectProvider注解</title>
    <url>/2020/05/24/2020-05-24-Mybatis%20@SelectProvider%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>原：<a href="https://blog.csdn.net/qq_36872046/article/details/80291939" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>实习项目中MyBatis中用到了<code>@selectProvider</code>，功能就是用来单独写一个class类与方法，用来提供一些xml或者注解中不好写的sql。其实就是用用自定义的provider类构造SQL语句</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type 属性用于指定获取sql语句的指定类</span><br><span class="line">method 属性用于指定类中要执行获取sql语句的方法</span><br></pre></td></tr></table></figure>

<h2 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h2><p><code>mapper</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SelectProvider</span>(type=BaseUserProvider.class,method=<span class="string">"selectUserById"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseUser <span class="title">selectById</span><span class="params">(@Param(value=<span class="string">"id"</span>)</span>Integer id)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<br>当mapper中传入的参数是使用<code>@param</code>注解修饰，在<code>xxxProvider</code>类中必须使用Map对象接收参数。</p>
<p><code>BaseUserProvider</code>类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">selectUserById</span><span class="params">(Map&lt;String, Object&gt; para)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">        SELECT(<span class="string">"*"</span>);</span><br><span class="line">        FROM(<span class="string">"base_user"</span>);</span><br><span class="line">        WHERE(<span class="string">"id="</span>+para.get(<span class="string">"id"</span>));</span><br><span class="line">    &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时：以上代码是借助<code>org.apache.ibatis.jdbc.SQL</code>类 使用固定的<code>SELECT FROM WHERE</code> 格式，也可以直接使用<code>return “select * from base_user where id =” + para.get(“id”);</code> 来实现sql拼接。</p>
<h2 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">selectUserById</span><span class="params">(Map&lt;String, Object&gt; para)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">            SELECT(<span class="string">"*"</span>);</span><br><span class="line">            FROM(<span class="string">"base_user"</span>);</span><br><span class="line">            WHERE(<span class="string">"id="</span>+para.get(<span class="string">"id"</span>));</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isNotBlank((String)para.get(<span class="string">"username"</span>)))&#123;</span><br><span class="line">                WHERE(<span class="string">"username="</span>+para.get(<span class="string">"username"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<br>此时的sql写法在拼接sql中不需要在使用 and 进行连接 ，在where 方法中已拼入where 源码如下：</p>
<pre><code>private static final String AND = &quot;) \nAND (&quot;;
private static final String OR = &quot;) \nOR (&quot;;</code></pre><p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面试高频知识点整理</title>
    <url>/2020/05/20/2020-05-20-Java%20%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>Java 面试高频知识点整理</p>
</blockquote>
<h2 id="排序算法-9"><a href="#排序算法-9" class="headerlink" title="排序算法 9"></a>排序算法 9</h2><h3 id="P1：排序算法的分类"><a href="#P1：排序算法的分类" class="headerlink" title="P1：排序算法的分类"></a>P1：排序算法的分类</h3><p>排序算法可以分为内部排序和外部排序，在内存中进行的排序称为内部排序，当要排序的数据量很大时无法全部拷贝到内存，需要使用外存进行排序，这种排序称为外部排序。</p>
<p>内部排序包括比较排序和非比较排序，比较排序包括插入排序、选择排序、交换排序和归并排序，非比较排序包括计数排序、基数排序和桶排序。其中插入排序又包括直接插入排序和希尔排序，选择排序包括直接选择排序和堆排序，交换排序包括冒泡排序和快速排序。</p>
<hr>
<h3 id="P2：直接插入排序"><a href="#P2：直接插入排序" class="headerlink" title="P2：直接插入排序"></a>P2：直接插入排序</h3><p>直接插入排序属于插入排序，是一种稳定的排序，平均时间复杂度和最差时间复杂度均为 O(n²)，当元素基本有序时的最好时间复杂度为O(n)，空间复杂度为 O(1)。</p>
<p>基本原理是每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。适用于待排序记录较少或基本有序的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> insertNum = nums[i];</span><br><span class="line">        <span class="keyword">int</span> insertIndex;</span><br><span class="line">        <span class="keyword">for</span> (insertIndex = i - <span class="number">1</span>; insertIndex &gt;= <span class="number">0</span> &amp;&amp; nums[insertIndex] &gt; insertNum; insertIndex--) &#123;</span><br><span class="line">            nums[insertIndex + <span class="number">1</span>] = nums[insertIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[insertIndex + <span class="number">1</span>] = insertNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：</strong>直接插入并没有利用到要插入的序列已有序的特点，插入第 i 个元素时可以通过二分查找找到要插入的位置，再把第 i 个元素前 1位与插入位置之间的所有元素后移，把第 i 个元素放在目标位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryInsertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt; nums.length; index++) &#123;</span><br><span class="line">        <span class="keyword">int</span> insertNum = nums[index];</span><br><span class="line">        <span class="keyword">int</span> insertIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (insertNum &gt; nums[mid])</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (insertNum &lt; nums[mid])</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                insertIndex = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (insertIndex == -<span class="number">1</span>)</span><br><span class="line">            insertIndex = start;</span><br><span class="line">        <span class="keyword">if</span> (index - insertIndex &gt;= <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(nums, insertIndex, nums, insertIndex + <span class="number">1</span>, index - insertIndex);</span><br><span class="line">        nums[insertIndex] = insertNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P3：希尔排序"><a href="#P3：希尔排序" class="headerlink" title="P3：希尔排序"></a>P3：希尔排序</h3><p>希尔排序属于插入排序，又称缩小增量排序，是对直接插入排序的一种改进，并且是一种不稳定的排序，平均时间复杂度为O(n^1.3^)，最差时间复杂度为 O(n²)，最好时间复杂度为 O(n)，空间复杂度为 O(1)。</p>
<p>基本原理是把记录按下标的一定增量分组，对每组进行直接插入排序，每次排序后减小增量，当增量减至 1 时，排序完毕。适用于中等规模的数据量，对规模非常大的数据量不是最佳选择。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = nums.length / <span class="number">2</span>; d &gt; <span class="number">0</span> ; d /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> insertNum = nums[i];</span><br><span class="line">            <span class="keyword">int</span> insertIndex;</span><br><span class="line">            <span class="keyword">for</span> (insertIndex = i - d; insertIndex &gt;= <span class="number">0</span> &amp;&amp; nums[insertIndex] &gt; insertNum; insertIndex -= d) &#123;</span><br><span class="line">                nums[insertIndex + d] = nums[insertIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[insertIndex + d] = insertNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P4：直接选择排序"><a href="#P4：直接选择排序" class="headerlink" title="P4：直接选择排序"></a><strong>P4：直接选择排序</strong></h3><p>直接选择排序属于选择排序，是一种不稳定的排序，任何情况下时间复杂度都是 O(n²)，空间复杂度为 O(1)。基本原理是每次在未排序序列中找到最小元素，和未排序序列的第一个元素交换位置，再在剩余的未排序序列重复该操作直到所有元素排序完毕。适用于数据量较小的情况，比直接插入排序稍快。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; nums.length - <span class="number">1</span>; index++)&#123;</span><br><span class="line">        minIndex = index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>;i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[minIndex]) </span><br><span class="line">                minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index != minIndex)&#123;</span><br><span class="line">            swap(nums, index, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P5：堆排序"><a href="#P5：堆排序" class="headerlink" title="P5：堆排序"></a><font color = 'red'>P5：堆排序</font></h3><p>堆排序属于选择排序，是对直接选择排序的改进，并且是一种不稳定的排序，任何情况时间复杂度都为 O(nlogn)，空间复杂度为 O(1)。</p>
<p>基本原理是将待排序记录看作完全二叉树，可以建立大根堆或小根堆，大根堆中每个节点的值都不小于它的子节点值，小根堆中每个节点的值都不大于它的子节点值。适用于数据量较大的情况。</p>
<p>以大根堆为例，在建堆时首先将最后一个节点作为当前节点，如果当前结点存在父节点且值大于父节点，就将当前节点和父节点交换。在移除时首先暂存根节点的值，然后用最后一个节点代替根节点并作为当前节点，如果当前节点存在子节点且值小于子节点，就将其与值较大的子节点进行交换，调整完堆后返回暂存的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    nums[i] = num;</span><br><span class="line">    <span class="keyword">int</span> curIndex = i;</span><br><span class="line">    <span class="keyword">while</span> (curIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (curIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[parentIndex] &lt; nums[curIndex]) </span><br><span class="line">            swap(nums, parentIndex, curIndex);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        curIndex =parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    nums[<span class="number">0</span>] = nums[size - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> curIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = curIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = curIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &gt;= size) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = leftIndex;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; size &amp;&amp; nums[maxIndex] &lt; nums[rightIndex])</span><br><span class="line">            maxIndex = rightIndex;</span><br><span class="line">        <span class="keyword">if</span> (nums[curIndex] &lt; nums[maxIndex])</span><br><span class="line">            swap(nums, curIndex, maxIndex);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        curIndex = maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P6：冒泡排序"><a href="#P6：冒泡排序" class="headerlink" title="P6：冒泡排序"></a>P6：冒泡排序</h3><p>冒泡排序属于交换排序，是一种稳定的排序，平均时间复杂度和最坏时间复杂度均为 O(n²)，当元素基本有序时的最好时间复杂度为O(n)，空间复杂度为 O(1)。</p>
<p>基本原理是比较相邻的元素，如果第一个比第二个大就进行交换，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，每一轮排序后末尾元素都是有序的，针对 n 个元素重复以上步骤 n -1 次排序完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; nums.length - <span class="number">1</span> - i; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &gt; nums[index + <span class="number">1</span>]) </span><br><span class="line">                swap(nums, index, index + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：</strong>当序列已经有序时仍会进行不必要的比较，可以设置一个标志位记录是否有元素交换，如果没有直接结束比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">betterBubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> swap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        swap = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; nums.length - <span class="number">1</span> - i; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &gt; nums[index + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, index ,index + <span class="number">1</span>);</span><br><span class="line">                swap = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swap) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P7：快速排序"><a href="#P7：快速排序" class="headerlink" title="P7：快速排序"></a><font color = 'red'>P7：快速排序</font></h3><p>快速排序属于交换排序，是对冒泡排序的一种改进，并且是一种不稳定的排序，平均时间复杂度和最好时间复杂度均为 O(nlogn)，当元素基本有序时的最坏时间复杂度为O(n²)，空间复杂度为 O(logn)。</p>
<p>基本原理是首先选择一个基准元素，然后通过一趟排序将要排序的数据分割成独立的两部分，一部分全部小于等于基准元素，一部分全部大于等于基准元素，然后再按此方法递归对这两部分数据分别进行快速排序。适用于数据量较大且元素基本无序的情况。</p>
<p>快速排序的一次划分从两头交替搜索，直到 low 和 high 指针重合，因此时间复杂度是 O(n)，而整个算法的时间复杂度与划分趟数有关。最好情况是每次划分选择的中间数恰好将当前序列几乎等分，经过 logn 趟划分便可得到长度为 1 的子表，这样算法的时间复杂度为O(nlogn)。最坏的情况是每次所选中间数是当前序列中的最大或最小元素，这使每次划分所得的子表其中一个为空表，另一个子表的长度为原表的长度 - 1。这样长度为 n 的数据表的需要经过 n 趟划分，整个排序算法的时间复杂度为O(n²)。</p>
<p>从空间上看尽管快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为 log(n+1)，最坏情况下栈的最大深度为 n。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = getPivotIndex(nums, start, end);</span><br><span class="line">        quickSort(nums, start, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, pivotIndex + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[start];</span><br><span class="line">    <span class="keyword">int</span> low = start;</span><br><span class="line">    <span class="keyword">int</span> high = end;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high &amp;&amp; nums[low] &lt;= pivot) </span><br><span class="line">            low++;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high &amp;&amp; nums[high] &gt; pivot) </span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) </span><br><span class="line">            swap(nums, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, start, high);</span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：</strong>当规模足够小时，例如 <code>end - start &lt; 10</code> 时，采用直接插入排序。</p>
<hr>
<h3 id="P8：归并排序"><a href="#P8：归并排序" class="headerlink" title="P8：归并排序"></a>P8：归并排序</h3><p>归并排序是基于归并操作的排序算法，是一种稳定的排序算法，任何情况时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。</p>
<p>基本原理是应用分治法将待排序序列分成两部分，然后对两部分分别递归排序，最后进行合并，使用一个辅助空间并设定两个指针分别指向两个有序序列的起始元素，将指针对应的较小元素添加到辅助空间，重复该步骤到某一序列到达末尾，然后将另一序列剩余元素合并到辅助空间末尾。适用于数据量大且对稳定性有要求的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] help;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    sort(arr, start, mid);</span><br><span class="line">    sort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">    merge(arr, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end + <span class="number">1</span> - start &gt;= <span class="number">0</span>) System.arraycopy(arr, start, help, start, end + <span class="number">1</span> - start);</span><br><span class="line">    <span class="keyword">int</span> p = start;</span><br><span class="line">    <span class="keyword">int</span> q = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = start;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= mid &amp;&amp; q &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (help[p] &lt; help[q]) </span><br><span class="line">            arr[index++] = help[p++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            arr[index++] = help[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= mid) arr[index++] = help[p++];</span><br><span class="line">    <span class="keyword">while</span> (q &lt;= end) arr[index++] = help[q++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P9：排序算法的选择原则"><a href="#P9：排序算法的选择原则" class="headerlink" title="P9：排序算法的选择原则"></a>P9：排序算法的选择原则</h3><p>当数据量规模较小时，可以考虑直接插入排序或直接选择排序，当元素分布有序时直接插入排序将大大减少比较次数和移动记录的次数，如果不要求稳定性，可以使用直接选择排序，效率略高于直接插入排序。</p>
<p>当数据量规模中等时，可以选择希尔排序。</p>
<p>当数据量规模较大时，可以考虑堆排序、快速排序和归并排序。如果对稳定性有要求可以采用归并排序，如果元素分布随机可以采用快速排序，如果元素分布接近正序或逆序可以采用堆排序。</p>
<p>一般不使用冒泡排序。</p>
<hr>
<h2 id="设计模式-7"><a href="#设计模式-7" class="headerlink" title="设计模式 7"></a>设计模式 7</h2><h3 id="P1：设计模式的原则"><a href="#P1：设计模式的原则" class="headerlink" title="P1：设计模式的原则"></a>P1：设计模式的原则</h3><p><strong>开闭原则：</strong>面向对象设计中最基础的设计原则，指一个软件实体（类、模块、方法等）应该对扩展开放，对修改关闭。它强调用抽象构建框架，用实现扩展细节，提高代码的可复用性和可维护性。例如在版本更新时尽量不修改源代码，但可以增加新功能。</p>
<p><strong>单一职责原则：</strong>一个类、接口或方法只负责一个职责，可以提高代码可读性和可维护性，降低代码复杂度以及变更引起的风险。</p>
<p><strong>依赖倒置原则：</strong>程序应该依赖于抽象类或接口，而不是具体的实现类。可以降低代码的耦合度，提高系统的稳定性。</p>
<p><strong>接口隔离原则：</strong>将不同功能定义在不同接口中实现接口隔离，避免了类依赖它不需要的接口，减少了接口之间依赖的冗余性和复杂性。</p>
<p><strong>里氏替换原则：</strong>对开闭原则的补充，规定了任何父类可以出现的地方子类都一定可以出现，可以约束继承泛滥，加键程序健壮性。</p>
<p><strong>迪米特原则：</strong>也叫最少知道原则，每个模块对其他模块都要尽可能少的了解和依赖，可以降低代码耦合度。</p>
<p><strong>合成/聚合原则：</strong>尽量使用组合(has a)或聚合(contains a)而不是继承关系达到软件复用的目的，可以使系统更加灵活，降低耦合度。</p>
<hr>
<h3 id="P2：设计模式的分类"><a href="#P2：设计模式的分类" class="headerlink" title="P2：设计模式的分类"></a>P2：设计模式的分类</h3><p><strong>创建型模式：</strong>提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。包括：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p><strong>结构型模式：</strong>通过类和接口之间的继承和引用实现创建复杂结构对象的功能。包括：适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式。</p>
<p><strong>行为型模式：</strong>通过类之间不同的通信方式实现不同的行为方式。包括：责任链模式、命名模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板模式、访问者模式。</p>
<hr>
<h3 id="P3：工厂模式"><a href="#P3：工厂模式" class="headerlink" title="P3：工厂模式"></a>P3：工厂模式</h3><p>工厂模式属于创建型模式，分为简单工厂模式，工厂方法模式和抽象工厂模式。</p>
<p>简单工厂模式指由一个工厂对象来创建实例，客户端不需要关注创建的逻辑，只需要提供传入工厂对象的参数。</p>
<p>工厂方法模式指定义一个创建对象的接口，让接口的实现类来决定创建哪一种对象，工厂方法模式让类的实例化推迟到子类中进行。工厂方法模式中客户端只需关心对应的工厂而无需关心创建细节，主要解决了产品扩展的问题，在简单工厂模式中如果产品种类变多，工厂的职责会越来越多，不便于维护。</p>
<p>抽象工厂模式指提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类。客户端不依赖于产品类实例如何被创建和实现的细节，主要用于系统的产品有多于一个的产品族，而系统只消费其中某一个产品族产品的情况。</p>
<p><strong>总结：</strong></p>
<p><strong>简单工厂：</strong>一个工厂，一种抽象产品。例如一个麦当劳店，可以生产多种汉堡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacDonaldFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">eatHamburger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"beef"</span>.equals(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BeefHamburger();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"pig"</span>.equals(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PigHamburger();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeefHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃牛肉汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PigHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃猪肉汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工厂方法：</strong>多个工厂，一种抽象产品。例如一个麦当劳店，可以生产多种汉堡，一个肯德基店，也可以生产多种汉堡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Hamburger <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KFCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃麦当劳汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃肯德基汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象工厂：</strong>多个工厂，多种抽象产品。例如一个麦当劳店和一个肯德基店都可以生产多种汉堡和可乐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Hamburger <span class="title">buildHamburger</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Drink <span class="title">buildDrink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">buildHamburger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">buildDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MCDrink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">buildHamburger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KFCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">buildDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KFCDrink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃麦当劳汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃肯德基汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCDrink</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喝麦当劳饮料"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCDrink</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喝肯德基饮料"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P4：单例模式"><a href="#P4：单例模式" class="headerlink" title="P4：单例模式"></a><font color="red">P4：单例模式</font></h3><p>单例模式属于创建型模式，是指一个单例类在任何情况下都只存在一个实例，构造器必须是私有的并由自己创建一个静态实例对象，并对外提供一个静态公有的获取实例方法。优点是在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例的情况下，并且可以避免对资源的多重占用。缺点是没有抽象层，难以扩展，与单一职责原则冲突。</p>
<p><strong>饿汉式：</strong>在类加载时就初始化创建单例对象，是线程安全的，但不管是否使用都会创建对象，可能会浪费内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒汉式：</strong>在外部调用时才会加载，是线程不安全的，可以加锁保证线程安全但效率低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双重检查锁：</strong>使用 volatile 以及两次检查来减小 synchronized 锁范围，提升效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckSingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态内部类：</strong>可以同时解决饿汉式的内存浪费问题和懒汉式的线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举：</strong>这种方式是 Effective Java 作者提倡的方式，它不仅能避免多线程同步问题，还能防止反序列化重新创建新的对象，绝对防止多次实例化，也能防止反射破解单例的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P5：代理模式"><a href="#P5：代理模式" class="headerlink" title="P5：代理模式"></a><font color="red">P5：代理模式</font></h3><p>代理模式属于结构型模式，为其他对象提供一种代理以控制对这个对象的访问，可以增强目标对象的功能。优点是可以增强目标对象的功能，一定程度降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，同时也会增加系统复杂度。</p>
<p><strong>静态代理：</strong>代理对象持有真实对象的引用，调用代理对象方法时也会调用真实对象的方法，但是会在真实对象方法的前后增加一些其他逻辑。需要手动完成代理操作，在程序运行前就已经存在代理类的字节码文件，代理类和被代理类的关系在运行前就已经确定了。 缺点是一个代理类只能为一个目标类服务，如果要服务多种类型就会增加很大的工作量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hr</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我需要找招聘一个员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hr hr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hr = <span class="keyword">new</span> Hr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hr.findWorker();</span><br><span class="line">        System.out.println(<span class="string">"找到了员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态代理：</strong>动态代理在程序运行时才通过反射创建具体的代理类，代理类和被代理类的关系在运行前是不确定的。动态代理的适用性更强，主要分为 JDK 动态代理和 CGLib 动态代理。</p>
<ul>
<li><p><strong>JDK 动态代理：</strong>通过 <code>Proxy</code>类的 <code>newInstance</code> 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 <code>InvocationHandler</code> 调用处理器实例来指明具体的逻辑，相比静态代理最大的优势是接口中声明的所有方法都被转移到 <code>InvocationHandler</code> 中的 <code>invoke</code> 方法集中处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Hr hr = <span class="keyword">new</span> Hr();</span><br><span class="line">    Company proxyHr = (Company) Proxy.newProxyInstance(hr.getClass().getClassLoader(), hr.getClass().getInterfaces(), (proxy, method, args1) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"接收代理请求"</span>);</span><br><span class="line">        Object obj = method.invoke(hr, args1);</span><br><span class="line">        System.out.println(<span class="string">"找到了员工，完成请求"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxyHr.findWorker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CGLib 动态代理：</strong>与 JDK 动态代理不同的是，JDK 动态代理要求实现被代理对象的接口，而 CGLib 要求继承被代理对象，如果一个类是 final 类则不能使用 CGLib 动态代理。两种代理都是在运行期生成字节码，JDK 动态代理直接写字节码，而 CGLib 动态代理使用 ASM 框架写字节码，ASM 作用于已编译好的 Class 文件，其目的是生成、转换和分析以字节数组表示的已编译 Java 类。 JDK 动态代理调用代理方法是通过反射机制实现的，而 GCLib 动态代理是通过 FastClass 机制直接调用方法的，为代理类和被代理类各生成一个类，该类为代理类和被代理类的方法会分配一个 int 类型的参数，调用方法时可以直接定位而省去反射，因此调用方法的效率更高。</p>
</li>
</ul>
<hr>
<h3 id="P6：装饰器模式"><a href="#P6：装饰器模式" class="headerlink" title="P6：装饰器模式"></a>P6：装饰器模式</h3><p>指在不改变原有对象的基础上，将功能附加到对象上，相比继承可以更加灵活地扩展原有对象的功能，属于结构型模式。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下提供了额外的功能。装饰器模式适合的场景：在不想增加很多子类的前提下扩展一个类的功能或给一个类添加附加职责、动态地给一个类添加功能，这些功能可以再动态地撤销。</p>
<p><strong>和动态代理的区别：</strong>装饰器模式的关注点在于给对象动态添加方法，而动态代理更注重对象的访问控制。动态代理通常会在代理类中创建被代理对象的实例，而装饰器模式会将装饰者作为构造器的参数。</p>
<hr>
<h3 id="P7：适配器模式"><a href="#P7：适配器模式" class="headerlink" title="P7：适配器模式"></a>P7：适配器模式</h3><p>适配器模式属于结构型模式，它作为两个不兼容的接口之间的桥梁，结合了两个独立接口的功能，将一个类的接口转换成另外一个接口，这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。优点是使得原本由于接口不兼容而不能一起工作的类可以一起工作。 缺点是过多使用适配器会让系统非常零乱，不易整体进行把握。</p>
<p><strong>和装饰器模式的区别：</strong>适配器模式的是要将一个接口转变成另一个接口，目的是通过改变接口来解决接口不兼容的问题。而装饰器模式不是要改变被装饰对象的接口，而是要增强原有对象的功能。例如 java.io 包中，适配器模式是将 InputStream 字节输入流通过适配器 InputStreamReader 转换为 Reader 字符输入流，而装饰器模式是将 InputStream 通过装饰器 BufferedInputStream 增强为缓冲字节输入流。</p>
<hr>
<h2 id="Java-基础-20"><a href="#Java-基础-20" class="headerlink" title="Java 基础 20"></a>Java 基础 20</h2><h3 id="P1：Java-语言的基本概念"><a href="#P1：Java-语言的基本概念" class="headerlink" title="P1：Java 语言的基本概念"></a>P1：Java 语言的基本概念</h3><p><strong>优点：</strong></p>
<ul>
<li><p>具有平台无关性，摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想。</p>
</li>
<li><p>提供了一种相对安全的内存管理和访问机制，避免了绝大部分内存泄漏和指针越界问题。</p>
</li>
<li><p>实现了热点代码检测和运行时编译及优化，使得 Java 程序随运行时间增长可以获得更高的性能。</p>
</li>
<li><p>有一套完善的应用程序接口，还支持很多第三方类库。</p>
</li>
</ul>
<p><strong>Java 平台无关性原理：</strong></p>
<p>主要是通过 JVM 和 Java 语言规范实现。</p>
<ul>
<li>编译器生成一个体系结构中立的目标文件格式，这是一种编译后的代码，只要有 Java 运行时系统，这些编译后的代码可以在很多处理器上运行。Java 编译器通过生成与特定计算机体系结构无关的字节码指令来实现这一特性，字节码文件不仅可以很容易地在任何机器上解释执行，还可以动态地转换成本地机器代码，转换是由 JVM 实现的，JVM 是平台相关的，屏蔽了不同操作系统的差异。</li>
<li>Java 中基本数据类型的大小以及有关运算的行为都有明确的说明，例如 Java 中的 int 类型永远为 32 位的整数，而在 C/C++ 中 int 可能是 16 位整数、32 位整数，也可能是编译器开发商指定的其他任何大小。在 Java 中数值类型有固定的字节数，二进制数据以固定的格式进行存储和传输，字符串则采用标准的 Unicode 格式存储。</li>
</ul>
<p><strong>专业术语：</strong></p>
<ul>
<li>JDK：Java Development Kit，Java 开发工具包。它提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、JRE 以及常用的 Java 基础类库等，是 JAVA 的核心。JDK 是编写 Java 程序的程序员使用的软件。</li>
<li>JRE：Java Runtime Environment，Java 运行时环境，是运行基于 Java 语言编写的程序所不可缺少的运行环境。JRE 是运行 Java 程序的用户使用的软件。</li>
<li>SE：Standard Edition，标准版，用于桌面或简单服务器应用的 Java 平台。</li>
<li>EE：Enterprise Edition，企业版，用于复杂服务器应用的 Java 平台。</li>
<li>ME：Micro Edition，微型版，用于小型设备的 Java 平台。</li>
</ul>
<hr>
<h3 id="P2：Java-基本数据类型"><a href="#P2：Java-基本数据类型" class="headerlink" title="P2：Java 基本数据类型"></a>P2：Java 基本数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>占用内存大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1 字节</td>
<td>-2^7^ ~ 2^7^-1</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
<td>-2^15^ ~ 2^15^-1</td>
</tr>
<tr>
<td>int</td>
<td>4 字节</td>
<td>-2^31^ ~ 2^31^-1</td>
</tr>
<tr>
<td>long</td>
<td>8 字节</td>
<td>-2^63^ ~ 2^63^-1</td>
</tr>
<tr>
<td>float</td>
<td>4 字节</td>
<td>±3.4E+38F（有效位数 6~7 位）</td>
</tr>
<tr>
<td>double</td>
<td>8 字节</td>
<td>±1.7E+308（有效位数 15 位）</td>
</tr>
<tr>
<td>char</td>
<td>英文在 UTF-8 和 GBK 中均占 1 字节，中文在 UTF-8 占 3 字节，GBK 占 2 字节。</td>
<td>/</td>
</tr>
<tr>
<td>boolean</td>
<td>单个变量用 int 代替，占 4 字节，而数组会编码成 byte 数组，占 1 字节。</td>
<td>true、false</td>
</tr>
</tbody></table>
<p>每个基本数据类型都对应一个自己的包装类，除了 int 和 char 对应 Integer 和 Character 之外，其余基本数据类型的包装类都是首字母大写即可。自动装箱指的是将基本数据类型包装为一个包装类对象，例如向一个泛型为 Integer 类型的集合添加 int 类型的元素。自动拆箱指的是将一个包装类对象转换为一个基本数据类型，例如将一个包装类对象赋值给一个基本数据类型的变量。要比较两个包装类的数值需要使用 <code>equals</code> 方法，而不能使用 <code>==</code> 比较运算符。</p>
<hr>
<h3 id="P3：String"><a href="#P3：String" class="headerlink" title="P3：String"></a>P3：String</h3><p><strong>不可变性：</strong>String 是不可变类，并且存储数据的 value 字符数组也是 final 修饰的不可变数组，因此当修改一个 String 变量的值时，并没有真正修改它引用的 String 对象的字符数组中的值，而是重新创建了一个 String 对象赋值给了 String 变量进行引用。</p>
<p><strong>字符串拼接：</strong>直接使用 + 进行字符串拼接，如果是字面量会自动拼接为一个新的常量。要提升拼接效率可以使用 StringBuilder 或 StringBuffer 可变字符串，区别是 StringBuffer 使用了 synchronized 保证线程安全性，但一般字符串拼接都是单线程操作，所以使用 StringBuilder 较多。常量和常量的拼接，结果也在常量池中，且不存在两个相同的常量。只要参与拼接的字符串里有变量，结果就在堆中。</p>
<p><strong>创建：</strong> 如果是通过字符串常量赋值的形式，例如 String s = “s”，字符串常量内容存于常量池，变量存于栈中并直接引用常量池中的字符串。如果是通过new 的形式，例如 <code>String s = new String(&quot;s&quot;)</code>，会先在堆中创建实例对象，然后再去常量池寻找需要的字符串常量，如果找到了则直接使用，没找到则开辟新的空间并存储内容，最后栈中变量引用堆中对象，对象再引用常量池中的字符串。</p>
<hr>
<h3 id="P4：值调用和引用调用"><a href="#P4：值调用和引用调用" class="headerlink" title="P4：值调用和引用调用"></a>P4：值调用和引用调用</h3><p>按值调用指的是方法接收的是调用者提供的值，而按引用调用指的是方法接收的是调用者提供的变量地址。Java 总是采用按值调用，也就是说方法得到的是所有参数值的一个副本，当传递对象时实际上方法接收的是这个对象引用的副本。方法不能修改基本数据类型的参数，可以改变对象参数的状态，但不能让对象参数引用一个新的对象。</p>
<p>举例来说，如果传递了一个 int 类型的值 ，改变该值不会影响实参，因为改变的是该值的一个副本。如果传递了一个 int[] 类型的数组，改变数组的内容会影响实参，而如果改变这个参数的引用，并不会让实参引用新的数组对象。</p>
<hr>
<h3 id="P5：面向对象"><a href="#P5：面向对象" class="headerlink" title="P5：面向对象"></a><font color="red">P5：面向对象</font></h3><p><strong>概念：</strong>面向对象是一种程序设计思想，相对于面向过程而言更适合解决规模较大的问题。采用面向对象的开发方式可以对现实的事物进行抽象，把现实的事物映射为开发对象，接近人的思维。并且可以通过继承或组合的方式实现代码的重用，因此开发效率高。并且面向对象的开发方式提高了代码的可读性，使代码结构更加清晰，方便代码的维护。</p>
<p><strong>特性：</strong></p>
<ul>
<li><strong>封装：</strong>也称数据隐藏，从形式上看就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。</li>
<li><strong>继承：</strong>可以通过继承来扩展一个类，扩展的子类可以继承父类的属性和方法，并可以添加自己独有的属性和方法。Java 中类只可以单继承，接口之间是可以多继承的。继承是一种”is-a”的关系，可以提高代码的复用性。</li>
<li><strong>多态：</strong>父类的变量可以引用一个子类的对象，在运行时通过动态绑定来决定调用的方法。<ul>
<li><strong>重载：</strong>是指同一个类中具有多个方法名相同而方法参数列表不同的方法，重载方法的返回值类型不做要求，但方法的参数列表必须不同。重载属于一种编译时多态。</li>
<li><strong>重写：</strong>是指子类具有和父类方法名和方法参数列表都相同的方法，要求返回值不大于父类方法的返回值，抛出的异常类型不大于父类方法抛出的异常类型，访问修饰符可见性不小于父类方法的访问修饰符可见性。重写属于一种运行时多态。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="P6：方法修饰符"><a href="#P6：方法修饰符" class="headerlink" title="P6：方法修饰符"></a>P6：方法修饰符</h3><table>
<thead>
<tr>
<th>访问修饰符</th>
<th>本类可见性</th>
<th>本包可见性</th>
<th>子类可见性</th>
<th>不同包可见性</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>默认</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<hr>
<h3 id="P7：接口和抽象类"><a href="#P7：接口和抽象类" class="headerlink" title="P7：接口和抽象类"></a>P7：接口和抽象类</h3><p><strong>成员变量：</strong>接口中的成员变量默认是 public static final 修饰的常量，抽象类中的成员变量无特殊要求。</p>
<p><strong>构造器：</strong>接口和抽象类都不能直接实例化，但接口没有构造器，抽象类是有构造器的。</p>
<p><strong>方法：</strong>接口中的方法默认是 public 修饰的，Java 8 开始支持默认方法和静态方法，Java 9 开始支持私有方法。抽象类中的方法不做要求，抽象类可以不含抽象方法，但含有抽象方法的类一定是抽象类。</p>
<p><strong>继承：</strong>接口可以多继承和多实现，而抽象类只能单继承。</p>
<p><strong>选择原则：</strong>如果知道某个类应该成为基类，那么第一选择应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。在接口和抽象类的选择上，必须遵守这样一个原则：行为模型应该总是通过接口而不是抽象类定义。通过抽象类建立行为模型会出现的问题：如果有一个产品类 A，有两个子类 B 和 C 分别有自己的功能，如果出现一个既有 B 产品功能又有 C 产品功能的新产品需求，由于 Java 不允许多继承就出现了问题，而如果是接口的话只需要同时实现两个接口即可。</p>
<hr>
<h3 id="P8：Object-类"><a href="#P8：Object-类" class="headerlink" title="P8：Object 类"></a>P8：Object 类</h3><p>Object 的类是所有类的父类，位于java.lang包下，Object 类的方法：</p>
<ul>
<li><strong>Object:</strong> 即Object的构造方法，大部分情况下，Java中通过形如 new A(args..)形式创建一个属于该类型的对象。其中A即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。为体现此特性，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。</li>
<li><strong>getClass：</strong>返回包含对象信息的类对象。解释下”类对象”的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。</li>
</ul>
<ul>
<li><strong>equals：</strong>用于检测一个对象是否等于另一个对象，默认使用 <code>==</code> 比较两个对象的引用，可以重写 equals 方法自定义比较规则。equals 方法需要满足以下规范：自反性、对称性、传递性、一致性并对于任何非空引用 x，<code>x.equals(null)</code>  返回 false。</li>
<li><strong>hashCode：</strong>散列码是由对象导出的一个整型值，是没有规律的，每个对象都有一个默认的散列码，值由对象的存储地址得出。字符串可能有相同的散列码，因为字符串的散列码是由内容导出的。为了在集合中正确使用对象，一般需要同时重写 equals 和 hashCode 方法，要求是 equals 相同是 hashCode 必须相同，但 hashCode 相同时 equals 未必相同，因此 hashCode 是两个对象相同的必要不充分条件。</li>
<li><strong>toString</strong>：打印对象时默认会调用它的 toString 方法，如果没有重写该方法默认打印的是表示对象值的一个字符串，一般需要重写该方法。打印数组时可以使用 <code>Arrays.toString()</code> 方法。</li>
<li><strong>clone：</strong>clone 方法声明为 protected，类只能通过该方法克隆它自己的对象，如果希望其他类也能调用该方法必须定义该方法为 public。如果一个对象的类没有实现 Cloneable 接口，该对象调用 clone 方法会抛出一个 CloneNotSupport 异常。默认的 clone 方法是浅拷贝，一般重写 clone 方法需要实现 Cloneable 接口并指定访问修饰符为 public。<ul>
<li><strong>浅拷贝：</strong>如果对象包含子对象的引用，拷贝字段就会得到相同子对象的另一个引用，如果共享的子对象是不可变的则是安全的，通常子对象都是可变的，因此浅拷贝是不安全的，拷贝对象的更改会影响原对象。</li>
<li><strong>深拷贝：</strong>会完全拷贝基本数据类型和引用数据类型，深拷贝是安全的。</li>
</ul>
</li>
<li><strong>wait / notify / notifyAll：</strong>阻塞或唤醒持有该对象锁的线程。</li>
<li><strong>finalize：</strong>要确定一个对象死亡至少要经过两次标记，如果对象在进行可达性分析后发现没有与GC Roots 连接的引用链，会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。假如对象没有重写 finalize 方法或者该方法已经被虚拟机调用过，那么这两种情况视为没有必要执行。如果这个对象被判断为有必要执行，就会被放置在一个叫做 F-Queue 的队列中，由一条虚拟机自动建立的低调度优先级的 Finalizer 线程去执行它们的 finalize 方法。虚拟机会触发该方法但不保证它会运行结束，这是为了防止某个对象的 finalize 方法执行缓慢或发生死循环。只要对象在 finalize 方法中重新与引用链上的任何一个对象建立关联关系就会在第二次标记时被移出即将回收集合，否则就会被真正回收。由于运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法，因此它并不适合释放资源，释放资源完全可以使用 try-finally 代码块。</li>
</ul>
<hr>
<h3 id="P9：内部类"><a href="#P9：内部类" class="headerlink" title="P9：内部类"></a>P9：内部类</h3><p>使用内部类主要有两个原因：内部类可以对同一个包中的其他类隐藏。内部类方法可以访问定义这个内部类的作用域中的数据，包括原本私有的数据。内部类是一个编译器现象，与虚拟机无关。编译器会把内部类转换成常规的类文件，用美元符号 $ 分隔外部类名与内部类名，而虚拟机对此一无所知。</p>
<p><strong>静态内部类：</strong>由static修饰，属于外部类本身，只加载一次。类可以定义的成分静态内部类都可以定义，可以访问外部类的静态变量和方法，通过 <code>new 外部类.内部类构造器</code> 来创建对象。只要内部类不需要访问外部类对象，就应该使用静态内部类。</p>
<p><strong>成员内部类：</strong>属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可以访问外部类的所有内容，通过 <code>new 外部类构造器.new 内部类构造器</code> 来创建对象。</p>
<p><strong>局部内部类：</strong>定义在方法、构造器、代码块、循环中。不能声明访问修饰符，只能定义实例成员变量和实例方法，作用范围仅在声明这个局部类的代码块中。</p>
<p><strong>匿名内部类：</strong>没有名字的局部内部类，可以简化代码，匿名内部类会立即创建一个匿名内部类的对象返回，对象类型相当于当前 new 的类的子类类型。匿名内部类一般用于实现事件监听器和其他回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NormalInnerClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态内部类创建对象</span></span><br><span class="line">        <span class="keyword">new</span> OuterClass.StaticInnerClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 成员内部类创建对象</span></span><br><span class="line">        <span class="keyword">new</span> OuterClass().new NormalInnerClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 局部内部类创建对象</span></span><br><span class="line">        <span class="keyword">new</span> LocalClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 匿名内部类创建对象</span></span><br><span class="line">        Runnable runnable = () -&gt; &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="P10：static-关键字"><a href="#P10：static-关键字" class="headerlink" title="P10：static 关键字"></a>P10：static 关键字</h3><p>static 关键字主要有两个作用：（1）为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。（2）让某个属性或方法与类而不是对象关联在一起，可以在不创建对象的情况下通过类名来访问。</p>
<p><strong>作用范围：</strong></p>
<p>static 修饰的变量称为静态变量，也叫做类变量，可以直接通过类名来访问，静态变量存储在 JVM 的方法区中。</p>
<p>static 修饰的方法称为静态方法，也叫做类方法，可以直接通过类名来访问，静态方法只能访问静态变量或静态方法。</p>
<p>static 修饰的代码块称为静态代码块，只能定义在类下，会在类加载时执行，只会执行一次。</p>
<p>static 修饰的类称为静态内部类，可以访问外部类的静态变量和方法。</p>
<p>static 也可以用来导入包下的静态变量。</p>
<p><strong>类初始化的顺序：</strong></p>
<p>（1）父类静态代码块和静态变量<br>（2）子类静态代码块和静态变量<br>（3）父类普通代码块和普通变量<br>（4）父类构造器<br>（5）子类普通代码块和普通变量<br>（6）子类构造器</p>
<p>其中代码块和变量的初始化顺序按照类中声明的顺序执行。</p>
<hr>
<h3 id="P11：序列化和反序列化"><a href="#P11：序列化和反序列化" class="headerlink" title="P11：序列化和反序列化"></a>P11：序列化和反序列化</h3><p>Java 对象在 JVM 运行时被创建，当 JVM 退出时存活对象都会销毁，如果需要将对象及其状态持久化，就需要通过序列化来实现，将对象及其状态信息保存在字节数组中，在需要时再将这些字节数组反序列化为对象。对象序列化保存的是对象的状态，因此类中的静态变量不会被序列化，因为静态变量是类属性。</p>
<p>要实现序列化功能需要实现 <code>java.io.Serializabale</code> 标记接口，序列化和反序列化必须保持序列化 ID 的一致，一般使用 <code>private static final long serialVersionUID</code> 定义序列化 ID，如果需要序列化父类的状态，父类也需要实现该接口。</p>
<p>有许多序列化框架，例如 fastjson、thrift等，也可以使用 JDK 自带的 ObjectOutputStream 类的 writeObject 方法实现序列化，将对象以流的方式写入磁盘中，ObjectInputStream 类的 readObject 方法实现反序列化，以流的方式从磁盘读取。</p>
<p>除了静态变量外，transient 修饰的变量也不会被序列化。transient 的作用就是把这字段的生命周期仅限于内存中而不会写到磁盘里持久化，被 transient 修饰的变量会被设为对应数据类型的默认初始值。</p>
<p>除了实现 Serializabale 接口外，另一种方法是实现 Exteranlizable 接口。 需要重写 writeExternal 和 readExternal 方法，它的效率比Serializable 高一些，并且可以决定哪些属性需要序列化（即使是 transient 修饰的变量），但是对大量对象或者重复对象则效率低。</p>
<hr>
<h3 id="P12：反射"><a href="#P12：反射" class="headerlink" title="P12：反射"></a>P12：反射</h3><p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java的反射机制。优点是运行时动态获取类的全部信息，缺点是破坏了类的封装性，泛型的约束性。反射是框架的核心灵魂，动态代理设计模式采用了反射机制，还有 Spring、Hibernate 等框架也大量使用到了反射机制。</p>
<p>在程序运行期间，Java 运行时系统始终为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类名为 Class。</p>
<p>获取 Class 实例的方法有三种：（1）直接通过 <code>类名.class</code> 。②通过对象的 <code>getClass()</code>方法。③通过 <code>Class.forName(类的全限定名)</code>。Class 类中的 getFields、getMethods 和 getConstructors 方法分别返回这个类支持的公共字段、方法和构造器的数组，其中包括父类的公共成员。Class 类中的 getDeclaredFields、getDeclaredMethods 和 getDeclaredConstructors 方法分别返回这个类声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括父类的成员。</p>
<p>Field、Method、Constructor 分别用于描述类的字段、方法和构造器。这三个类都有一个 getName 方法返回字段、方法或构造器的名称。Field 类有一个 getType 方法用来返回描述字段类型的一个对象，这个对象的类型也是 Class。Method 和 Constructor 类有报告参数类型的方法，Method 类还有一个报告返回类型的方法。这三个类都有一个 getModifiers 方法，它返回一个整数，用不同的 0/1 位描述所使用的修饰符。</p>
<hr>
<h3 id="P13：注解"><a href="#P13：注解" class="headerlink" title="P13：注解"></a>P13：注解</h3><p>注解是一种标记，可以使类或接口附加额外的信息，是帮助编译器和 JVM 完成一些特定功能的，例如常用注解 <code>@Override</code> 标识一个方法是重写方法。</p>
<p>元注解就是自定义注解的注解，包括：</p>
<ul>
<li><p><code>@Target</code>：用来约束注解作用的位置，值是 ElementType 枚举类实例，包括 METHOD 方法、VARIABLE 变量、TYPE 类/接口、PARAMETER 方法参数、CONSTRUCTORS 构造器和 LOACL_VARIABLE 局部变量等。</p>
</li>
<li><p><code>@Rentention</code>：用来约束注解的生命周期，值是 RetentionPolicy 枚举类实例，包括：SOURCE 源码、CLASS 字节码和 RUNTIME 运行时。</p>
</li>
<li><p><code>@Documented</code>：表明这个注解应该被 javadoc 工具记录。</p>
</li>
<li><p><code>@Inherited</code>：表明某个被标注的类型是被继承的。</p>
</li>
</ul>
<hr>
<h3 id="P14：异常"><a href="#P14：异常" class="headerlink" title="P14：异常"></a>P14：异常</h3><p>所有的异常都派生于 Throwable 类的一个类实例，在下一层分为 Error 和 Exception。</p>
<p>Error 类描述了 Java 运行时系统的内部错误和资源耗尽错误，如果出现了这种错误，一般无能为力。</p>
<p>Exception 类又分为 RuntimeException 和其他异常，一般规则是由编程错误导致的异常属于 RuntimeException，如果程序本身没有问题，但由于像 IO 错误这类问题导致的异常属于其他异常。派生于 Error 和 RuntimeException 的异常属于非检查型异常，其余异常都属于检查型异常。</p>
<p>常见的 RuntimeException 异常：</p>
<ul>
<li>ClassCastException，错误的强制类型转换。</li>
<li>ArrayIndexOutOfBoundsException，数组访问越界。</li>
<li>NullPointerException，空指针异常。</li>
</ul>
<p>常见的检查型异常：</p>
<ul>
<li>FileNotFoundException，试图打开不存在的文件。</li>
<li>ClassNotFoundException，试图根据指定字符串查找 Class 对象，而这个类并不存在。</li>
<li>IOException，试图超越文件末尾继续读取数据。</li>
</ul>
<p><strong>异常处理：</strong></p>
<p><strong>抛出异常：</strong>遇到异常不进行具体处理，而是将异常抛出给调用者，由调用者根据情况处理。抛出异常有2种形式，一种是 throws 关键字声明抛出的异常，作用在方法上，一种是使用throw 语句直接抛出异常，作用在方法内。</p>
<p><strong>捕获异常：</strong>使用 try/catch 进行异常的捕获，try 中发生的异常会被 catch 代码块捕获，根据情况进行处理，如果有 finally 代码块无论是否发生异常都会执行，一般用于释放资源，Java 7 开始可以将资源定义在 try 代码块中自动释放资源。</p>
<hr>
<h3 id="P15：泛型"><a href="#P15：泛型" class="headerlink" title="P15：泛型"></a>P15：泛型</h3><p>泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制允许程序在编译时检测非法的类型。</p>
<p><strong>类型擦除：</strong></p>
<p>虚拟机没有泛型类型对象，所有对象都属于普通类。无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被擦除，如果没有限定类型就会替换为 Object，如果有限定类型就会替换为第一个限定类型，例如 <code>&lt;T extends A &amp; B&gt;</code> 会使用 A 类型替换 T。</p>
<p>泛型主要用于编译阶段，在编译后生成的 Java 字节代码文件中不包含泛型中的类型信息。</p>
<p><strong>泛型规范：</strong></p>
<table>
<thead>
<tr>
<th>泛型标记</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>E（Element）</td>
<td>在集合中使用，表示在集合中存放的元素。</td>
</tr>
<tr>
<td>T（Type）</td>
<td>表示类，包括基本的类以及自定义类。</td>
</tr>
<tr>
<td>K（Key）</td>
<td>表示键，例如 Map 集合中的 Key。</td>
</tr>
<tr>
<td>V（Value）</td>
<td>表示值，例如 Map 集合中的 Value。</td>
</tr>
<tr>
<td>N（Number）</td>
<td>表示数值类型。</td>
</tr>
<tr>
<td>？</td>
<td>表示不确定的类型。</td>
</tr>
</tbody></table>
<p><strong>泛型限定：</strong></p>
<p>对泛型上限的限定使用&lt;? extends T&gt;，它表示该通配符所代表的类型是 T 类的子类型或 T 接口的子接口。</p>
<p>对泛型下限的限定使用&lt;? super T&gt;，它表示该通配符所代表的类型是 T 类的父类型或 T 接口的父接口。</p>
<hr>
<h3 id="P16：Java-8-新特性"><a href="#P16：Java-8-新特性" class="headerlink" title="P16：Java 8 新特性"></a><font color="red">P16：Java 8 新特性</font></h3><p><strong>lambda 表达式：</strong>lambda 表达式允许把函数作为一个方法的参数传递到方法中，主要用来简化匿名内部类的代码。</p>
<p><strong>函数式接口：</strong>使用 <code>@FunctionalInterface</code> 注解标识，有且仅有一个抽象方法，可以被隐式转换为 lambda 表达式。</p>
<p><strong>方法引用：</strong>可以直接引用已有类或对象的方法或构造器，进一步简化 lambda 表达式。方法引用有四种形式：引用构造方法、引用类的静态方法、引用特定类的任意对象方法、引用某个对象的方法。</p>
<p><strong>接口中的方法：</strong>接口中可以定义 <code>default</code> 修饰的默认方法，降低了接口升级的复杂性，还可以定义静态方法。</p>
<p><strong>注解：</strong>Java 8 引入了重复注解机制，相同的注解在同一个地方可以声明多次。注解的作用范围也进行了扩展，可以作用于局部变量、泛型、方法异常等。</p>
<p><strong>类型推测：</strong>加强了类型推测机制，可以使代码更加简洁，例如在定义泛型集合时可以省略对象中的泛型参数。</p>
<p><strong>Optional 类：</strong>用来处理空指针异常，提高代码可读性。</p>
<p><strong>Stream 类：</strong>把函数式编程风格引入 Java 语言，提供了很多功能，可以使代码更加简洁。方法包括<code>forEach()</code> 遍历、<code>count()</code> 统计个数、<code>filter()</code> 按条件过滤、<code>limit()</code> 取前 n 个元素、<code>skip()</code> 跳过前 n 个元素、<code>map()</code> 映射加工、<code>concat()</code> 合并stream流等。</p>
<p><strong>日期：</strong>增强了日期和时间的 API，新的 java.time 主要包含了处理日期、时间、日期/时间、时区、时刻和时钟等操作。</p>
<p><strong>JavaScript：</strong>Java 8 提供了一个新的 Nashorn JavaScript 引擎，它允许我们在 JVM上运行特定的 JavaScript 应用。</p>
<hr>
<h3 id="P17：Java-IO"><a href="#P17：Java-IO" class="headerlink" title="P17：Java IO"></a>P17：Java IO</h3><table>
<thead>
<tr>
<th>IO 模型</th>
<th>对应的 Java 版本</th>
</tr>
</thead>
<tbody><tr>
<td>BIO（同步阻塞 IO）</td>
<td>1.4 之前</td>
</tr>
<tr>
<td>NIO（同步非阻塞 IO）</td>
<td>1.4</td>
</tr>
<tr>
<td>AIO（异步非阻塞 IO）</td>
<td>1.7</td>
</tr>
</tbody></table>
<p><strong>同步和异步是通信机制，阻塞和非阻塞是调用状态。</strong></p>
<ul>
<li><p>同步 IO 是用户线程发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行。</p>
</li>
<li><p>异步 IO 是用户线程发起 I/O 请求后仍可以继续执行，当内核 I/O 操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p>
</li>
<li><p>阻塞 IO 是指 I/O 操作需要彻底完成后才能返回用户空间 。</p>
</li>
<li><p>非阻塞 IO 是指 I/O 操作被调用后立即返回一个状态值，无需等 I/O 操作彻底完成。</p>
</li>
</ul>
<p><strong>BIO：</strong></p>
<p>同步阻塞式 IO，服务器实现模式为一个连接请求对应一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。可以通过线程池机制改善，这种 IO 称为伪异步 IO。</p>
<p>主要分为字符流和字节流，字符流包括字符输入流 Reader 和字符输出流 Writer，字节流包括字节输入流 InputStream 和 字节输出流 OutputStream，字节流和字符流都有对应的缓冲流和过滤流，也可以将字节流包装为字符流。</p>
<p><strong>适用场景：</strong>连接数目少、服务器资源多、开发难度低。</p>
<hr>
<p><strong>NIO：</strong></p>
<p>同步非阻塞 IO，服务器实现模式为多个连接请求对应一个线程，客户端发送的连接请求都会注册到一个多路复用器 Selector 上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理，有数据才会开启线程处理，性能比较好。</p>
<p><strong>同步是指线程还是要不断接收客户端连接并处理数据，非阻塞是指如果一个管道没有数据，不需要等待，可以轮询下一个管道。</strong></p>
<p>有三个核心组件：</p>
<ul>
<li><p><strong>Selector</strong></p>
<p>选择器或多路复用器，主要作用是轮询检查多个 Channel 的状态，判断 Channel 注册的事件是否发生，即判断 Channel 是否处于可读或可写状态。在使用之前需要将 Channel 注册到 Selector 上，注册之后会得到一个 SelectionKey，通过 SelectionKey 可以获取 Channel 和 Selector 的相关信息。</p>
</li>
<li><p><strong>Channel</strong></p>
<p>双向通道，替换了 IO 中的 Stream，不能直接访问数据，要通过 Buffer 来读写数据，也可以和其他 Channel 交互。</p>
<p><strong>分类：</strong>FileChannel 处理文件、DatagramChannel 处理 UDP 数据、SocketChannel 处理 TCP 数据，用作客户端、ServerSocketChannel 处理 TCP 数据，用作服务器端。</p>
</li>
<li><p><strong>Buffer</strong></p>
<p>缓冲区，本质是一块可读写数据的内存，这块内存被包装成 NIO 的 Buffer 对象，用来简化数据的读写。Buffer 的三个重要属性：position 表示下一次读写数据的位置，limit 表示本次读写的极限位置，capacity 表示最大容量。</p>
<ul>
<li><code>flip()</code> 将写转为读，底层实现原理是把 position 置 0，并把 limit 设为当前的 position 值。</li>
<li>通过 <code>clear()</code> 将读转为写模式（用于读完全部数据的情况，把 position 置 0，limit 设为 capacity）。</li>
<li>通过 <code>compact()</code> 将读转为写模式（用于没有读完全部数据，存在未读数据的情况，让 position 指向未读数据的下一个）。</li>
<li><font color ="red"><strong>通道的方向和 Buffer 的方向是相反的，读取数据相当于向 Buffer 写入，写出数据相当于从 Buffer 读取。</strong></font></li>
</ul>
<p><strong>使用步骤：</strong>向 Buffer 写入数据，调用 flip 方法将 Buffer 从写模式切换为读模式，从 Buffer 中读取数据，调用 clear 或 compact 方法来清空 Buffer。</p>
</li>
</ul>
<p><strong>适应场景：</strong>连接数目多、连接时间短、开发难度高。</p>
<hr>
<p><strong>AIO：</strong></p>
<p>异步非阻塞 IO，服务器实现模式为一个有效请求对应一个线程,客户端的 I/O 请求都是由操作系统先完成 IO 操作后再通知服务器应用来启动线程直接使用数据。</p>
<p><strong>异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情，非阻塞是指客户端有数据才会处理，处理好再通知服务器。</strong></p>
<p>AsynchronousServerSocketChannel 异步服务器端通道，通过静态方法 <code>open()</code> 获取实例，通过 accept 方法获取客户端连接通道。</p>
<p>AsynchronousSocketChannel 异步客户端通道，通过静态方法 <code>open()</code> 获取实例，过 connect 方法连接服务器通道。</p>
<p>AsynchronousChannelGroup 异步通道分组管理器，它可以实现资源共享。创建时需要传入一个ExecutorService，也就是绑定一个线程池，该线程池负责两个任务：处理 IO 事件和触发 CompletionHandler 回调接口。</p>
<p><strong>实现方式：</strong></p>
<p>通过 Future 的 get 方法进行阻塞式调用。</p>
<p>通过实现 CompletionHandler 接口，重写请求成功的回调方法 completed() 和 请求失败回调方法 failed()。</p>
<p><strong>适用场景：</strong>连接数目多、连接时间长、开发难度高。</p>
<hr>
<h3 id="P18：List"><a href="#P18：List" class="headerlink" title="P18：List"></a>P18：List</h3><p>List 是一种线性列表结构，元素是有序、可重复的。</p>
<p>*<em>ArrayList *</em></p>
<p>底层由数组实现，随机访问效率高，读快写慢，由于写操作涉及元素的移动，因此写操作效率低。</p>
<p>ArrayList 实现了 RandomAcess 标记接口，如果一个类实现了该接口，那么表示这个类使用索引遍历比迭代器更快。</p>
<p>三个重要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>elementData 是 ArrayList 的数据域，transient 表示它不会被序列化，不使用 elementData 直接序列化是因为这是一个缓存数组，出于性能考虑通常会预留一些容量，当容量不足时会扩充容量，因此可能会有大量空间没有存储元素，采用这样的方式可以保证只序列化实际有值的那些元素而不需要序列化整个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>size 表示当前 List 的实际大小，elementData 的大小是大于等于 size 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>该成员变量继承自 AbstractList，记录了ArrayList 结构性变化的次数。所有涉及结构变化的方法都会增加该值，包括add()、remove()、addAll()、removeRange() 及clear() 等。</p>
<p>在使用迭代器遍历 ArrayList 时不能修改元素，modCount 统计 ArrayList 修改次数，expectedModCount 则是在迭代器初始化时记录的modCount 值，每次访问新元素时都会检查 modCount 和 expectedModCount是否相等，如果不相等就会抛出异常。</p>
<p><strong>LinkedList</strong></p>
<p>底层由链表实现，与 ArrayList 相反，需要顺序访问元素，即使有索引也需要从头遍历，因此写快读慢。</p>
<p>LinkedList 实现了 Deque 接口，具有队列的属性，可在尾部增加元素，在头部获取元素，也能操作头尾之间任意元素。</p>
<p>所有成员变量都被 transient 修饰，序列化原理和ArrayList类似。</p>
<p><strong>Vector 和 Stack</strong></p>
<p>Vector 的实现和 ArrayList 基本一致，底层使用的也是数组，它和 ArrayList 的区别主要在于：（1）Vector 的所有公有方法都使用了 synchronized 修饰保证线程安全性。（2）增长策略不同，Vector 多了一个成员变量 capacityIncrement 用于标明扩容的增量。</p>
<p>Stack 是 Vector 的子类，实现和 Vector基本一致，与之相比多提供了一些方法表达栈的含义。</p>
<hr>
<h3 id="P19：HashSet"><a href="#P19：HashSet" class="headerlink" title="P19：HashSet"></a><strong>P19：HashSet</strong></h3><p>HashSet 中的元素是无序、不重复的，最多只能有一个 null 值。</p>
<p>HashSet 的底层是通过 HashMap 实现的，HashMap 的 key 值即 HashSet 存储的元素，所有 key 都使用相同的 value ，一个static final 修饰的变量名为 PRESENT 的 Object 类型的对象。</p>
<p>由于 HashSet 的底层是 HashMap 实现的，HashMap 是线程不安全的，因此 HashSet 也是线程不安全的。</p>
<p><strong>去重：</strong><br>对于基本类型的包装类，直接按值进行比较。对于引用数据类型，会先比较 hashCode() 返回值是否相同，如果不同则代表不是同一个对象，如果相同则继续比较equals()方法返回值是否相同，都相同说明是同一个对象。</p>
<hr>
<h3 id="P20：HashMap"><a href="#P20：HashMap" class="headerlink" title="P20：HashMap"></a><font color="red">P20：HashMap</font></h3><p><strong>JDK 8 之前</strong></p>
<p>底层实现是数组 + 链表，主要成员变量包括：存储数据的 table 数组、键值对数量 size、加载因子 loadFactor。</p>
<p>table 数组用于记录 HashMap 的所有数据，它的每一个下标都对应一条链表，所有哈希冲突的数据都会被存放到同一条链表中，Entry 是链表的节点元素，包含四个成员变量：键 key、值 value、指向下一个节点的指针 next 和 元素的散列值 hash。</p>
<p>在 HashMap 中数据都是以键值对的形式存在的，键对应的 hash 值将会作为其在数组里的下标，如果两个元素 key 的 hash 值一样，就会发送哈希冲突，被放到同一个下标中的链表上，为了使 HashMap 的查询效率尽可能高，应该使键的 hash 值尽可能分散。</p>
<p>HashMap 默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p>
<p><strong>1.put 方法：添加元素</strong></p>
<p>① 如果 key 为 null 值，直接存入 table[0]。② 如果 key 不为 null 值，先计算 key 对应的散列值。③ 调用 indexFor 方法根据 key 的散列值和数组的长度计算元素存放的下标 i。④ 遍历 table[i] 对应的链表，如果 key 已经存在，就更新其 value 值然后返回旧的 value 值。⑤ 如果 key 不存在，就将 modCount 的值加 1，使用 addEntry 方法增加一个节点，并返回 null 值。</p>
<p><strong>2.hash 方法：计算元素 key 对应的散列值</strong></p>
<p>① 处理 String 类型的数据时，直接调用对应方法来获取最终的hash值。② 处理其他类型数据时，提供一个相对于 HashMap 实例唯一不变的随机值 hashSeed 作为计算的初始量。③ 执行异或和无符号右移操作使 hash 值更加离散，减小哈希冲突的概率。</p>
<p><strong>3.indexFor 方法：计算元素下标</strong></p>
<p>直接将 hash 值和数组长度 - 1 进行与操作并返回，保证计算后的结果不会超过 table 数组的长度范围。</p>
<p><strong>4.resize 方法：根据newCapacity 来确定新的扩容阈值 threshold</strong></p>
<p>① 如果当前容量已经达到了最大容量，就将阈值设置为 Integer 的最大值，之后扩容就不会再触发。② 创建一个新的容量为 newCapacity 的 Entry 数组，并调用 transfer 方法将旧数组的元素转移到新数组.③ 将阈值设为（newCapacity 和加载因子 loadFactor 的积）和（最大容量 + 1 ）的较小值。</p>
<p><strong>5.transfer：转移旧数组到新数组</strong></p>
<p>① 遍历旧数组的所有元素，调用 rehash 方法判断是否需要哈希重构，如果需要就重新计算元素 key 的散列值。② 调用 indexFor 方法根据 key 的散列值和数组的长度计算元素存放的下标 i，利用头插法将旧数组的元素转移到新的数组。</p>
<p><strong>6.get 方法：根据 key 获取元素的 value 值</strong></p>
<p>① 如果 key 为 null 值，调用 getForNullKey 方法，如果 size 为 0 表示链表为空，返回 null 值。如果 size 不为 0，说明存在链表，遍历 table[0] 的链表，如果找到了 key 为 null 的节点则返回其 value 值，否则返回 null 值。② 调用 getEntry 方法，如果 size 为 0 表示链表为空，返回 null 值。如果 size 不为 0，首先计算 key 的散列值，然后遍历该链表的所有节点，如果节点的 key 值和 hash 值都和要查找的元素相同则返回其 Entry 节点。③ 如果找到了对应的 Entry 节点，使用 getValue 方法获取其 value 值并返回，否则返回 null 值。</p>
<hr>
<p>*<em>JDK 8 开始 *</em></p>
<p>使用的是数组 + 链表/红黑树的形式，table 数组的元素数据类型换成了 Entry 的静态实现类 Node。</p>
<p><strong>1.put 方法：添加元素</strong></p>
<p>① 调用 putVal 方法添加元素。② 如果 table 为空或没有元素时就进行扩容，否则计算元素下标位置，如果不存在就新创建一个节点存入。③ 如果首节点和待插入元素的 hash值和 key 值都一样，直接更新 value 值。④ 如果首节点是 TreeNode 类型，调用 putTreeVal 方法增加一个树节点，每一次都比较插入节点和当前节点的大小，待插入节点小就往左子树查找，否则往右子树查找，找到空位后执行两个方法：balanceInsert 方法，把节点插入红黑树并对红黑树进行调整使之平衡。moveRootToFront 方法，由于调整平衡后根节点可能变化，table 里记录的节点不再是根节点，需要重置根节点。⑤ 如果是链表节点，就遍历链表，根据 hash 值和 key 值判断是否重复，决定更新值还是新增节点。如果遍历到了链表末尾，添加链表元素，如果达到了建树阈值，还需要调用 treeifyBin 方法把链表重构为红黑树。⑥ 存放元素后，将 modCount 值加 1，如果节点数 + 1大于扩容阈值，还需要进行扩容。</p>
<p><strong>2.get 方法：根据 key 获取元素的 value 值</strong></p>
<p>① 调用 getNode 方法获取 Node 节点，如果不是 null 值就返回 Node 节点的 value 值，否则返回 null。② 如果数组不为空，先比较第一个节点和要查找元素的 hash 值和 key 值，如果都相同则直接返回。③ 如果第二个节点是 TreeNode 节点则调用 getTreeNode 方法进行查找，否则遍历链表根据 hash 值和 key 值进行查找，如果没有找到就返回 null。</p>
<p><strong>3.hash 方法：计算元素 key 对应的散列值</strong></p>
<p>Java 8 的计算过程简单了许多，如果 key 非空就将 key 的 hashCode() 返回值的高低16位进行异或操作，这主要是为了让尽可能多的位参与运算，让结果中的 0 和 1 分布得更加均匀，从而降低哈希冲突的概率。</p>
<p><strong>4.resize 方法：扩容数组</strong></p>
<p>重新规划长度和阈值，如果长度发生了变化，部分数据节点也要重新排列。</p>
<p><strong>重新规划长度</strong></p>
<p>① 如果 size 超出扩容阈值，把 table 容量增加为之前的2倍。② 如果新的 table 容量小于默认的初始化容量16，那么将 table 容量重置为16。③ 如果新的 table 容量大于等于最大容量，那么将阈值设为 Integer 的最大值，并且 return 终止扩容，由于 size 不可能超过该值因此之后不会再发生扩容。</p>
<p><strong>重新排列数据节点</strong></p>
<p>① 如果节点为 null 值则不进行处理。② 如果节点不为 null 值且没有next节点，那么重新计算其散列值然后存入新的 table 数组中。③ 如果节点为 TreeNode 节点，那么调用 split 方法进行处理，该方法用于对红黑树调整，如果太小会退化回链表。④ 如果节点是链表节点，需要将链表拆分为 hashCode() 返回值超出旧容量的链表和未超出容量的链表。对于<code>hash &amp; oldCap == 0</code> 的部分不需要做处理，反之需要放到新的下标位置上，新下标 = 旧下标 + 旧容量。</p>
<p><strong>线程不安全：</strong>Java 7 扩容时 resize 方法调用的 transfer 方法中使用头插法迁移元素，多线程会导致 Entry 链表形成环形数据结构，Entry 节点的 next 永远不为空，引起死循环。Java 8 在 resize 方法中完成扩容，并且改用了尾插法，不会产生死循环的问题，但是在多线程的情况下还是可能会导致数据覆盖的问题，因此依旧线程不安全。</p>
<hr>
<p><strong>红黑树：</strong>红黑树是一种自平衡的二叉查找树。</p>
<p><strong>特性：</strong>红黑树的每个节点只能是红色或者黑色、根节点是黑色的、每个叶子节点都是黑色的、如果一个叶子节点是红色的，它的子结点必须是黑色的、从一个节点到该节点的叶子节点的所有路径都包含相同数目的黑色节点。</p>
<p><strong>左旋：</strong>对节点进行左旋，相当于把节点的右节点作为其父节点，即将节点变成一个左节点。</p>
<p><strong>右旋：</strong>对节点进行右旋，相当于把节点的左节点作为其父节点，即将节点变成一个右节点。</p>
<p><strong>插入：</strong>① 被插入的节点是根节点，直接将其涂为黑色。② 被插入节点的父节点是黑色的，不做处理，节点插入后仍是红黑树。③ 被插入节点的父节点是红色的，一定存在非空祖父节点，根据叔叔节点的颜色分类处理。</p>
<p><strong>删除：</strong>① 被删除的节点没有子节点，直接将其删除。② 被删除节点只有一个子节点，直接删除该节点，并用其唯一子节点替换其位置。③ 被插入节点有两个子节点，先找出该节点的替换节点，然后把替换节点的数值复制给该节点，删除替换节点。</p>
<p><strong>调整平衡：</strong>在插入和删除节点后，通过左旋、右旋或变色使其重新成为红黑树。① 如果当前节点的子节点是一红一黑，直接将该节点设为黑色。② 如果当前节点的子结点都是黑色，且当前节点是根节点，则不做处理。③ 如果当前节点的子节点都是黑色且当前节点不是根节点，根据兄弟节点的颜色分类处理。</p>
<hr>
<h2 id="JVM-15"><a href="#JVM-15" class="headerlink" title="JVM 15"></a>JVM 15</h2><h3 id="P1：运行时数据区"><a href="#P1：运行时数据区" class="headerlink" title="P1：运行时数据区"></a><font color="red">P1：运行时数据区</font></h3><p><strong>程序计数器</strong></p>
<p>程序计数器是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。程序计数器是线程私有的，各条线程之间互不影响，独立存储。</p>
<p>如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是本地（Native）方法，计数器值则应为空（Undefined）。</p>
<p>此内存区域是唯一一个在《 Java 虚拟机规范》中没有规定任何内存溢出情况的区域。</p>
<p><strong>Java 虚拟机栈</strong></p>
<p>Java 虚拟机栈是线程私有的，每当有新的线程创建时就会给它分配一个栈空间，当线程结束后栈空间就被回收，因此栈与线程拥有相同的生命周期。栈主要用来实现方法的调用与执行，每个方法在执行的时候都会创建一个栈帧用来存储这个方法的局部变量、操作栈、动态链接和方法出口等信息。当一个方法被调用时，会压入一个新的栈帧到这个线程的栈中，当方法调用结束后会弹出这个栈帧，回收掉调用这个方法使用的栈空间。</p>
<p>该区域有两类异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。如果 JVM 栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常（HotSpot 不可以动态扩展，不存在此问题）。</p>
<p><strong>本地方法栈</strong></p>
<p>本地方法栈与虚拟机栈的作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法（字节码）服务，而本地方法栈是为虚拟机栈用到的本地（Native）方法服务。调用本地方法时虚拟机栈保持不变，动态链接并直接调用指定的本地方法。</p>
<p>《 Java 虚拟机规范》对本地方法栈中方法所用语言、使用方式与数据结构无强制规定，具体的虚拟机可根据需要自由实现，例如 HotSpot 直接将虚拟机栈和本地方法栈合二为一。</p>
<p>与虚拟机栈一样，本地方法栈也会在栈深度异常和栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<p><strong>Java 堆</strong></p>
<p>Java 堆是虚拟机所管理的内存中最大的一块。堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，Java 里几乎所有的对象实例都在这里分配内存。</p>
<p>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象（例如数组），多数虚拟机实现出于简单、存储高效的考虑会要求连续的内存空间。</p>
<p>Java 堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的 JVM 都是按照可扩展来实现的。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，虚拟机将抛出 OutOfMemoryError 异常。</p>
<p><strong>方法区</strong></p>
<p>方法区和 Java 堆一样是各个线程共享的内存区域，它用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>JDK 8 之前使用永久代来实现方法区，这种设计导致了 Java 应用容易遇到内存溢出问题，因为永久代有<code>-XX:MaxPermSize</code>的上限，即使不设置也有默认大小。JDK 6 时 HotSpot 的开发团队就准备放弃永久代，改用本地内存来实现方法区，JDK  7 时已经把原本放在永久代的字符串常量池、静态变量等移出，到了 JDK8 时永久代被完全废弃，改用在本地内存中实现的元空间来代替，把 JDK 7 中永久代剩余内容（主要是类型信息）全部移到元空间。</p>
<p>《 Java 虚拟机规范》对方法区的约束很宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾回收。垃圾回收行为在该区域出现较少，主要回收目标是针对常量池的回收和对类型的卸载，一般来说该区域的回收效果比较难令人满意，尤其是类型的卸载，条件十分苛刻。如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError 异常。</p>
<p><strong>运行时常量池</strong></p>
<p>运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。一般来说，除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的另一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是说并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被利用的较多的是String 类的 intern() 方法。</p>
<p>由于运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>
<p><strong>直接内存</strong></p>
<p>直接内存不是 JVM 运行时数据区的一部分，也不是《 Java 虚拟机规范》中定义的内存区域，但是这部分内存也被频繁使用，而且也可能导致内存溢出异常。</p>
<p>JDK 1.4 中新加入了 NIO 模型，引入了一种基于通道与缓冲区的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，避免了在 Java 堆和 Native堆中来回复制数据。</p>
<p>本机直接内存的分配不会收到 Java 堆大小的限制，但还是会受到本机总内存大小以及处理器寻址空间的限制，一般配置虚拟机参数时会根据实际内存去设置 <code>-Xmx</code> 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError 异常。</p>
<hr>
<h3 id="P2：对象创建的过程"><a href="#P2：对象创建的过程" class="headerlink" title="P2：对象创建的过程"></a>P2：对象创建的过程</h3><p>当 JVM 遇到一条字节码 new 指令时，首先将检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查这个引用代表的类是否已被加载、解析和初始化，如果没有就必须先执行类加载过程。</p>
<p>在类加载检查通过后虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，分配空间的任务实际上等于把一块确定大小的内存块从 Java 堆中划分出来。假设 Java 堆内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点指示器，分配内存就是把该指针向空闲方向挪动一段与对象大小相等的距离，这种方式叫”指针碰撞”。</p>
<p>如果 Java 堆中的内存不是规整的，那么虚拟机就必须维护一个列表记录哪些内存块是可用的，在分配时从列表中找到一块足够大的空间划分给对象实例并更新列表上的记录，这种方式叫做”空闲列表”。</p>
<p>选择哪种分配方式由堆是否规整决定，堆是否规整又由所用垃圾回收器是否带有空间压缩整理能力决定。因此使用 Serial、ParNew 等带压缩整理的收集器时，系统采用指针碰撞；当使用 CMS 这种基于清除算法的垃圾收集器时，理论上只能采用空间列表分配内存。</p>
<p><strong>分配内存的线程安全问题：</strong>对象创建在虚拟机中十分频繁，即使修改一个指针所指向的位置在并发情况下也不是线程安全的，可能出现正给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决该问题有两个方法：① 虚拟机采用 CAS 加失败重试的方式保证更新操作的原子性。② 把内存分配的动作按照线程划分在不同空间进行，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB 分配，只有 TLAB 用完了分配新缓冲区时才需要同步。</p>
<p>内存分配完成后虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，保证对象的实例字段在 Java 代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型对应的零值。之后虚拟机还要对对象进行必要设置，例如对象是哪个类的实例、如何找到类的元数据信息等。</p>
<p>至此从虚拟机的视角来看一个新的对象已经产生了，但从程序的角度来说对象创建才刚开始。此时构造方法，即 Class 文件中的 init 方法还没有执行，所有字段都为默认零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说 new 指令后会接着执行 init 方法，按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
<hr>
<h3 id="P3：对象的内存布局"><a href="#P3：对象的内存布局" class="headerlink" title="P3：对象的内存布局"></a><strong>P3：对象的内存布局</strong></h3><p>在 HotSpot 虚拟机中，对象在堆内存中的存储布局可分为三个部分。</p>
<p><strong>对象头</strong></p>
<p>对象头包括两类信息，第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID等，这部分数据叫做”Mark Word”。</p>
<p>对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，JVM 通过该指针来确定对象是哪个类的实例。并非所有虚拟机实现都必须在对象数据上保留类型指针，查找对象的元数据不一定要经过对象本身。此外如果对象是一个 Java 数组，在对象头还必须有一块用于记录数组长度的数据。</p>
<p><strong>实例数据</strong></p>
<p>实例数据部分是对象真正存储的有效信息，即程序员在代码里所定义的各种类型的字段内容。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。</p>
<p><strong>对齐填充</strong></p>
<p>这部分不是必然存在的，仅仅起占位符的作用。由于 HotSpot 虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，而对象头已经被设为正好是 8 字节的整数倍，因此如果对象实例数据部分没有对齐，就需要对齐填充来补全。</p>
<hr>
<h3 id="P4：对象的访问定位"><a href="#P4：对象的访问定位" class="headerlink" title="P4：对象的访问定位"></a>P4：对象的访问定位</h3><p>Java 程序会通过栈上的 reference 数据来操作堆上的具体对象，而具体对象访问方式是由虚拟机决定的，主流的访问方式主要有使用句柄和直接指针两种。</p>
<p><strong>使用句柄</strong></p>
<p>如果使用句柄访问，Java 堆中将可能会划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p>
<p>优点是 reference 中存储的是稳定句柄地址，在对象被移动（处于垃圾收集过程中）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。</p>
<p><strong>直接指针</strong></p>
<p>如果使用直接指针访问的话，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话就不需要多一次间接访问的开销。</p>
<p>优点就是速度更快，节省了一次指针定位的时间开销，HotSpot 主要使用的就是直接指针来进行对象访问。</p>
<hr>
<h3 id="P5：内存溢出异常"><a href="#P5：内存溢出异常" class="headerlink" title="P5：内存溢出异常"></a>P5：内存溢出异常</h3><p><strong>Java 堆溢出</strong></p>
<p>Java 堆用于存储对象实例，我们只要不断创建对象，并且保证GC Roots到对象有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆容量的限制后就会产生OOM异常。例如在 while 死循环中一直 new 创建实例。</p>
<p>Java 堆内存的 OOM 是实际应用中最常见的 OOM 情况，常规的处理方法是先通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，确认内存中导致 OOM 的对象是否是必要的，即分清楚到底是出现了内存泄漏还是内存溢出。</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链，找到泄露对象是通过怎样的引用路径、与哪些GC Roots相关联才导致垃圾收集器无法回收它们，一般可以准确定位到对象创建的位置进而找出产生内存泄漏代码的具体位置。</p>
<p>如果不是内存泄漏，即内存中的对象确实都是必须存活的那就应当检查 JVM 的堆参数设置，与机器的内存相比是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</p>
<p><strong>虚拟机栈和本地方法栈溢出</strong></p>
<p>由于HotSpot虚拟机不区分虚拟机和本地方法栈，因此设置本地方法栈大小的参数没有意义，栈容量只能由 <code>-Xss</code> 参数来设定，存在两种异常：</p>
<ul>
<li><p><strong>StackOverflowError：</strong>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。例如一个递归方法不断调用自己。</p>
<p>该异常有明确错误堆栈可供分析，容易定位到问题所在。</p>
</li>
</ul>
<ul>
<li><strong>OutOfMemoryError：</strong>如果 JVM 栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。HotSpot 虚拟机不支持虚拟机栈的扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OOM异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。</li>
</ul>
<p><strong>运行时常量池溢出</strong></p>
<p>String类的intern方法是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象的引用，否则会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p>
<p>在 JDK6及之前常量池都分配在永久代，因此可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 限制永久代的大小，间接限制常量池的容量。在 while 死循环中不断调用intern方法，之后将导致运行时常量池溢出。</p>
<p>在 JDK7 及之后版本不会导致该问题，因为存放在永久代的字符串常量池已经被移至 Java 堆中。</p>
<p><strong>方法区溢出</strong></p>
<p>方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。只要不断在运行时产生大量的类去填满方法区，就会导致溢出。例如使用 JDK 的反射或 CGLib 直接操作字节码在运行时生成大量的类会导致溢出。当前的很多主流框架如Spring、Hibernate等对类增强是都会使用CGLib这类字节码技术，增强的类越多，就需要越大的方法区保证动态生成的新类型可以载入内存，也就更容易导致方法区溢出。</p>
<p>JDK 8 之后永久代完全被废弃，取而代之的是元空间，HotSpot 提供了一些参数作为元空间的防御措施：</p>
<p><code>-XX:MaxMetaspaceSize</code>：设置元空间的最大值，默认 -1，表示不限制即只受限于本地内存大小。</p>
<p><code>-XX:MetaspaceSize</code>：指定元空间的初始大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量空间就适当降低该值，如果释放了很少的空间就适当提高该值。</p>
<p><code>-XX:MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有<code>-XX:MinMetaspaceFreeRatio</code>，用于控制最大的元空间剩余容量百分比。</p>
<p><strong>本机直接内存溢出</strong></p>
<p>直接内存的容量大小可通过 <code>-XX:MaxDirectMemorySize</code> 指定，如果不去指定则默认与 Java 堆的最大值一致。</p>
<p>由直接内存导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见有什么明显的异常情况，如果发现内存溢出后产生的Dump 文件很小，而程序中又直接或间接使用了直接内存（典型的间接使用就是 NIO），那么就可以考虑检查直接内存方面的原因。</p>
<hr>
<h3 id="P6：判断对象是否是垃圾"><a href="#P6：判断对象是否是垃圾" class="headerlink" title="P6：判断对象是否是垃圾"></a>P6：判断对象是否是垃圾</h3><p>在堆中存放着所有对象实例，垃圾收集器在对堆进行回收前，首先要判断对象是否还存活着。</p>
<p><strong>引用计数算法</strong></p>
<p>在对象中添加一个引用计数器，如果有一个地方引用它计数器就加1，引用失效时计数器就减1，如果计数器为0则该对象就是不再被使用的。该算法原理简单，效率也高，但是在 Java中很少使用，因为它存在对象之间互相循环引用的问题，导致计数器无法清零。</p>
<p><strong>可达性分析算法</strong></p>
<p>当前主流语言的内存管理子系统都是使用可达性分析算法来判断对象是否存活的。这个算法的基本思路就是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到GC Roots之间没有任何引用链相连，则此对象是不可能再被使用的。</p>
<p>可作为GC Roots的对象：</p>
<ul>
<li>在虚拟机栈中引用的对象，如线程被调用的方法堆栈中的参数、局部变量等。</li>
<li>在方法区中类静态属性引用的对象，如类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，如字符串常量池中的引用。</li>
<li>在本地方法栈中 JNI 即 Native 方法引用的对象。</li>
<li>JVM 内部的引用，如基本数据类型对应的 Class 对象，一些常驻异常对象，系统类加载器等。</li>
<li>所有被 synchronized 同步锁持有的对象。</li>
</ul>
<hr>
<h3 id="P7：引用类型"><a href="#P7：引用类型" class="headerlink" title="P7：引用类型"></a>P7：引用类型</h3><p>无论通过引用计数还是可达性分析判断对象是否存活，都和引用离不开关系。在 JDK1.2 之前引用的定义是：如果 reference 类型数据存储的数值代表另外一块内存的起始地址，那么就称该 reference 数据是代表某块内存、某个对象的引用。在 JDK 1.2之后 Java 对引用的概念进行了扩充，按强度分为四种：</p>
<p><strong>强引用</strong>：最传统的引用定义，指代码中普遍存在的引用赋值。任何情况下只要强引用存在，垃圾收集器就永远不会回收被引用的对象。</p>
<p><strong>软引用</strong>：描述一些还有用但非必需的对象。只被软引用关联的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围中进行二次回收，如果这次回收还没有足够的内存才会抛出 OOM 异常。</p>
<p><strong>弱引用</strong>：描述非必需对象，引用强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器开始工作时无论当前内存是否足够都会回收只被弱引用关联的对象。</p>
<p><strong>虚引用</strong>：也称幽灵引用或幻影引用，是最弱的引用关系。一个对象是否有虚引用存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象实例。该引用的唯一目的就是为了能在这个对象被垃圾收集器回收时收到一个系统通知。</p>
<hr>
<h3 id="P8：GC-算法"><a href="#P8：GC-算法" class="headerlink" title="P8：GC 算法"></a><font color="red">P8：GC 算法</font></h3><p><strong>标记-清除算法</strong></p>
<ul>
<li><p><strong>原理：</strong>分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象，或者标记存活的对象并统一回收所有未被标记的对象。标记过程就是判断对象是否属于垃圾的过程。</p>
</li>
<li><p><strong>特点：</strong>① 执行效率不稳定，如果堆中包含大量对象且其中大部分是需要被回收的，这时必须进行大量标记和清除，导致效率随对象数量增长而降低。② 内存空间碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时无法找出足够的连续内存而不得不提前触发另一次垃圾收集。</p>
</li>
</ul>
<p><strong>标记-复制算法</strong></p>
<ul>
<li><p><strong>原理：</strong>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的空间用完了，就将还存活着的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。</p>
</li>
<li><p><strong>特点：</strong>① 实现简单、运行高效，解决了内存碎片问题。② 代价是将可用内存缩小为原来的一半，浪费了过多空间。</p>
</li>
<li><p><strong>HotSpot 的新生代划分：</strong></p>
<p>把新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时将 Eden 和 Survivor 中仍然存活的对象一次性复制到另一块 Survivor 上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，即每次新生代中可用空间为整个新生代的90%。</p>
</li>
</ul>
<p><strong>标记-整理算法</strong></p>
<ul>
<li><strong>原理：</strong>标记-复制算法在对象存活率较高时要进行较多的复制操作，效率将会降低。并且如果不想浪费空间，就需要有额外空间进行分配担保，应对被使用内存中所有对象都100%存活的极端情况，所以老年代一般不使用此算法。老年代使用标记-整理算法，标记过程与标记-清除算法一样，只是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</li>
<li><strong>特点：</strong>标记-清除与标记-整理的本质差异在于前者是一种非移动式回收算法而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险策略：① 如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，是一种极为负重的操作，而且这种移动必须全程暂停用户线程才能进行。② 如果不移动对象就会导致空间碎片问题，只能依赖更复杂的内存分配器和内存访问器来解决。所以是否移动对象都存在弊端，移动则内存回收时更复杂，不移动则内存分配时更复杂。</li>
</ul>
<hr>
<h3 id="P9：垃圾收集器"><a href="#P9：垃圾收集器" class="headerlink" title="P9：垃圾收集器"></a>P9：垃圾收集器</h3><p><strong>经典垃圾收集器：</strong>指 JDK 11之前的全部可用垃圾收集器。</p>
<p><strong>Serial</strong></p>
<p>最基础、历史最悠久的收集器，该收集器是一个使用复制算法的单线程工作收集器，单线程的意义不仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调它进行垃圾收集时必须暂停其他所有工作线程直到收集结束。</p>
<p>Serial 是虚拟机运行在客户端模式下的默认新生代收集器，优点是简单高效，对于内存受限的环境它是所有收集器中最小的；对于单核处理器或处理器核心较少的环境来说，Serial 收集器由于没有线程交互开销，因此可获得最高的单线程收集效率。</p>
<p><strong>ParNew</strong></p>
<p>实质上是 Serial 的多线程版本，除了使用多线程进行垃圾收集外其余行为完全一致。</p>
<p>ParNew 是虚拟机运行在服务端模式下的默认新生代收集器，一个重要原因是除了 Serial 外只有它能与 CMS 配合。自从 JDK 9 开始，ParNew 加 CMS 收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了，官方希望他能被 G1 完全取代。</p>
<p><strong>Parallel Scavenge</strong></p>
<p>新生代收集器，基于标记-复制算法，是可以并行的多线程收集器，与 ParNew 类似。</p>
<p>特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能缩短收集时用户线程的停顿时间，而 Parallel Scavenge 的目标是达到一个可控制的吞吐量，吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值。自适应调节策略也是它区别于 ParNew 的一个重要特性。</p>
<p><strong>Serial Old</strong></p>
<p>Serial 的老年代版本，同样是一个单线程收集器，使用标记-整理算法。</p>
<p>Serial Old 是虚拟机在客户端模式下的默认老年代收集器，用于服务端有两种用途：一种是 JDK 5 及之前与 Parallel Scavenge 搭配使用，另一种是作为CMS 发生失败时的预案。</p>
<p><strong>Parellel Old</strong></p>
<p>Parallel Scavenge 的老年代版本，支持多线程收集，基于标记-整理算法实现。这个收集器直到 JDK 6 才开始提供，在注重吞吐量优先的场景可以有效考虑Parallel Scavenge 加 Parallel Old 组合。</p>
<p><strong>CMS</strong></p>
<p>以获取最短回收停顿时间为目标的收集器，如果希望系统停顿时间尽可能短以给用户带来更好的体验就可以使用 CMS。</p>
<p>基于标记-清除算法，过程相对复杂，分为四个步骤：初始标记、并发标记、重新标记、并发清除。</p>
<p>其中初始标记和重新标记仍然需要 STW（Stop The World，表示系统停顿），初始标记仅是标记 GC Roots 能直接关联到的对象，速度很快。并发标记就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程并发运行。重新标记则是为了修正并发标记期间因用户程序运作而导致标记产生变动的那一部分对象的标记记录，该阶段停顿时间比初始标记稍长，但远比并发标记短。最后是并发清除，清理标记阶段判断的已死亡对象，由于不需要移动存活对象，因此该阶段也可以与用户线程并发。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器都可以和用户线程一起工作，所以从总体上说CMS 的内存回收过程是与用户线程并发执行的。</p>
<p>CMS 是 HotSpot 追求低停顿的第一次成功尝试，但还存在三个明显缺点：① 对处理器资源非常敏感，在并发阶段虽然不会导致用户线程暂停，但会降低总吞吐量。② 无法处理浮动垃圾，有可能出现并发失败而导致另一次 FullGC。③ 由于基于标记-清除算法，因此会产生大量空间碎片，给大对象分配带来麻烦。</p>
<p><strong>G1</strong></p>
<p>开创了收集器面向局部收集的设计思路和基于Region的内存布局，是一款主要面向服务端的收集器，最初设计目标是替换CMS。</p>
<p>G1 之前的收集器，垃圾收集的目标要么是整个新生代，要么是整个老年代或整个堆。而 G1 可以面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收受益最大，这就是 G1 的 MixedGC 模式。</p>
<p>不再坚持固定大小及数量的分代区域划分，而是把 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要扮演新生代的 Eden 空间、Survivor 空间或老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p>
<p>跟踪各个 Region 里面的垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的经验值，在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的 Region。这种回收方式保证了 G1 在有限的时间内获取尽可能高的收集效率。</p>
<p>G1的运作过程：</p>
<ul>
<li><strong>初始标记：</strong>标记 GC Roots 能直接关联到的对象并修改 TAMS 指针的值，让下一阶段用户线程并发运行时能正确地在可用 Region 中分配新对象。该阶段需要 STW 但耗时很短，是借用进行 MinorGC 时同步完成的。</li>
<li><strong>并发标记：</strong>从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图，找出需要回收的对象。该阶段耗时长，但可与用户线程并发执行，当对扫描完成后还要重新处理 SATB 记录的在并发时有引用变动的对象。</li>
<li><strong>最终标记：</strong>对用户线程做一个短暂暂停，用于处理并发阶段结束后仍遗留下来的少量 SATB 记录。</li>
<li><strong>筛选回收：</strong>对各个 Region 的回收价值和成本排序，根据用户期望的停顿时间指定回收计划，可自由选择任意多个 Region 构成回收集然后把决定回收的那一部分的存活对象复制到空的 Region 中，再清理掉整个旧的 Region 的全部空间。该操作必须暂停用户线程，由多条收集器线程并行完成。</li>
</ul>
<p>可以由用户指定期望的停顿时间是 G1 的一个强大功能，但该值不能设得太低，一般设置为100~300毫秒比较合适。G1不会存在内存空间碎片的问题，但 G1 为了垃圾收集产生的内存占用和程序运行时的额外执行负载都高于CMS。</p>
<hr>
<p><strong>低延迟垃圾收集器：</strong>指 Shenandoah 和 ZGC，这两个收集器几乎整个工作过程全都是并发的，只有初始标记、最终标记这些阶段有短暂停顿，停顿的时间基本上是固定的。</p>
<p><strong>Shenandoah</strong></p>
<p>相比 G1 内存布局同样基于 Region，默认回收策略也是优先处理回收价值最大的 Region。但在管理堆内存方面，与 G1 有不同：① 支持并发整理，G1 的回收阶段不能与用户线程并发。②默认不使用分代收集，不会有专门的新生代 Region 或老年代 Region。③ 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为连接矩阵的全局数据结构来记录跨 Region 的引用关系。</p>
<p><strong>ZGC</strong></p>
<p>JDK11中新加入的具有实验性质的低延迟垃圾收集器，和 Shenandoah 的目标高度相似，都希望在尽可能对吞吐量影响不大的前提下实现在任意堆大小下都可以把垃圾收集器的停顿时间限制在 10ms 以内的低延迟。</p>
<p>基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理，以低延迟为首要目标。内存布局也采用基于 Region 的堆内存布局，但不同的是 ZGC 的 Region 具有动态性，是动态创建和销毁的，并且区容量大小也是动态变化的。</p>
<hr>
<h3 id="P10：内存分配与回收策略"><a href="#P10：内存分配与回收策略" class="headerlink" title="P10：内存分配与回收策略"></a>P10：内存分配与回收策略</h3><p>以 Seial + Serial Old 客户端默认收集器组合为例：</p>
<p><strong>对象优先在 Eden 区分配</strong></p>
<p>大多数情况下对象在新生代 Eden 区分配，当 Eden 区没有足够空间进行分配时虚拟机将发起一次 MinorGC。</p>
<p>可通过 <code>-XX:Xms</code> 和 <code>-XX:Xmx</code> 设置堆大小， <code>-Xmn</code> 设置新生代的大小， <code>-XX:SurvivorRatio</code> 设置新生代中 Eden 和 Survivor的比例。</p>
<p><strong>大对象直接进入老年代</strong></p>
<p>大对象是指需要大量连续内存空间的对象，最典型的是很长的字符串或者元素数量很庞大的数组。大对象容易导致内存明明还有不少空间时就提前触发垃圾收集以获得足够的连续空间才能安置它们，当复制对象时大对象就意味着高额内存复制开销。</p>
<p>HotSpot 提供了 <code>-XX:PretenureSizeThreshold</code> 参数，大于该值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间来回复制产生大量内存复制操作。</p>
<p><strong>长期存活对象进入老年代</strong></p>
<p>虚拟机给每一个对象定义了一个对象年龄计数器，存储在对象头。对象通常在 Eden 诞生，如果经历过第一次 MinorGC 仍然存活并且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1。对象在 Survivor 中每熬过一次 MinorGC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。对象晋升老年代的年龄阈值可通过 <code>-XX:MaxTenuringThreshold</code> 设置。</p>
<p><strong>动态对象年龄判定</strong></p>
<p>为了适应不同程序的内存状况，虚拟机并不永远要求对象年龄达到阈值才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代，无需等到 <code>-XX:MaxTenuringThreshold</code> 参数设置的年龄。</p>
<p><strong>空间分配担保</strong></p>
<p>发生 MinorGC 前，虚拟机必须先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 MinorGC可以确定是安全的。</p>
<p>如果不成立，虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的值是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将冒险尝试一次 MinorGC，如果不满足或不允许担保失败就会改成一次 FullGC。</p>
<p>之所以说冒险是因为新生代使用复制算法，为了内存利用率只使用其中一个 Survivor 作为备份，因此当出现大量对象在 MinorGC 后仍然存活的情况时需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。</p>
<hr>
<h3 id="P11：故障处理工具"><a href="#P11：故障处理工具" class="headerlink" title="P11：故障处理工具"></a>P11：故障处理工具</h3><p><strong>jps：虚拟机进程状况工具</strong></p>
<p>jps 即 JVM Process Status，参考了 UNIX 命令的命名格式，功能和 ps 命令类似：可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（LVMID)。LVMID 与操作系统的进程 ID（PID）是一致的，使用 Windows 的任务管理器或 UNIX 的 ps 命令也可以查询到虚拟机进程的 LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位就必须依赖 jps 命令。</p>
<p>jps 还可以通过 RMI 协议查询开启了 RMI 服务的远程虚拟机进程状态，参数 hostid 为 RMI 注册表中注册的主机名。</p>
<p><strong>jstat：虚拟机统计信息监视工具</strong></p>
<p>jstat 即 JVM Statistic Monitoring Tool，是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译器等运行时数据，在没有 GUI 界面的服务器上是运行期定位虚拟机性能问题的常用工具。</p>
<p>一些参数的含义：S0 和 S1 表示两个 Survivor 区，E 表示新生代，O 表示老年代，YGC 表示 Young GC 次数，YGCT 表示Young GC 耗时，FGC 表示 Full GC 次数，FGCT 表示 Full GC 耗时，GCT 表示所有 GC 总耗时。</p>
<p><strong>jinfo：Java 配置信息工具</strong></p>
<p>jinfo 表示 Configuration Info for Java，作用是实时查看和调整虚拟机各项参数，使用 jps 的 -v 参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值就只能使用 jinfo 的 -flag 选项进行查询。jinfo 还可以把虚拟机进程的 System.getProperties() 的内容打印出来。</p>
<p><strong>jmap：Java 内存映像工具</strong></p>
<p>jmap 表示 Memory Map for Java，jamp 命令用于生成堆转储快照，还可以查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率，当前使用的是哪种收集器等。和 jinfo 命令一样，有部分功能在 Windows 平台下受限，除了生成堆转储快照的 -dump 选项和用于查看每个类实例的 -histo 选项外，其余选项都只能在 Linux 使用。</p>
<p><strong>jhat：虚拟机堆转储快照分析工具</strong></p>
<p>jhat 表示 JVM Heap Analysis Tool，JDK 提供 jhat 命令与 jmap 搭配使用来分析 jamp 生成的堆转储快照。jhat 内置了一个微型的 HTTP/Web 服务器，生成堆转储快照的分析结果后可以在浏览器中查看。</p>
<p><strong>jstack：Java 堆栈跟踪工具</strong></p>
<p>jstack 表示 Stack Trace for Java，jstack 命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。线程出现停顿时通过 jstack 查看各个线程的调用堆栈，就可以获知没有响应的现场到底在后台做什么或等待什么资源。</p>
<p>除了上述的基础故障处理工具，还有一些可视化故障处理工具，例如 JHSDB 基于服务性代理的调试工具、JConsole Java 监视与管理控制台、VisualVM 多合一故障处理工具、Java Mission Control 可持续在线监控工具。</p>
<hr>
<h3 id="P12：类加载机制和初始化时机"><a href="#P12：类加载机制和初始化时机" class="headerlink" title="P12：类加载机制和初始化时机"></a><font color="red">P12：类加载机制和初始化时机</font></h3><p>在 Class 文件中描述的各类信息最终都需要加载到虚拟机后才能运行和使用。JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java类型，这个过程被称为虚拟机的类加载机制。与其他在编译时需要连接的语言不同，Java 中类型的加载、连接和初始化都是在程序运行期间完成的，这种策略让 Java 进行类加载时增加了性能开销，但却为 Java 应用提供了极高的扩展性和灵活性，Java 可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<p>一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分统称为连接。加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的动态绑定特性。</p>
<p>关于何时需要开始类加载的第一个阶段”加载”，《 Java 虚拟机规范》没有强制约束，但对于初始化严格规定了有且只有6种情况：</p>
<ul>
<li><p>遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有初始化则需要先触发初始化。典型场景有：① 使用new关键字实例化对象。② 读取或设置一个类型的静态字段。③ 调用一个类型的静态方法。</p>
</li>
<li><p>对类型进行反射调用时，如果类型没有初始化则需要先触发初始化。</p>
</li>
<li><p>当初始化类时，如果其父类没有初始化则需要先触发父类的初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类即包含 main 方法的类，虚拟机会先初始化该类。</p>
</li>
<li><p>当使用 JDK 7 新加入的动态语言支持时，如果 MethodHandle 实例的解析结果为指定类型的方法句柄且这个句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
</li>
<li><p>当一个接口定义了默认方法时，如果该接口的实现类发生初始化，那接口要在其之前初始化。</p>
</li>
</ul>
<p>除了这六种情况外其余所有引用类型的方式都不会触发初始化，称为被动引用。被动引用的实例：① 子类使用父类的静态字段时，只有直接定义这个字段的父类会被初始化。② 通过数组定义使用类。③ 常量在编译期会存入调用类的常量池，不会初始化定义常量的类。</p>
<p>接口的加载过程和类真正有所区别的是当初始化类时，如果其父类没有初始化则需要先触发其父类的初始化，但在一个接口初始化时并不要求其父接口全部完成了初始化，只有在真正使用到父接口时（如引用接口中定义的常量）才会初始化。</p>
<hr>
<h3 id="P13：类加载过程"><a href="#P13：类加载过程" class="headerlink" title="P13：类加载过程"></a><font color="red">P13：类加载过程</font></h3><p><strong>加载</strong></p>
<p>加载是类加载的第一个阶段，在该阶段虚拟机需要完成三件事：① 通过一个类的全限定类名来获取定义此类的二进制字节流。② 将这个字节流所代表的静态存储结构转化为方法区的运行时数据区结构。③ 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。</p>
<p>加载结束后，虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中了，方法区中的数据存储格式完全由虚拟机自定义实现。类型数据安置在方法区之后，会在 Java 堆中实例化一个 Class 对象，这个对象将作为程序员访问方法区中类型数据的外部接口。加载与连接的部分动作是交叉进行的，加载尚未完成时连接可能已经开始。</p>
<p><strong>验证</strong></p>
<p>验证是连接的第一步，目的是确保 Class 文件的字节流中包含的信息符合约束要求，保证这些信息不会危害虚拟机的安全。Java 语言本身是安全的，但如果虚拟机不检查输入的字节流，对其完全信任的话，很可能因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃。</p>
<p>验证主要包含了四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<p>验证对于虚拟机的类加载机制来说是一个非常重要但非必需的阶段，因为验证只有通过与否的区别，只要通过了验证其后就对程序运行期没有任何影响了。如果程序运行的全部代码都已被反复使用和验证过，在生产环境的就可以考虑关闭大部分类验证措施缩短类加载时间。</p>
<p><strong>准备</strong></p>
<p>准备是正式为类变量分配内存并设置零值的阶段，该阶段进行的内存分配仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。如果变量被final修饰，编译时 Javac 会为变量生成 ConstantValue 属性，那么在准备阶段虚拟机就会将该变量的值设为程序员指定的值。</p>
<p><strong>解析</strong></p>
<p>解析是将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li><strong>符号引用：</strong>符号引用以一组符号描述引用目标，可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。与虚拟机内存布局无关，引用目标并不一定是已经加载到虚拟机内存中的内容。</li>
<li><strong>直接引用：</strong>直接引用是可以直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。和虚拟机的内存布局直接相关，引用目标必须已在虚拟机的内存中存在。</li>
</ul>
<p>解析部分主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符合引用进行。</p>
<p><strong>初始化</strong></p>
<p>初始化是类加载过程的最后一步，直到该阶段，JVM 才真正开始执行类中编写的代码。</p>
<p>准备阶段时变量已经赋过一次系统零值，而在初始化阶段会根据程序员的编码去初始化类变量和其他资源。</p>
<p>初始化阶段就是执行类构造器 &lt;client&gt; 方法的过程，该方法是 Javac 编译器自动生成的。</p>
<hr>
<h3 id="P14：类加载器和双亲委派模型"><a href="#P14：类加载器和双亲委派模型" class="headerlink" title="P14：类加载器和双亲委派模型"></a><font color="red">P14：类加载器和双亲委派模型</font></h3><p>类加载阶段中”通过一个类的全限定名来获取描述该类的二进制字节流”的动作被设计为放到 JVM 外部实现，以便让应用程序自己决定如何获取所需的类，实现这个动作的代码就是类加载器。</p>
<p><strong>比较两个类是否相等：</strong>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。只有在两个类是由同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个 Class 文件，被同一个 JVM 加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>从 JVM 的角度看只存在两种不同的类加载器：一种是启动类加载器，由 C++ 语言实现，是虚拟机自身的一部分；另一种是其他所有类加载器，由 Java 语言实现，独立存在于虚拟机外部且全部继承自抽象类 <code>java.lang.ClassLoader</code>。</p>
<p>自 JDK1.2 起 Java 一直保持着三层类加载器、双亲委派的类加载结构。</p>
<ul>
<li><strong>启动类加载器</strong>：负载加载存放在 <code>JAVA_HOME/lib</code> 目录，或者指定路径中存放的能够被虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，如果用户需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</li>
<li><strong>扩展类加载器</strong>：负载加载 <code>JAVA_HOME/lib/ext</code> 目录，或者系统变量所指定的路径中的类库。这种扩展机制在 JDK 9 后被模块化所取代，由于扩展类加载器是由 Java 编写的，开发者可以直接在程序中使用扩展类加载器来加载 Class 文件。</li>
<li><strong>应用程序类加载器</strong>：也称系统类加载器，负载加载用户类路径上的所有类库，同样可以直接在代码中使用。如果应用程序中没有自定义类加载器，一般情况下该类加载器就是程序中默认的类加载器。</li>
</ul>
<p><strong>双亲委派模型</strong></p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承关系来实现的，而通常使用组合关系来复用父加载器的代码。</p>
<p>如果一个类加载器收到了类加载请求，它不会自己去尝试加载这个类，而首先将该请求委派给自己的父加载器完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成请求时，子加载器才会尝试自己完成加载。</p>
<p>好处是 Java 中的类跟随它的类加载器一起具备了一种带有优先级的层次关系，可以保证某个类在程序的各个类加载器环境中都是同一个类，对于保证程序的稳定运行极为重要。</p>
<hr>
<h3 id="P15：Java-程序运行的过程"><a href="#P15：Java-程序运行的过程" class="headerlink" title="P15：Java 程序运行的过程"></a>P15：Java 程序运行的过程</h3><p><strong>通过 Javac 编译器将 .java 代码转为 JVM 可以加载的 .class 字节码文件。</strong></p>
<p>Javac 编译器是由 Java 语言编写的程序，从 Javac 代码的总体结构看，编译过程可以分为 1 个准备过程和 3 个处理过程：① 准备过程：初始化插入式注解处理器。② 解析与填充符号表过程：进行词法、语法分析，将源代码的字符流转为标记集合，构造出抽象语法树。填充符号表，产生符号地址和符号信息。③ 插入式注解处理器的注解处理过程。④ 分析与字节码生成过程，包括标注检查，对语法的静态信息进行检查；数据流及控制流分析，对程序动态运行过程进行检查；解语法糖，将简化代码编写的语法糖还原为原有的形式；字节码生成，将前面各个步骤的信息转换为字节码。</p>
<p>Javac 属于前端编译器，完成了从程序到抽象语法树或中间字节码的生成，在此之后还有一组内置于 JVM 内部的后端编译器，即即时编译器或提前编译器，来完成代码优化以及从字节码生成本地机器码的过程。 </p>
<p><strong>通过即时编译器 JIT 把字节码文件编译成本地机器码。</strong></p>
<p>Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为”热点代码”，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，在运行时虚拟机会把这些代码编译成本地机器码，并尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。</p>
<p>客户端编译器的执行过程：① 平台独立的前端将字节码构造成一种高级中间代码表示 HIR。② 平台相关的后端从 HIR 中产生低级中间代码表示 LIR。③ 在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。</p>
<p>服务端编译器专门面向服务端的典型应用场景，并为服务器的性能配置针对性调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器，它会执行大部分经典的优化动作，如无用代码消除、循环表达式外提、消除公共子表达式、基本块重排序等，还会实施一些与 Java 语言特性相关的优化，如范围检查消除、空值检查消除等，也可能根据解释器或客户端编译器提供的性能监控信息进行一些不稳定的预测性激进优化。</p>
<p><strong>还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。</strong></p>
<hr>
<h2 id="并发-20"><a href="#并发-20" class="headerlink" title="并发 20"></a>并发 20</h2><h3 id="P1：Java-内存模型"><a href="#P1：Java-内存模型" class="headerlink" title="P1：Java 内存模型"></a><font color="red">P1：Java 内存模型</font></h3><p>Java 线程的通信由 JMM 控制，JMM 的主要目的是定义程序中各种变量的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量包括实例字段、静态字段和构成数组元素的对象，但不包括局部变量与方法参数，因为它们是线程私有的，不存在多线程竞争问题。为了获得更好的执行效率，JMM 没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施，JMM 遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除该锁，某个 volatile 变量只会单线程访问就把它当作普通变量。</p>
<p>JMM 规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间中进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方工作内存中的变量，两个线程之间的通信必须经过主内存，JMM 通过控制主内存与每个线程的工作内存之间的交互来提供内存可见性保证。</p>
<p>关于主内存与工作内存之间的交互，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存等实现细节，JMM 定义了 8 种原子操作：</p>
<ul>
<li><strong>lock：</strong>作用于主内存变量，把变量标识为一条线程独占的状态。</li>
<li><strong>unlock：</strong>作用于主内存变量，把处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。</li>
<li><strong>read：</strong>作用于主内存变量，把变量值从主内存传到工作内存。</li>
<li><strong>load：</strong>作用于工作内存变量，把 read 从主存中得到的值放入工作内存的变量副本。</li>
<li><strong>use：</strong>作用于工作内存变量，把工作内存中的变量值传给执行引擎，每当虚拟机遇到需要使用变量值的字节码指令时执行该操作。</li>
<li><strong>assign：</strong>作用于工作内存变量，把从执行引擎接收的值赋给工作内存变量，每当虚拟机遇到给变量赋值的字节码指令时执行该操作。</li>
<li><strong>store：</strong>作用于工作内存变量，把工作内存中的变量值传送到主内存。</li>
<li><strong>write：</strong>作用于主内存变量，把 store 从工作内存取到的变量值放入主内存变量中。</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存，就要按顺序执行 read 和 load ，如果要把变量从工作内存同步回主内存，就要按顺序执行 store 和 write 。JMM 只要求这两种操作必须按顺序执行，但不要求连续，也就是说 read 和 load、store 和 write 之间可插入其他指令。这种定义十分严谨但过于复杂，之后 Java 将内存操作简化为 lock、unlock、read 和 write 四种，但这只是语言描述上的等价化简。</p>
<hr>
<h3 id="P2：as-if-serial-和-happens-before-规则"><a href="#P2：as-if-serial-和-happens-before-规则" class="headerlink" title="P2：as-if-serial 和 happens-before 规则"></a>P2：as-if-serial 和 happens-before 规则</h3><p><strong>as-if-serial</strong></p>
<p>as-if-serial 的语义是：不管怎么重排序，单线程程序的执行结果不能被改变，编译器和处理器必须遵循 as-if-serial 语义。</p>
<p>为了遵循 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作重排序，因为这种重排序会改变执行结果。但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p>as-if-serial 语义把单线程程序保护了起来，给了程序员一种幻觉：单线程程序是按程序的顺序执行的，使程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<p><strong>happens-before</strong></p>
<p>先行发生原则，是 JMM 中定义的两项操作之间的偏序关系，它是判断数据是否存在竞争，线程是否安全的重要手段。</p>
<p>JMM 将 happens-before 要求禁止的重排序按是否会改变程序执行结果分为两类。对于会改变结果的重排序 JMM 要求编译器和处理器必须禁止这种重排序，对于不会改变结果的重排序，JMM 对编译器和处理器不做要求。 </p>
<p>JMM 存在一些天然的 happens-before 关系，无需任何同步器协助就已经存在。如果两个操作的关系不在此列，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。</p>
<ul>
<li><strong>程序次序规则：</strong>在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>管程锁定规则：</strong>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li><strong>volatile 规则：</strong>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</li>
<li><strong>线程启动规则：</strong>线程对象的 start 方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则：</strong>线程中的所有操作都先行发生于对此线程的终止检测。</li>
<li><strong>线程中断规则：</strong>对线程 interrupt 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li><strong>对象终结规则：</strong>一个对象的初始化完成先行发生于它的 finalize 方法的开始。</li>
<li><strong>传递性：</strong>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C 。</li>
</ul>
<p><strong>区别</strong></p>
<p>as-if-serial 保证单线程程序的执行结果不被改变，happens-before 保证正确同步的多线程程序的执行结果不被改变。这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行的并行度。</p>
<hr>
<h3 id="P3：指令重排序"><a href="#P3：指令重排序" class="headerlink" title="P3：指令重排序"></a>P3：指令重排序</h3><p>重排序指从源代码到指令序列的重排序，在执行程序时为了提高性能，编译器和处理器通常会对指令进行重排序，分为三种：</p>
<ul>
<li><p>编译器优化的重排序：编译器在不改变单线程程序语义的前提下可以重排语句的执行顺序。</p>
</li>
<li><p>指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
</li>
<li><p>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作操作看上去可能是乱序执行。</p>
</li>
</ul>
<p>从 Java 源代码到最终实际执行的指令序列，会分别经历编译器优化重排序、指令级并行重排序和内存系统重排序，这些重排序可能会导致多线程程序出现内存可见性问题。</p>
<p>对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障指令，即一组用于实现对内存操作顺序限制的处理器指令，通过内存屏障指令来禁止特定类型的处理器重排序。JMM 属于语言级的内存模型，它确保在不同的编译器和处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<hr>
<h3 id="P4：原子性、可见性和有序性"><a href="#P4：原子性、可见性和有序性" class="headerlink" title="P4：原子性、可见性和有序性"></a>P4：原子性、可见性和有序性</h3><p><strong>原子性</strong></p>
<p>由 JMM 直接保证的原子性变量操作包括 read、load、assign、use、store 和 write，基本数据类型的访问都是具备原子性的，例外就是 long 和 double 的非原子性协定，允许虚拟机将没有被 volatile 修饰的 64 位数据的操作划分为两次 32 位的操作。</p>
<p>如果应用场景需要更大范围的原子性保证，JMM 还提供了 lock 和 unlock 操作满足这种需求，尽管 JVM 没有把这两种操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是 synchronized 关键字。</p>
<p><strong>可见性</strong></p>
<p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知修改。JMM 通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现可见性，无论是普通变量还是volatile变量都是如此，区别是 volatile 保证新值能立即同步到主内存以及每次使用前立即从主内存刷新，因此说 volatile 保证了多线程操作变量的可见性，而普通变量则不能保证。</p>
<p>除了 volatile 之外，还有两个关键字能实现可见性，分别是 synchronized 和 final，同步块的可见性是由”对一个变量执行unlock 前必须先把此变量同步回主内存中，即先执行 store 和 write”这条规则获得的。final 的可见性是指：被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把”this”引用传递出去，那么其他线程就能看到 final 字段的值。</p>
<p><strong>有序性</strong></p>
<p>有序性可以总结为：在本线程内观察所有操作是有序的，在一个线程内观察另一个线程，所有操作都是无序的。前半句是指”as-if-serial 语义”，后半句是指”指令重排序”和”工作内存与主内存同步延迟”现象。</p>
<p>Java 提供了 volatile 和 synchronized 保证线程间操作的有序性，volatile 本身就包含了禁止指令重排序的语义，而 synchronized 则是由”一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，该规则决定了持有同一个锁的两个同步块只能串行进入。</p>
<hr>
<h3 id="P5：volatile-关键字"><a href="#P5：volatile-关键字" class="headerlink" title="P5：volatile 关键字"></a><font color="red">P5：volatile 关键字</font></h3><p>JVM 提供的最轻量级的同步机制，JMM 为 volatile 定义了一些特殊的访问规则，当一个变量被定义为 volatile 后具备两种特性：</p>
<ul>
<li><p><strong>保证此变量对所有线程的可见性</strong></p>
<p>可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是立即可以得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</p>
<p>volatile 变量在各个线程的工作内存中不存在一致性问题，但 Java 的运算操作符并非原子操作，这导致 volatile 变量运算在并发下仍是不安全的。</p>
</li>
<li><p><strong>禁止指令重排序优化</strong></p>
<p>使用 volatile 变量进行写操作，汇编指令操作是带有 lock 前缀的，相当于一个内存屏障，后面的指令不能重排到内存屏障之前的位置。只有一个处理器时不需要使用内存屏障，但如果有两个或更多的处理器访问同一块内存，且其中有一个在观测另一个，就需要使用内存屏障来保证一致性了。</p>
<p>使用 lock 前缀的指令在多核处理器中会引发两件事：① 将当前处理器缓存行的数据写回到系统内存。② 这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效。</p>
<p>这种操作相当于对缓存中的变量做了一次 store 和 write 操作，可以让 volatile 变量的修改对其他处理器立即可见。</p>
</li>
</ul>
<hr>
<p><strong>静态变量 i 执行多线程 i++ 的不安全问题</strong></p>
<p>通过反编译会发现一个自增语句是由 4 条字节码指令构成的，依次为getstatic、iconst_1、iadd、putstatic，当getstatic把 i 的值取到操作栈顶时，volatile保证了 i 的值在此刻是正确的，但是在执行iconst_1、iadd这些指令时，其他线程可能已经改变了i的值，而操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 i 值同步回了主内存。 </p>
<p>即使编译出来只有一条字节码指令也不能意味着这条指令就是一个原子操作，一条字节码指令在解释执行时，解释器要运行很多行代码才能实现它的语义。如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令。</p>
<hr>
<p><strong>适用场景</strong></p>
<p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>
<p>变量不需要与其他状态变量共同参与不变约束。</p>
<hr>
<p><strong>volatile的内存语义</strong></p>
<p>从内存语义角度来说，volatile的写-读与锁的释放-获取具有相同的内存效果。</p>
<ul>
<li><p><strong>写内存语义：</strong>当写一个volatile变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
</li>
<li><p><strong>读内存语义：</strong>当读一个volatile变量时，JMM 会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p>
</li>
</ul>
<hr>
<p><strong>volatile指令重排序的特点</strong></p>
<p>当第二个操作是volatile 写时，不管第一个操作是什么都不能重排序，确保写之前的操作不会被编译器重排序到写之后。</p>
<p>当第一个操作是volatile 读时，不管第二个操作是什么都不能重排序，确保读之后的操作不会被编译器重排序到读之前。</p>
<p>当第一个操作是volatile 写，第二个操作是 volatile 读时不能重排序。</p>
<hr>
<p><strong>JSR-133 增强 volatile 语义的原因</strong></p>
<p>在旧的内存模型中，虽然不允许 volatile 变量之间重排序，但允许 volatile 变量与普通变量重排序，可能导致内存不可见问题。为了提供一种比锁更轻量级的线程通信机制，严格限制了编译器和处理器对 volatile 变量与普通变量的重排序，确保 volatile 的写-读和锁的释放-获取具有相同的内存语义。</p>
<hr>
<h3 id="P6：final-关键字"><a href="#P6：final-关键字" class="headerlink" title="P6：final 关键字"></a><font color="red">P6：final 关键字</font></h3><p>final 可以保证可见性，被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么在其他线程中就能看见 final 字段的值。</p>
<p><strong>JSR-133 增强 final语义的原因</strong></p>
<p>在旧的 JMM 中，一个严重的缺陷就是线程可能看到 final 域的值会改变。比如一个线程看到一个 int 类型 final 域的值为0，此时该值是还未初始化之前的零值，过一段时间之后该值被某线程初始化后这个线程再去读这个 final 域的值会发现值变为1。</p>
<p>为了修复该漏洞，JSR-133 通过为 final 域增加写和读重排序规则，提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造方法中没有逸出），那么不需要使用同步就可以保证任意线程都能看到这个final域在构造方法中被初始化之后的值。</p>
<p><strong>写 final 域重排序规则</strong></p>
<p>禁止把 final 域的写重排序到构造方法之外，编译器会在final域的写之后，构造方法的 return之前，插入一个Store Store屏障。该规则可以确保在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。</p>
<p>对于引用类型，增加了约束：在构造方法内对一个 final 引用的对象的成员域的写入，与随后在构造方法外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<p><strong>读 final 域重排序规则</strong></p>
<p>在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM 禁止处理器重排序这两个操作。编译器会在读final域操作的前面插入一个Load Load 屏障，该规则可以确保在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。</p>
<hr>
<h3 id="P7：synchronized-关键字"><a href="#P7：synchronized-关键字" class="headerlink" title="P7：synchronized 关键字"></a><font color="red">P7：synchronized 关键字</font></h3><p>最基本的互斥同步手段就是 synchronized 关键字，它是一种块结构的同步语法。synchronized 经过 Javac 编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 两个字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的Class对象；对于同步方法块，锁是 synchronized 括号里的对象。</p>
<p>根据《 Java 虚拟机规范》的要求，在执行 monitorenter 指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了那个对象的锁，那么就把锁的计数器的值增加 1，而在执行 monitorexit 指令时会将锁计数器的值减 1。一旦计数器的值为 0，锁随即就被释放了。如果获取锁对象失败，那当前线程就应该被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p>
<p>被 synchronized 修饰的同步块对一条线程来说是可重入的，并且同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。从执行成本的角度看，持有锁是一个重量级的操作。在主流 JVM 实现中，Java 的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统帮忙完成，这就不可避免陷入用户态到核心态的转换中，进行这些状态转换需要耗费很多的处理器时间。</p>
<p>每个 Java 对象都有一个关联的 monitor 监视器，当这个对象由同步块或同步方法调用时，执行方法的线程必须先获取到对象的监视器才能进入同步块或同步方法。例如有两个线程 A 和 B 竞争锁资源对应的 monitor，当线程 A 竞争到锁时，会将 monitor 中的 owner 设置为 A，把线程 B 阻塞并放到等待竞争资源的 ContentionList 队列。ContentionList 中的部分线程会进入 EntryList，EntryList 中的线程会被指定为 OnDeck 竞争候选者线程，如果获得了锁资源将进入 Owner 状态，释放锁资源后进入 !Owner 状态。被阻塞的线程会进入 WaitSet。</p>
<p><strong>不公平的原因</strong></p>
<p>所有收到锁请求的线程首先自旋，如果通过自旋也没有获取锁资源将被放入 ContentionList 队列，该做法对于已经进入队列的线程是不公平的。</p>
<p>为了防止 ContentionList 尾部的元素被大量线程进行 CAS 访问影响性能，Owner 线程会在释放锁时将 ContentionList 的部分线程移动到 EntryList 并指定某个线程为 OnDeck 线程，Owner 并没有将锁直接传递给 OnDeck 线程而是把锁竞争的权利交给它，该行为叫做竞争切换，牺牲了公平性但提高了性能。</p>
<hr>
<h3 id="P8：锁优化"><a href="#P8：锁优化" class="headerlink" title="P8：锁优化"></a><font color="red">P8：锁优化</font></h3><p>JDK 6 对 synchronized 做了很多优化，引入了适应自旋、锁消除、锁粗化、偏向锁和轻量级锁等提高锁的效率，锁一共有 4 个状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，这种只能升级不能降级的锁策略是为了提高获得锁和释放锁的效率。</p>
<p><strong>自旋锁与自适应自旋</strong></p>
<p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给 JVM 的并发性能带来了很大压力。同时虚拟机开发团队也注意到了在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂机和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多核心处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环，这项技术就是所谓的自旋锁。</p>
<p>自旋锁在 JDK 1.4中就已经引入，只不过默认是关闭的，在 JDK 6中就已经改为默认开启了。自旋等待不能代替阻塞，自旋等待本身虽然避免了线程切换的开销，但它要占用处理器时间，所以如果锁被占用的时间很短，自旋的效果就会非常好，反之只会白白消耗处理器资源。因此自旋的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认次数是 10 次。</p>
<p>在 JDK 6 中对自旋锁的优化，引入了自适应自旋。自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能之间省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长以及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准。</p>
<p><strong>锁消除</strong></p>
<p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上的数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p>
<p><strong>锁粗化</strong></p>
<p>原则上我们在编写代码时，总是推荐将同步块的作用范围限制得尽量小，只在共享数据得实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁得线程也能尽可能快拿到锁。</p>
<p>大多数情况下这种原则是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能消耗。</p>
<p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<p><strong>偏向锁</strong></p>
<p>它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都去掉，连 CAS 操作都不去做了。</p>
<p>偏向锁的意思就是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>当一个线程访问同步代码块并获取锁时，会在对象头和帧栈中的锁记录里存储锁偏向的线程 ID，以后该线程再进入和退出同步代码块不需要进行 CAS 操作来加锁和解锁，只需要简单地测试一下对象头的”Mark Word”里是否存储着指向当前线程的偏向锁。如果测试成功表示线程已经获得了锁，如果失败则需要再测试一下”Mark Word”中偏向锁的标识是否设置成了 1 即表示当前使用偏向锁，如果设置了就尝试使用 CAS 将对象头的偏向锁指向当前线程，否则使用 CAS 方式竞争锁。</p>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要等待全局安全点即此时没有正在执行的字节码，它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态则将对象头设为无锁状态。如果线程还活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的”Mark Word”要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<p><strong>轻量级锁</strong></p>
<p>轻量级是相对于操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为重量级锁。轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>在代码即将进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝。然后虚拟机将使用 CAS 操作尝试把对象的 Mark Word 更新为指向锁记录的指针，如果这个更新操作成功了，即代表该线程拥有了这个对象的锁，并且锁标志位将转变为”00”，表示此对象处于轻量级锁定状态。</p>
<p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是则说明当前线程以及拥有了这个对象的锁，直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态变为”10”，此时Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也必须进入阻塞状态。</p>
<p>解锁操作也同样是通过 CAS 操作来进行，如果对象的 Mark Word 仍然指向线程的锁记录，那就用 CAS 操作把对象当前的 Mark Word 和线程复制的 Mark Word 替换回来。假如能够替换成功，那整个同步过程就顺利完成了，如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时唤醒被挂起的线程。</p>
<p><strong>偏向锁、轻量级锁和重量级锁的区别</strong></p>
<p>偏向锁的优点是加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距，缺点是如果线程间存在锁竞争会带来额外锁撤销的消耗，适用于只有一个线程访问同步代码块的场景。</p>
<p>轻量级锁的优点是竞争的线程不会阻塞，提高了程序的响应速度，缺点是如果线程始终得不到锁会自旋消耗CPU，适用于追求响应时间和同步代码块执行非常快的场景。</p>
<p>重量级锁的优点是线程竞争不使用自旋不会消耗CPU，缺点是线程会被阻塞，响应时间很慢，适应于追求吞吐量、同步代码块执行较慢的场景。</p>
<hr>
<h3 id="P9：Lock-接口"><a href="#P9：Lock-接口" class="headerlink" title="P9：Lock 接口"></a>P9：Lock 接口</h3><p>自 JDK 5 起 Java类库提供了 juc 并发包，其中的 Lock 接口成为了一种全新的互斥同步手段。基于Lock 接口，用户能够以非块结构来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步。</p>
<p>重入锁 ReentrantLock 是 Lock 接口最常见的一种实现，它与 synchronized 一样是可重入的，在基本用法上也很相似，不过它增加了一些高级功能，主要包括以下三项：</p>
<ul>
<li><strong>等待可中断：</strong>是指持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待而处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li><strong>公平锁：</strong>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带有布尔值的构造器要求使用公平锁。不过一旦使用了公平锁，将会导致性能急剧下降，明显影响吞吐量。</li>
<li><strong>锁绑定多个条件：</strong>是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。在 synchronized中，锁对象的 wait 跟它的notify/notifyAll 方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联时就不得不额外添加一个锁，而 ReentrantLock 可以多次调用 newCondition 方法。</li>
</ul>
<p>一般优先考虑使用synchronized：① synchronized 是 Java 语法层面的同步，足够清晰和简单。② Lock 应该确保在 finally 中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用 synchronized 可以由 JVM 来确保即使出现异常锁也能被正常释放。③ 尽管在 JDK 5 时ReentrantLock 的性能领先于 synchronized，但在 JDK 6 进行锁优化之后，二者的性能基本能够持平。从长远来看 JVM 更容易针对synchronized进行优化，因为 JVM 可以在线程和对象的元数据中记录 synchronized 中锁的相关信息，而使用Lock的话 JVM 很难得知具体哪些锁对象是由特定线程持有的。</p>
<p><strong>ReentrantLock 的可重入实现</strong></p>
<p>以非公平锁为例，通过 nonfairTryAcquire 方法获取锁，该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求则将同步状态值进行增加并返回 true，表示获取同步状态成功。</p>
<p>成功获取锁的线程再次获取锁，只是增加了同步状态值，这就要求 ReentrantLock 在释放同步状态时减少同步状态值。如果该锁被获取了 n 次，那么前 n-1 次 tryRelease 方法必须都返回fasle，只有同步状态完全释放了才能返回 true，该方法将同步状态是否为 0 作为最终释放的条件，当同步状态为 0 时，将占有线程设置为null，并返回 true 表示释放成功。</p>
<p>对于非公平锁只要 CAS 设置同步状态成功则表示当前线程获取了锁，而公平锁则不同。公平锁使用 tryAcquire 方法，该方法与nonfairTryAcquire 的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断，如果该方法返回 true 表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。、</p>
<hr>
<h3 id="P10：读写锁"><a href="#P10：读写锁" class="headerlink" title="P10：读写锁"></a>P10：读写锁</h3><p>ReentrantLock 是排他锁，在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一个读锁和一个写锁，通过分离读写锁使并发性相比一般的排他锁有了很大提升。</p>
<p>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。只需要在读操作时获取读锁，写操作时获取写锁即可，当写锁被获取时后续的读写操作都会被阻塞，写锁释放之后所有操作继续执行，编程方式相对于使用等待/通知机制的实现方式变得简单。</p>
<p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态即一个整形变量上维护多个读线程和一个写线程的状态。如果在一个 int 型变量上维护多种状态，就一定要按位切割使用这个变量，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。</p>
<p>写锁是一个支持重入的排他锁，如果当前线程已经获得了写锁则增加写状态，如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获得写锁的线程则当前线程进入等待状态。写锁的释放与 ReentrantLock 的释放过程类似，每次释放均减少写状态，当写状态为 0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<p>读锁是一个支持重入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问时，读锁总会被成功地获取，而所做的只是线程安全地增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取则进入等待状态。读锁的每次释放均会减少读状态，减少的值是（1&lt;&lt;16），读锁的每次释放是线程安全的。</p>
<p>锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级指的是把持住当前拥有的写锁，再获取到读锁，随后释放先前拥有的写锁的过程。</p>
<p>锁降级中读锁的获取是必要的，主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程 A 获取了写锁修改了数据，那么当前线程是无法感知线程 A 的数据更新的。如果当前线程获取读锁，即遵循锁降级的步骤，线程 A 将会被阻塞，直到当前线程使用数据并释放读锁之后，线程 A 才能获取写锁进行数据更新。</p>
<hr>
<h3 id="P11：AQS-队列同步器"><a href="#P11：AQS-队列同步器" class="headerlink" title="P11：AQS 队列同步器"></a>P11：AQS 队列同步器</h3><p>队列同步器是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 类型的成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。</p>
<p><strong>使用方式</strong></p>
<p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法 getState、setState 和 compareAndSetState 来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型地同步组件。</p>
<p><strong>和锁的关系</strong></p>
<p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所关注的领域。</p>
<p><strong>同步队列</strong></p>
<p>AQS 中每当有新的线程请求资源时，该线程都会进入一个等待队列，只有当持有锁的线程释放锁资源后该线程才能持有资源。等待队列通过双向链表实现，线程会被封装在链表的 Node 节点中，Node 的等待状态包括：CANCELLED 表示线程已取消、SIGNAL 表示线程需要唤醒、CONDITION 表示线程正在等待、PROPAGATE 表示后继节点会传播唤醒操作，只会在共享模式下起作用。</p>
<p><strong>两种模式</strong></p>
<p>独占模式表示锁会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取到锁继续执行，在同一时间内只能有一个线程获取到这个锁，ReentrantLock 就采用的是独占模式。</p>
<p>共享模式表示多个线程获取同一个锁的时候有可能会成功，ReadLock 就采用的是共享模式。</p>
<p>独占模式通过 acquire 和 release 方法获取和释放锁，共享模式通过 acquireShared 和 releaseShared 方法获取和释放锁。</p>
<p><strong>独占式的获取和释放流程</strong></p>
<p>在获取同步状态时，同步器调用 acquire 方法，维护一个同步队列，使用 tryAcquire 方法安全地获取线程同步状态，获取状态失败的线程会构造同步节点并通过 addWaiter 方法被加入到同步队列的尾部，并在队列中进行自旋。之后会调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞节点被中断实现，移出队列或停止自旋的条件是前驱节点是头结点并且成功获取了同步状态。</p>
<p>在释放同步状态时，同步器调用 tryRelease 方法释放同步状态，然后调用 unparkSuccessor 方法（该方法使用 LockSupport 唤醒处于等待状态的线程）唤醒头节点的后继节点，进而使后继节点重新尝试获取同步状态。</p>
<p><strong>只有当前驱节点是头节点时才能够尝试获取同步状态原因</strong></p>
<p>头节点是成功获取到同步状态的节点，而头节点的线程释放同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</p>
<p>维护同步队列的FIFO原则，节点和节点在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节点，这样就使得节点的释放规则符合FIFO，并且也便于对过早通知的处理（过早通知是指前驱节点不是头结点的线程由于中断而被唤醒）。</p>
<p><strong>共享式的获取和释放流程</strong></p>
<p>在获取同步状态时，同步器调用 acquireShared 方法，该方法调用 tryAcquireShared 方法尝试获取同步状态，返回值为 int 类型，当返回值大于等于 0 时表示能够获取到同步状态。因此在共享式获取锁的自旋过程中，成功获取到同步状态并退出自旋的条件就是该方法的返回值大于等于0。</p>
<p>释放同步状态时，调用 releaseShared 方法，释放同步状态后会唤醒后续处于等待状态的节点。对于能够支持多线程同时访问的并发组件，它和独占式的主要区别在于 tryReleaseShared 方法必须确保同步状态安全释放，一般通过循环和 CAS 来保证，因为释放同步状态的操作会同时来自多个线程。</p>
<hr>
<h3 id="P12：线程"><a href="#P12：线程" class="headerlink" title="P12：线程"></a><font color="red">P12：线程</font></h3><p>现代操作系统在运行一个程序时会为其创建一个进程，而操作系统调度的最小单位是线程，线程也叫轻量级进程。在一个进程中可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上告诉切换，让使用者感觉到这些线程在同时执行。</p>
<p><strong>生命周期</strong></p>
<p>①NEW：初始状态，创建后还没有启动的线程处于这种状态，此时还没有调用 start 方法。②RUNNABLE：Java 线程将操作系统中的就绪和运行两种状态统称为 RUNNABLE，此时线程有可能正在等待操作系统分配CPU时间片，也有可能正在执行③BLOCKED：阻塞状态，阻塞状态与等待状态的区别是阻塞状态在等待一个排它锁，在程序等待进入同步区域时线程将进入这种状态。④WAITING：等待状态，表示线程进入等待状态，处于该状态的线程不会被分配CPU时间片，进入该状态表示当前线程需要等待其他线程通知或中断。会导致线程陷入等待状态的方法：没有设置超时参数的wait 和 join方法、LockSupport的 park 方法。⑤TIME_WAITING：限期等待状态，该状态不同于 WAITING，可以在指定时间内自行返回。会导致线程陷入限期等待状态的方法：设置了超时参数的 wait 和 join 方法、LockSupport 的 parkNanos 和 parkUntil 方法。⑥TERMINATED：终止状态，表示当前线程已经执行完毕或异常退出。</p>
<p><strong>实现方式</strong></p>
<p>①继承 Thread 类并重写 run方法。优点是实现简单，缺点是不能继承其他类，功能单一。②实现 Runnable 接口并重写 run 方法，并将该实现类作为参数传入 Thread 构造器。优点是避免了单继承的局限性，适合多个相同程序代码的线程共享一个资源，实现解耦操作，代码和线程独立。③实现 Callable 接口并重写 call 方法，包装成 FutureTask 对象并作为参数传入Thread构造器。优点是可以获取线程执行结果的返回值。④可以通过线程池创建。</p>
<p><strong>方法</strong></p>
<p>① wait是Object类的方法，调用wait方法的线程会进入WAITING状态，只有等待其他线程的通知或被中断后才会解除阻塞，调用wait方法会释放锁资源。② sleep 是 Thread 类的方法，调用 sleep 方法会导致当前线程进入休眠状态，与 wait 不同的是该方法不会释放锁资源，进入的是 TIMED-WAITING 状态。③ yiled 方法会使当前线程让出 CPU 时间片给优先级相同或更高的线程，回到 RUNNABLE 状态，与其他线程一起重新竞争CPU时间片。④ join 方法用于等待其他线程运行终止，如果当前线程调用了另一个线程的 join 方法，则当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就绪态，等待获取CPU时间片。底层使用的是wait，也会释放锁。</p>
<p><strong>守护线程</strong></p>
<p>守护线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作，当 JVM 中不存在非守护线程时，JVM 将会退出，可以通过 setDaemon(true) 将线程设置为daemon线程，但必须在线程启动之前设置。守护线程被用于完成支持性工作，但是在 JVM 退出时守护线程中的 finally 块并不一定会被执行，因为当 JVM 中没有非守护线程时需要立即退出，所有守护线程都将立即终止，因此不能依靠 finally 确保执行关闭或清理资源的逻辑。</p>
<hr>
<h3 id="P13：线程间通信"><a href="#P13：线程间通信" class="headerlink" title="P13：线程间通信"></a>P13：线程间通信</h3><p>通信是指线程之间以何种机制来交换信息，在命令式编程中线程之间的通信机制有两种，共享内存和消息传递。在共享内存的并发模型里线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里线程之间没有公共状态，线程之间必须通过发送消息来显示通信。Java 并发采用共享内存模型，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<p><strong>volatile 和 synchronized 关键字</strong></p>
<p>volatile 可以修饰字段，告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回主内存，它能保证所有线程对变量访问的可见性。</p>
<p>synchronized 可以修饰方法或以同步块的形式使用，它主要确保多个线程在同一个时刻只能有一个线程处于方法或同步块中，保证了线程对变量访问的可见性和排他性。</p>
<p><strong>等待/通知机制</strong></p>
<p>等待通知机制是指一个线程 A 调用了对象 O 的 wait 方法进入等待状态，而另一个线程 B 调用了对象 O 的 notify 或 notifyAll 方法，线程 A 收到通知后从 wait 方法返回，进而执行后序操作。两个线程通过对象 O 完成交互，对象上的 wait 和 notify/notifyAll 就如同开关信号，用来完成等待方和通知方之间的交互工作。</p>
<p><strong>管道 IO 流</strong></p>
<p>管道 IO 流和普通文件IO 流或网络 IO 流的不同之处在于它主要用于线程之间的数据传输，传输的媒介为内存。管道流主要包括了四种具体实现：PipedOutputStream、PipedInputStream、PipedReader 和 PipedWriter，对于 Piped 类型的流必须要通过 connect 方法进行绑定。</p>
<p><strong>Thread.join</strong></p>
<p>如果一个线程执行了某个线程的 join 方法，这个线程就会阻塞等待执行了 join 方法的线程终止之后才返回，这里涉及了等待/通知机制。join 方法的底层是通过 wait 方法实现的，当线程终止时会调用自身的 notifyAll 方法，通知所有等待在该线程对象上的线程。</p>
<p><strong>ThreadLocal</strong></p>
<p>ThreadLoacl 是线程变量，内部以 ThreadLocal 为键，任意对象为值的存储结构实现。该结构绑定在每个线程上，存储的值在每个线程中都是一个唯一副本，每个线程可以通过 ThreadLocal 对象访问自己唯一的值。</p>
<p>这种存储结构叫 ThreadLocalMap ，是 ThreadLocal 的一个静态内部类，是一个弱引用集合，它的存值、取值实现类似于 HashMap，使用 set 设置值，使用 get 获取值。使用弱引用的目的是为了节约资源，如果执行过程中发生了 GC，ThreadLocal 是 null 但由于 ThreadLocalMap 生命周期和线程一样，不会被回收，这时候就会导致 ThreadLocalMap 的 key 不存在而 value 还在的内存泄漏问题，解决办法是使用完 ThreadLocal 后执行remove操作。</p>
<hr>
<h3 id="P14：ConcurrentHashMap"><a href="#P14：ConcurrentHashMap" class="headerlink" title="P14：ConcurrentHashMap"></a>P14：ConcurrentHashMap</h3><p><strong>JDK 8 之前</strong></p>
<p>ConcurrentHashMap 用于解决 HashMap 的线程不安全和 HashTable 的并发效率低下问题，HashTable 之所以效率低下是因为所有线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器一部分数据，那么多线程访问容器不同数据段的数据时线程间就不会存在锁竞争，从而有效提高并发效率，这就是 ConcurrentHashMap 的锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。</p>
<p>get 操作实现简单高效，先经过一次再散列，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素。get 的高效在于这个过程不需要加锁，除非读到空值才会加锁重读。get 方法里将要使用的共享变量都定义为 volatile 类型，volatile 保证了多线程的可见性，可以多线程读，但是只能保证单线程写，在 get 操作里只需要读所以不用加锁。</p>
<p>put 操作必须加锁，put 方法首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。</p>
<p>size 操作用于统计元素的数量，必须统计每个 Segment 的大小然后求和，在统计结果累加的过程中，之前累加过的 count 变化的几率很小，因此 ConcurrentHashMap 的做法是先尝试两次通过不加锁的方式统计结果，如果统计过程中容器大小发生了变化则再通过加锁的方式统计所有 Segment 的大小。判断容器是否发生变化是根据 modCount 变量确定的。</p>
<p><strong>JDK 8 开始</strong></p>
<p>JDK 8 的实现摒弃了 Segment 分段概念，使用 Synchronized 和 CAS 来保证线程安全。</p>
<p>get 操作同样不需要同步控制，put 操作时如果没有出现哈希冲突，就使用 CAS 方式来添加元素，如果出现了哈希冲突就使用 synchronized 加锁的方式添加元素。</p>
<hr>
<h3 id="P15：CAS-操作"><a href="#P15：CAS-操作" class="headerlink" title="P15：CAS 操作"></a>P15：CAS 操作</h3><p>CAS 表示 Compare And Swap，比较并交换，CAS 需要三个操作数，分别是内存位置 V、旧的预期值 A 和准备设置的新值 B。CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则它就不执行更新。但不管是否更新都会返回 V 的旧值，这些处理过程是原子操作，执行期间不会被其他线程打断。</p>
<p>在 JDK 5 后，Java 类库中才开始使用 CAS 操作，该操作由 Unsafe 类里的 <code>compareAndSwapInt</code> 等几个方法包装提供。HotSpot 在内部对这些方法做了特殊处理，即时编译的结果是一条平台相关的处理器 CAS 指令。Unsafe 类不是给用户程序调用的类，因此在 JDK 9 之前只有 Java 类库可以使用 CAS，譬如 juc 包里的 AtomicInteger类中 <code>compareAndSet</code> 等方法都使用了Unsafe 类的 CAS 操作来实现。</p>
<p>尽管 CAS 既简单又高效，但这种操作无法涵盖互斥同步的所有场景，并且 CAS 从语义上来说存在一个逻辑漏洞：如果 V 初次读取的时候是 A，并且在准备赋值的时候检查到它的值仍为 A，这依旧不能说明它的值没有被其他线程更改过，因为这段时间内假设它的值先改为了 B 又改回 A，那么 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 ABA 问题，juc 包提供了一个 AtomicStampedReference，原子更新带有版本号的引用类型，它可以通过控制变量值的版本来解决 ABA 问题。这个类并不常用，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决该问题，改用传统的互斥同步可能会比原子类更高效。</p>
<hr>
<h3 id="P16：原子操作类"><a href="#P16：原子操作类" class="headerlink" title="P16：原子操作类"></a>P16：原子操作类</h3><p>Java 从 JDK 5 开始提供了 java.util.concurrent.atomic 包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。到 JDK 8 该包共有17个类，依据作用分为四种：原子更新基本类型类、原子更新数组类、原子更新引用类以及原子更新字段类，atomic 包里的类基本都是使用 Unsafe 实现的包装类。</p>
<p><strong>原子更新基本类型</strong></p>
<p>AtomicInteger 原子更新整形、 AtomicLong 原子更新长整型、AtomicBoolean 原子更新布尔类型。</p>
<p>getAndIncrement 以原子方式将当前的值加 1，首先在 for 死循环中取得 AtomicInteger  里存储的数值，第二步对 AtomicInteger  当前的值进行加 1 操作，第三步调用 compareAndSet 方法进行原子更新，该操作先检查当前数值是否等于 expect，如果等于则说明当前值没有被其他线程修改，则将值更新为 next，否则会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。</p>
<p>atomic 包中只提供了 三种基本类型的原子更新，atomic 包里的类基本都是使用 Unsafe 实现的，Unsafe 只提供三种 CAS 方法：compareAndSwapInt、compareAndSwapLong 和 compareAndSwapObject，例如原子更新 Boolean 时是先转成整形再使用 compareAndSwapInt 进行 CAS，所以原子更新 char、float、double 也可以用类似思路实现。</p>
<p><strong>原子更新数组</strong></p>
<p>AtomicIntegerArray，原子更新整形数组里的元素、 AtomicLongArray 原子更新长整型数组里的元素、 AtomicReferenceArray 原子更新引用类型数组里的元素。</p>
<p><strong>原子更新引用</strong></p>
<p>AtomicReference 原子更新引用类型、AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 类型的标记位、 AtomicStampedReference 原子更新带有版本号的引用类型，关联一个整数值用于原子更新数据和数据的版本号，可以解决 ABA 问题。</p>
<p><strong>原子更新字段</strong></p>
<p>AtomicIntegerFieldUpdater 原子更新整形字段的更新器、 AtomicLongFieldUpdater 原子更新长整形字段的更新器AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器。</p>
<p>由于原子更新字段类都是抽象类，每次使用的时候必须使用静态方法 newUpdater 创建一个更新器，并且需要设置想要更新的类和字段。并且更新类的字段必须使用 public volatile 修饰。</p>
<p><strong>JDK 8 更新的类</strong></p>
<p>DoubleAccumulator 、 LongAccumulator、DoubleAdder、LongAdder、Striped64。</p>
<hr>
<h3 id="P17：并发工具类"><a href="#P17：并发工具类" class="headerlink" title="P17：并发工具类"></a>P17：并发工具类</h3><p><strong>等待多线程完成的 CountDownLatch</strong></p>
<p>CountDownLatch 允许一个或多个线程等待其他线程完成操作，构造器接收一个 int 类型的参数作为计数器，如果要等待 n 个点就传入 n。每次调用 countDown 方法时计数器减 1，await 方法会阻塞当前线程直到计数器变为0，由于 countDown方法可用在任何地方，所以 n 个点既可以是 n 个线程也可以是一个线程里的 n 个执行步骤。</p>
<p><strong>同步屏障 CyclicBarrier</strong></p>
<p>同步屏障的作用是让一组线程到达一个屏障或同步点时被阻塞，直到最后一个线程到达屏障时，屏障才会解除，所有被拦截的线程才会继续运行。构造器中的参数表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 自己已到达屏障，然后当前线程被阻塞。还支持在构造器中传入一个 Runable 类型的任务，当线程到达屏障时会优先执行该任务。适用于多线程计算数据，最后合并计算结果的应用场景。</p>
<p>CountDownLacth 的计数器只能用一次，而 CyclicBarrier 的计数器可使用 reset 方法重置，所以 CyclicBarrier 能处理更为复杂的业务场景，例如计算错误时可用重置计数器重新计算。</p>
<p><strong>控制并发线程数的 Semaphore</strong></p>
<p>信号量用来控制同时访问特定资源的线程数量，它通过协调各个线程以保证合理使用公共资源。信号量可以用于流量控制，特别是公共资源有限的应用场景，比如数据库连接。Semaphore 的构造器参数接收一个 int 值，表示可用的许可数量即最大并发数。使用acquire 方法获得一个许可证，使用 release 方法归还许可，还可以用 tryAcquire 尝试获得许可。</p>
<p><strong>线程间交换数据的 Exchanger</strong> </p>
<p>交换者是用于线程间协作的工具类，用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过 exchange 方法交换数据，如果第一个线程先执行exchange方法它会阻塞等待第二个线程执行exchange方法，当两个线程都到达同步点时这两个线程就可以交换数据，将本线程生产出的数据传递给对方。应用场景包括遗传算法、校对工作等。</p>
<hr>
<h3 id="P18：线程池"><a href="#P18：线程池" class="headerlink" title="P18：线程池"></a>P18：线程池</h3><p><strong>好处</strong></p>
<p>① 降低资源消耗，复用已创建的线程降低线程创建和消耗的开销。② 提高响应速度，当任务到达时，任务可以不需要等到线程创建就可以立即执行。③ 提高线程的可管理性，线程是稀缺资源，如果无限制地创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<p><strong>当提交一个新任务到线程池时的处理流程</strong></p>
<p>① 判断核心线程池里的线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务，此时 workCount &lt; corePoolSize，这一步需要获取全局锁。② 如果核心线程池已满，判断工作队列是否已满，如果没有就将新提交的任务存储在工作队列中，此时 workCount &gt;= corePoolSize。③ 如果工作队列已满，判断线程池的线程是否都处于工作状态，如果没有则创建一个新的工作线程来执行任务，此时 workCount &lt; maximumPoolSize，这一步也需要获取全局锁。④ 如果线程池已满，按照拒绝策略来处理任务，此时 workCount &gt; maximumPoolSize。</p>
<p>线程池采取这种设计思路是为了在执行 execute 方法时尽可能地避免获取全局锁，在线程池完成预热之后，即当前运行的线程数大于等于corePoolSize 时，几乎所有的 execute 方法都是执行步骤 2，不需要获取全局锁。</p>
<p>线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。线程池中的线程执行任务分为两种情况：①在 execute 方法中创建一个线程时会让这个线程执行当前任务。②这个线程执行完任务之后，就会反复从工作队列中获取任务并执行。</p>
<p>可以使用 execute 和 submit 方法向线程池提交任务。execute 用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功了。submit 用于提交需要返回值的任务，线程池会返回一个 Future 类型的对象，通过该对象可以判断任务是否执行成功，并且可以通过该对象的 get 方法获取返回值，get 会阻塞当前线程直到任务完成，带超时参数的 get 方法会在阻塞当前线程一段时间后立即返回，这时任务可能还没有完成。</p>
<p><strong>创建线程池的参数</strong></p>
<p>① <strong>corePoolSize：</strong>线程池的基本大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池的基本大小时就不再创建。② <strong>workQueue：</strong>工作队列，用于保存等待执行任务的阻塞队列。③ <strong>maximumPoolSize：</strong>线程池最大数量，如果工作队列已满，并且创建的线程数小于最大线程数，则线程池还会创建新的线程执行任务，如果使用无界阻塞队列该参数无意义。④ <strong>threadFactory：</strong>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。⑤ <strong>handler：</strong>拒绝策略，默认策略下使用 AbortPolicy 直接抛出异常，CallerRunsPolicy 表示重新尝试提交该任务，DiscardOldestPolicy 表示抛弃队列里最近的一个任务并执行当前任务，DiscardPolicy 表示直接抛弃当前任务不处理。⑥ <strong>keepAliveTime：</strong>线程活动的保持时间，线程池工作线程空闲后保持存活的时间，所以如果任务很多，且每个任务的执行时间较短，可以调大时间提高线程的利用率。⑦ <strong>unit：</strong>线程活动保持时间的单位。</p>
<p><strong>关闭线程池</strong></p>
<p>可以通过调用 shutdown 或 shutdownNow 方法关闭线程池，原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法中断线程，所以无法响应中断的任务可能永远无法终止。区别是 shutdownNow 首先将线程池的状态设为 STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表，而 shutdown 只是将线程池的状态设为 SHUTDOWN，然后中断所有没有正在执行任务的线程。通常调用 shutdown 来关闭线程池，如果任务不一定要执行完则可以调用 shutdownNow。</p>
<p><strong>合理设置线程池</strong></p>
<p>首先可以从以下角度分析：①任务的性质：CPU密集型任务、IO密集型任务和混合型任务。②任务的优先级：高、中和低。③任务的执行时间：长、中和短。④任务的依赖性：是否依赖其他系统资源，如数据库连接。</p>
<p>性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应配置尽可能小的线程，如配置 N<del>cpu</del>+1 个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如 2 * N<del>cpu</del>。混合型的任务，如果可以拆分，将其拆分为一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大那么分解后的吞吐量将高于串行执行的吞吐量，如果相差太大则没必要分解。</p>
<p>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 处理。</p>
<p>执行时间不同的任务可以交给不同规模的线程池处理，或者使用优先级队列让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，由于线程提交 SQL 后需要等待数据库返回的结果，等待的时间越长 CPU 空闲的时间就越长，因此线程数应该尽可能地设置大一些提高CPU的利用率。</p>
<p>建议使用有界队列，能增加系统的稳定性和预警能力，可以根据需要设置的稍微大一些。</p>
<hr>
<h3 id="P19：阻塞队列"><a href="#P19：阻塞队列" class="headerlink" title="P19：阻塞队列"></a>P19：阻塞队列</h3><p>阻塞队列支持阻塞的插入和移除，当队列满时，阻塞插入元素的线程直到队列不满。当队列为空时，获取元素的线程会被阻塞直到队列非空。阻塞队列常用于生产者和消费者的场景，阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p>
<p><strong>Java中的阻塞队列</strong></p>
<p>ArrayBlockingQueue，由数组组成的有界阻塞队列，默认情况下不保证线程公平，有可能先阻塞的线程最后才访问队列。</p>
<p>LinkedBlockingQueue，由链表结构组成的有界阻塞队列，队列的默认和最大长度为 Integer 的最大值。</p>
<p>PriorityBlockingQueue，支持优先级排序的无界阻塞队列，默认情况下元素按照顺序升序排序。可以自定义 compareTo 方法指定元素排序规则，或者初始化时指定 Comparator 对元素排序，不能保证同优先级元素的顺序。</p>
<p>DelayQueue，支持延时获取元素的无界阻塞队列，使用优先级队列实现。创建元素时可以指定多久才能从队列中获取当前元素，只有延迟期满时才能从队列中获取元素，适用于缓存系统和定时任务调度。</p>
<p>SynchronousQueue，不存储元素的阻塞队列，每一个 put 操作必须等待一个 take 操作。默认使用非公平策略，也支持公平策略，适用于传递性场景，吞吐量高于 ArrayBlockingQueue 和 LinkedBlockingQueue。</p>
<p>LinkedTransferQueue，由链表组成的无界阻塞队列，相对于其他阻塞队列多了 tryTransfer 和 transfer 方法。transfe方法：如果当前有消费者正在等待接收元素，可以把生产者传入的元素立刻传输给消费者，如果没有消费者等待接收元素，会将元素放在队列的尾节点并等到该元素被消费者消费了才返回。tryTransfer 方法用来试探生产者传入的元素能否直接传给消费者，如果没有消费者等待接收元素则返回 false，和transfer 的区别是无论消费者是否消费都会立即返回。</p>
<p>LinkedBlockingDeque，由链表组成的双向阻塞队列，可以从队列的两端插入和移出元素，在多线程同时入队时减少了竞争。</p>
<p><strong>实现原理</strong></p>
<p>使用通知模式实现，当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。例如 JDK 中的 ArrayBlockingQueue 使用了 Condition 实现。当往队列里插入一个元素，如果队列不可用，那么阻塞生产者主要通过LockSupport 的 park 方法实现，park 在不同的操作系统中使用不同的方式实现，在 Linux 下使用的是系统方法 pthread_cond_wait 实现。</p>
<hr>
<h3 id="P20：Executor-框架"><a href="#P20：Executor-框架" class="headerlink" title="P20：Executor 框架"></a>P20：Executor 框架</h3><p>Java 的线程既是工作单元，也是执行机制。从 JDK 5开始把工作单元与执行机制分离开来，工作单元包括 Runnable 和 Callable，而执行机制由 Exectuor 框架提供。</p>
<p>在 HotSpot 的线程模型中，Java 线程被一对一映射为本地操作系统线程，Java 线程启动时会创建一个本地操作系统线程，当该 Java线程终止时，这个操作系统线程也会被回收，操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p>在上层，Java 多线程程序通常把应用分解为若干任务，然后使用用户级的调度器即 Executor 框架将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<p>Executor 框架主要由三部分组成：①任务，包括被执行任务需要实现的接口，Runnable 或 Callable。②任务的执行，包括任务执行机制的核心接口 Executor 以及继承自 Executor 的 ExecutorService 。③异步计算的结果，包括接口 Future 和实现 Future 接口的 FutureTask 类。</p>
<p><strong>ThreadPoolExecutor</strong></p>
<p>ThreadPoolExecutor 是 Executor框架最核心的类，是线程池的实现类，主要有三种。</p>
<p>① FixedThreadPool，可重用固定线程数的线程池，corePoolSize 和 maximumPoolSize都被设置为创建时的指定参数 nThreads，当线程池中的线程数大于 corePoolSize 时，keepAliveTime 为多余的空闲线程等待新任务的最长时间，超过这个时间后的多余线程将被终止，将其设置为 0L 时多余空闲线程将被立即终止。该线程池使用的工作队列是无界阻塞队列 LinkedBlockingQueue，适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载比较重的服务器。</p>
<p>② SingleThreadExecutor，使用单个线程的线程池，corePoolSize 和 maximumPoolSize都被设置为 1，其他参数和 FiexedThreadPool相同。适用于需要保证顺序执行各个任务，并且在任意时间点不会有多个线程是活动的的应用场景。</p>
<p>③ CachedThreadPool，一个根据需要创建线程的线程池，corePoolSize 被设置为0，maximumPoolSize 被设置为 Integer 最大值。该线程池使用的工作队列是没有容量的 SynchronousQueue，但由于 maximumPoolSize 设为 Integer最大值，如果主线程提交任务的速度高于线程处理的速度，线程池会不断创建新线程，极端情况下会创建过多线程而耗尽CPU和内存资源。适用于执行很多短期异步任务的小程序，或者负载较轻的服务器。</p>
<p><strong>ScheduledThreadPoolExecutor</strong></p>
<p>继承自 ThreadPoolExecutor，主要用来在给定的延迟之后运行任务，或者定期执行任务。其功能与 Timer 类似但更强大和灵活。Timer对应的是单个后台线程，而 ScheduledThreadPoolExecutor 可以在构造器中指定多个对应的后台线程数。</p>
<p>主要有两种：① ScheduledThreadPool：创建固定线程个数的线程池，适用于需要多个后台线程执行周期任务，同时需要限制后台线程数量的应用场景。② SingleThreadScheduledExecutor：只包含一个线程的线程池，适用于单个后台线程执行周期任务，同时需要保证顺序执行任务的应用场景。</p>
<p>实现原理是将待调度任务放入一个DelayQueue 中，调度任务主要有三个 long 类型的参数，time 表示这个任务将要被执行的具体时间，sequenceNumber 表示这个任务被添加到线程池的序号，period 表示任务执行时间间隔。DelayQueue封装了一个PriorityQueue，队列按照 time 进行排序，如果相同则比较sequenceNumber，越小的排在前面，即如果两个任务的执行时间相同，先提交的任务先被执行。</p>
<hr>
<h2 id="Spring-10"><a href="#Spring-10" class="headerlink" title="Spring 10"></a>Spring 10</h2><h3 id="P1：Spring-框架"><a href="#P1：Spring-框架" class="headerlink" title="P1：Spring 框架"></a>P1：Spring 框架</h3><p>Spring 是分层的企业级应用轻量级开源框架，以 IoC 和 AOP为内核。Spring 可以降低企业级应用开发的复杂性，对此主要采取了四个关键策略：基于 POJO 的轻量级和最小侵入性编程、通过依赖注入和面向接口实现松耦合、基于切面和惯性进行声明式编程、通过切面和模板减少样板式代码。</p>
<p><strong>好处</strong></p>
<p>降低代码耦合度、简化开发。通过 Spring 提供的 IoC 容器可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些底层的需求编写代码，可以更专注于上层的应用。</p>
<p>AOP 编程以及声明式事务的支持。通过 Spring 的 AOP 功能可以方便进行面向切面的编程，通过声明式事务可以灵活进行事务管理，提高开发效率和质量。</p>
<p>方便程序的测试和集成各种框架。可以用非容器依赖的编程方式进行几乎所有的测试工作，可以降低各种框架的使用难度，提供了对 Mybatis 和 Hibernate 等框架的直接支持。</p>
<p>降低了 JavaEE API 的使用难度。Spring 对 JDBC、JavaMail、远程调用等 API 进行了封装，使这些 API 的使用难度大幅降低。</p>
<p><strong>核心容器</strong></p>
<p>核心容器由 spring-beans、spring-core、spring-context 和 spring-expression 四个模块组成。</p>
<p>spring-beans 和 spring-core 模块是 Spring 的核心模块，包括了控制反转和依赖注入。BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用代码进行分离，BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才会对其进行实例化与依赖关系的装配。</p>
<p>spring-context 模块构架于核心模块之上，扩展了 BeanFactory，为它添加了 Bean 的生命周期控制、框架事件体系及资源透明化加载等功能。ApplicationConext 是该模块的核心接口，它是 BeanFactory 的子接口，它实例化后会自动对所有单例 Bean 进行实例化与依赖关系的装配，使之处于待用状态。</p>
<p>spring-expression 是 EL 语言的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。</p>
<hr>
<h3 id="P2：IoC-控制反转"><a href="#P2：IoC-控制反转" class="headerlink" title="P2：IoC 控制反转"></a>P2：IoC 控制反转</h3><p>IoC 即控制反转，是一种给予应用程序中目标组件更多控制的设计范式，简单来说就是把原来代码里需要实现的对象创建、依赖反转给容器来帮忙实现，需要创建一个容器并且需要一种描述来让容器知道要创建的对象之间的关系，在 Spring 框架中管理对象及其依赖关系是通过 Spring 的 IoC 容器实现的，IoC 的作用是降低代码耦合度。</p>
<p>IoC 的实现方式有依赖注入和依赖查找，由于依赖查找使用的很少，因此 IoC 也叫做依赖注入。依赖注入指对象被动地接受依赖类而不用自己主动去找，对象不是从容器中查找它依赖的类，而是在容器实例化对象时主动将它依赖的类注入给它。假设一个 Car 类需要一个 Engine 的对象，那么一般需要需要手动 new 一个 Engine，利用 IoC 就只需要定义一个私有的 Engine 类型的成员变量，容器会在运行时自动创建一个 Engine 的实例对象并将引用自动注入给成员变量。</p>
<p><strong>基于 XML 的容器初始化</strong></p>
<p>当创建一个 ClassPathXmlApplicationContext 时，构造器做了两件事：首先调用父容器的构造器为容器设置好 Bean 资源加载器，然后调用父类的 setConfigLocations 方法设置 Bean 配置信息的定位路径。</p>
<p>ClassPathXmlApplicationContext 通过调用父类 AbstractApplicationContext 的 refresh 方法启动整个 IoC 容器对 Bean 定义的载入过程，refresh 是一个模板方法，规定了 IoC 容器的启动流程。refresh 方法的主要作用是：在创建 IoC 容器之前如果已有容器存在，需要把已有的容器销毁和关闭，以保证在 refresh 方法之后使用的是新创建的 IoC 容器。</p>
<p>容器创建后通过 loadBeanDefinitions 方法加载 Bean 配置资源，该方法会做两件事：首先调用资源加载器的方法获取要加载的资源，其次真正执行加载功能，由子类 XmlBeanDefinitionReader 实现。在加载资源时，首先会解析配置文件路径，读取配置文件的内容，然后通过 XML 解析器将 Bean 配置信息转换成文档对象，之后再按照 Spring Bean 的定义规则对文档对象进行解析。</p>
<p>Spring IoC 容器中注册解析的 Bean 信息存放在一个 HashMap 集合中，key 是 String 字符串，值是 BeanDefinition，在注册过程中需要使用 synchronized 同步块保证线程安全。当 Bean 配置信息中配置的 Bean 被解析后且被注册到 IoC 容器中，初始化就算真正完成了，Bean 定义信息已经可以使用，并且可以被检索。Spring IoC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护，注册的 Bean 定义信息是控制反转和依赖注入的基础。</p>
<p><strong>基于注解的容器初始化</strong></p>
<p>Spring 对注解的处理分为两种方式：① 直接将注解 Bean 注册到容器中，可以在初始化容器时注册，也可以在容器创建之后手动注册，然后刷新容器使其对注册的注解 Bean 进行处理。② 通过扫描指定的包及其子包的所有类处理，在初始化注解容器时指定要自动扫描的路径。</p>
<hr>
<h3 id="P3：DI-依赖注入"><a href="#P3：DI-依赖注入" class="headerlink" title="P3：DI 依赖注入"></a>P3：DI 依赖注入</h3><p><strong>可注入的数据类型</strong></p>
<p>基本数据类型和 String、集合类型、Bean 类型。</p>
<p><strong>实现方式</strong></p>
<p>构造器注入：IoC Service Provider 会检查被注入对象的构造器，取得它所需要的依赖对象列表，进而为其注入相应的对象。这种方法的优点是在对象构造完成后就处于就绪状态，可以马上使用。缺点是当依赖对象较多时，构造器的参数列表会比较长，构造器无法被继承，无法设置默认值。对于非必需的依赖处理可能需要引入多个构造器，参数数量的变动可能会造成维护的困难。</p>
<p>setter 方法注入：当前对象只需要为其依赖对象对应的属性添加 setter 方法，就可以通过 setter 方法将依赖对象注入到被依赖对象中。setter 方法注入在描述性上要比构造器注入强，并且可以被继承，允许设置默认值。缺点是无法在对象构造完成后马上进入就绪状态。</p>
<p>接口注入：必须实现某个接口，这个接口提供一个方法来为其注入依赖对象。使用较少，因为它强制要求被注入对象实现不必要的接口，侵入性强。</p>
<p><strong>相关注解</strong></p>
<p><code>@Autowired</code>：自动按类型注入，如果有多个匹配则按照指定 Bean 的 id 查找，查找不到会报错。</p>
<p><code>@Qualifier</code>：在自动按照类型注入的基础上再按照 Bean 的 id 注入，给变量注入时必须搭配 <code>@Autowired</code>，给方法注入时可单独使用。</p>
<p><code>@Resource</code> ：直接按照 Bean 的 id 注入，只能注入 Bean 类型。</p>
<p><code>@Value</code> ：用于注入基本数据类型和 String 类型。</p>
<p><strong>依赖注入的过程</strong></p>
<p>getBean 方法是获取 Bean 实例的方法，该方法会调用 doGetBean 方法，doGetBean 真正实现向 IoC 容器获取 Bean 的功能，也是触发依赖注入的地方。如果 Bean 定义为单例模式，容器在创建之前先从缓存中查找以确保整个容器中只存在一个实例对象。如果 Bean 定义为原型模式，则容器每次都会创建一个新的实例。</p>
<p>具体创建 Bean 实例对象的过程由 ObjectFactory 的 createBean 方法完成，该方法主要通过 createBeanInstance 方法生成 Bean 包含的 Java 对象实例和 populateBean 方法对 Bean 属性的依赖注入进行处理。</p>
<p>在 createBeanInstance 方法中根据指定的初始化策略，通过简单工厂、工厂方法或容器的自动装配特性生成 Java 实例对象，对工厂方法和自动装配特性的 Bean，调用相应的工厂方法或参数匹配的构造器即可完成实例化对象的工作，但最常用的默认无参构造器需要使用 JDK 的反射或 CGLib 来进行初始化。</p>
<p>在 populateBean 方法中，注入过程主要分为两种情况：① 属性值类型不需要强制转换时，不需要解析属性值，直接进行依赖注入。② 属性值类型需要强制转换时，首先需要解析属性值，然后对解析后的属性值进行依赖注入。依赖注入的过程就是将 Bean 对象实例设置到它所依赖的 Bean 对象属性上，真正的依赖注入是通过 setPropertyValues 方法实现的，该方法使用了委派模式。</p>
<p>BeanWrapperImpl 类负责对容器完成初始化的 Bean 实例对象进行属性的依赖注入，对于非集合类型的属性，大量使用 JDK 的反射机制，通过属性的 getter 方法获取指定属性注入前的值，同时调用属性的 setter 方法为属性设置注入后的值。对于集合类型的属性，将属性值解析为目标类型的集合后直接赋值给属性。</p>
<p>当 Spring IoC 容器对 Bean 定义资源的定位、载入、解析和依赖注入全部完成后，就不再需要我们手动创建所需的对象，Spring IoC 容器会自动为我们创建对象并且注入好相关依赖。</p>
<hr>
<h3 id="P4：Bean-对象"><a href="#P4：Bean-对象" class="headerlink" title="P4：Bean 对象"></a>P4：Bean 对象</h3><p><strong>生命周期</strong></p>
<p>在 IoC 容器的初始化过程中会对 Bean 定义完成资源定位，加载读取配置并解析，最后将解析的 Bean 信息放在一个 HashMap 集合中。当 IoC 容器初始化完成后，会进行对 Bean 实例的创建和依赖注入过程，注入对象依赖的各种属性值，在初始化时可以指定自定义的初始化方法。经过这一系列初始化操作后 Bean 达到可用状态，接下来就可以使用 Bean 了，当使用完成后会调用 destroy 方法进行销毁，此时也可以指定自定义的销毁方法，最终 Bean 被销毁且从容器中移除。</p>
<p>指定 Bean 初始化和销毁的方法：</p>
<p>XML 方式通过配置 bean 标签中的 init-Method 和 destory-Method 指定自定义初始化和销毁方法。 </p>
<p>注解方式通过 <code>@PreConstruct</code> 和 <code>@PostConstruct</code> 注解指定自定义初始化和销毁方法。</p>
<p><strong>作用范围</strong></p>
<p>通过 scope 属性指定 bean 的作用范围，包括：① singleton：单例模式，是默认作用域，不管收到多少 Bean 请求每个容器中只有一个唯一的 Bean 实例。② prototype：原型模式，和 singleton 相反，每次 Bean 请求都会创建一个新的实例。③ request：每次 HTTP 请求都会创建一个新的 Bean 并把它放到 request 域中，在请求完成后 Bean 会失效并被垃圾收集器回收。④ session：和 request 类似，确保每个 session 中有一个 Bean 实例，session 过期后 bean 会随之失效。⑤ global session：当应用部署在 Portlet 容器中时，如果想让所有 Portlet 共用全局存储变量，那么这个变量需要存储在 global session 中。</p>
<p><strong>创建方式</strong></p>
<p><strong>XML</strong></p>
<p>通过默认无参构造器，只需要指明 bean 标签中的 id 和 class 属性，如果没有无参构造器会报错。</p>
<p>使用静态工厂方法，通过 bean 标签中的 class 属性指明静态工厂，factory-method 属性指明静态工厂方法。</p>
<p>使用实例工厂方法，通过 bean 标签中的 factory-bean 属性指明实例工厂，factory-method 属性指明实例工厂方法。</p>
<p><strong>注解</strong></p>
<p><code>@Component</code> 把当前类对象存入 Spring 容器中，相当于在 xml 中配置一个 bean 标签。value 属性指定 bean 的 id，默认使用当前类的首字母小写的类名。</p>
<p><code>@Controller</code>，<code>@Service</code>，<code>@Repository</code> 三个注解都是 <code>@Component</code>  的衍生注解，作用及属性都是一模一样的。只是提供了更加明确语义，<code>@Controller</code> 用于表现层，<code>@Service</code>用于业务层，<code>@Repository</code>用于持久层。如果注解中有且只有一个 value 属性要赋值时可以省略 value。</p>
<p>如果想将第三方的类变成组件又没有源代码，也就没办法使用 <code>@Component</code> 进行自动配置，这种时候就要使用 <code>@Bean</code> 注解。被 <code>@Bean</code> 注解的方法返回值是一个对象，将会实例化，配置和初始化一个新对象并返回，这个对象由 Spring 的 IoC 容器管理。name 属性用于给当前 <code>@Bean</code>  注解方法创建的对象指定一个名称，即 bean 的 id。当使用注解配置方法时，如果方法有参数，Spring 会去容器查找是否有可用 bean对象，查找方式和 <code>@Autowired</code> 一样。</p>
<p><code>@Configuration</code> 用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解，value 属性用于指定配置类的字节码。</p>
<p><code>@ComponentScan</code> 用于指定 Spring 在初始化容器时要扫描的包。basePackages 属性用于指定要扫描的包。</p>
<p><code>@PropertySource</code> 用于加载 <code>.properties</code> 文件中的配置。value 属性用于指定文件位置，如果是在类路径下需要加上 classpath。</p>
<p><code>@Import</code> 用于导入其他配置类，在引入其他配置类时可以不用再写 <code>@Configuration</code> 注解。有 <code>@Import</code> 的是父配置类，引入的是子配置类。value 属性用于指定其他配置类的字节码。</p>
<p><strong>BeanFactory、FactoryBean 和 ApplicationContext 的区别</strong></p>
<p>BeanFactory 是一个 Bean 工厂，实现了工厂模式，是 Spring IoC 容器最顶级的接口，可以理解为含有 Bean 集合的工厂类，它的作用是管理 Bean，包括实例化、定位、配置应用程序中的对象及建立这些对象之间的依赖。BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才会对其进行实例化与依赖关系的装配，属于延迟加载，适合多例模式。</p>
<p>FactoryBean 是一个工厂 Bean，作用是生产其他 Bean 实例，可以通过实现该接口，提供一个工厂方法来自定义实例化 Bean 的逻辑。</p>
<p>ApplicationConext 是 BeanFactory 的子接口，扩展了 BeanFactory 的功能，提供了支持国际化的文本消息，统一的资源文件读取方式，事件传播以及应用层的特别配置等。容器会在初始化时对配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化时就已经完成，属于立即加载，适合单例模式，一般推荐使用 ApplicationContext。</p>
<hr>
<h3 id="P5：AOP-面向切面编程"><a href="#P5：AOP-面向切面编程" class="headerlink" title="P5：AOP 面向切面编程"></a>P5：AOP 面向切面编程</h3><p><strong>概念和原理</strong></p>
<p>AOP 即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理的技术，在不修改源码的基础上对方法进行增强。优点是可以减少代码的冗余，提高开发效率，维护方便。</p>
<p>Spring 会根据类是否实现了接口来判断动态代理的方式，如果实现了接口会使用 JDK 的动态代理，核心是 InvocationHandler 接口和 Proxy 类，如果没有实现接口会使用 CGLib 动态代理，CGLib 是在运行时动态生成某个类的子类，如果某一个类被标记为 final，是不能使用 CGLib 动态代理的。</p>
<p>JDK 动态代理主要通过重组字节码实现，首先获得被代理对象的引用和所有接口，生成新的类必须实现被代理类的所有接口，动态生成Java 代码后编译新生成的 <code>.class</code> 文件并重新加载到 JVM 运行。JDK 代理直接写 Class 字节码，CGLib是采用ASM框架写字节码，生成代理类的效率低。但是CGLib调用方法的效率高，因为 JDK 使用反射调用方法，CGLib 使用 FastClass 机制为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法生成一个 index，这个 index 可以作为参数直接定位要调用的方法。</p>
<p>常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。</p>
<p><strong>相关注解</strong></p>
<p><code>@Aspect</code>：声明被注解的类是一个切面 Bean。</p>
<p><code>@Before</code>：前置通知，指在某个连接点之前执行的通知。</p>
<p><code>@After</code>：后置通知，指某个连接点退出时执行的通知（不论正常返回还是异常退出）。</p>
<p><code>@AfterReturning</code>：返回后通知，指某连接点正常完成之后执行的通知，返回值使用returning属性接收。</p>
<p><code>@AfterThrowing</code>：异常通知，指方法抛出异常导致退出时执行的通知，和<code>@AfterReturning</code>只会有一个执行，异常使用throwing属性接收。</p>
<p><strong>相关术语</strong></p>
<p><code>Aspect</code>：切面，一个关注点的模块化，这个关注点可能会横切多个对象。</p>
<p><code>Joinpoint</code>：连接点，程序执行过程中的某一行为，即业务层中的所有方法。。</p>
<p><code>Advice</code>：通知，指切面对于某个连接点所产生的动作，包括前置通知、后置通知、返回后通知、异常通知和环绕通知。</p>
<p><code>Pointcut</code>：切入点，指被拦截的连接点，切入点一定是连接点，但连接点不一定是切入点。</p>
<p><code>Proxy</code>：代理，Spring AOP 中有 JDK 动态代理和 CGLib 代理，目标对象实现了接口时采用 JDK 动态代理，反之采用 CGLib 代理。</p>
<p><code>Target</code>：代理的目标对象，指一个或多个切面所通知的对象。</p>
<p><code>Weaving</code> ：织入，指把增强应用到目标对象来创建代理对象的过程。</p>
<p><strong>AOP 的过程</strong></p>
<p>Spring AOP 是由 BeanPostProcessor 后置处理器开始的，这个后置处理器是一个监听器，可以监听容器触发的 Bean 生命周期事件，向容器注册后置处理器以后，容器中管理的 Bean 就具备了接收 IoC 容器回调事件的能力。BeanPostProcessor 的调用发生在 Spring IoC 容器完成 Bean 实例对象的创建和属性的依赖注入之后，为 Bean 对象添加后置处理器的入口是 initializeBean 方法。</p>
<p>Spring 中 JDK 动态代理生通过 JdkDynamicAopProxy 调用 Proxy 的 newInstance 方法来生成代理类，JdkDynamicAopProxy 也实现了 InvocationHandler 接口，invoke 方法的具体逻辑是先获取应用到此方法上的拦截器链，如果有拦截器则创建 MethodInvocation 并调用其 proceed 方法，否则直接反射调用目标方法。因此 Spring AOP 对目标对象的增强是通过拦截器实现的。</p>
<hr>
<h3 id="P6：Spring-MVC-核心组件"><a href="#P6：Spring-MVC-核心组件" class="headerlink" title="P6：Spring MVC 核心组件"></a>P6：Spring MVC 核心组件</h3><p><code>DispatcherServlet</code>：SpringMVC 中的前端控制器，是整个流程控制的核心，负责接收请求并转发给对应的处理组件。</p>
<p><code>Handler</code>：处理器，完成具体业务逻辑，相当于 Servlet 或 Action。</p>
<p><code>HandlerMapping</code>：完成URL 到 Controller映射的组件，DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</p>
<p><code>HandlerInterceptor</code>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</p>
<p><code>HandlerExecutionChain</code>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor。</p>
<p><code>HandlerAdapter</code>：处理器适配器，Handler执行业务方法前需要进行一系列操作，包括表单数据验证、数据类型转换、将表单数据封装到JavaBean等，这些操作都由 HandlerAdapter 完成。DispatcherServlet 通过 HandlerAdapter 来执行不同的 Handler。</p>
<p><code>ModelAndView</code>：装载了模型数据和视图信息，作为 Handler 的处理结果返回给 DispatcherServlet。</p>
<p><code>ViewResolver</code>：视图解析器，DispatcherServlet 通过它将逻辑视图解析为物理视图，最终将渲染的结果响应给客户端。</p>
<hr>
<h3 id="P7：Spring-MVC-处理流程"><a href="#P7：Spring-MVC-处理流程" class="headerlink" title="P7：Spring MVC 处理流程"></a>P7：Spring MVC 处理流程</h3><p>Web 容器启动时会通知 Spring 初始化容器，加载 Bean 的定义信息并初始化所有单例 Bean，然后遍历容器中的 Bean，获取每一个 Controller 中的所有方法访问的 URL，将 URL 和对应的 Controller 保存到一个 Map 集合中。</p>
<p>所有的请求会转发给 DispatcherServlet 前端处理器处理，DispatcherServlet 会请求 HandlerMapping 找出容器中被 <code>@Controler</code> 注解修饰的 Bean 以及被 <code>@RequestMapping</code> 修饰的方法和类，生成 Handler 和 HandlerInterceptor 并以一个 HandlerExcutionChain 处理器执行链的形式返回。</p>
<p>之后 DispatcherServlet 使用 Handler 找到对应的 HandlerApapter，通过 HandlerApapter 调用 Handler 的方法，将请求参数绑定到方法的形参上，执行方法处理请求并得到 ModelAndView。</p>
<p>最后 DispatcherServlet 根据使用 ViewResolver 试图解析器对得到的 ModelAndView 逻辑视图进行解析得到 View 物理视图，然后对视图渲染，将数据填充到视图中并返回给客户端。</p>
<p><strong>注解</strong></p>
<p><code>@Controller</code>：在类定义处添加，将类交给IoC容器管理。</p>
<p><code>@RequtestMapping</code>：将URL请求和业务方法映射起来，在类和方法定义上都可以添加该注解。<code>value</code> 属性指定URL请求的实际地址，是默认值。<code>method</code> 属性限制请求的方法类型，包括GET、POST、PUT、DELETE等。如果没有使用指定的请求方法请求URL，会报405 Method Not Allowed 错误。<code>params</code> 属性限制必须提供的参数，如果没有会报错。</p>
<p><code>@RequestParam</code>：如果 Controller 方法的形参和 URL 参数名一致可以不添加注解，如果不一致可以使用该注解绑定。<code>value</code> 属性表示HTTP请求中的参数名。<code>required</code> 属性设置参数是否必要，默认false。<code>defaultValue</code> 属性指定没有给参数赋值时的默认值。</p>
<p><code>@PathVariable</code>：Spring MVC 也支持 RESTful 风格的 URL，通过 <code>@PathVariable</code> 完成请求参数与形参的绑定。</p>
<hr>
<h3 id="P8：Spring-Data-JPA-框架"><a href="#P8：Spring-Data-JPA-框架" class="headerlink" title="P8：Spring Data JPA 框架"></a>P8：Spring Data JPA 框架</h3><p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，可使开发者用极简的代码实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展，可以极大提高开发效率。</p>
<p>ORM 即 Object-Relational Mapping ，表示对象关系映射，映射的不只是对象的值还有对象之间的关系，通过 ORM 就可以把对象映射到关系型数据库中。操作实体类就相当于操作数据库表，可以不再重点关注 SQL 语句。</p>
<p>使用时只需要持久层接口继承 JpaRepository 即可，泛型参数列表中第一个参数是实体类类型，第二个参数是主键类型。运行时通过 <code>JdkDynamicAopProxy</code> 的 <code>invoke</code> 方法创建了一个动态代理对象 <code>SimpleJpaRepository</code>，<code>SimpleJpaRepository</code> 中封装了 JPA 的操作，通过 <code>hibernate</code>（封装了JDBC）完成数据库操作。</p>
<p><strong>注解</strong></p>
<p><code>@Entity</code>：表明当前类是一个实体类。</p>
<p><code>@Table</code> ：关联实体类和数据库表。</p>
<p><code>@Column</code> ：关联实体类属性和数据库表中字段。</p>
<p><code>@Id</code> ：声明当前属性为数据库表主键对应的属性。</p>
<p><code>@GeneratedValue</code>： 配置主键生成策略。</p>
<p><code>@OneToMany</code> ：配置一对多关系，mappedBy 属性值为主表实体类在从表实体类中对应的属性名。</p>
<p><code>@ManyToOne</code> ：配置多对一关系，targetEntity 属性值为主表对应实体类的字节码。</p>
<p><code>@JoinColumn</code>：配置外键关系，name 属性值为外键名称，referencedColumnName 属性值为主表主键名称。</p>
<p><strong>对象导航查询</strong></p>
<p>通过 get 方法查询一个对象的同时，通过此对象可以查询它的关联对象。</p>
<p>对象导航查询一到多默认使用延迟加载的形式， 关联对象是集合，因此使用立即加载可能浪费资源。</p>
<p>对象导航查询多到一默认使用立即加载的形式， 关联对象是一个对象，因此使用立即加载。</p>
<p>如果要改变加载方式，在实体类注解配置加上 fetch 属性即可，LAZY 表示延迟加载，EAGER 表示立即加载。</p>
<hr>
<h3 id="P9：Mybatis-框架"><a href="#P9：Mybatis-框架" class="headerlink" title="P9：Mybatis 框架"></a>P9：Mybatis 框架</h3><p>Mybatis 是一个实现了数据持久化的 ORM 框架，简单理解就是对 JDBC 进行了封装。</p>
<p><strong>优点</strong></p>
<p>相比 JDBC 减少了大量代码量，减少冗余代码。</p>
<p>使用灵活，SQL 语句写在 XML 里，从程序代码中彻底分离，降低了耦合度，便于管理。</p>
<p>提供 XML 标签，支持编写动态 SQL 语句。</p>
<p>提供映射标签，支持对象与数据库的 ORM 字段映射关系。</p>
<p><strong>缺点</strong></p>
<p>SQL 语句编写工作量较大，尤其是字段和关联表多时。</p>
<p>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<p><strong>映射文件标签</strong></p>
<p><code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 标签分别对应查询、添加、更新、删除操作。</p>
<p><code>parameterType</code>  属性表示参数的数据类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型，当有多个参数时可以使用 <code>#{argn}</code> 的形式表示第 n 个参数。除了基本数据类型都要以全限定类名的形式指定参数类型。</p>
<p><code>resultType</code>  表示返回的结果类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型。还可以使用把返回结果封装为复杂类型的 <code>resultMap</code> 。</p>
<p><strong>缓存</strong></p>
<p>使用缓存可以减少程序和数据库交互的次数，从而提高程序的运行效率。第一次查询后会自动将结果保存到缓存中，下一次查询时直接从缓存中返回结果无需再次查询数据库。</p>
<ul>
<li><p><strong>一级缓存</strong></p>
<p>SqlSession 级别，默认开启且不能关闭。</p>
<p>操作数据库时需要创建 SqlSession 对象，在对象中有一个 HashMap 用于存储缓存数据，不同 SqlSession 之间缓存数据区域互不影响。</p>
<p>一级缓存的作用域是 SqlSession 范围的，在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存在缓存中，第二次查询直接从缓存中获取。</p>
<p>如果 SqlSession 执行了 DML 操作（insert、update、delete），Mybatis 必须将缓存清空以保证数据的有效性。 </p>
</li>
<li><p><strong>二级缓存</strong></p>
<p>Mapper 级别，默认关闭。</p>
<p>使用二级缓存时多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区，同样使用 HashMap 进行数据存储，相比于一级缓存，二级缓存范围更大，多个 SqlSession 可以共用二级缓存，作用域是 Mapper 的同一个 namespace，不同 SqlSession 两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功后会将数据保存在二级缓存中，第二次可直接从二级缓存中取出数据。</p>
<p>要使用二级缓存，先在在全局配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>再在对应的映射文件中配置一个 cache 标签即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="P10：Spring-Cloud-框架"><a href="#P10：Spring-Cloud-框架" class="headerlink" title="P10：Spring Cloud 框架"></a>P10：Spring Cloud 框架</h3><p><strong>单体应用存在的问题</strong></p>
<p>随着业务发展，开发越来越复杂。</p>
<p>修改、新增某个功能，需要对整个系统进行测试、重新部署。</p>
<p>一个模块出现问题，可能导致整个系统崩溃。</p>
<p>多个开发团队同时对数据进行管理，容易产生安全漏洞。</p>
<p>各个模块使用同一种技术开发，各个模块很难根据实际情况选择更合适的技术框架，局限性很大。</p>
<p><strong>分布式和集群的区别</strong></p>
<p>集群：一台服务器无法负荷高并发的数据访问量，就设置多台服务器一起分担压力，是在物理层面解决问题。</p>
<p>分布式：将一个复杂的问题拆分成若干简单的小问题，将一个大型的项目架构拆分成若干个微服务来协同完成，在软件设计层面解决问题。</p>
<p><strong>微服务的优点</strong></p>
<p>各个服务的开发、测试、部署都相互独立，用户服务可以拆分为独立服务，如果用户量很大，可以很容易对其实现负载。</p>
<p>当新需求出现时，使用微服务不再需要考虑各方面的问题，例如兼容性、影响度等。</p>
<p>使用微服务拆分项目后，各个服务之间消除了很多限制，只需要保证对外提供的接口正常可用，而不限制语言和框架等选择。</p>
<p><strong>服务治理 Eureka</strong></p>
<p>服务治理的核心由三部分组成：<strong>服务提供者</strong>、<strong>服务消费者</strong>、<strong>注册中心</strong>。</p>
<p>服务注册：在分布式系统架构中，每个微服务在启动时，将自己的信息存储在注册中心。</p>
<p>服务发现：服务消费者从注册中心获取服务提供者的网络信息，通过该信息调用服务。</p>
<p>Spring Cloud 的服务治理使用 Eureka 实现，Eureka 是 Netflix 开源的基于 REST 的服务治理解决方案，Spring Cloud 集成了 Eureka，提供服务注册和服务发现的功能，可以和基于 Spring Boot 搭建的微服务应用轻松完成整合，将 Eureka 二次封装为 Spring Cloud Eureka。<strong>Eureka Server</strong> 是注册中心，所有要进行注册的微服务通过 Eureka Client 连接到 Eureka Server 完成注册。</p>
<p><strong>服务网关 Zuul</strong></p>
<p>Spring Cloud 集成了 Zuul 组件，实现服务网关。Zuul 是 Netflix 提供的一个开源的 API 网关服务器，是客户端和网站后端所有请求的中间层，对外开放一个 API，将所有请求导入统一的入口，屏蔽了服务端的具体实现逻辑，可以实现方向代理功能，在网关内部实现动态路由、身份认证、IP过滤、数据监控等。</p>
<p><strong>负载均衡 Ribbon</strong></p>
<p>Spring Cloud Ribbon 是一个负载均衡的解决方案，Ribbon 是 Netflix 发布的均衡负载器，Spring Cloud Ribbon是基于 Netflix Ribbon 实现的，是一个用于对 HTTP 请求进行控制的负载均衡客户端。</p>
<p>在注册中心对 Ribbon 进行注册之后，Ribbon 就可以基于某种负载均衡算法（轮循、随机、加权轮询、加权随机等）自动帮助服务消费者调用接口，开发者也可以根据具体需求自定义 Ribbon 负载均衡算法。实际开发中 Spring Clooud Ribbon 需要结合 Spring Cloud Eureka 使用，Eureka 提供所有可以调用的服务提供者列表，Ribbon 基于特定的负载均衡算法从这些服务提供者中选择要调用的具体实例。</p>
<p><strong>声明式接口调用 Feign</strong></p>
<p>Feign 与 Ribbon 一样也是 Netflix 提供的，Feign 是一个声明式、模板化的 Web Service 客户端，简化了开发者编写 Web 服务客户端的操作，开发者可以通过简单的接口和注解来调用 HTTP API，Spring Cloud Feign 整合了 Ribbon 和 Hystrix，具有可插拔、基于注解、负载均衡、服务熔断等一系列功能。</p>
<p>相比于 Ribbon + RestTemplate 的方式，Feign 可以大大简化代码开发，支持多种注解，包括 Feign 注解、JAX-RS 注解、Spring MVC 注解等。RestTemplate 是 Spring 框架提供的基于 REST 的服务组件，底层是对 HTTP 请求及响应进行了封装，提供了很多访问 REST 服务的方法，可以简化代码开发。</p>
<p><strong>服务熔断 Hystrix</strong></p>
<p>熔断器的作用是在不改变各个微服务调用关系的前提下，针对错误情况进行预先处理。</p>
<p>设计原则：服务隔离机制、服务降级机制、熔断机制、提供实时监控和报警功能和提供实时配置修改功能</p>
<p>Hystrix 数据监控需要结合 <code>Spring Boot Actuator</code> 使用，Actuator 提供了对服务的数据监控、数据统计，可以通过 <code>hystirx-stream</code> 节点获取监控的请求数据，同时提供了可视化监控界面。</p>
<p><strong>服务配置 Config</strong></p>
<p>Spring Cloud Config 通过服务端可以为多个客户端提供配置服务，既可以将配置文件存储在本地，也可以将配置文件存储在远程的 Git 仓库，创建 Config Server，通过它管理所有的配置文件。</p>
<p><strong>服务跟踪 Zipkin</strong></p>
<p>Spring Cloud Zipkin 是一个可以采集并跟踪分布式系统中请求数据的组件，让开发者更直观地监控到请求在各个微服务耗费的时间，Zipkin 包括两部分 Zipkin Server 和 Zipkin Client。</p>
<hr>
<h2 id="MySQL-15"><a href="#MySQL-15" class="headerlink" title="MySQL 15"></a>MySQL 15</h2><h3 id="P1：逻辑架构"><a href="#P1：逻辑架构" class="headerlink" title="P1：逻辑架构"></a>P1：逻辑架构</h3><p>第一层是服务器层，主要提供连接处理、授权认证、安全等功能，该层的服务不是 MySQL 独有的，大多数基于网络的 C/S 服务都有类似架构。</p>
<p>第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。</p>
<p>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。</p>
<hr>
<h3 id="P2：锁"><a href="#P2：锁" class="headerlink" title="P2：锁"></a>P2：锁</h3><p>当有多个查询需要在同一时刻修改数据时就会产生并发控制的问题，MySQL 在两个层面进行并发控制：服务器层与存储引擎层。</p>
<p><strong>读写锁</strong></p>
<p>在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。</p>
<p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插入到写锁前面。</p>
<p><strong>锁策略</strong></p>
<p>一种提高共享资源并发性的方法就是让锁定对象更有选择性，尽量只锁定需要修改的部分数据而不是所有资源，更理想的方式是只对会修改的数据进行精确锁定。任何时刻在给定的资源上，锁定的数据量越少，系统的并发程度就越高，只要不发生冲突即可。</p>
<p>锁策略就是在锁的开销和数据安全性之间寻求平衡，这种平衡也会影响性能。大多数商业数据库系统没有提供更多选择，一般都是在表上加行锁，而 MySQL 提供了多种选择，每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。MySQL 最重要的两种锁策略：</p>
<ul>
<li><p>表锁是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。</p>
</li>
<li><p>行锁可以最大程度地支持并发处理，同时也带来了最大的锁开销。InnoDB 和 XtraDB 以及一些其他存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。</p>
</li>
</ul>
<p><strong>死锁</strong></p>
<p>死锁是指两个或者多个事务在同一资源上相互占用并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资源时也会产生死锁。</p>
<p>为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持有最少行级排它锁的事务进行回滚。</p>
<p>锁的行为与顺序是和存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁有些则不会。死锁的产生有双重原因：有些是真正的数据冲突，这种情况很难避免，有些则完全是由于存储引擎的实现方式导致的。</p>
<p>死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<hr>
<h3 id="P3：事务"><a href="#P3：事务" class="headerlink" title="P3：事务"></a><font color = 'red'>P3：事务</font></h3><p>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行成功，要么全部执行失败。</p>
<p><strong>ACID 特性</strong></p>
<p>一个运行良好的事务处理系统必须具备 ACID 特性，实现了 ACID 的数据库需要更强的CPU处理能力、更大的内存和磁盘空间。</p>
<ul>
<li><p><strong>原子性 atomicity</strong></p>
<p>一个事务在逻辑上是必须不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分。</p>
</li>
<li><p><strong>一致性 consistency</strong></p>
<p>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>
</li>
<li><p><strong>隔离性 isolation</strong></p>
<p>针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p>
</li>
<li><p><strong>持久性 durability</strong></p>
<p>一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。</p>
</li>
</ul>
<p><strong>隔离级别</strong></p>
<p>在 SQL 标准中定义了四种隔离级别，每一种隔离级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<ul>
<li><p><strong>未提交读 READ UNCOMMITTED</strong></p>
<p>在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，从性能上说也没有比其他级别好很多，因此很少使用。</p>
</li>
<li><p><strong>提交读 READ COMMITTED</strong></p>
<p>大多数数据库系统默认的隔离级别就是提交读，但 MySQL 不是。提交读满足了隔离性的简单定义：一个事务开始时只能”看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。这个级别有时也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。提交读存在不可重复读和幻读的问题。</p>
</li>
<li><p><strong>可重复读 REPEATABLE READ</strong>（MySQL默认的隔离级别）</p>
<p>可重复读解决了不可重复读的问题，该级别保证了在同一个事务中多次读取同样的记录结果是一致的。但可重复读隔离级别还是无法解决幻读的问题，所谓幻读，指的是当某个事务在读取某个范围内的记录时，会产生幻行。InnoDB 存储引擎通过多版本并发控制MVCC 解决幻读的问题。</p>
</li>
<li><p><strong>可串行化 SERIALIZABLE</strong></p>
<p>该级别是最高的隔离级别，通过强制事务串行执行，避免了幻读的问题。可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。</p>
</li>
</ul>
<p><strong>MySQL 中的事务</strong></p>
<p>MySQL 提供了两种事务型的存储引擎：InnoDB 和 NDB Cluster。</p>
<p>MySQL 事务默认采用自动提交模式，如果不是显式地开始一个事务，则每个查询都将被当作一个事务执行提交操作。在当前连接中，可以通过设置 AUTOCOMMIT 变量来启用或禁用自动提交模式。</p>
<p>1 或 ON 表示启用，0 或 OFF表示禁用，当禁用自动提交时，所有的查询都是在一个事务中，直到显式地执行 COMMIT 或 ROLLBACK 后该事务才会结束，同时又开始了一个新事务。修改 AUTOCOMMIT 对非事务型表，例如 MyISAM 或内存表不会有任何影响，对这类表来说没有 COMMIT 或 ROLLBACK 的概念，也可以理解为一直处于启用自动提交的模式</p>
<p>有一些命令在执行之前会强制执行提交当前的活动事务，例如<code>ALTER TABLE</code>和<code>LOCK TABLES</code>等。</p>
<p>MySQL能够识别所有的 4个 ANSI 隔离级别，InnoDB 引擎也支持所有隔离级别。</p>
<hr>
<h3 id="P4：MVCC-多版本并发控制"><a href="#P4：MVCC-多版本并发控制" class="headerlink" title="P4：MVCC 多版本并发控制"></a>P4：MVCC 多版本并发控制</h3><p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>不同的存储引擎的 MVCC 实现是不同的，典型的有乐观并发控制和悲观并发控制。</p>
<p><strong>InnoDB 的 MVCC 实现</strong></p>
<p>InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间间。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>REPEATABLE READ 级别下 MVCC 的具体实现</strong></p>
<p>SELECT：InnoDB 会根据以下两个条件检查每行记录：</p>
<ul>
<li><p>只查找版本早于当前事务版本的数据行，可以确保事务读取的行要么是事务开始前已经存在的，要么是事物自身插入或修改过的。</p>
</li>
<li><p>行的删除版本要么未定义，要么大于当前事务版本号，可以确保事务读取到的行在事务开始前未被删除。</p>
</li>
</ul>
<p>INSERT ：为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p>DELETE：为删除的每一行保存当前系统版本号作为行删除标识。</p>
<p>UPDATE：为插入的每一行新记录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<p>保存这两个额外系统版本号使大多数读操作都可以不用加锁。这样设计使读数据操作简单且高效，并且能保证只会读取到符合标准的行。不足之处是每行记录都需要额外存储空间，需要做更多行检查工作以及一些额外维护工作。</p>
<p>MVCC 只能在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作，因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</p>
<hr>
<h3 id="P5：InnoDB-存储引擎"><a href="#P5：InnoDB-存储引擎" class="headerlink" title="P5：InnoDB 存储引擎"></a>P5：InnoDB 存储引擎</h3><p>InnoDB 是 MySQL 的默认事务型引擎，它被设计用来处理大量的短期事务。InnoDB 的性能和自动崩溃恢复特性，使得它在非事务型存储需求中也很流行，除非有特别原因否则应该优先考虑 InnoDB 引擎。</p>
<p>InnoDB 的数据存储在表空间中，表空间由一系列数据文件组成。MySQL4.1 后 InnoDB 可以将每个表的数据和索引放在单独的文件中。</p>
<p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 <code>REPEATABLE READ</code>，并且通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p>
<p>InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结构和其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果主键很大的话其他所有索引都会很大，因此如果表上索引较多的话主键应当尽可能小。</p>
<p>InnoDB 的存储格式是平台独立的，可以将数据和索引文件从一个平台复制到另一个平台。</p>
<p>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p>
<p><strong>选择合适的存储引擎</strong></p>
<p>MySQL5.5 将 InnoDB 作为默认存储引擎，除非需要用到某些 InnoDB 不具备的特性，并且没有其他方法可以代替，否则都应该优先选用InnoDB。</p>
<p>如果应用需要事务支持，那么 InnoDB 是目前最稳定并且经过验证的选择。如果不需要事务并且主要是 SELECT 和 INSERT 操作，那么MyISAM 是不错的选择。相对而言，MyISAM 崩溃后发生损坏的概率要比 InnoDB 大很多而且恢复速度也要慢，因此即使不需要事务支持，也可以选择InnoDB。</p>
<p>如果可以定期地关闭服务器来执行备份，那么备份的因素可以忽略。反之如果需要在线热备份，那么 InnoDB 就是基本的要求。</p>
<hr>
<h3 id="P6：MyISAM-存储引擎"><a href="#P6：MyISAM-存储引擎" class="headerlink" title="P6：MyISAM 存储引擎"></a>P6：MyISAM 存储引擎</h3><p>在 MySQL5.1及之前，MyISAM 是默认的存储引擎，MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行锁，最大的缺陷就是崩溃后无法安全恢复。对于只读的数据或者表比较小、可以忍受修复操作的情况仍然可以使用 MyISAM。</p>
<p>MyISAM 将表存储在数据文件和索引文件中，分别以 <code>.MYD</code> 和 <code>.MYI</code> 作为扩展名。MyISAM 表可以包含动态或者静态行，MySQL 会根据表的定义决定行格式。MyISAM 表可以存储的行记录数一般受限于可用磁盘空间或者操作系统中单个文件的最大尺寸。</p>
<p>MyISAM 对整张表进行加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也支持并发往表中插入新的记录。</p>
<p>对于MyISAM 表，MySQL 可以手动或自动执行检查和修复操作，这里的修复和事务恢复以及崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，而且修复操作很慢。</p>
<p>对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前 500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</p>
<p>创建 MyISAM 表时如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理缓冲区或关闭表的时候才会将对应的索引库写入磁盘。这种方式可以极大提升写性能，但在数据库或主机崩溃时会造成索引损坏，需要执行修复。延迟更新索引键的特性可以在全局设置也可以单个表设置。</p>
<p>MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。MyISAM 最典型的性能问题还是表锁问题，如果所有的查询长期处于 Locked 状态，那么原因毫无疑问就是表锁。</p>
<h3 id="P7：Memory-存储引擎"><a href="#P7：Memory-存储引擎" class="headerlink" title="P7：Memory 存储引擎"></a>P7：Memory 存储引擎</h3><p>如果需要快速访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用的。Memory 表至少要比 MyISAM 表快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘 IO，Memory 表的结构在重启以后还会保留，但数据会丢失。</p>
<p>Memory 表适合的场景：查找或者映射表、缓存周期性聚合数据的结果、保存数据分析中产生的中间数据。</p>
<p>Memory 表支持哈希索引，因此查找速度极快。虽然速度很快但还是无法取代传统的基于磁盘的表，Memory 表使用表级锁，因此并发写入的性能较低。它不支持 BLOB 和 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR 列，实际存储时也会转换成CHAR，这可能导致部分内存的浪费。</p>
<p>如果 MySQL 在执行查询的过程中需要使用临时表来保持中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了Memory 表的限制，或者含有 BLOB 或 TEXT 字段，临时表会转换成 MyISAM 表。</p>
<hr>
<h3 id="P8：数据类型"><a href="#P8：数据类型" class="headerlink" title="P8：数据类型"></a>P8：数据类型</h3><p><strong>整数类型</strong></p>
<p>如果存储整数可以使用这几种整数类型：TINYINT、SMALLINT、MEDIUMINT、INT，BIGINT，它们分别使用8、16、24、32、64 位存储空间。</p>
<p>整数类型有可选的 UNSIGNED 属性，表示不允许负值，可以使整数的上限提高一倍。有符号和无符号类型使用相同的存储空间并具有相同的性能，可以根据实际情况选择合适的类型。</p>
<p>MySQL 可以为整数类型指定宽度，例如 INT(11)，这对大多数应用没有意义，不会限制值的范围，只是规定了 MySQL 的交互工具显示字符的个数，对于存储和计算来说 INT(1) 和 INT(11) 是相同的。</p>
<p><strong>实数类型</strong></p>
<p>实数是带有小数部分的数字，但它们不只是为了存储小数，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。MySQL既支持精确类型，也支持不精确类型。</p>
<p>FLOAT 和 DOUBLE 支持使用标准的浮点运算进行近似运算，DECIMAL 用于存储精确的小数。</p>
<p>浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。FLOAT 使用 4 字节存储，DOUBLE 占用8字节，MySQL 内部使用DOUBLE 作为内部浮点计算的类型。</p>
<p>因为需要额外空间和计算开销，所以应当尽量只在对小数进行精确计算时才使用 DECIMAL。在数据量较大时可以考虑 BIGINT 代替DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储的数据精确到万分之一分，则可以把所有金额乘以一百万将结果存储在 BIGINT 中，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。</p>
<p><strong>VARCHAR</strong></p>
<p>VARCHAR 用于存储可变字符串，是最常见的字符串数据类型。它比定长字符串更节省空间，因为它仅使用必要的空间。VARCHAR 需要 1或 2 个额外字节记录字符串长度，如果列的最大长度不大于 255 字节则只需要1 字节。VARCHAR 不会删除末尾空格。</p>
<p>VARCHAR 节省了存储空间，但由于行是变长的，在 UPDATE 时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长并且页内没有更多的空间可以存储，这种情况下不同存储引擎处理不同，InnoDB 会分裂页而 MyISAM 会将行拆分成不同片。</p>
<p>适用场景：字符串列的最大长度比平均长度大很多、列的更新很少、使用了 UTF8 这种复杂字符集，每个字符都使用不同的字节数存储。</p>
<p>InnoDB 可以把过长的 VARCHAR 存储为 BLOB。</p>
<p><strong>CHAR</strong></p>
<p>CHAR 是定长的，根据定义的字符串长度分配足够的空间。CHAR 会删除末尾空格。</p>
<p>CHAR 适合存储很短的字符串，或所有值都接近同一个长度，例如存储密码的 MD5 值。对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。对于非常短的列，CHAR 在存储空间上也更有效率，例如用 CHAR 来存储只有 Y 和 N 的值只需要一个字节，但是 VARCHAR 需要两个字节，因为还有一个记录长度的额外字节。</p>
<p><strong>BLOB 和 TEXT 类型</strong></p>
<p>BLOB 和TEXT 都是为了存储大数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。MySQL会把每个 BLOB 和 TEXT 值当作一个独立的对象处理，存储引擎在存储时通常会做特殊处理。当值太大时，InnoDB 会使用专门的外部存储区来进行存储。BLOB 和TEXT 仅有的不同是 BLOB 存储的是二进制数据，没有排序规则或字符集，而 TEXT 有字符集和排序规则。</p>
<p>MySQL 对 BLOB 和TEXT 列进行排序与其他类型不同：它只对每个列最前 <code>max_sort_length</code> 字节而不是整个字符串做排序，如果只需要排序前面一小部分字符，则可以减小 <code>max_sort_length</code> 的配置。MySQL 不能将 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。</p>
<p><strong>DATETIME</strong></p>
<p>这个类型能保存大范围的值，从 1001 年到 9999 年，精度为秒。它把日期和时间封装到了一个整数中，与时区无关，使用 8 字节的存储空间。</p>
<p><strong>TIMESTAMP</strong></p>
<p>它和 UNIX 时间戳相同。TIMESTAMP 只使用 4 字节的存储空间，因此它的范围比DATETIME 小得多，只能表示1970年到2038年，并且依赖于时区。通常应该选择 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<hr>
<h3 id="P9：索引的分类"><a href="#P9：索引的分类" class="headerlink" title="P9：索引的分类"></a>P9：索引的分类</h3><p>索引在也叫做键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。</p>
<p>索引大大减少了服务器需要扫描的数据量、可以帮助服务器避免排序和临时表、可以将随机 IO 变成顺序 IO。但索引并不总是最好的工具，对于非常小的表，大部分情况下会采用全表扫描。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长，这种情况下应该使用分区技术。</p>
<p>在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能高效地使用索引的最左前缀列。</p>
<p><strong>B-Tree 索引</strong></p>
<p>大多数 MySQL 引擎都支持这种索引，使用术语 B-Tree 是因为 MySQL 在 CREATE TABLE 和其他语句中也使用该关键字。不过底层的存储引擎可能使用不同的存储结构，例如 NDB 集群实际使用 T-Tree，而 InnoDB 则使用 B+Tree。</p>
<p>存储引擎以不同方式使用 B-Tree 索引，性能也不同。例如 MyISAM 使用前缀压缩技术使得索引更小，但 InnoDB 则按照原数据格式进行存储。再例如 MyISAM 索引通过数据的物理位置引用被索引的行，而 InnoDB 则根据主键引用被索引的行。</p>
<p>B-Tree 通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。叶子节点的指针指向的是被索引的数据，而不是其他的节点页。</p>
<p>B-Tree索引适用于全键值、键值范围或键前缀查找，其中键前缀查找只适用于最左前缀查找。索引对如下类型的查询有效：</p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配。</li>
<li>匹配最左前缀：只使用索引的第一列。</li>
<li>匹配列前缀：只匹配某一列的值的开头部分。</li>
<li>匹配范围值：查找某两个值之间的范围。</li>
<li>精确匹配某一列并范围匹配另一列：有一列全匹配而另一列范围匹配。</li>
<li>只访问索引的查询：B-Tree 通常可以支持只访问索引的查询，即查询只需要访问索引而无需访问数据行。</li>
</ul>
<p>因为索引树中的节点有序，所以除了按值查找之外索引还可以用于查询中的 ORDER BY 操作。一般如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式排序。</p>
<p>B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。</li>
<li>不能跳过索引中的列，例如索引为 (id,name,sex)，不能只使用 id 和 sex 而跳过 name。</li>
<li>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</li>
</ul>
<p><strong>哈希索引</strong></p>
<p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>只有 Memory 引擎显式支持哈希索引，这也是 Memory 引擎的默认索引类型。</p>
<p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引的速度非常快，但它也有一些限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针而不存储字段值，所以不能使用索引中的值来避免读取行。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，因此无法用于排序。</li>
<li>哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如在数据列(a,b)上建立哈希索引，如果查询的列只有a就无法使用该索引。</li>
<li>哈希索引只支持等值比较查询，不支持任何范围查询。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突时，存储引擎必须遍历链表中所有的行指针，逐行进行比较直到找到所有符合条件的行。</li>
<li>如果哈希冲突很高的话，索引维护的代价也会很高。</li>
</ul>
<p>自适应哈希索引是 InnoDB 引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置，但如果有必要可以关闭该功能。</p>
<p>如果存储引擎不支持哈希索引，可以创建自定义哈希索引，在 B-Tree基础 上创建一个伪哈希索引，它使用哈希值而不是键本身进行索引查找，需要在查询的 WHERE 子句中手动指定哈希函数。当数据表非常大时，CRC32 会出现大量的哈希冲突，可以考虑自己实现 64 位哈希函数，或者使用 MD5 函数返回值的一部分作为自定义哈希函数。</p>
<p><strong>空间索引</strong></p>
<p>MyISAM 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 即地理信息系统的相关函数来维护数据，但 MySQL 对 GIS 的支持并不完善，因此大部分人都不会使用这个特性。</p>
<p><strong>全文索引</strong></p>
<p>通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字的匹配进行查询过滤，那么就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。全文索引有自己独特的语法，没有索引也可以工作，如果有索引效率会更高。</p>
<p>全文索引可以支持各种字符内容的搜索，包括 CHAR、VARCHAR 和 TEXT 类型，也支持自然语言搜索和布尔搜索。在 MySQL 中全文索引有很多限制，例如表锁对性能的影响、数据文件的崩溃恢复等，这使得 MyISAM 的全文索引对很多应用场景并不合适。MyISAM 的全文索引作用对象是一个”全文集合”，可能是某个数据表的一列，也可能是多个列。具体的对某一条记录，MySQL 会将需要索引的列全部拼接成一个字符串然后进行索引。</p>
<p>MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的”文档指针”。全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。</p>
<p><strong>聚簇索引</strong></p>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。当表有聚餐索引时，它的行数据实际上存放在索引的叶子页中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>优点：① 可以把相关数据保存在一起，例如实现电子邮箱时可以根据用户 ID 聚集数据，这样只需要从磁盘读取少数数据页就能获取某个用户的全部邮件，如果没有使用聚簇索引，每封邮件可能都导致一次磁盘 IO。② 数据访问更快，聚簇索引将索引和数据保存在同一个 B-Tree 中，因此获取数据比非聚簇索引要更快。③ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>
<p>缺点：① 聚簇索引最大限度提高了 IO 密集型应用的性能，如果数据全部在内存中将会失去优势。② 插入速度验证依赖于插入顺序，按照主键的顺序插入是加载数据到 InnoDB 引擎最快的方式。③ 更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置。④ 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间。④ 当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。</p>
<p><strong>覆盖索引</strong></p>
<p>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。</p>
<p>优点：① 索引条目通常远小于数据行大小，可以极大减少数据访问量。② 因为索引按照列值顺序存储，所以对于 IO 密集型防伪查询回避随机从磁盘读取每一行数据的 IO 少得多。③ 由于 InnoDB 使用聚簇索引，覆盖索引对 InnoDB 很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。</p>
<hr>
<h3 id="P10：索引使用原则"><a href="#P10：索引使用原则" class="headerlink" title="P10：索引使用原则"></a><font color = 'red'>P10：索引使用原则</font></h3><p><strong>建立索引</strong></p>
<p>对查询频次较高，且数据量比较大的表建立索引。索引字段的选择，最佳候选列应当从 WHERE 子句的条件中提取，如果 WHERE 子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</p>
<p><strong>使用前缀索引</strong></p>
<p>索引列开始的部分字符，索引创建后也是使用硬盘来存储的，因此短索引可以提升索引访问的 IO 效率。对于 BLOB、TEXT 或很长的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。前缀索引是一种能使索引更小更快的有效方法，但缺点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p>
<p><strong>选择合适的索引顺序</strong></p>
<p>当不需要考虑排序和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索引提升查询效率。</p>
<p><strong>删除无用索引</strong></p>
<p>MySQL 允许在相同列上创建多个索引，重复的索引需要单独维护，并且优化器在优化查询时也需要逐个考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免创建重复索引。如果创建了索引 (A,B) 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引，对于 B-Tree 索引来说是冗余的。解决重复索引和冗余索引的方法就是删除这些索引。除了重复索引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。</p>
<p><strong>减少碎片</strong></p>
<p>B-Tree 索引可能会碎片化，碎片化的索引可能会以很差或无序的方式存储在磁盘上，这会降低查询的效率。表的数据存储也可能碎片化，包括行碎片、行间碎片、剩余空间碎片，对于 MyISAM 这三类碎片化都有可能发生，对于 InnoDB 不会出现短小的行碎片，它会移动短小的行重写到一个片段中。可以通过执行 OPTIMIZE TABLE 或者导出再导入的方式重新整理数据，对于 MyISAM 可以通过排序重建索引消除碎片。InnoDB 可以通过先删除再重新创建索引的方式消除索引碎片。</p>
<p><strong>索引失效情况</strong></p>
<p>如果索引列出现了隐式类型转换，则 MySQL 不会使用索引。常见的情况是在 SQL 的 WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。</p>
<p>如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。</p>
<p>MySQL 不能在索引中执行 LIKE 操作，这是底层存储引擎 API 的限制，最左匹配的 LIKE 比较会被转换为简单的比较操作，但如果是以通配符开头的 LIKE 查询，存储引擎就无法做笔记。这种情况下 MySQL 服务器只能提取数据行的值而不是索引值来做比较。</p>
<p>如果查询中的列不是独立的，则 MySQL 不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。</p>
<p>对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列，对于多个等值查询则没有这种限制。</p>
<p>如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。</p>
<hr>
<h3 id="P11：优化数据类型"><a href="#P11：优化数据类型" class="headerlink" title="P11：优化数据类型"></a>P11：优化数据类型</h3><p><strong>更小的通常更好</strong></p>
<p>一般情况下尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常也更快，因为它们占用更少的磁盘、内存和 CPU 缓存。</p>
<p><strong>尽可能简单</strong></p>
<p>简单数据类型的操作通常需要更少的 CPU 周期，例如整数比字符操作代价更低，因为字符集和校对规则使字符相比整形更复杂。应该使用 MySQL 的内建类型 date、time 和 datetime 而不是字符串来存储日期和时间，另一点是应该使用整形存储 IP 地址。</p>
<p><strong>尽量避免 NULL</strong></p>
<p>通常情况下最好指定列为 NOT NULL，除非需要存储 NULL值。因为如果查询中包含可为 NULL 的列对 MySQL 来说更难优化，可为 NULL 的列使索引、索引统计和值比较都更复杂，并且会使用更多存储空间。当可为 NULL 的列被索引时，每个索引记录需要一个额外字节，在MyISAM 中还可能导致固定大小的索引变成可变大小的索引。</p>
<p>通常把可为 NULL 的列设置为 NOT NULL 带来的性能提升较小，因此调优时没必要首先查找并修改这种情况。但如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。</p>
<p>在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。下一步是选择具体类型，很多 MySQL 数据类型可以存储相同类型的数据，只是存储的长度和范围不一样，允许的精度不同或需要的物理空间不同。</p>
<hr>
<h3 id="P12：优化查询概述"><a href="#P12：优化查询概述" class="headerlink" title="P12：优化查询概述"></a>P12：优化查询概述</h3><p><strong>优化数据访问</strong></p>
<p>如果把查询看作一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定时间。如果要优化查询，要么消除一些子任务，要么减少子任务的执行次数。查询性能低下最基本的原因是访问的数据太多，大部分性能低下的查询都可以通过减少访问的数据量进行优化。可以通过以下两个步骤分析。</p>
<p>是否向数据库请求了不需要的数据：有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这会给 MySQL 服务器造成额外负担并增加网络开销，另外也会消耗应用服务器的 CPU 和内存资源。例如多表关联时返回全部列，取出全部列会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的 IO、内存和 CPU 的消耗，因此使用 SELECT * 时需要仔细考虑是否真的需要返回全部列。再例如总是重复查询相同的数据，比较好的解决方案是初次查询时将数据缓存起来，需要的时候从缓存中取出。</p>
<p>MySQL 是否在扫描额外的记录：在确定查询只返回需要的数据后，应该看看查询为了返回结果是否扫描了过多的数据，最简单的三个衡量指标时响应时间、扫描的行数和返回的行数。如果发现查询需要扫描大量数据但只返回少数的行，可以使用以下手动优化：① 使用覆盖索引扫描，把所有需要用的列都放到索引中，这样存储引擎无需回表查询对应行就可以返回结果。② 改变库表结构。 ③ 重写这个复杂的查询，让 MySQL 优化器能够以更优化的方式执行这个查询。</p>
<p><strong>重构查询方式</strong></p>
<p>在优化有问题的查询时，目标应该是找到一个更优的方法获取实际需要的结果，而不一定总是需要从 MySQL 获取一模一样的结果集。</p>
<p>切分查询：有时候对于一个大查询可以将其切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。例如删除旧数据，定期清除大量数据时，如果用一个大的语句一次性完成的话可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的 DELETE 语句切分成多个较小的查询可以尽可能小地影响 MySQL 的性能，同时还可以减少MySQL 复制的延迟。</p>
<p>分解关联查询：很多高性能应用都会对关联查询进行分解，可以对每一个表进行单表查询，然后将结果在应用程序中进行关联。分解关联查询可以让缓存的效率更高、减少锁的竞争、提升查询效率、还可以减少冗余记录的查询。</p>
<hr>
<h3 id="P13：查询执行流程"><a href="#P13：查询执行流程" class="headerlink" title="P13：查询执行流程"></a>P13：查询执行流程</h3><p>简单来说分为五步：① 客户端发送一条查询给服务器。② 服务器先检查查询缓存，如果命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。③ 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。④ MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。⑤ 将结果返回给客户端。 </p>
<p><strong>查询缓存</strong></p>
<p>在解析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，也不会匹配缓存结果，这种情况下会进行下一个阶段的处理。如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前 MySQL 会检查一次用户权限。如果权限没有问题，MySQL 会跳过其他阶段，直接从缓冲中拿到结果并返回给客户端，这种情况下查询不会被解析，不用生成执行计划，不会被执行。</p>
<p><strong>查询优化处理</strong></p>
<p>该阶段包括多个子阶段：解析 SQL、预处理、优化 SQL 执行计划。首先 MySQL 通过关键字将 SQL 语句进行解析，并生成一颗对应的解析树，MySQL 解析器将使用 MySQL 语法规则验证和解析查询。例如它将验证是否使用了错误的关键字，或者使用关键字的顺序是否正确等。预处理器则根据一些 MySQL 规则进一步检查解析树是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名看它们是否有歧义。下一步预处理器会验证权限，这一步通常很快，除非服务器上有非常多的权限配置。</p>
<p>语法树被认为合法后，查询优化器将其转成执行计划。一条查询可以有多种查询方式，最后都返回相同的结果，优化器的作用就是找到这其中最好的执行计划。MySQL 使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。优化策略可以简单分为两种，一种是静态优化，可以直接对解析树分析并完成优化，不依赖于特别的数值，可以认为是一种编译时优化。另一种是动态优化，和查询的上下文有关，每次查询时都需要重新评估。</p>
<p>MySQL 可以处理的优化类型包括：重新定义表的关联顺序、将外连接转化成内连接、使用等价变换规则、优化 COUNT() 和 MIN() 以及 MAX() 函数、预估并转为常数表达式、覆盖索引扫描、子查询优化等。</p>
<p><strong>查询执行引擎</strong></p>
<p>在解析和优化阶段，MySQL 将生成查询对应的执行计划，MySQL 的查询执行引擎则根据这个计划来完成整个查询。执行计划是一个数据结构，而不是其他关系型数据库那样会生成对应的字节码。查询执行阶段并不复杂，MySQL 只是简单的根据执行计划给出的指令逐步执行，再根据执行计划执行的过程中，有大量操作需要通过调用存储引擎实现的接口来完成。</p>
<p><strong>返回结果给客户端</strong></p>
<p>查询执行的最后一个阶段是将结果返回给客户端，即使查询不需要返回结果集，MySQL 仍然会返回这个查询的一些信息，如该查询影响到的行数。如果查询可以被缓存，那么 MySQL 会在这个阶段将结果存放到查询缓冲中。MySQL 将结果集返回客户端是一个增量、逐步返回的过程，这样做的好处是服务器无需存储太多的结果，减少内存消耗，也可以让客户端第一时间获得响应结果。结果集中的每一行给都会以一个满足 MySQL 客户端/服务器通信协议的包发送，再通过 TCP 协议进行传输，在 TCP 传输过程中可能对包进行缓存然后批量传输。</p>
<hr>
<h3 id="P14：优化-SQL"><a href="#P14：优化-SQL" class="headerlink" title="P14：优化 SQL"></a><font color = 'red'>P14：优化 SQL</font></h3><p><strong>优化 COUNT 查询</strong></p>
<p>COUNT 是一个特殊的函数，它可以统计某个列值的数量，在统计列值时要求列值是非空的，不会统计 NULL 值。如果在 COUNT 中指定了列或列的表达式，则统计的就是这个表达式有值的结果数，而不是 NULL。</p>
<p>COUNT 的另一个作用是统计结果集的行数，当 MySQL 确定括号内的表达式不可能为 NULL 时，实际上就是在统计行数。当使用 COUNT(<em>) 时，\</em> 不会扩展成所有列，它会忽略所有的列而直接统计所有的行数。</p>
<p>某些业务场景并不要求完全精确的 COUNT 值，此时可以使用近似值来代替，EXPLAIN 出来的优化器估算的行数就是一个不错的近似值，因为执行 EXPLAIN 并不需要真正地执行查询。</p>
<p>通常来说 COUNT 都需要扫描大量的行才能获取精确的结果，因此很难优化。在 MySQL 层还能做的就只有覆盖扫描了，如果还不够就需要修改应用的架构，可以增加汇总表或者外部缓存系统。</p>
<p><strong>优化关联查询</strong></p>
<p>确保 ON 或 USING 子句中的列上有索引，在创建索引时就要考虑到关联的顺序。</p>
<p>确保任何 GROUP BY 和 ORDER BY 的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引来优化这个过程。</p>
<p>在 MySQL 5.5 及以下版本尽量避免子查询，可以用关联查询代替，因为执行器会先执行外部的 SQL 再执行内部的 SQL。</p>
<p><strong>优化 GROUP BY</strong></p>
<p>如果没有通过 ORDER BY 子句显式指定要排序的列，当查询使用 GROUP BY 子句的时候，结果集会自动按照分组的字段进行排序，如果不关心结果集的顺序，可以使用 ORDER BY NULL 禁止排序。</p>
<p><strong>优化 LIMIT 分页</strong></p>
<p>在偏移量非常大的时候，需要查询很多条数据再舍弃，这样的代价非常高。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。最简单的办法是尽可能地使用覆盖索引扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。</p>
<p>还有一种方法是从上一次取数据的位置开始扫描，这样就可以避免使用 OFFSET。其他优化方法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做排序的数据列。</p>
<p><strong>优化 UNION 查询</strong></p>
<p>MySQL 通过创建并填充临时表的方式来执行 UNION 查询，除非确实需要服务器消除重复的行，否则一定要使用 UNION ALL，如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，这会导致对整个临时表的数据做唯一性检查，这样做的代价非常高。</p>
<p><strong>使用用户自定义变量</strong></p>
<p>在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。用户自定义变量是一个用来存储内容的临时容器，在连接 MySQL 的整个过程中都存在，可以在任何可以使用表达式的地方使用自定义变量。例如可以使用变量来避免重复查询刚刚更新过的数据、统计更新和插入的数量等。</p>
<p><strong>优化 INSERT</strong> </p>
<p>需要对一张表插入很多行数据时，应该尽量使用一次性插入多个值的 INSERT 语句，这种方式将缩减客户端与数据库之间的连接、关闭等消耗，效率比多条插入单个值的 INSERT 语句高。也可以关闭事务的自动提交，在插入完数据后提交。当插入的数据是按主键的顺序插入时，效率更高。</p>
<hr>
<h3 id="P15：复制"><a href="#P15：复制" class="headerlink" title="P15：复制"></a>P15：复制</h3><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。主库和备库之间可以有多种不同的组合方式。</p>
<p>MySQL 支持两种复制方式：基于行的复制和基于语句的复制，基于语句的复制也称为逻辑复制，从 MySQL 3.23 版本就已存在，基于行的复制方式在 5.1 版本才被加进来。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。</p>
<p>MySQL 复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库，但是老版本不能作为新版本服务器的备库，因为它可能无法解析新版本所用的新特性或语法，另外所使用的二进制文件格式也可能不同。</p>
<p>复制解决的问题：数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试。</p>
<p><strong>复制步骤</strong></p>
<p>概述：① 在主库上把数据更改记录到二进制日志中。② 备库将主库的日志复制到自己的中继日志中。 ③ 备库读取中继日志中的事件，将其重放到备库数据之上。</p>
<p>第一步是在主库上记录二进制日志，每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。</p>
<p>下一步，备库将主库的二进制日志复制到其本地的中继日志中。备库首先会启动一个工作的 IO 线程，IO 线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储线程，这个线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库 IO 线程会将接收到的事件记录到中继日志中。</p>
<p>备库的 SQL 线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当 SQL 线程追赶上 IO 线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL 线程执行的时间也可以通过配置选项来决定是否写入其自己的二进制日志中。</p>
<p>这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行，也就是说 IO 线程能够独立于 SQL 线程工作。但这种架构也限制了复制的过程，在主库上并发允许的查询在备库只能串行化执行，因为只有一个 SQL 线程来重放中继日志中的事件。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于一台电脑配置多个ssh密钥</title>
    <url>/2020/05/18/2020-05-18-%E5%85%B3%E4%BA%8E%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh%E5%AF%86%E9%92%A5/</url>
    <content><![CDATA[<blockquote>
<p>之前在自己电脑上配置了GitHub的ssh，实习时需要再配置另一个，配置完成之后发现无法<code>git clone</code>，解决方法在此记录。</p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h2><ul>
<li><code>ssh-keygen -t rsa -C xxx@mail.com</code>生成rsa文件；</li>
<li>复制<code>id_rsa.pub</code>文件中的<code>pub key</code>，添加到github或者对应的git网站中；</li>
<li><code>git clone ssh://git@github.com/xx/xxxxxxx</code></li>
</ul>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>如上，再重新添加一个时，</p>
<ul>
<li><p><code>ssh-keygen -t rsa -C xxx@companymail.com</code>生成另一个<code>id_rsa_company</code>，注意这一步自定义时换一下名称；</p>
</li>
<li><p>同上第二步</p>
</li>
<li><p><code>git clone ssh://git@git.company.com/xx/xxxxxxx</code>时却发现报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxx</span><br><span class="line">git@git.company.com: Permission denied (publickey).</span><br><span class="line">fatal: Counld not read from remote repository.</span><br><span class="line">xxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>对于一台电脑配置多个ssh密钥的解决方法：</p>
<ul>
<li><pre><code>ssh-keygen -t rsa -C &quot;123456@qq.com&quot; -f ~/.ssh/id_rsa
ssh-keygen -t rsa -C &quot;654321@qq.com&quot; -f ~/.ssh/id_rsa_1
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 对应git网站中分别添加上述生成的`id_rsa.pub`中内容即可</span><br><span class="line"></span><br><span class="line">* 在存放上述两个`id_rsa`文件的目录下`touch config`新建一个config文件并加入一下内容</span><br></pre></td></tr></table></figure>
# git@github.com
Host github.com
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_rsa
# git@git.company.com
Host git.company.com
    HostName git.company.com
    User git
    IdentityFile ~/.ssh/id_rsa_1

...
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 再进行`git clone ssh://git@git.company.com/xx/xxxxxxx`成功。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 另</span><br><span class="line"></span><br><span class="line">1. 删除本地全局设置</span><br><span class="line"></span><br><span class="line">   如果之前设置过`git config -global user.name` 和 `user.email`可能就需要用`git config -global unset user.name` 和 `user.email`删除掉，或者直接把用户目录下的.gitconfig文件删除，然后为每个仓库设置独立的用户名和邮箱，就是在仓库里面用上面的命令不要global选项</span><br><span class="line"></span><br><span class="line">2. **配置全局信息**</span><br></pre></td></tr></table></figure>
 $ git config --global user.name &quot;Firstname Lastname&quot;
 $ git config --global user.email &quot;your_email@example.com&quot;
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个命令会在`~/.gitconfig`填入以下信息：</span><br></pre></td></tr></table></figure>
 [user]
   name = Firstname Lastname
   email = your_email@example.com
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果需要修改信息，直接修改这个文件即可。</span><br><span class="line"></span><br><span class="line">**配置单独信息**</span><br></pre></td></tr></table></figure>
 $ cd your_project
 $ git config user.name &quot;Firstname Lastname&quot;
 $ git config user.email &quot;your_email@example.com&quot;</code></pre><p> 这个命令会在项目目录下输出文件：<code>/.git／.config</code></p>
<p> 这里设置的姓名和邮箱地址会用在 Git 的提交日志中。</p>
</li>
</ul>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC之Thrift</title>
    <url>/2020/05/12/2020-05-12-RPC%E4%B9%8BThrift/</url>
    <content><![CDATA[<blockquote>
<p>参照：<a href="https://www.cnblogs.com/yjmyzz/tag/thrift/" target="_blank" rel="noopener">https://www.cnblogs.com/yjmyzz/tag/thrift/</a></p>
</blockquote>
<blockquote>
<p>实习准备，需要了解一下Thrift，在此做简单记录。</p>
</blockquote>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li><strong>独立缩放</strong>。每一个服务的缩放可用三个轴来表示。x轴-水平可扩展，即某个服务器上的某个服务是否可以在其他服务器中同样部署；y-轴，业务可扩展，加入某个服务为UserService，其中包含很多账户相关信息，是否可抽离出AccountService；z-轴，数据可扩展，每个服务是否可以独立使用自己的一个数据库；</li>
<li><strong>独立发布和部署</strong>。遇到bug或者新版本发布，只部署对应服务即可，不必重新部署整个应用程序。</li>
<li><strong>独立开发</strong>。每个服务有自己的代码库，开发人员可专注于一项服务，只关注较小范围。</li>
<li><strong>优雅降级</strong>。如果服务崩溃，其影响不会涉及到其他服务，不会导致整个应用程序发生灾难性故障。</li>
<li><strong>分散治理</strong>。每个服务的开发人员可以选择自己独立的技术栈，指定最合适的策略。</li>
</ul>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>远程过程调用，其实就是实现某台机器调用另一台远程机器上的接口的技术手段。RPC框架所做的就是实现客户端调用服务器接口这个通信过程。</p>
<h1 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Thrift是一个FaceBook开源的高效RPC框架，其主要特点是跨语言及二进制高效传输（当然，除了二进制，也支持json等常用序列化机制）。</p>
<p>跨语言通常有二种做法，</p>
<p>一是将其它语言转换成某种主流的通用语言。</p>
<p>二是先定义一种规范文件（可以简单的理解为『母版』），然后由特定的编译器，将『母版』直接编译成目标语言的源代码。</p>
<p>Thrift走的是第二条路，使用Thrift框架时，先定义名为.thrift后缀的文件，然后由thrift编译器编译成指定语言的源文件，然后借助thrift提供的各种语言的实现lib库，完成RPC的调用。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>Windows下安装：</strong></p>
<p><a href="http://thrift.apache.org/docs/install/windows" target="_blank" rel="noopener">http://thrift.apache.org/docs/install/windows</a> 这是官网的windows安装指导说明，windows的安装其实最简单</p>
<p>官网： <a href="http://thrift.apache.org/download。" target="_blank" rel="noopener">http://thrift.apache.org/download。</a></p>
<p><a href="http://www.apache.org/dyn/closer.cgi?path=/thrift/0.13.0/thrift-0.13.0.tar.gz" target="_blank" rel="noopener">thrift-0.13.0.tar.gz</a></p>
<p>下载这二个文件即可，第1个是编译器，第2个压缩包里包括了种示例代码。把thrift-0.13.0.exe保存到某个目录，比如：E:\Thrift下，然后将thrift-0.13.0.exe改个简单的名字，比如：thrift.exe(这一步非必须)，最后在环境变量的path路径里，把E:\Thrift加上，保证Command窗口下，键入<code>thrift - version</code>能输出对应版本。</p>
<p><strong>centos 安装 :</strong></p>
<p><a href="http://thrift.apache.org/docs/install/centos" target="_blank" rel="noopener">http://thrift.apache.org/docs/install/centos</a> 参考这个安装，上面的详细的命令，按上面的命令一步步来就行了，主要过程是先安装一堆依赖的工具，然后</p>
<p>git clone <a href="https://git-wip-us.apache.org/repos/asf/thrift.git" target="_blank" rel="noopener">https://git-wip-us.apache.org/repos/asf/thrift.git</a></p>
<p>将thrift源代码拉到本地，再build，生成thrift编译器</p>
<p><strong>mac osx 安装：</strong></p>
<p><a href="http://thrift.apache.org/docs/install/os_x" target="_blank" rel="noopener">http://thrift.apache.org/docs/install/os_x</a> 参考这里，大概步骤跟centos差不多，相信大家都能搞定，唯一要注意的是，mac os上没有yum之类的工具，建议使用<a href="http://brew.sh/" target="_blank" rel="noopener">brew</a> 工具安装</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>demo样例参考：<a href="https://juejin.im/post/5afa19bf51882542653995b7" target="_blank" rel="noopener">https://juejin.im/post/5afa19bf51882542653995b7</a></p>
<ul>
<li><strong>IDEA中Thrift插件配置</strong></li>
</ul>
<ol>
<li>IDEA-Plugins安装<code>Thrift Support</code>插件，安装之后重启，<code>Compiler</code>中出现<code>Thrift compiler</code>即为安装成功。</li>
</ol>
<ul>
<li><strong>创建Thrift项目并编译生成RPC接口</strong></li>
</ul>
<ol>
<li><p>新建Thrift工程：<code>new project</code>–<code>Intellij Platform Plugin</code>–<code>Thrift</code>，（下一步选做，个人没成功）项目创建完成以后，在 <strong>Project Settings</strong> 中设置好 <strong>Facets</strong> 的 Thrift配置，添加一个 <strong>Java的Generator</strong>，在弹出的对话框中配置好 <strong>Output folder</strong> 路径，该路径用于存放由 <strong>thrift文件</strong> 转化而成的 <strong>java源文件</strong>。</p>
</li>
<li><p>在thrift工程的src目录下创建thrift接口文件：<code>RPCDateService.thrift</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">namespace java com.hansonwang99.thrift.interface</span><br><span class="line">service RPCDateService&#123;</span><br><span class="line">    <span class="function">string <span class="title">getDate</span><span class="params">(<span class="number">1</span>:string userName)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在该接口文件中，我们定义了一个 <strong>提供日期的Service</strong>，让客户端能通过该接口查询到服务器当前的时间</p>
</li>
<li><p>右击.thrift源文件，点击 <strong>Recompile ‘xxx.thrift’</strong> 即可完成 <strong>thrift接口文件 —&gt; java接口文件</strong> 的转换，生成的<code>xxx.java</code>文件在上述第2步配置的output路径中，但是本人没有成功，故采用以下方法：</p>
<p>命令行下先进入ThriftDemo\src\thrift所在目录，<code>thrift -r -gen java xxx.thrift</code>这样同样可以生成<code>xxx.java</code>文件</p>
</li>
</ol>
<ul>
<li><strong>开发ThriftAPI接口</strong></li>
</ul>
<ol>
<li><p>新建一个maven项目：ThriftAPI，pom.xml中添加thrift依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加java文件，将thrift文件编译生成的com/xxx/xxx.java文件夹整体拷贝到maven项目的java文件夹下</p>
</li>
<li><p><code>maven</code>–<code>Lifecycle</code>–<code>package</code>进行打包，生成jar包，注意这里需要在<code>Project Structure</code>中将jdk、modules等对应的版本都切换为1.8，本人系统默认的JDK11会出现问题。</p>
</li>
<li><p>因为接下来的server和client两份工程中的maven要引入该依赖，所以需要将生成的jar包添加到本地mvn仓库中（<a href="http://www.lwqgj.cn/771.html中的(二)）" target="_blank" rel="noopener">http://www.lwqgj.cn/771.html中的(二)）</a>:</p>
<ul>
<li><p>安装maven，这里不再具体阐述，下载-解压-添加环境变量(<a href="https://www.jianshu.com/p/62a76daf5096" target="_blank" rel="noopener">https://www.jianshu.com/p/62a76daf5096</a>)</p>
</li>
<li><p>mvn命令将jar包添加到本地maven库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=D:\Java\hansonwang99-SpringBoot_RPC_Thrift-master\SpringBoot_RPC_Thrift\ThriftAPI\target\ThriftAPI-1.0-SNAPSHOT.jar -DgroupId=com.hansonwang99 -DartifactId=ThriftAPI -Dversion=1.0-SNAPSHOT -Dpackaging=jar</span><br></pre></td></tr></table></figure>

<p>其中，<code>-Dfile</code>就是生成的jar包的路径，<code>-DgroupID</code>、<code>-Dartifacted</code>、<code>-Dversion</code>、<code>-Dpackaging</code>分别就是包路径、包名、包版本、打包方式，这些都要与ThriftAPI工程中pom.xml文件中的完全一致才可以。</p>
<p><img src="https://i.loli.net/2020/05/15/xEQs9k8fubp3Ddc.jpg" alt="添加成功截图"></p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>开发RPC服务端</strong></p>
<p>利用SpringBoot来实现RPC服务端。</p>
</li>
</ul>
<ol>
<li><p>pom.xml文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hansonwang99<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ThriftAPI<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">！--</span> 下方<span class="attr">thrift</span>的依赖原项目中没有，但是我这里不加会报错 <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Controller并实现RPC接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCDateServiceImpl</span> <span class="keyword">implements</span> <span class="title">RPCDateService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDate</span><span class="params">(String userName)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        Date now=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"今天是"</span>+<span class="string">"yyyy年MM月dd日 E kk点mm分"</span>);</span><br><span class="line">        String nowTime = simpleDateFormat.format( now );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + userName + <span class="string">"\n"</span> + nowTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将服务器当前时间以字符串形式返回给调用端！</p>
</li>
<li><p>编写RPCThriftServer：用于启动RPC服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCThriftServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;thrift.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;thrift.minWorkerThreads&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minThreads;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;thrift.maxWorkerThreads&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxThreads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TBinaryProtocol.Factory protocolFactory;</span><br><span class="line">    <span class="keyword">private</span> TTransportFactory transportFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RPCDateServiceImpl rpcDateService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        protocolFactory = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line">        transportFactory = <span class="keyword">new</span> TTransportFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RPCDateService.Processor processor = <span class="keyword">new</span> RPCDateService.Processor&lt;RPCDateService.Iface&gt;( rpcDateService );</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TServerTransport transport = <span class="keyword">new</span> TServerSocket(port);</span><br><span class="line">            TThreadPoolServer.Args tArgs = <span class="keyword">new</span> TThreadPoolServer.Args(transport);</span><br><span class="line">            tArgs.processor(processor);</span><br><span class="line">            tArgs.protocolFactory(protocolFactory);</span><br><span class="line">            tArgs.transportFactory(transportFactory);</span><br><span class="line">            tArgs.minWorkerThreads(minThreads);</span><br><span class="line">            tArgs.maxWorkerThreads(maxThreads);</span><br><span class="line">            TServer server = <span class="keyword">new</span> TThreadPoolServer(tArgs);</span><br><span class="line">            logger.info(<span class="string">"thrift服务启动成功, 端口=&#123;&#125;"</span>, port);</span><br><span class="line">            server.serve();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"thrift服务启动失败"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建SpringBootApplication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCThriftServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RPCThriftServer rpcThriftServer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(RPCThriftServerApplication.class, args);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rpcThriftServer = context.getBean(RPCThriftServer.class);</span><br><span class="line">            rpcThriftServer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">thrift.port</span>=<span class="string">6666</span></span><br><span class="line"><span class="meta">thrift.minWorkerThreads</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">thrift.maxWorkerThreads</span>=<span class="string">100</span></span><br></pre></td></tr></table></figure>

<p>让thrift服务起在6666端口。</p>
</li>
</ol>
<ul>
<li><p><strong>开发RPC客户端</strong></p>
<p>同样用SpringBoot来实现RPC客户端。</p>
</li>
</ul>
<ol>
<li><p>pom.xml中添加依赖，同服务器端。</p>
</li>
<li><p>编写RPCThriftClient：用于发出RPC调用，包括两部分。</p>
<p><code>RPCThriftClient.java</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCThriftClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RPCDateService.Client client;</span><br><span class="line">    <span class="keyword">private</span> TBinaryProtocol protocol;</span><br><span class="line">    <span class="keyword">private</span> TSocket transport;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(String host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        transport = <span class="keyword">new</span> TSocket(host, port);</span><br><span class="line">        protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">        client = <span class="keyword">new</span> RPCDateService.Client(protocol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RPCDateService.<span class="function">Client <span class="title">getRPCThriftService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> TTransportException </span>&#123;</span><br><span class="line">        transport.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        transport.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RPCThriftClientConfig.java</code>是利用config生成bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCThriftClientConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;thrift.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;thrift.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RPCThriftClient <span class="title">rpcThriftClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RPCThriftClient rpcThriftClient = <span class="keyword">new</span> RPCThriftClient();</span><br><span class="line">        rpcThriftClient.setHost(host);</span><br><span class="line">        rpcThriftClient.setPort(port);</span><br><span class="line">        <span class="keyword">return</span> rpcThriftClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Restful的Controller作为调用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hansonwang99"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCThriftContoller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RPCThriftClient rpcThriftClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/thrift"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">thriftTest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rpcThriftClient.open();</span><br><span class="line">            <span class="keyword">return</span> rpcThriftClient.getRPCThriftService().getDate(<span class="string">"hansonwang99"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"RPC调用失败"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rpcThriftClient.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建SpringBootApplication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCThriftClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RPCThriftClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件application.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thrift.host=localhost</span><br><span class="line">thrift.port=<span class="number">6666</span></span><br><span class="line">server.port=<span class="number">9999</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><strong>通信实验</strong></li>
</ul>
<ol>
<li>分别启动服务器端和客户端的应用。</li>
<li>浏览器输入：<code>localhost:9999/hansonwang99/thrift</code> 即可查看客户端从服务端取回的服务器当前时间，说明RPC通信过程打通。</li>
</ol>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title>length&length()&size()区别</title>
    <url>/2020/05/11/2020-05-11-length&amp;length()&amp;size()%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>白板写代码时经常分不清这三者区别，这里分辨一下。</p>
</blockquote>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>Java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性；</li>
<li>Java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法；</li>
<li>Java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看；</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String []list=&#123;<span class="string">"ma"</span>,<span class="string">"cao"</span>,<span class="string">"yuan"</span>&#125;;</span><br><span class="line">        String a=<span class="string">"macaoyuan"</span>;</span><br><span class="line">        System.out.println(list.length);</span><br><span class="line">        System.out.println(a.length());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; array=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        array.add(a);</span><br><span class="line">        System.out.println(array.size());</span><br><span class="line">    &#125;</span><br><span class="line">---------------------------------------------</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">    <span class="number">1</span></span><br></pre></td></tr></table></figure>





<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录3</title>
    <url>/2020/03/16/2020-03-16-Leetcode%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<blockquote>
<p>这里不对每道题都做记录。</p>
</blockquote>
<ul>
<li>904题， Fruit Into Baskets，中等难度，题目比较难读懂，其实简单来说就是找出数组中长度最大的连续由2种元素构成的子数组，返回这个子数组的长度。HashMap+滑动窗口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, start = <span class="number">0</span>; <span class="comment">//start为滑动窗口头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">            count.put(tree[i], count.getOrDefault(tree[i], <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">//如果存在key对应的value,则value+1;如果key不存在，则value设为默认值0+1</span></span><br><span class="line">        <span class="keyword">while</span>(count.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            count.put(tree[start], count.get(tree[start]) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(count.get(tree[start]) == <span class="number">0</span>)&#123;</span><br><span class="line">                count.remove(tree[start]);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">            res = Math.max(res, i - start +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>41题，First Missing Positive，找出给出的数组中没有出现的最小正整数。重点是要求时间复杂度O(n)，另外空间复杂度O(1)，那么只能覆盖原有数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//桶排序的思想</span></span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums.length &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[nums[i]-<span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                i--;    <span class="comment">//不要忘了这一步</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length+<span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>152，Maximum Product Subarray，寻找最大乘积的子数组。DP，保留一个到某一位来看的最大值和最小值。因为在数组中有负数的出现，所以到这一位为止的能得到的最大值，可能是由之前的最大值和这个数相乘得到，也可能是最小值和这个数相乘得到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> global = nums[<span class="number">0</span>]; <span class="comment">//全局最优</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>]; <span class="comment">//记录局部最大值</span></span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>]; <span class="comment">//记录局部最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length; i++)  &#123;   <span class="comment">//注意从1开始</span></span><br><span class="line">            <span class="comment">// 最大值一定在max*nums[i], min*nums[i]), nums[i]三个数之间</span></span><br><span class="line">            <span class="comment">// 更新max,min</span></span><br><span class="line">            <span class="keyword">int</span> maxTemp = Math.max(max * nums[i], min * nums[i]); <span class="comment">//Math的max方法只能比较两个数的大小</span></span><br><span class="line">            <span class="keyword">int</span> minTemp = Math.min(max * nums[i], min * nums[i]);</span><br><span class="line">            max = Math.max(maxTemp, nums[i]);  </span><br><span class="line">            min = Math.min(minTemp, nums[i]);</span><br><span class="line"></span><br><span class="line">            global = Math.max(global, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>142，Linked List Cycle II，环形链表。置快指针每次走两步、慢指针每次走一步，当它们相遇时，表示该链表有环。然后再将slow指针指向头结点，slow和fast同时向前走，下一个相遇的点即是入环节点。</p>
<p><img src="https://i.loli.net/2020/03/17/eCzKVZT6kaBRguP.png" alt="图解.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          ListNode slow = head;</span><br><span class="line">          ListNode fast = head;</span><br><span class="line">          <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">              fast = fast.next.next;</span><br><span class="line">              slow = slow.next;</span><br><span class="line">              <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                  fast = head;      <span class="comment">//fast指向头，同时变慢</span></span><br><span class="line">                  <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">                      fast = fast.next;  </span><br><span class="line">                      slow = slow.next;</span><br><span class="line">                  &#125; </span><br><span class="line">                  <span class="keyword">return</span> slow;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="54">
<li><p>Spiral Matrix，螺旋矩阵，下边给个高票答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> rowBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowEnd = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> colBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> colEnd = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123;</span><br><span class="line">            <span class="comment">// Traverse Right</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = colBegin; i &lt;= colEnd; ++i) &#123;</span><br><span class="line">                res.add(matrix[rowBegin][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rowBegin++;</span><br><span class="line">            <span class="comment">// Traverse Down</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = rowBegin; i &lt;= rowEnd; ++i) &#123;</span><br><span class="line">                res.add(matrix[i][colEnd]);</span><br><span class="line">            &#125;</span><br><span class="line">            colEnd--;</span><br><span class="line">            <span class="comment">// Traverse Left</span></span><br><span class="line">            <span class="keyword">if</span>(rowBegin &lt;= rowEnd) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = colEnd; i &gt;= colBegin; i--) &#123;</span><br><span class="line">                    res.add(matrix[rowEnd][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                rowEnd--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Traver Up</span></span><br><span class="line">            <span class="keyword">if</span>(colBegin &lt;= colEnd) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = rowEnd; i &gt;= rowBegin; i--) &#123;</span><br><span class="line">                    res.add(matrix[i][colBegin]);</span><br><span class="line">                &#125;</span><br><span class="line">                colBegin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>39题，combination Sum，在给出的数中找到和为target的组合，回溯递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">// 组合得到target</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;()；</span><br><span class="line">        dfs(res,temp,target,candidates,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp, <span class="keyword">int</span> target,<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;  <span class="comment">//target为0，说明已找到合适的结果,将中间集加入结果集</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; candidates.length &amp;&amp; target &gt; candidates[i]; i++) &#123;</span><br><span class="line">            temp.add(candidates[i]);</span><br><span class="line">            dfs(res, temp, target - candidates[i], candidates, i);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于回溯：<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/</a></p>
</li>
<li><p>63题. Unique Paths II，DP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">//左上开始计数为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 填充第一列和第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;    <span class="comment">// 如果当前块无阻碍且前一块可走到当前块，当前块计数为1</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                obstacleGrid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                obstacleGrid[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; col; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i-<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                obstacleGrid[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                obstacleGrid[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>56题，区间合并。这道题目分析之前先了解一下Arrays.sort()之前没见过的用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char）</span></span><br><span class="line">        <span class="comment">//而要使用它们对应的类</span></span><br><span class="line">        Integer[] a = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//定义一个自定义类MyComparator的对象</span></span><br><span class="line">        Comparator cmp = <span class="keyword">new</span> MyComparator();</span><br><span class="line">        Arrays.sort(a, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Comparator是一个接口，所以这里我们自己定义的类MyComparator要implents该接口</span></span><br><span class="line"><span class="comment">//而不是extends Comparator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果o1小于o2，我们就返回正值，如果o1大于o2我们就返回负值，</span></span><br><span class="line">        <span class="comment">//这样颠倒一下，就可以实现反向排序了</span></span><br><span class="line">        <span class="keyword">if</span> (o1 &lt; o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">// 钉钉面试，数组合并</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution27</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] arr) &#123;</span><br><span class="line">        Arrays.parallelSort(arr, Comparator.comparingInt(x -&gt; x[<span class="number">0</span>]));  <span class="comment">//lambda表达式，按照数组左端点排序</span></span><br><span class="line">        <span class="comment">//匿名内部类写法</span></span><br><span class="line"><span class="comment">/*        Arrays.sort(arr, new Comparator&lt;int[]&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(int[] o1, int[] o2) &#123;</span></span><br><span class="line"><span class="comment">                return o1[0] - o2[0];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">0</span> || list.getLast()[<span class="number">1</span>] &lt; arr[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                list.add(arr[i]);<span class="comment">//集合为空，或不满足条件，向后新增</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//满足条件，集合最后元素的end=最大值</span></span><br><span class="line">                list.getLast()[<span class="number">1</span>] = Math.max(list.getLast()[<span class="number">1</span>], arr[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>];<span class="comment">//生成结果数组</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;<span class="comment">//遍历集合</span></span><br><span class="line">            res[index++] = list.removeFirst();<span class="comment">//删除集合首元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</li>
</ul>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于后端运行出现的一些错误或警告</title>
    <url>/2020/01/12/2020-01-12-%E5%85%B3%E4%BA%8E%E5%90%8E%E7%AB%AF%E8%BF%90%E8%A1%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF%E6%88%96%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p>解决项目中的问题。</p>
</blockquote>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-01-10 02:01:14.103  INFO 15864 --- [nio-8081-exec-7] o.apache.coyote.http11.Http11Processor   : Error parsing HTTP request header</span><br><span class="line"> Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: Invalid character found in method name. HTTP method names must be tokens</span><br><span class="line">	at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:415) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]</span><br><span class="line">	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:292) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]</span><br><span class="line">	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.27.jar!/:9.0.27]</span><br><span class="line">	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:861) [tomcat-embed-core-9.0.27.jar!/:9.0.27]</span><br><span class="line">	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1579) [tomcat-embed-core-9.0.27.jar!/:9.0.27]</span><br><span class="line">	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.27.jar!/:9.0.27]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_231]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_231]</span><br><span class="line">	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.27.jar!/:9.0.27]</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_231]</span><br></pre></td></tr></table></figure>

<p>在发起请求时，浏览器自动在前面加了https，但是由于域名没有ssl认证，所以会报这个错误，去掉https中的’s’就好了 。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-01-10 18:43:48.484  WARN 15864 --- [nio-8081-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /</span><br></pre></td></tr></table></figure>

<p>因为是加了拦截器后才反生这样情况，应该是拦截器没有能够成功加载资源文件 </p>
<p>原拦截器在config/MvcConfig中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MvcConfig extends WebMvcConfigurationSupport &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决办法如下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但<code>WebMvcConfigurerAdapter</code>在springboot2.0之后已经被抛弃，所以改为spring boot官方推荐的这个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/var/lib/mysql/mysql.sock&apos; (2)</span><br></pre></td></tr></table></figure>

<p>服务器重启之后mysql出现问题，重启服务器。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下安装MongoDB</title>
    <url>/2020/01/08/2020-01-08-windows%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB/</url>
    <content><![CDATA[<blockquote>
<p>中间不少踩坑，记录最后成功方法。</p>
</blockquote>
<h1 id="一、MongoDB简介"><a href="#一、MongoDB简介" class="headerlink" title="一、MongoDB简介"></a>一、MongoDB简介</h1><p>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成，MongoDB文档类似于JSON对象，字段值可以包含其他文档，数组及文档数组。</p>
<p>MongoDB服务端可运行在Linux、Windows或mac os x平台，支持32位和64位应用，默认端口为27017。</p>
<p>MongoDB支持各种编程语言: Python，Java，C++，PHP，C#等多种语言。</p>
<h1 id="二、下载MongoDB"><a href="#二、下载MongoDB" class="headerlink" title="二、下载MongoDB"></a>二、下载MongoDB</h1><p>MongoDB提供了可用于32位系统和64位系统的预编译二进制包（新版本没有了32位系统的安装文件），你可以进入MongoDB官网下载安装，MongoDB的预编译二进制包的下载地址为：<a href="https://www.mongodb.com/download-center/community，打开之后会看到如下图，直接点击Download下载即可，也可以在Version中选择你想要的版本：" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community，打开之后会看到如下图，直接点击Download下载即可，也可以在Version中选择你想要的版本：</a></p>
<p><img src="https://i.loli.net/2020/01/08/9HTaAOJyLYwmG3P.jpg" alt="下载"></p>
<h1 id="三、安装MongoDB"><a href="#三、安装MongoDB" class="headerlink" title="三、安装MongoDB"></a>三、安装MongoDB</h1><p>双击打开文件进行安装，在安装过程中，可以通过点击 “Custom(自定义)” 按钮来设置你的安装目录。 之后稍微等待一会就安装好了。 </p>
<h1 id="四、配置MongoDB"><a href="#四、配置MongoDB" class="headerlink" title="四、配置MongoDB"></a>四、配置MongoDB</h1><p>MongoDB的安装过程是很简单的，但是配置就比较麻烦了，可能会遇到各种各样的问题，需要你有足够的耐心和仔细。</p>
<p>首先要在MongoDB的data文件夹里新建一个db文件夹；</p>
<p>然后在cmd窗口中运行如下命令：<code>mongod --dbpath E:\MongoDB\data\db</code></p>
<p> 运行成功之后，我们打开浏览器，输入127.0.0.1:27017 , 看到显示<code>It looks like you are trying to access MongoDB over HTTP on the native driver port.</code>，就说明MongoDB服务已经成功启动了。 </p>
<p>但是如果每次都要这么启动服务的话很显然太麻烦了，这里可以选择设置成开机自启动，也可以选择用命令<code>net start|stop MongoDB</code>来手动启动或关闭，这里我选择使用后者，具体方法如下。</p>
<p>还是打开cmd窗口，不过这次是以管理员身份运行，然后输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod --dbpath &quot;E:\MongoDB\data&quot; --logpath &quot;E:\MongoDB\log\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot;</span><br></pre></td></tr></table></figure>

<p> 如果没有报错的话就说明成功添加到服务里了，可以使用win+R然后输入services.msc命令进行查看： </p>
<p><img src="https://i.loli.net/2020/01/08/4SETaCnqQI75HNw.png" alt="image.png"></p>
<p> 然后在cmd窗口中运行<code>net start MongoDB</code>： </p>
<p><img src="https://i.loli.net/2020/01/08/fRBFzPIdtMx3Wba.png" alt="image.png"></p>
<p>怎么解决呢？两个步骤：</p>
<p>1）运行sc delete mongodb删除服务；</p>
<p>2）再运行一次配置服务的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod --dbpath &quot;E:\MongoDB\data&quot; --logpath &quot;E:\MongoDB\log\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot;</span><br></pre></td></tr></table></figure>

<p> 然后再运行<code>net start MongoDB</code>，服务启动成功： </p>
<p><img src="https://i.loli.net/2020/01/08/aAGJ4kQrN5qpsLd.png" alt="image.png"></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB学习</title>
    <url>/2020/01/08/2020-01-08-MongoDB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、MongoDB快速入门"><a href="#一、MongoDB快速入门" class="headerlink" title="一、MongoDB快速入门"></a>一、MongoDB快速入门</h1><p><strong>RDBMS VS MongoDB</strong></p>
<p>直接给出的表显示RDBMS(关系型数据库管理系统)术语 与 MongoDB 的关系，直观明了：</p>
<table>
<thead>
<tr>
<th>SQL术语/概念</th>
<th>MongoDB术语/概念</th>
<th>解释/说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据属性/字段(域)</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td>Embedded Documents</td>
<td>表连接,MongoDB3.2提供了Join操作</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键,MongoDB默认自动将_id字段设置为主键,可以手动设置</td>
</tr>
</tbody></table>
<p> 通过下图实例，也可以更直观的的了解Mongo中的一些概念： </p>
<p><img src="https://i.loli.net/2020/01/08/wRUscWqHzxnmP4F.png" alt="image.png"></p>
<h1 id="二、MongoDB基本操作"><a href="#二、MongoDB基本操作" class="headerlink" title="二、MongoDB基本操作"></a>二、MongoDB基本操作</h1><p> Mongo自带shell客户端： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mongo</span><br><span class="line"></span><br><span class="line">&gt; show dbs                     show database names</span><br><span class="line"></span><br><span class="line">&gt; db</span><br><span class="line">    查看当前数据库的名称</span><br><span class="line"></span><br><span class="line">&gt; show collections             </span><br><span class="line">    显示当前数据库的所有集合</span><br><span class="line"></span><br><span class="line">&gt; use foolbar</span><br><span class="line">    切换到foolbar数据库,如果foolbar数据库不存在,会在该数据第一次插入之后创建</span><br><span class="line"></span><br><span class="line">&gt; show collections;</span><br><span class="line">    显示当前数据库中有哪些集合,起初为空</span><br><span class="line"></span><br><span class="line">&gt;db.blog.insert(&#123;&quot;title1&quot;:&quot;instrduce of mongo&quot;&#125;);</span><br><span class="line">    WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line">    第一次插入数据会创建数据库(集合) 插入的数据是一个文档  </span><br><span class="line"></span><br><span class="line">&gt; db.blog.find()</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ecd83853a67e204962ae&quot;), &quot;title1&quot; : &quot;instrduce of mongo&quot; &#125;</span><br><span class="line">    查找当前数据库中blog集合的所有文档</span><br><span class="line"></span><br><span class="line">&gt; db.blog.insert(&#123;&quot;docment&quot;:&quot;hello mongoDB!&quot;&#125;);</span><br><span class="line">    WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.blog.find()</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ecd83853a67e204962ae&quot;), &quot;title1&quot; : &quot;instrduce of mongo&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ed873853a67e204962af&quot;), &quot;docment&quot; : &quot;hello mongoDB!&quot; &#125;</span><br><span class="line"></span><br><span class="line">&gt; db.blog.insert(&#123;&quot;title&quot; : &quot;mytest&quot;, &quot;name&quot; : &quot;pc&quot;&#125;);</span><br><span class="line">    WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.blog.insert(&#123;&quot;title&quot; : &quot;mytest&quot;, &quot;name&quot; : &quot;pc&quot;&#125;);</span><br><span class="line">    WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.blog.insert(&#123;&quot;name&quot; : &quot;xwp&quot;&#125;);</span><br><span class="line">    WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.blog.insert(&#123;&quot;name&quot; : &quot;xwp&quot;&#125;);</span><br><span class="line">    WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.blog.find()</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;550247c18976c0e0b467e800&quot;), &quot;title&quot; : &quot;mytest&quot;, &quot;name&quot; : &quot;pc&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;550248468976c0e0b467e801&quot;), &quot;name&quot; : &quot;xwp&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ecd83853a67e204962ae&quot;), &quot;title1&quot; : &quot;instrduce of mongo&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ed873853a67e204962af&quot;), &quot;docment&quot; : &quot;hello mongoDB!&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503edee3853a67e204962b0&quot;), &quot;title&quot; : &quot;mytest&quot;, &quot;name&quot; : &quot;pc&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ee013853a67e204962b1&quot;), &quot;name&quot; : &quot;xwp&quot; &#125;</span><br><span class="line"></span><br><span class="line">&gt; db.blog.remove(&#123;_id :  ObjectId(&quot;550247c18976c0e0b467e800&quot;)&#125;);</span><br><span class="line">    WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)</span><br><span class="line">    从当前数据库中的blog集合中移除_id为ObjectId(&quot;550247c18976c0e0b467e800&quot;)的文档</span><br><span class="line"></span><br><span class="line">&gt; db.blog.find()</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;550248468976c0e0b467e801&quot;), &quot;name&quot; : &quot;xwp&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ecd83853a67e204962ae&quot;), &quot;title1&quot; : &quot;instrduce of mongo&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ed873853a67e204962af&quot;), &quot;docment&quot; : &quot;hello mongoDB!&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503edee3853a67e204962b0&quot;), &quot;title&quot; : &quot;mytest&quot;, &quot;name&quot; : &quot;pc&quot; &#125;</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5503ee013853a67e204962b1&quot;), &quot;name&quot; : &quot;xwp&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; show collections;</span><br><span class="line">    blog</span><br><span class="line"></span><br><span class="line">&gt; db.createCollection(&quot;xunlei&quot;);</span><br><span class="line">    &#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">    在当前数据库创建一个指定名称的集合</span><br><span class="line"></span><br><span class="line">&gt; show collections;</span><br><span class="line">    blog</span><br><span class="line">    xunlei</span><br><span class="line"></span><br><span class="line">&gt;db.blog.findOne()</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;550248468976c0e0b467e801&quot;), &quot;name&quot; : &quot;xwp&quot; &#125;</span><br><span class="line">    这个shell函数findOne会返回一个文档 而find函数会返回最多二十个文档.更多区别我们在后面详细介绍.</span><br><span class="line"></span><br><span class="line">&gt;db.blog.count()</span><br><span class="line">    5</span><br><span class="line">    统计集合blog所有文档数量</span><br><span class="line"></span><br><span class="line">ctrl+c退出mongo客户端</span><br></pre></td></tr></table></figure>

<p>最基本操作上述可见，补充一些：</p>
<ul>
<li><strong>pretty() 方法</strong></li>
</ul>
<p>结果显示在一个格式化的方式，可以使用 pretty() 方法.</p>
<p><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;db.mycol.find().pretty()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MongoDB中AND</strong></li>
</ul>
<p><strong>语法:</strong></p>
<p>在 find() 方法，如果通过多个键分离’,’，那么 MongoDB 处理 AND 条件。AND 基本语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MongoDB中OR</strong></li>
</ul>
<p><strong>语法:</strong></p>
<p>OR条件的基础上要查询文件，需要使用$or关键字。OR 基本语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;db.mycol.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MongoDB 与 RDBMS Where 语句比较</strong></li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>语法</th>
<th>例子</th>
<th>RDBMS 等同</th>
</tr>
</thead>
<tbody><tr>
<td>Equality</td>
<td>{&lt; key&gt;:&lt; value&gt;}</td>
<td>db.mycol.find({“by”:”tutorials itcast”}).pretty()</td>
<td>where by = ‘tutorials itcast’</td>
</tr>
<tr>
<td>Less Than</td>
<td>{&lt; key&gt;:{$lt:&lt; value&gt;}}</td>
<td>db.mycol.find({“likes”:{$lt:50}}).pretty()</td>
<td>where likes &lt; 50</td>
</tr>
<tr>
<td>Less Than Equals</td>
<td>{&lt; key&gt;:{$lte:&lt; value&gt;}}</td>
<td>db.mycol.find({“likes”:{$lte:50}}).pretty()</td>
<td>where likes &lt;= 50</td>
</tr>
<tr>
<td>Greater Than</td>
<td>{&lt; key&gt;:{$gt:&lt; value&gt;}}</td>
<td>db.mycol.find({“likes”:{$gt:50}}).pretty()</td>
<td>where likes &gt; 50</td>
</tr>
<tr>
<td>Greater Than Equals</td>
<td>{&lt; key&gt;:{$gte:&lt; value&gt;}}</td>
<td>db.mycol.find({“likes”:{$gte:50}}).pretty()</td>
<td>where likes &gt;= 50</td>
</tr>
<tr>
<td>Not Equals</td>
<td>{&lt; key&gt;:{$ne:&lt; value&gt;}}</td>
<td>db.mycol.find({“likes”:{$ne:50}}).pretty()</td>
<td>where likes != 50</td>
</tr>
</tbody></table>
<ul>
<li><strong>更新操作 在 MongoDB update() 和 SQL Update 区别</strong></li>
</ul>
<table>
<thead>
<tr>
<th>SQL Update Statements</th>
<th>MongoDB update() Statements</th>
</tr>
</thead>
<tbody><tr>
<td><code>UPDATE users SET status = &quot;C&quot; WHERE age &gt; 25</code></td>
<td><code>db.users.update(   { age: { $gt: 25 } },   { $set: { status: &quot;C&quot; } },   { multi: true } )</code></td>
</tr>
<tr>
<td><code>UPDATE users SET age = age + 3 WHERE status = &quot;A&quot;</code></td>
<td><code>db.users.update(   { status: &quot;A&quot; } ,   { $inc: { age: 3 } },   { multi: true } )</code></td>
</tr>
</tbody></table>
<ul>
<li>在执行remove()函数前先执行find()命令来判断执行的条件是否正确，这是一个比较好的习惯。<strong>remove命令一定要三思而后行！！</strong></li>
</ul>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat中如何复制数据库</title>
    <url>/2020/01/07/2020-01-07-Navicat%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<blockquote>
<p>解决项目中的问题</p>
</blockquote>
<h1 id="转存为SQL"><a href="#转存为SQL" class="headerlink" title="转存为SQL"></a>转存为SQL</h1><p><img src="https://i.loli.net/2020/01/07/B5NWZnUX8KIiuEk.jpg" alt="转存为SQL"></p>
<p>如上图所示，转存为sql，在另一个数据库中再逐表新建。</p>
<h1 id="使用备份"><a href="#使用备份" class="headerlink" title="使用备份"></a>使用备份</h1><ol>
<li><p>选中需要被复制的数据库，选择备份，右键备份菜单，选择新建备份，输入名字保存确定。 注意查看备份路径。</p>
<p><img src="https://i.loli.net/2020/01/07/CizrAhslc1b7UaH.jpg" alt="Snipaste_2020-01-07_15-30-49.jpg"></p>
</li>
<li><p>新建一个数据库，选中后，右键备份菜单，选择还原备份，弹出窗口后选择上一步的备份文件，然后开始导入即可。 </p>
</li>
</ol>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于项目部署服务器后更换</title>
    <url>/2019/12/26/2019-12-26-%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E6%9B%B4%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>基于阿里云cetos7.4的项目。在此记录一下。</p>
</blockquote>
<h1 id="更换前端"><a href="#更换前端" class="headerlink" title="更换前端"></a>更换前端</h1><p>直接将<code>npm run build</code>打包生成的文件在apache-tomcat-8.5.45/webapps/heater中替换即可。</p>
<h1 id="更换后端jar包"><a href="#更换后端jar包" class="headerlink" title="更换后端jar包"></a>更换后端jar包</h1><p>先<code>jps</code>查看运行的进程，<code>kill -9 进程号</code>杀死，然后<code>service redis_6379 stop</code>停止redis，再上传新的jar包，<code>service redis_6379 start</code>启动redis，最后<code>nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log 2&gt;&amp;1 &amp;</code>后台运行jar包，立即网页查看可能会出现network error，稍等即可。</p>
<h1 id="开机重启"><a href="#开机重启" class="headerlink" title="开机重启"></a>开机重启</h1><ul>
<li><p>init 6 /reboot重启</p>
</li>
<li><p>开启firewallD，<code>service firewalld restart</code></p>
</li>
<li><p>开启mysql，已开机自启</p>
</li>
<li><p>开启redis，已开机自启</p>
</li>
<li><p>前端运行，<code>cd /</code>    <code>cd /usr/local/tomcat/apache-tomcat-8.5.45/bin</code>   <code>sh shartup.sh</code></p>
</li>
<li><p>后端运行 <code>cd /</code>   <code>cd home</code>    <code>nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log 2&gt;&amp;1 &amp;</code></p>
</li>
<li><p>重启之后遇到过redis的6379.conf配置文件变更的情况导致无法远程连接，按照之前<a href="https://gsynf.top/2019/12/18/2019-12-18-CentOS7%E4%B8%8B%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE/#more" target="_blank" rel="noopener">Centos7下后端配置</a>中的介绍再次修改即可。</p>
</li>
</ul>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>vue</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系列补充</title>
    <url>/2019/12/23/2019-12-23-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照寒小阳<a href="https://blog.csdn.net/han_xiaoyang" target="_blank" rel="noopener">系列博客</a>，部分代码由于引用包的问题会有<a href="https://www.kesci.com/home/project/5bfe39b3954d6e0010681cd1" target="_blank" rel="noopener">修改</a>，B站也有其Kaggle学习视频，感谢。这里只针对其博客某些地方进行补充。</p>
</blockquote>
<h1 id="逻辑回归初步"><a href="#逻辑回归初步" class="headerlink" title="逻辑回归初步"></a>逻辑回归初步</h1><ul>
<li>对于某些数据分布，很难从线性模型中找到一个直线能较好的分离开两种数据。而逻辑回归诞生就是为了干这事的，逻辑回归简单来说就等于线性回归乘以sigmoid函数，通过逻辑回归，我们可以将线性回归得到的可能无穷多的值，压缩到0和1的范围内。</li>
</ul>
<h1 id="从初等数学视角解读逻辑回归"><a href="#从初等数学视角解读逻辑回归" class="headerlink" title="从初等数学视角解读逻辑回归"></a>从初等数学视角解读逻辑回归</h1><p>博客中图片全挂，无法阅读，<a href="https://chenrudan.github.io/blog/2016/01/09/logisticregression.html" target="_blank" rel="noopener">以此代之</a>。（有点复杂……）</p>
<h1 id="逻辑回归应用之Kaggle泰坦尼克之灾"><a href="#逻辑回归应用之Kaggle泰坦尼克之灾" class="headerlink" title="逻辑回归应用之Kaggle泰坦尼克之灾"></a>逻辑回归应用之Kaggle泰坦尼克之灾</h1><ul>
<li>jupyter实现代码自动补全<ul>
<li>Anaconda Prompt中<code>python -m pip install jupyter_contrib_nbextensions</code></li>
<li>Anaconda Prompt中<code>jupyter contrib nbextension install --user --skip-running-check</code></li>
<li>上面两个步骤都没报错后，启动 Jupyter Notebook，上面选项栏会出现 Nbextensions 的选项 </li>
<li>Nbextensions 中勾选 “Table of Contents” 以及 “Hinterland” </li>
</ul>
</li>
<li>matplotlib.pyplot绘图中文标签无法显示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>] <span class="comment">#用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="literal">False</span> <span class="comment">#用来正常显示负号</span></span><br></pre></td></tr></table></figure>

<ul>
<li>matplotlib画多个子图时重叠</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">fig = plt.figure()</span><br><span class="line"> </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">具体的画图程序</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>Pad:用于设置绘图区边缘与画布边缘的距离大小</p>
<p>w_pad:用于设置绘图区之间的水平距离的大小</p>
<p>H_pad:用于设置绘图区之间的垂直距离的大小</p>
<p>例子：</p>
<p>fig.tight_layout(pad=0.4, w_pad=3.0, h_pad=3.0)</p>
<ul>
<li>Matplotlib绘图时x轴标签重叠</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig=plt.figure(figsize=(<span class="number">12</span>,<span class="number">10</span>)) <span class="comment"># 设置画布大小</span></span><br></pre></td></tr></table></figure>

<ul>
<li>as_matrix() 报警告<code>FutureWarning: Method .as_matrix will be removed in a future version. Use .values  instead</code>, 根据提示：把<code>as_matrix()</code>改为<code>values</code>即可 </li>
<li>利用Logistic回归算法进行数据建模 ，提示警告<code>FutureWarning: Default solver will be changed to &#39;lbfgs&#39;……</code>，解决方法：传入参数后即可消除警告：<code>clf = linear_model.LogisticRegression(C=1.0, penalty=&#39;l1&#39;, tol=1e-6, solver=&#39;liblinear&#39;)</code>， LogisticRegerssion算法的solver仅支持以下几个参数’liblinear’, ‘newton-cg’, ‘lbfgs’, ‘sag’, ‘saga’。 </li>
<li>pandas有时因为行数或列数太多显示不全，而用省略号代替</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.options.display.max_columns = <span class="literal">None</span></span><br><span class="line">pd.options.display.max_rows = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 以下无效</span></span><br><span class="line"><span class="comment"># pd.set_option('display.max_rows', None)    # 显示的最大行数（避免只显示部分行数据）</span></span><br><span class="line"><span class="comment"># pd.set_option('display.max_columns', None)   # 显示的最大列数（避免列显示不全）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关于以下疑问： “以Cabin为例，原本一个属性维度，因为其取值可以是[‘yes’,’no’]，而将其平展开为’Cabin_yes’,’Cabin_no’两个属性”，可是直接将cabin作为一个属性，1代表有，0代表无就可以，sex也一样，1代表男，0代表女，为什么非要弄成两个属性呢？<ul>
<li>答：这样也可以, 不过这里用 dummies 函数自带的功能进行 one-hot 更好,因为后面1,2,3等舱位变成100, 010, 001,如果手动改成0,1,2,数据的范围就不统一了,不利于后面的训练 就 sex 而言, 手动改成0,1完全可以，但也就不符合one-hot编码了</li>
</ul>
</li>
<li>在使用其他分类器部分44行<code>if str.find(big_string, substring) != -1:</code>报错<code>AttributeError: module &#39;string&#39; has no attribute &#39;find&#39;</code>，这是因为python版本升级，函数名称已有改变，只需要将string改为str即可。</li>
<li>在使用其他分类器部分190行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grid_search = GridSearchCV(pipeline, param_grid=param_grid, verbose=<span class="number">3</span>,scoring=<span class="string">'accuracy'</span>,\</span><br><span class="line">cv=StratifiedShuffleSplit(Y_train, n_iter=<span class="number">10</span>, test_size=<span class="number">0.2</span>, train_size=<span class="literal">None</span>, indices=<span class="literal">None</span>, \</span><br><span class="line">random_state=seed, n_iterations=<span class="literal">None</span>)).fit(X_train, Y_train)</span><br></pre></td></tr></table></figure>

<p>报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError: __init__() got an unexpected keyword argument &apos;n_iter&apos;</span><br><span class="line">TypeError: __init__() got an unexpected keyword argument &apos;indices&apos;</span><br><span class="line">TypeError: __init__() got an unexpected keyword argument &apos;n_iterations&apos;</span><br></pre></td></tr></table></figure>

<p>将报错的全删</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv=StratifiedShuffleSplit(Y_train, test_size=<span class="number">0.2</span>, train_size=<span class="literal">None</span>,random_state=seed)).fit(X_train, Y_train)</span><br></pre></td></tr></table></figure>

<p>但是又有新的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError: only integer scalar arrays can be converted to a scalar index</span><br></pre></td></tr></table></figure>

<p>所以又将代码恢复到了最初，本质在于原sklearn.cross_validation 包中StratifiedShuffleSplit的接口和现在sklearn.model_selection包中StratifiedShuffleSplit的接口不一样，然鹅网格搜索这一部分由于接口很多都改变，导致越改越乱……(先ε=ε=ε=┏(゜ロ゜;)┛，具体可<a href="https://blog.csdn.net/Douhh_sisy/article/details/80616045" target="_blank" rel="noopener">参考</a>以及<a href="https://www.kesci.com/home/project/5cde1e210ee9cd002ccd6204/code" target="_blank" rel="noopener">这里</a>。</p>
<ul>
<li>总结</li>
</ul>
<p>对于任何的机器学习问题，不要一上来就追求尽善尽美，先用自己会的算法撸一个baseline的model出来，再进行后续的分析步骤，一步步提高。</p>
<p>在问题的结果过程中：</p>
<p>『对数据的认识太重要了！』<br>『数据中的特殊点/离群点的分析和处理太重要了！』<br>『特征工程(feature engineering)太重要了！』<br>『模型融合(model ensemble)太重要了！』<br>本文中用机器学习解决问题的过程大概如下图所示：<br><img src="https://i.loli.net/2019/12/26/ZHehOtzaQB8WnEu.png" alt=""></p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue路由跳转及背景显示的bug</title>
    <url>/2019/12/19/2019-12-19-%E5%85%B3%E4%BA%8Evue%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%8F%8A%E8%83%8C%E6%99%AF%E6%98%BE%E7%A4%BA%E7%9A%84bug/</url>
    <content><![CDATA[<blockquote>
<p> 关于vue路由跳转及背景显示的bug，解决项目中的问题。</p>
</blockquote>
<h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p><img src="https://i.loli.net/2019/12/19/DoBkcRrWCyf4Osa.png" alt=""></p>
<p>如图，假设从页面1到页面2，浏览器地址栏显示是已经跳转成功的，页面2显示了一部分，但还有一部分，比如背景之类的还是页面1的，只有点击浏览器的刷新才会完全成为页面2。</p>
<h1 id="解决1"><a href="#解决1" class="headerlink" title="解决1"></a>解决1</h1><p>之前关于背景图的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">body&#123;</span><br><span class="line">    background-image: url(~assets/img/home/bg.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    /* 平铺 */</span><br><span class="line">    background-size: cover;</span><br><span class="line">    /* 当页面的其余部分滚动时，背景图像不会移动 */</span><br><span class="line">    background-attachment: fixed;</span><br><span class="line">    margin: 0px;</span><br><span class="line">    padding: 0px;</span><br><span class="line">    /* 当内容溢出元素框时,内容会被修剪,并且其余内容是不可见的 */</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    position: absolute;</span><br><span class="line">&#125;</span><br><span class="line">……………………</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>其实这个方式是错的，因为vue挂载dom，是挂载到#app上， 所以背景图不能放在body中 。正确的做法应该是，给定一个div设置背景元素，这个div撑满body即可。 修改之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.loginpage&#123;</span><br><span class="line">   background-image: url(~assets/img/home/bg.jpg);</span><br><span class="line">   background-repeat: no-repeat;</span><br><span class="line">   /* 平铺 */</span><br><span class="line">   background-size: cover;</span><br><span class="line">   /* 当内容溢出元素框时,内容会被修剪,并且其余内容是不可见的 */</span><br><span class="line">   overflow: hidden;</span><br><span class="line">   position: absolute;</span><br><span class="line">   /*背景图小，拉伸一下*/</span><br><span class="line">   height: 100%;</span><br><span class="line">   width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">……………………</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>问题解决。</p>
<h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>采用上述方案，在屏幕较小的浏览器中打开时，登录框显示不全，需要按住ctrl +滚轮缩放，这样会造成不变，所以加入滚轮更方便一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.loginpage &#123;</span><br><span class="line">   background-image: url(~assets/img/home/bg.jpg);</span><br><span class="line">   /*图片不重复*/</span><br><span class="line">   background-repeat: no-repeat;</span><br><span class="line">   /* 平铺，让背景图基于容器大小伸缩  */</span><br><span class="line">   background-size: cover;</span><br><span class="line">   -webkit-background-size: cover;</span><br><span class="line">   -moz-background-size: cover;</span><br><span class="line">   -o-background-size: cover;</span><br><span class="line">  /* !* 当内容溢出元素框时,内容会被修剪,并且其余内容是不可见的 *!*/</span><br><span class="line">  /* !*overflow: hidden;*!*/</span><br><span class="line">  /* !*position: absolute;*!*/</span><br><span class="line">   height: 100%;</span><br><span class="line">   width: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然有了滚轮，但是当浏览器放大之后，滑倒底部：</p>
<p><img src="https://i.loli.net/2019/12/19/5Ypstk9iN1nGz6X.png" alt=""></p>
<p>背景下边还是会出现空白，所以最初的想法是保持背景不随滚轮滑动而滑动，找到的方法基本上都是添加一个属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-attachment: fixed;</span><br></pre></td></tr></table></figure>

<p>但是试验了半天发现这个属性只有写在body中才会有效，这个之前的冲突，所以作罢。</p>
<h1 id="解决2"><a href="#解决2" class="headerlink" title="解决2"></a>解决2</h1><p>加入了<code>min-heigh</code>、<code>min-width</code>两个属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.loginpage &#123;</span><br><span class="line">   background-image: url(~assets/img/home/bg.jpg);</span><br><span class="line">   /*图片不重复*/</span><br><span class="line">   background-repeat: no-repeat;</span><br><span class="line">   /* 平铺，让背景图基于容器大小伸缩  */</span><br><span class="line">   background-size: cover;</span><br><span class="line">   -webkit-background-size: cover;</span><br><span class="line">   -moz-background-size: cover;</span><br><span class="line">   -o-background-size: cover;</span><br><span class="line">  /* !* 当内容溢出元素框时,内容会被修剪,并且其余内容是不可见的 *!*/</span><br><span class="line">  /* !*overflow: hidden;*!*/</span><br><span class="line">  /* !*position: absolute;*!*/</span><br><span class="line">   height: 100%;</span><br><span class="line">   width: 100%;</span><br><span class="line">  min-height: 700px;</span><br><span class="line">  min-width: 1000px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><p>解决上述问题之后，在谷歌、火狐、edge浏览器都没问题，但在ie浏览器会出现如下问题</p>
<p><img src="https://i.loli.net/2019/12/19/p3wVxQLuF6d5OlU.png" alt=""></p>
<h1 id="解决3"><a href="#解决3" class="headerlink" title="解决3"></a>解决3</h1><p>打开控制台，找到对应位置</p>
<p><img src="https://i.loli.net/2019/12/19/7pZfCoa64NrYUen.png" alt=""></p>
<p>发现修改<code>transform: translate();</code>可以解决，所以代码中加入即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.el-image__inner--center &#123;</span><br><span class="line">  transform: translate(-50%,0%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue-cli3打包</title>
    <url>/2019/12/19/2019-12-20-%E5%85%B3%E4%BA%8Evue-cli3%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<blockquote>
<p> 关于vue-cli3打包，解决项目中的问题。</p>
</blockquote>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>打包直接<code>npm run build</code>,会在项目文件下生成一个dist文件夹，但是打开index.html为空白。</p>
<p>首先，在vue.config.js中加入如下内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//基本路径</span></span><br><span class="line">  <span class="comment">//baseUrl: './',//vue-cli3.3以下版本使用</span></span><br><span class="line">  publicPath:<span class="string">'./'</span>,<span class="comment">//vue-cli3.3+新版本使用</span></span><br><span class="line">  <span class="comment">// assetsDir: './', //本地打开index.html访问静态资源</span></span><br><span class="line">  <span class="comment">// 输出文件目录</span></span><br><span class="line">  outputDir: <span class="string">'dist'</span>,</span><br><span class="line">  <span class="comment">// webpack-dev-server 相关配置</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">8888</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再次打包</p>
<h1 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul>
<li><p>项目下执行 <code>npm install -g serve</code></p>
</li>
<li><p>执行 <code>serve -s dist</code>，看到如下画面</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/12/20/ZTNw8Hqx2YOtAhE.png" alt=""></p>
<ul>
<li>在浏览器中输入 Local:<a href="http://localhost:5000；或者On" target="_blank" rel="noopener">http://localhost:5000；或者On</a> Your Network:<a href="http://192.168.1.100:5000" target="_blank" rel="noopener">http://192.168.1.100:5000</a> 即可。 这也是vue CLI3.0的新功能 。</li>
</ul>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ul>
<li>项目下执行<code>npm install http-server -g</code></li>
<li>然后在dist文件下执行<code>http-server</code></li>
</ul>
<h1 id="部署到Tomcat"><a href="#部署到Tomcat" class="headerlink" title="部署到Tomcat"></a>部署到Tomcat</h1><ol>
<li>到vue项目中修改vue.config.js文件：</li>
</ol>
<ul>
<li>修改 publicPath: process.env.NODE_ENV === “production” ? “/你在Tomcat新建的文件夹名称/“ : “/“,</li>
</ul>
<ol start="2">
<li>在路由router.js文件中添加</li>
</ol>
<ul>
<li>base:’/你在Tomcat新建的项目文件夹名称/‘,</li>
</ul>
<ol start="3">
<li>在Tomcat的webapps下的项目文件夹目录下新建一个WEB-INF的文件夹，打开此文件夹再新建一个web.xml的文件。文件内容如下： </li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">"3.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>webapp<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">     webapp</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">error-page</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">location</span>&gt;</span>/<span class="tag">&lt;/<span class="name">location</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>上传访问</p>
<p>将打包生成的文件夹下的内容上传到Tomcat服务器webapps下的项目文件夹，浏览器输入<code>ip:端口/文件夹名</code>称即可访问。</p>
</li>
</ol>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vuecli3项目运行报错sockjs-node/info解决方案</title>
    <url>/2019/12/19/2019-12-19-vuecli3%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99sockjs-nodeinfo%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p> 关于vuecli3项目运行报错sockjs-node/info解决方案，解决项目中的问题。</p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>启动项目后，在内网非本机运行项目时，控制台报错如下： </p>
<p><img src="https://i.loli.net/2019/12/19/YFwXZtLHQSEdNf1.jpg" alt=""></p>
<h2 id="报错分析"><a href="#报错分析" class="headerlink" title="报错分析"></a>报错分析</h2><p>首先，sockjs-node是何方神圣？不难查出，sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟、全双工的浏览器和web服务器之间通信通道。那么在各端表现为：</p>
<ul>
<li>服务端：sockjs-node（<a href="https://github.com/sockjs/sockjs-node）" target="_blank" rel="noopener">https://github.com/sockjs/sockjs-node）</a></li>
<li>客户端：sockjs-clien（<a href="https://github.com/sockjs/sockjs-client）" target="_blank" rel="noopener">https://github.com/sockjs/sockjs-client）</a></li>
</ul>
<p>vue-cli3.x的启动方式是 <code>npm run serve</code>，没有用到该sockjs-node功能，但启动时会默认连续发请求调用本地接口。因此我们要做的就是移除掉它。那么如何移除？</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>分享两种方案，我这里使用了第一种方法。</p>
<h2 id="1-注释法"><a href="#1-注释法" class="headerlink" title="1. 注释法"></a>1. 注释法</h2><p>顾名思义，找到依赖包中的源码，将其注释：</p>
<ol>
<li>进入路径 <code>/node_modules/sockjs-client/dist/sockjs.js</code></li>
<li>代码1605行注释掉：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// self.xhr.send(payload);  //本行注释</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        self.emit(<span class="string">'finish'</span>, <span class="number">0</span>, <span class="string">''</span>);</span><br><span class="line">        self._cleanup(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启项目（ps:可在代码开发完成后关闭，会同步关闭热加载）</li>
</ol>
<h2 id="2-配置vue-config"><a href="#2-配置vue-config" class="headerlink" title="2. 配置vue.config"></a>2. 配置vue.config</h2><p>vue.config.js中的module.exports中添加如下，然后重启：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: <span class="string">'http://localhost:8080'</span>,</span><br><span class="line">    public: <span class="string">'192.168.xxx.xxx:8080'</span>  <span class="comment">// 本地ip</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下后端配置</title>
    <url>/2019/12/18/2019-12-18-CentOS7%E4%B8%8B%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>基于阿里云cetos7.4的后端配置。在此记录一下。</p>
</blockquote>
<h1 id="一、安装mysql"><a href="#一、安装mysql" class="headerlink" title="一、安装mysql"></a>一、安装mysql</h1><p>之前已经讲过，<a href="https://gsynf.top/2019/08/30/2019-08-30-CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85MySQL%E5%8F%8A%E8%BF%9E%E6%8E%A5/" target="_blank" rel="noopener">详见</a>，注意要在阿里云的安全组中打开3306端口，否则无法远程连接。</p>
<h1 id="二、安装redis"><a href="#二、安装redis" class="headerlink" title="二、安装redis"></a>二、安装redis</h1><h2 id="1-在centOS里通过wget下载redis"><a href="#1-在centOS里通过wget下载redis" class="headerlink" title="1.在centOS里通过wget下载redis"></a>1.在centOS里通过wget下载redis</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.9.tar.gz   //版本去redis官网查看最新即可</span><br></pre></td></tr></table></figure>

<h2 id="2-在-usr-local里面创建redis目录（这个是安装目录，自己随意放）"><a href="#2-在-usr-local里面创建redis目录（这个是安装目录，自己随意放）" class="headerlink" title="2.在/usr/local里面创建redis目录（这个是安装目录，自己随意放）"></a>2.在/usr/local里面创建redis目录（这个是安装目录，自己随意放）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">mkdir redis</span><br></pre></td></tr></table></figure>

<h2 id="3-解压到创建的目录"><a href="#3-解压到创建的目录" class="headerlink" title="3.解压到创建的目录"></a>3.解压到创建的目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">tar -xzvf redis-4.0.9.tar.gz -C /usr/local/redis</span><br></pre></td></tr></table></figure>


<p>已解压成功</p>
<h2 id="4-进入目录编译一下，用make命令编译一下"><a href="#4-进入目录编译一下，用make命令编译一下" class="headerlink" title="4.进入目录编译一下，用make命令编译一下"></a>4.进入目录编译一下，用make命令编译一下</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/redis-4.0.9</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>注意：make命令执行完成编译后，会在src目录下生成6个可执行文件，</p>
<p>分别是redis-server、redis-cli、redis-benchmark、redis-check-aof、redis-check-rdb、redis-sentinel。</p>
<h2 id="5-编译生成的可执行文件拷贝到-usr-local-bin目录下"><a href="#5-编译生成的可执行文件拷贝到-usr-local-bin目录下" class="headerlink" title="5.编译生成的可执行文件拷贝到/usr/local/bin目录下"></a>5.编译生成的可执行文件拷贝到/usr/local/bin目录下</h2><p>这一步是为了后期可以直接使用命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/redis-4.0.9/src</span><br><span class="line">cp &#123;redis-server,redis-cli,redis-benchmark,redis-check-aof,redis-check-rdb,redis-sentinel&#125; /usr/local/bin</span><br></pre></td></tr></table></figure>

<h2 id="6-进入redis-4-0-9执行安装命令make-install"><a href="#6-进入redis-4-0-9执行安装命令make-install" class="headerlink" title="6.进入redis-4.0.9执行安装命令make install"></a>6.进入redis-4.0.9执行安装命令make install</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ../</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="7-执行基本配置"><a href="#7-执行基本配置" class="headerlink" title="7.执行基本配置"></a>7.执行基本配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./utils/install_server.sh</span><br></pre></td></tr></table></figure>

<p> 一阵回车就可以了，红圈就是默认配置的路径!!! </p>
<p><img src="https://i.loli.net/2019/12/18/2bWNDOy8Z5tkPmo.png" alt=""></p>
<h2 id="8-查看开机启动列表"><a href="#8-查看开机启动列表" class="headerlink" title="8.查看开机启动列表"></a>8.查看开机启动列表</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">chkconfig --<span class="keyword">list</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/18/s7wMyvhx5gabmTp.png" alt=""></p>
<h2 id="9-开启关闭命令"><a href="#9-开启关闭命令" class="headerlink" title="9.开启关闭命令"></a>9.开启关闭命令</h2><p>开启Redis服务操作通过/etc/init.d/redis_6379 start命令，也可通过（service redis_6379 start）；</p>
<p>关闭Redis服务操作通过/etc/init.d/redis_6379 stop命令，也可通过（service redis_6379 stop）；</p>
<h2 id="10-远程登陆redis"><a href="#10-远程登陆redis" class="headerlink" title="10.远程登陆redis"></a>10.远程登陆redis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/redis</span><br></pre></td></tr></table></figure>

<p>编辑 6379.conf，（黑底蓝字，眼要瞎了）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">vim</span> 6379<span class="selector-class">.conf</span></span><br></pre></td></tr></table></figure>

<p> a.在bind 127.0.0.1前加“#”将其注释掉 ；</p>
<p> b.默认为保护模式，把 protected-mode yes 改为 protected-mode no </p>
<p> c.默认为不守护进程模式，把daemonize no 改为daemonize yes </p>
<p> d.将 requirepass foobared前的“#”去掉，密码改为你想要设置的密码 （我这里没有设置）</p>
<h2 id="11-开放端口"><a href="#11-开放端口" class="headerlink" title="11.开放端口"></a>11.开放端口</h2><p>同样，去阿里云安全组开放6379端口。</p>
<h2 id="12-补充"><a href="#12-补充" class="headerlink" title="12.补充"></a>12.补充</h2><p>如果上述设置了密码，在服务器使用关闭命令会出现<code>(error) NOAUTH Authentication required.</code>错误。 这是由于配置了密码以后，关闭的时候没有密码，所以会关闭不了。找到/etc/init.d/redis_6379文件，修改一下代码 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$CLIEXEC -a &quot;password&quot; -p $REDISPORT shutdown</span><br></pre></td></tr></table></figure>

<p>然后就可以运行service redis_6379 stop关闭redis了。 </p>
<h1 id="三、安装JDK"><a href="#三、安装JDK" class="headerlink" title="三、安装JDK"></a>三、安装JDK</h1><p>之前已经讲过，<a href="https://gsynf.top/2019/09/17/2019-09-17-Centos%E5%AE%89%E8%A3%85JDK%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AATomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">详见</a>。</p>
<h1 id="四、springboot项目打包"><a href="#四、springboot项目打包" class="headerlink" title="四、springboot项目打包"></a>四、springboot项目打包</h1><h2 id="1-打开端口"><a href="#1-打开端口" class="headerlink" title="1.打开端口"></a>1.打开端口</h2><p>打包前确认工程中指定的端口在服务器在未被占用， 并确保该端口已经添加到阿里云安全组中 。</p>
<h2 id="2-注意更改数据源"><a href="#2-注意更改数据源" class="headerlink" title="2.注意更改数据源"></a>2.注意更改数据源</h2><p>确保mysql、redis等 数据源连接参数正确，开发时若使用的是本地数据库，那在打包前将数据库连接参数修改为目标数据库。</p>
<h2 id="3-修改pom-xml"><a href="#3-修改pom-xml" class="headerlink" title="3.修改pom.xml"></a>3.修改pom.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span><span class="comment">&lt;!--添加打包时跳过tests --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，添加一行，否则打包时会自动进行测试，由于更换了数据源所以无法通过测试，打包失败。</p>
<h2 id="4-打包"><a href="#4-打包" class="headerlink" title="4.打包"></a>4.打包</h2><p><img src="https://i.loli.net/2019/12/18/RTnz3iQxUjbINYa.png" alt=""></p>
<h2 id="5-运行"><a href="#5-运行" class="headerlink" title="5.运行"></a>5.运行</h2><p>我这里传到了home文件夹下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd home</span><br><span class="line">java -jar heater-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>运行没有问题。</p>
<h2 id="6-打开防火墙"><a href="#6-打开防火墙" class="headerlink" title="6.打开防火墙"></a>6.打开防火墙</h2><p>虽然运行没有问题，但是发现app端以及postman都无法访问，均显示超时连接，最后发现需要打开防火墙的8081端口，同mysql打开3306端口，<a href="https://gsynf.top/2019/08/30/2019-08-30-CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85MySQL%E5%8F%8A%E8%BF%9E%E6%8E%A5/" target="_blank" rel="noopener">戳</a>。</p>
<h2 id="7-改为后台运行"><a href="#7-改为后台运行" class="headerlink" title="7.改为后台运行"></a>7.改为后台运行</h2><p>java -jar 自己的springboot项目.jar：执行springboot的项目，如果单单只执行该命令，linux只会短暂的运行该项目，当退出控制台后会自动关闭该项目。</p>
<p>首先需要进到自己springboot项目的根目录，然后执行如下linux命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>命令详解：</p>
<p>nohup：不挂断地运行命令，退出帐户之后继续运行相应的进程。</p>
<p>日志文件名.log：是nohup把command的输出重定向到当前目录的指定的“日志文件名.log”文件中，即输出内容不打印到屏幕上，而是输出到”日志文件名.log”文件中。不指定文件名会在当前目录创建nohup.out，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。</p>
<p>2&gt;&amp;1：2就是标准错误，1是标准输出，该命令相当于把标准错误重定向到标准输出么。这里&amp;相当于标准错误等效于标准输出，即把标准错误和标准输出同时输出到指定的“日志文件名.log”文件中。</p>
<h2 id="8-停止服务"><a href="#8-停止服务" class="headerlink" title="8.停止服务"></a>8.停止服务</h2><p>控制台输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps 或者 ps -ef | grep 包名</span><br></pre></td></tr></table></figure>

<p>找到刚才运行的进程id，输入下面的命令关闭进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 进程id</span><br></pre></td></tr></table></figure>

<h2 id="9-生产环境部署"><a href="#9-生产环境部署" class="headerlink" title="9.生产环境部署"></a>9.生产环境部署</h2><p>生产linux服务器下，可以编写统一脚本管理启动重启：</p>
<p><strong>单一脚本：</strong></p>
<p> 在自定义目录创建 wss.sh 脚本，编辑内容如下。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这里可替换为你自己的执行程序，其他代码无需更改</span></span><br><span class="line">APP_NAME=websocketserver-0.0.1-SNAPSHOT.jar</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">使用说明，用来提示输入参数</span></span><br><span class="line">usage() &#123;</span><br><span class="line">    echo "Usage: sh 脚本名.sh [start|stop|restart|status]"</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">检查程序是否在运行</span></span><br><span class="line">is_exist()&#123;</span><br><span class="line">  pid=`ps -ef|grep $APP_NAME|grep -v grep|awk '&#123;print $2&#125;' `</span><br><span class="line"><span class="meta">  #</span><span class="bash">如果不存在返回1，存在返回0     </span></span><br><span class="line">  if [ -z "$&#123;pid&#125;" ]; then</span><br><span class="line">    return 1</span><br><span class="line">  else</span><br><span class="line">    return 0</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">启动方法</span></span><br><span class="line">start()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  if [ $? -eq "0" ]; then</span><br><span class="line">    echo "$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; ."</span><br><span class="line">  else</span><br><span class="line">    nohup java -jar /mnt/ssd1/project/websocket/$APP_NAME &gt; /mnt/ssd1/project/websocket/websocketserverlog.file 2&gt;&amp;1 &amp;</span><br><span class="line">    echo "$&#123;APP_NAME&#125; start success"</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">停止方法</span></span><br><span class="line">stop()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  if [ $? -eq "0" ]; then</span><br><span class="line">    kill -9 $pid</span><br><span class="line">  else</span><br><span class="line">    echo "$&#123;APP_NAME&#125; is not running"</span><br><span class="line">  fi  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">输出运行状态</span></span><br><span class="line">status()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  if [ $? -eq "0" ]; then</span><br><span class="line">    echo "$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;"</span><br><span class="line">  else</span><br><span class="line">    echo "$&#123;APP_NAME&#125; is NOT running."</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">restart()&#123;</span><br><span class="line">  stop</span><br><span class="line">  start</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line">case "$1" in</span><br><span class="line">  "start")</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  "stop")</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">  "status")</span><br><span class="line">    status</span><br><span class="line">    ;;</span><br><span class="line">  "restart")</span><br><span class="line">    restart</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>注意在start()方法中根据自己情况修改启动命令，之后就可以通过 wss.sh start | stop | restart 实现启动，停止，重启操作了。</p>
<p>补充下<strong>sh xxx.sh与./xxx.sh区别</strong></p>
<p>sh xxx.sh 是不需要有执行权限</p>
<p>./xxx.sh 是需要有执行权限的，可以通过 <code>chmod +x xxx.sh</code> 赋予权限</p>
<p><strong>三个脚本:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.启动 脚本 start.sh  2.停止脚本 stop.sh  3.重启脚本  restart.sh</span><br></pre></td></tr></table></figure>

<p>启动之前先授权一下 : <code>chmod a+x 文件.sh</code>，以后执行脚本使用<code>./start|stop|restart.sh</code>即可。</p>
<p>启动服务脚本：vi start.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #!/bin/bash</span><br><span class="line"></span><br><span class="line">echo starting</span><br><span class="line"></span><br><span class="line">nohup java -jar 项目.jar &gt; log.file 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>停止服务脚本：vi stop.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  #!/bin/bash</span><br><span class="line"></span><br><span class="line">PID=$(ps -ef | grep 项目.jar | grep -v grep | awk &apos;&#123; print $2 &#125;&apos;)</span><br><span class="line"></span><br><span class="line"> if [ -z &quot;$PID&quot; ]</span><br><span class="line"> then</span><br><span class="line"> echo Application is already stopped</span><br><span class="line"></span><br><span class="line"> else</span><br><span class="line"> echo $PID</span><br><span class="line"> kill $PID</span><br><span class="line"> fi</span><br></pre></td></tr></table></figure>

<p>停止脚本的流程就是，通过ps查找到该项目进程id，然后kill掉。</p>
<p>重启脚本：vi restart.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo stop application</span><br><span class="line">source stop.sh</span><br><span class="line">echo start application</span><br><span class="line">source start.sh</span><br></pre></td></tr></table></figure>

<p>重启脚本流程好理解，依次调用停止，启动即可。</p>
<p>之后还可以利用这三个脚本文件设置开机自启。</p>
<h1 id="五、开放udp端口"><a href="#五、开放udp端口" class="headerlink" title="五、开放udp端口"></a>五、开放udp端口</h1><p>在阿里云安全组以及防火墙都要开放端口，注意要开放udp协议，不是tcp。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue报错NavigationDuplicated</title>
    <url>/2019/12/17/2019-12-17-%E5%85%B3%E4%BA%8Evue%E6%8A%A5%E9%94%99NavigationDuplicated/</url>
    <content><![CDATA[<blockquote>
<p> 关于重复点击导航栏，vue报错NavigationDuplicated，解决项目中的问题。</p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如题，重复点击导航栏，vue报错NavigationDuplicated。</p>
<p><img src="https://i.loli.net/2019/12/17/PeSRCr7dAKQcEm8.png" alt=""></p>
<p>虽说不影响使用，但看着很难受。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>出现这个错误可能是 vue-router在<code>3.1.0</code> 版本的路由跳转使用的是 <code>promise</code> 的方式，可能是因为vue的官方人员没设计好而造成了BUG。  <code>vue-router</code>官方 在 2019-08-06 推出的 <code>vue-router@3.1.1</code>已经修复了此bug：</p>
<p><img src="https://i.loli.net/2019/12/17/vTSFHXyLp6B4tk3.png" alt=""></p>
<p>但是好像并没有，我目前的版本是<code>3.1.3</code>。</p>
<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>在项目目录下运行 <code>npm i vue-router@3.0 -S</code> 即可 。 因为下载的是 <code>3.0.x</code> 的版本，路由跳转可能没有用到 <code>promise</code> ，所以可以解决此报错 。</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>这也是我目前解决问题采用的方案，在引入<code>vue-router</code>的文件内加入如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决重复点击导航栏报错NavigationDuplicated</span></span><br><span class="line"><span class="keyword">const</span> originalPush = VueRouter.prototype.push;</span><br><span class="line">VueRouter.prototype.push = <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> originalPush.call(<span class="keyword">this</span>, location).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于el-time-picker使用</title>
    <url>/2019/12/17/2019-12-17-%E5%85%B3%E4%BA%8Eel-time-picker%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p> 关于el-time-picker使用字符串，解决项目中的问题。</p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>时间选择计划采用element提供的，默认数据为从后端请求的当前设置</p>
<p><img src="https://i.loli.net/2019/12/17/kOjbpW5dUEa12GQ.png" alt=""></p>
<p>从后端请求回来的时间是字符串，格式为：“hh:mm”，但是看element官方文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-time-picker</span><br><span class="line">    v-model=&quot;value1&quot;</span><br><span class="line">    :picker-options=&quot;&#123;</span><br><span class="line">      selectableRange: &apos;18:30:00 - 20:30:00&apos;</span><br><span class="line">    &#125;&quot;</span><br><span class="line">    placeholder=&quot;任意时间点&quot;&gt;</span><br><span class="line">  &lt;/el-time-picker&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        value1: new Date(2016, 9, 10, 18, 40),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>好像绑定值要Date类型，所以先开始在返回的字符串上一顿操作，先转化为Date类型，提交时再转化回字符串来截取时分，弄得比较复杂。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>后来发现并不用这么复杂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-form-item label=&quot;一段模式起始&quot; &gt;</span><br><span class="line">    &lt;el-time-picker v-model=&quot;editForm.startTime1&quot; format=&apos;HH:mm&apos; value-format=&quot;HH:mm&quot;</span><br><span class="line">                    :picker-options=&quot;&#123;selectableRange:`00:00:00 -$&#123;editForm.endTime1 ? editForm.endTime1+&apos;:00&apos; : &apos;23:59:00&apos;&#125;`&#125;&quot;&gt;</span><br><span class="line">    &lt;/el-time-picker&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line">&lt;el-form-item label=&quot;一段模式结束&quot; &gt;</span><br><span class="line">    &lt;el-time-picker v-model=&quot;editForm.endTime1&quot; format=&apos;HH:mm&apos; value-format=&quot;HH:mm&quot;</span><br><span class="line">                    :picker-options=&quot;&#123;selectableRange:`$&#123;editForm.startTime1 ? editForm.startTime1+&apos;:00&apos; : &apos;00:00:00&apos;&#125; - &apos;23:59:00&apos;&#125;`&#125;&quot;&gt;</span><br><span class="line">    &lt;/el-time-picker&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<p>format：设置下拉框时间列表格式；</p>
<p>value-format：设置返回值格式</p>
<p>顺便还解决了一点逻辑问题，开始时间不能大于结束时间或最大时间值， 结束时间不得早于开始时间或时间最小值  ：</p>
<p>picker-options：设置selectableRange实现选择范围的确定，此处动态设需要拼接“秒”的值</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录2-Array</title>
    <url>/2019/12/15/2019-12-15-Leetcode%E8%AE%B0%E5%BD%952-Array/</url>
    <content><![CDATA[<blockquote>
<p>为了强化训练，对题目按照分类去做，此部分为Array。 </p>
</blockquote>
<blockquote>
<p>这里不对每道题都做记录。</p>
</blockquote>
<ul>
<li>118题， Pascal’s Triangle ，给一个整数，返回杨辉三角，主要休息二维列表的使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lists = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">                lists.append([<span class="number">1</span>]*(i+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i):</span><br><span class="line">                        lists[i][j] = lists[i<span class="number">-1</span>][j<span class="number">-1</span>] + lists[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>

<ul>
<li>121题，Best Time to Buy and Sell Stock ，最初的想法是维护两个数组，一个是记录当前price与之前每一个price的差，另一个是记录每一个price可赚得的最大收益，也就是第一个数组中每一个price对应的最大值，后来看到了相对简单的方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buy_price = float(<span class="string">'inf'</span>) </span><br><span class="line">profit = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">    <span class="keyword">if</span> price &lt; buy_price:</span><br><span class="line">        buy_price = price</span><br><span class="line">        <span class="keyword">if</span> price - buy_price &gt; profit:</span><br><span class="line">            profit = price - buy_price</span><br><span class="line"><span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于主线程获取子线程数据</title>
    <url>/2019/12/13/2019-12-13-%E5%85%B3%E4%BA%8E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p> 在主线程中获取子线程的数据，解决项目中的问题。</p>
</blockquote>
<p>在进行多线程编程中，比较重要也是比较困难的一个操作就是如何获取线程中的信息。</p>
<h1 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h1><p>比较常见的一种解决方案是，让线程类获取方法在结果字段设置之前返回一个标志值。然后主线程定时询问获取方法，看是否返回了标志之外的值。该方法不断测试str的值是否为”Hello”，如果不为”Hello”才打印输出它。例如：   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> threadtest1;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the command line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReturnThreadInfo returnThreadInfo = <span class="keyword">new</span> ReturnThreadInfo();</span><br><span class="line">        returnThreadInfo.start(); <span class="comment">//创建并启动ReturnThreadInfo线程</span></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            String str = returnThreadInfo.getThreadInfo();</span><br><span class="line">            <span class="keyword">if</span>(!str.equals(<span class="string">"Hello"</span>))&#123;</span><br><span class="line">                 System.out.println(returnThreadInfo.getThreadInfo());</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这种方案虽然能起到作用，但是它做了大量不需要做的工作。事实上，还有一种更简单有效的方法来解决这个问题。 </p>
<h1 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h1><p>轮询方法最大的特点是主类Main不断询问线程类是否结束，这实际上大量浪费了运行时间，特别是当线程特别多的时候。因此如果反过来在线程结束时，由线程自己告诉主类Main线程已经结束，然后Main再获取并输出str的值，这样就避免了轮询方法所带来的不必要的系统开销问题。<br>在具体的实现过程中，线程可以在结束时通过调用主类中的一个方法来实现告知功能，这种方法叫做回调。这样主类Main就可以在等待线程结束时休息，也就不会占用运行线程的时间。下面是修改后的Main类： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the command line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO code application logic here</span></span><br><span class="line">        ReturnThreadInfo returnThreadInfo = <span class="keyword">new</span> ReturnThreadInfo();</span><br><span class="line">        returnThreadInfo.start();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receiveStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 相比于前面，我们在Main类中添加了一个静态方法receiveStr(String str)，该方法是供线程结束之前调用，通过参数str将要返回的线程信息返回给Main类并输出显示出来。下面是修改后的ReturnThreadInfo类，该类在线程结束前回调了Main.receiveStr方法，通知线程已结束。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> threadtest1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnThreadInfo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnThreadInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str = <span class="string">"Hello World!"</span>;</span><br><span class="line">     Main.receiveStr(str); <span class="comment">//回调receiveStr方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有很多个对象关心线程的返回的信息,线程可以保存一个回调对象列表。某个对象可以通过已经定义的一个对象将自己添加到列表中，表示自己对这些信息的关注。如果有多个类的实例关心这些信息，也可以定义一个interface，在interface中声名回调方法，然后这些类都实现这个接口。其实这是典型的java处理事件的方法，这么做可以使得回调更灵活，可以处理涉及更多线程、对象和类的情况。 </p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录1</title>
    <url>/2019/12/05/2019-12-05-Leetcode%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<blockquote>
<p>建议使用英文，遇到不会的题目，社区会有很多讨论者给出答案，而中文版的较少，而且锻炼自己对于英文编程题目的理解。 </p>
</blockquote>
<blockquote>
<p>这里不对每道题都做记录。</p>
</blockquote>
<ul>
<li>13题， Roman to Integer，用了一个字典，苦恼于如何分情况写规则，看了评论区，用了两个字典，妙啊，真香。</li>
<li>14题，Longest Common Prefix，查看列表中的所有元素，一个all，骚气啊</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all([s[i] == strs[<span class="number">0</span>][i] <span class="keyword">for</span> s <span class="keyword">in</span> strs])</span><br></pre></td></tr></table></figure>

<ul>
<li>20题，Valid Parentheses，利用了堆栈后进先出，开始有点难理解，以后解决对称问题都可以借鉴</li>
<li>58题，length Of LastWord，判断字符串是否全为空格，<code>s.isspace()</code></li>
<li>66题，Plus One，得到一个任意长度整数的各个位</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = [] </span><br><span class="line"><span class="keyword">while</span> num:</span><br><span class="line">result.append(num % <span class="number">10</span>)</span><br><span class="line">num = num // <span class="number">10</span> <span class="comment">#取整除 - 返回商的整数部分（向下取整）</span></span><br><span class="line"><span class="comment"># 逆序，按正常的顺序返回</span></span><br><span class="line">result.reverse()</span><br></pre></td></tr></table></figure>

<ul>
<li>67题，Add Binary，将两个只有0和1的字符串进行二进制相加</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># int(x, base=10)x - - 字符串或数字;base - - 进制数，默认十进制</span></span><br><span class="line"><span class="comment"># bin(x)x - - int或者long int数</span></span><br><span class="line"><span class="comment"># 结果包含0bxxxx，所以从第二位开始</span></span><br><span class="line"><span class="keyword">return</span> str(bin(int(a, <span class="number">2</span>) + int(b, <span class="number">2</span>)))[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>

<ul>
<li>69题，Sqrt(x)，计算开方，返回整数部分，不能引入math库，所以sqrt()不能使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> int(pow(x, <span class="number">.5</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>70题， climbStairs，递归：对于n阶台阶，可以看成走了n-1阶基础上再跨1阶 + 走了n-2阶基础上再跨2阶，即<code>f(n)=f(n−1)+f(n−2)，f(0)=1，f(1)=1</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> n &gt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>)+self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>

<p>但是太费时，n比较大时Time Limit Exceeded，相同思路使用数组实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = [<span class="number">0</span>] * n</span><br><span class="line">result[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="number">2</span>:</span><br><span class="line">    result[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">    result[i] = result[i<span class="number">-1</span>] + result[i<span class="number">-2</span>]</span><br><span class="line"><span class="keyword">return</span> result[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>83题，Remove Duplicates from Sorted List， 移除给定有序链表的重复项 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        currentNode = head</span><br><span class="line">        <span class="keyword">while</span> currentNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> currentNode.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> currentNode.val == currentNode.next.val:</span><br><span class="line">                currentNode.next = currentNode.next.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                currentNode = currentNode.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<p>思路比较简单， 遍历这个链表，每个结点和其后面的结点比较，如果结点值相同了，只要将前面结点的 next 指针跳过紧挨着的相同值的结点，指向后面一个结点。 重点是借此回顾一下链表。</p>
<ul>
<li>100题，Same Tree，比较两棵树是否完全相同，使用递归比较简单，这里想记录的是看到别人代码中非常漂亮的一段</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if one of the nodes is null</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">    <span class="comment"># if both nodes are null then we need to return True</span></span><br><span class="line">    <span class="keyword">return</span> p == q</span><br></pre></td></tr></table></figure>

<p>很巧妙的判断了p为空或q为空或都为空应该返回的值。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Java和MySQL时区不一致</title>
    <url>/2019/12/04/2019-12-04-%E5%85%B3%E4%BA%8EJava%E5%92%8CMySQL%E6%97%B6%E5%8C%BA%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<blockquote>
<p>解决项目中的问题</p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>项目中记录udp消息的日志用到了Timestamp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpRecord</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"time"</span>,length = <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">private</span> Timestamp time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Timestamp <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Timestamp time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">udpRecord.setTime(getTime());</span><br><span class="line"><span class="function"><span class="keyword">public</span> Timestamp <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    Timestamp time = <span class="keyword">new</span> Timestamp(date.getTime());</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在数据库中发现存的时间并不是当前时间，但是在控制台打印得到的确实是当前时间。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>这是因为Java和MySQL时区不一致，其实也就是当前系统的时区和mysql的时区不一致，最简单的办法：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据库连接驱动</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://192.168.1.107/heater?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<p>加上<code>serverTimezone=Asia/Shanghai</code>即可。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SpringBoot中redis的存取问题</title>
    <url>/2019/12/04/2019-12-04-%E5%85%B3%E4%BA%8ESpringBoot%E4%B8%ADredis%E7%9A%84%E5%AD%98%E5%8F%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p> 解决项目中遇到的问题。</p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>存没有问题，有的数据采用set方法，有的数据保存到redis的list中，采用leftPush方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(key, value);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForList().leftPush(key, val);</span><br></pre></td></tr></table></figure>

<p>问题在于取，若取和存在同一个类或者方法中，就可以实现，但是理论上，只有存到了redis数据库，在其他地方也是可以取到的，但返回的都是null。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>之前也遇到过这种问题，当时在controller中可以取到，但在service中就不可以，所以开始也在考虑这个原因。最后发现真正的原因在于取的时候redisTemplate要实现序列化接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"redisTemplate"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedis</span><span class="params">(RedisTemplate redis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redis = redis;</span><br><span class="line">        redis.setKeySerializer(<span class="keyword">new</span> GenericToStringSerializer&lt;Object&gt;(Object.class));</span><br><span class="line">        redis.setValueSerializer(<span class="keyword">new</span> GenericToStringSerializer&lt;Object&gt;(Object.class));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPackage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        redis.opsForValue().get(<span class="string">"xxxxx"</span>);</span><br><span class="line">        redis.opsForList().rightPop(<span class="string">"xxxxx"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以实现。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>为GithubPages添加域名</title>
    <url>/2019/12/01/2019-12-01-%E4%B8%BAGithubPages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前提是你已经搭建好了博客，已经可以通过类似： <a href="https://gsynf.github.io/">https://gsynf.github.io/</a> 的方法访问。 </p>
<h1 id="添加一个CNAME文件"><a href="#添加一个CNAME文件" class="headerlink" title="添加一个CNAME文件"></a>添加一个CNAME文件</h1><p>向你的 Github Pages 仓库添加一个CNAME文件，不要包含Http://和www ，其中只能包含一个顶级域名，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.com</span><br></pre></td></tr></table></figure>

<p>如果你是用 hexo 框架搭建博客并部署到 Github Pages 上，每次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hexo g</span><br><span class="line">&gt; hexo d</span><br></pre></td></tr></table></figure>

<p>后会把你的博客所在目录下 public 文件夹里的东西都推到 Github Pages 仓库上，并且把 CNAME 文件覆盖掉，解决这个问题可以直接把 CNAME 文件添加到 source 文件夹里，这样每次推的时候就不用担心仓库里的 CNAME 文件被覆盖掉了。 </p>
<p>找到仓库的设置，找到 Custom domain添加域名后保存即可（添加CNAME文件并在文件中填写绑定的域名后应该会自动保存，看看有没有自动保存） </p>
<h1 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h1><p>ping你的<a href="https://link.zhihu.com/?target=http%3A//github.io">http://github.io</a>域名，得到一个IP； </p>
<p><img src="https://i.loli.net/2019/12/01/k9yitBKCY7ebNfW.png" alt=""></p>
<p>在阿里云修改你的域名解析记录，</p>
<p><img src="https://i.loli.net/2019/12/01/gUGtRyiHA5TKEOl.png" alt=""></p>
<p>添加两个A记录，用ping得到的IP，一个主机记录为：“www”，一个为“@”，这样通过<a href="http://gsynf.top/" target="_blank" rel="noopener">gsynf.top</a>和<a href="http://gsynf.top/" target="_blank" rel="noopener">www.gsynf.top</a>都能访问到你的博客了。 对DNS的配置不是立即生效的，过10分钟再去访问域名。 </p>
<p>注：上边我们用的是A记录，但有时候IP地址会更改，导致解析不正确，所以最好用CNAME别名记录，后面记录值就是xxx.github.io，但是我这里设置CNAME会提示冲突，原因是阿里云设置了<a href="https://help.aliyun.com/knowledge_detail/39787.html" target="_blank" rel="noopener">解析记录冲突规则</a>。</p>
<h1 id="启用-HTTPS"><a href="#启用-HTTPS" class="headerlink" title="启用 HTTPS"></a><strong>启用 HTTPS</strong></h1><p>自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了。</p>
<p><a href="https://github.blog/2018-05-01-github-pages-custom-domains-https/" target="_blank" rel="noopener">详情</a>。</p>
<p>配置也相当简单，只需要更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。</p>
<ul>
<li>185.199.108.153</li>
<li>185.199.109.153</li>
<li>185.199.110.153</li>
<li>185.199.111.153</li>
</ul>
<p>HTTPS 让你的网站和网站访客更安全，并且 Github 提供的这些 IP 地址自动将你的站点加入了 CDN，提高了访问速度。</p>
<p>还可以在 GiHub Pages 仓库的设置里勾选 ‘Enforce HTTPS’，这样所有访问你站点的请求都会走 HTTPS。</p>
<p> <strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SQL</title>
    <url>/2019/11/29/2019-11-29-%E5%85%B3%E4%BA%8ESQL/</url>
    <content><![CDATA[<blockquote>
<p>基于廖雪峰的官方网站</p>
</blockquote>
<h1 id="SQL-简介"><a href="#SQL-简介" class="headerlink" title="SQL 简介"></a>SQL 简介</h1><p>SQL = Structured Query Language</p>
<p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p>
<ul>
<li><p>DDL：Data Definition Language</p>
<p>DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p>
</li>
<li><p>DML：Data Manipulation Language</p>
<p>DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p>
</li>
<li><p>DQL：Data Query Language</p>
<p>DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p>
</li>
</ul>
<p>先准备好了一个<code>students</code>表和一个<code>classes</code>表，它们的结构和数据如下：</p>
<p><code>students</code>表存储了学生信息：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">class_id</th>
<th align="left">name</th>
<th align="left">gender</th>
<th align="left">score</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">小明</td>
<td align="left">M</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">小红</td>
<td align="left">F</td>
<td align="left">95</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">小军</td>
<td align="left">M</td>
<td align="left">88</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">小米</td>
<td align="left">F</td>
<td align="left">73</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">小白</td>
<td align="left">F</td>
<td align="left">81</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">2</td>
<td align="left">小兵</td>
<td align="left">M</td>
<td align="left">55</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">2</td>
<td align="left">小林</td>
<td align="left">M</td>
<td align="left">85</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">3</td>
<td align="left">小新</td>
<td align="left">F</td>
<td align="left">91</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">3</td>
<td align="left">小王</td>
<td align="left">M</td>
<td align="left">89</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">3</td>
<td align="left">小丽</td>
<td align="left">F</td>
<td align="left">85</td>
</tr>
</tbody></table>
<p><code>classes</code>表存储了班级信息：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">一班</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">二班</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">三班</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">四班</td>
</tr>
</tbody></table>
<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p>
<p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</p>
<p>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p>
<p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。 </p>
<ul>
<li><u>注意：通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</u> </li>
</ul>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p>
<ol>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li>
<li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li>
</ol>
<ul>
<li><u>注意：如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</u> </li>
</ul>
<h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>通过定义外键约束实现 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<p> 其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。 </p>
<p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p>
<p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_class_id;</span><br></pre></td></tr></table></figure>

<ul>
<li><u>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</u> </li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 </p>
<p>例如，对于<code>students</code>表， 如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_score (score);</span><br></pre></td></tr></table></figure>

<p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_name_score (<span class="keyword">name</span>, score);</span><br></pre></td></tr></table></figure>

<p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p>
<p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p>
<p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p>
<p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uni_name (<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>

<p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p>
<p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>

<p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。 </p>
<h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>使用SELECT查询的基本语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表名&gt;</span><br></pre></td></tr></table></figure>

<p>可以查询一个表的所有行和所有列的数据。</p>
<p>SELECT查询的结果是一个二维表。</p>
<p>另： <code>SELECT</code>语句其实并不要求一定要有<code>FROM</code>子句。 例如 用来判断当前到数据库的连接是否有效。许多检测工具会执行一条<code>SELECT 1;</code>来测试数据库连接。 </p>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> &lt;条件表达式&gt;</span><br></pre></td></tr></table></figure>

<p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code> 、 <code>&lt;条件1&gt; OR &lt;条件2&gt;</code> 、 <code>NOT &lt;条件&gt;</code>。</p>
<p>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。 </p>
<h3 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h3><table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">表达式举例1</th>
<th align="left">表达式举例2</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">使用=判断相等</td>
<td align="left">score = 80</td>
<td align="left">name = ‘abc’</td>
<td align="left">字符串需要用单引号括起来</td>
</tr>
<tr>
<td align="left">使用&gt;判断大于</td>
<td align="left">score &gt; 80</td>
<td align="left">name &gt; ‘abc’</td>
<td align="left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td>
</tr>
<tr>
<td align="left">使用&gt;=判断大于或相等</td>
<td align="left">score &gt;= 80</td>
<td align="left">name &gt;= ‘abc’</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用&lt;判断小于</td>
<td align="left">score &lt; 80</td>
<td align="left">name &lt;= ‘abc’</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用&lt;=判断小于或相等</td>
<td align="left">score &lt;= 80</td>
<td align="left">name &lt;= ‘abc’</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用&lt;&gt;判断不相等</td>
<td align="left">score &lt;&gt; 80</td>
<td align="left">name &lt;&gt; ‘abc’</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用LIKE判断相似</td>
<td align="left">name LIKE ‘ab%’</td>
<td align="left">name LIKE ‘%bc%’</td>
<td align="left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’；_表示一个，例如’ab _’将匹配’abc’</td>
</tr>
</tbody></table>
<h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span> <span class="keyword">FROM</span> ...</span><br></pre></td></tr></table></figure>

<p>让结果集仅包含指定列。这种操作称为投影查询。 </p>
<p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。 </p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>例如按照成绩从低到高进行排序： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br></pre></td></tr></table></figure>

<p>按照成绩从高到底排序，我们可以加上<code>DESC</code>表示“倒序”： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>score</code>列有相同的数据，要进一步排序，可以继续添加列名。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>, gender;</span><br></pre></td></tr></table></figure>

<p> 如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。 </p>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">LIMIT &lt;M&gt; OFFSET &lt;N&gt;</span><br></pre></td></tr></table></figure>

<p>可以对结果集进行分页，每次查询返回结果集的一部分； </p>
<p>分页查询的关键在于，首先要确定每页需要显示的结果数量<code>pageSize</code>，然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值： </p>
<p>例如把结果集分页，每页3条记录，获取第一页的结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>获取第二页的结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>后边以此类推。</p>
<h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 </p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">COUNT</td>
<td align="left">计算某一列有多少条记录</td>
</tr>
<tr>
<td align="left">SUM</td>
<td align="left">计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr>
<td align="left">AVG</td>
<td align="left">计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr>
<td align="left">MAX</td>
<td align="left">计算某一列的最大值</td>
</tr>
<tr>
<td align="left">MIN</td>
<td align="left">计算某一列的最小值</td>
</tr>
</tbody></table>
<p>例如，使用聚合函数查询男生数量并起别名为boysNum:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) boysNum <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p> 查询多张表的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; &lt;表<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>

<p>例如<code>SELECT * FROM students, classes;</code>就是同时从<code>students</code>表和<code>classes</code>表的“乘积” </p>
<p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，而且尽量不要用，这里主要借此介绍一下别名的使用。如果多个表中有相同的字段，结果集中就会有相同的两列，不好区分，此时就需要使用别名区分。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    students.id <span class="keyword">sid</span>,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line"><span class="keyword">FROM</span> students, classes;</span><br></pre></td></tr></table></figure>

<p>使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。 但是这样还有些繁琐， 所以SQL还允许给表设置一个别名，在投影查询中引用起来稍微简洁一点： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.id <span class="keyword">sid</span>,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c;</span><br></pre></td></tr></table></figure>

<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>事务需求： 选出所有学生，同时返回班级名称 ，使用到了最常用的内连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">name</th>
<th align="left">class_id</th>
<th align="left">class_name</th>
<th align="left">gender</th>
<th align="left">score</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">小明</td>
<td align="left">1</td>
<td align="left">一班</td>
<td align="left">M</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">小红</td>
<td align="left">1</td>
<td align="left">一班</td>
<td align="left">F</td>
<td align="left">95</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">小军</td>
<td align="left">1</td>
<td align="left">一班</td>
<td align="left">M</td>
<td align="left">88</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">小米</td>
<td align="left">1</td>
<td align="left">一班</td>
<td align="left">F</td>
<td align="left">73</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">小白</td>
<td align="left">2</td>
<td align="left">二班</td>
<td align="left">F</td>
<td align="left">81</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">小兵</td>
<td align="left">2</td>
<td align="left">二班</td>
<td align="left">M</td>
<td align="left">55</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">小林</td>
<td align="left">2</td>
<td align="left">二班</td>
<td align="left">M</td>
<td align="left">85</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">小新</td>
<td align="left">3</td>
<td align="left">三班</td>
<td align="left">F</td>
<td align="left">91</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">小王</td>
<td align="left">3</td>
<td align="left">三班</td>
<td align="left">M</td>
<td align="left">89</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">小丽</td>
<td align="left">3</td>
<td align="left">三班</td>
<td align="left">F</td>
<td align="left">88</td>
</tr>
</tbody></table>
<p>注意INNER JOIN查询的写法是：</p>
<ol>
<li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li>
<li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li>
<li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li>
<li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li>
</ol>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>把上述内连接查询改成外连接查询 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br></pre></td></tr></table></figure>

<p>结果会多出一行</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>class_id</th>
<th>class_name</th>
<th>gender</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>四班</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody></table>
<p>这也容易理解，因为根据<code>ON</code>条件<code>s.class_id = c.id</code>，<code>classes</code>表的id=4的行正是“四班”，但是，<code>students</code>表中并不存在class_id=4的行。 </p>
<p><strong>总结一下：</strong></p>
<p>INNER JOIN只返回同时存在于两张表的行数据，由于<code>students</code>表的<code>class_id</code>包含1，2，3，<code>classes</code>表的<code>id</code>包含1，2，3，4，所以，INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</p>
<p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以<code>NULL</code>填充剩下的字段。</p>
<p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的<code>class_name</code>是<code>NULL</code></p>
<h3 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h3><p>所谓全连接，就是使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL 。</p>
<ul>
<li><u>注意： MySQL不支持全外连接，所以只能采取关键字UNION来联合左、右连接的方法</u> </li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>假设查询语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tableA ??? <span class="keyword">JOIN</span> tableB <span class="keyword">ON</span> tableA.column1 = tableB.column2;</span><br></pre></td></tr></table></figure>

<p>把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录： </p>
<p><img src="https://i.loli.net/2019/11/29/OZzMjJ4rYSmVsay.png" alt=""></p>
<p> LEFT OUTER JOIN是选出左表存在的记录： </p>
<p><img src="https://i.loli.net/2019/11/29/WBR1z8MKHt6uxVa.png" alt=""></p>
<p> RIGHT OUTER JOIN是选出右表存在的记录： </p>
<p><img src="https://i.loli.net/2019/11/29/SsH1Lnj6ycJFdvp.png" alt=""></p>
<p> FULL OUTER JOIN则是选出左右表都存在的记录： </p>
<p><img src="https://i.loli.net/2019/11/29/dTSUeKM8r17NxwP.png" alt=""></p>
<h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，上一节详细讲述了<code>SELECT</code>语句的用法。</p>
<p>而对于增、删、改，对应的SQL语句分别是：</p>
<ul>
<li>INSERT：插入新记录；</li>
<li>UPDATE：更新已有记录；</li>
<li>DELETE：删除已有记录。</li>
</ul>
<h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p><code>INSERT</code>语句的基本语法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure>

<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p><code>UPDATE</code>语句的基本语法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;表名&gt; <span class="keyword">SET</span> 字段<span class="number">1</span>=值<span class="number">1</span>, 字段<span class="number">2</span>=值<span class="number">2</span>, ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>

<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><code>DELETE</code>语句的基本语法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>

<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h2 id="管理MySQL"><a href="#管理MySQL" class="headerlink" title="管理MySQL"></a>管理MySQL</h2><p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。 </p>
<ul>
<li><u>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</u> </li>
</ul>
<p>MySQL Client和MySQL Server的关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────&gt;│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure>

<p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。也可以只安装MySQL Client，然后连接到远程MySQL Server。 </p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>

<p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。 </p>
<p>要创建一个新数据库，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>要删除一个数据库，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE test;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>

<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>列出当前数据库的所有表，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_test      |</span><br><span class="line">+---------------------+</span><br><span class="line">| classes             |</span><br><span class="line">| statistics          |</span><br><span class="line">| students            |</span><br><span class="line">| students_of_class1  |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>

<p>要查看一个表的结构，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DESC students;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| class_id | bigint(20)   | NO   |     | NULL    |                |</span><br><span class="line">| name     | varchar(100) | NO   |     | NULL    |                |</span><br><span class="line">| gender   | varchar(1)   | NO   |     | NULL    |                |</span><br><span class="line">| score    | int(11)      | NO   |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>还可以使用以下命令查看创建表的SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE students;</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">| students | CREATE TABLE `students` (                             |</span><br><span class="line">|          |   `id` bigint(20) NOT NULL AUTO_INCREMENT,            |</span><br><span class="line">|          |   `class_id` bigint(20) NOT NULL,                     |</span><br><span class="line">|          |   `name` varchar(100) NOT NULL,                       |</span><br><span class="line">|          |   `gender` varchar(1) NOT NULL,                       |</span><br><span class="line">|          |   `score` int(11) NOT NULL,                           |</span><br><span class="line">|          |   PRIMARY KEY (`id`)                                  |</span><br><span class="line">|          | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE students;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure>

<p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure>

<p>要删除列，使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure>

<h3 id="退出MySQL"><a href="#退出MySQL" class="headerlink" title="退出MySQL"></a>退出MySQL</h3><p>使用<code>EXIT</code>命令退出MySQL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure>

<p>注意<code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p>
<h2 id="实用SQL语句"><a href="#实用SQL语句" class="headerlink" title="实用SQL语句"></a>实用SQL语句</h2><h3 id="插入或替换"><a href="#插入或替换" class="headerlink" title="插入或替换"></a>插入或替换</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &apos;小明&apos;, &apos;F&apos;, 99);</span><br></pre></td></tr></table></figure>

<p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p>
<h3 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &apos;小明&apos;, &apos;F&apos;, 99) ON DUPLICATE KEY UPDATE name=&apos;小明&apos;, gender=&apos;F&apos;, score=99;</span><br></pre></td></tr></table></figure>

<p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p>
<h3 id="插入或忽略"><a href="#插入或忽略" class="headerlink" title="插入或忽略"></a>插入或忽略</h3><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &apos;小明&apos;, &apos;F&apos;, 99);</span><br></pre></td></tr></table></figure>

<p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:</span><br><span class="line">CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;</span><br></pre></td></tr></table></figure>

<p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p>
<h3 id="写入查询结果集"><a href="#写入查询结果集" class="headerlink" title="写入查询结果集"></a>写入查询结果集</h3><p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p>
<p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">    id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后，我们就可以用一条语句写入各班的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure>

<p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="强制使用指定索引"><a href="#强制使用指定索引" class="headerlink" title="强制使用指定索引"></a>强制使用指定索引</h3><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;</span><br></pre></td></tr></table></figure>

<p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>这里对事务的理解和Spring中对事务的理解基本是一致的。</p>
<p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 从id=1的账户给id=2的账户转账100元</span><br><span class="line">-- 第一步：将id=1的A账户余额减去100</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">-- 第二步：将id=2的B账户余额加上100</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br></pre></td></tr></table></figure>

<p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p>
<p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<em>事务</em>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p>
<p>可见，数据库事务具有ACID这4个特性：</p>
<ul>
<li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li>
<li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li>
<li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li>
<li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li>
</ul>
<p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p>
<p>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>，例如，把上述的转账操作作为一个显式事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。</p>
<p><code>COMMIT</code>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果<code>COMMIT</code>语句执行失败了，整个事务也会失败。</p>
<p>有些时候，我们希望主动让事务失败，这时，可以用<code>ROLLBACK</code>回滚事务，整个事务会失败：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p>
<p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>
<table>
<thead>
<tr>
<th align="left">Isolation Level</th>
<th align="left">脏读（Dirty Read）</th>
<th align="left">不可重复读（Non Repeatable Read）</th>
<th align="left">幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Read Uncommitted</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Read Committed</td>
<td align="left">-</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Repeatable Read</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Serializable</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<h3 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h3><p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</p>
<p>我们来看一个例子。</p>
<p>首先，我们准备好<code>students</code>表的数据，该表仅一行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">ROLLBACK;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<p>当事务A执行完第3步时，它更新了<code>id=1</code>的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。</p>
<p>随后，事务A在第5步进行了回滚，事务B再次读取<code>id=1</code>的记录，发现和上一次读取到的数据不一致，这就是脏读。</p>
<p>可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。</p>
<h3 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h3><p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p>
<p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p>
<p>我们仍然先准备好<code>students</code>表的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">COMMIT;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<p>当事务B第一次执行第3步的查询时，得到的结果是<code>Alice</code>，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了<code>Bob</code>，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。 </p>
<h3 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h3><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p>
<p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p>
<p>我们仍然先准备好<code>students</code>表的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th align="left">时刻</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
<td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">BEGIN;</td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">COMMIT;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">UPDATE students SET name = ‘Alice’ WHERE id = 99;</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"></td>
<td align="left">SELECT * FROM students WHERE id = 99;</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<p>事务B在第3步第一次读取<code>id=99</code>的记录时，读到的记录为空，说明不存在<code>id=99</code>的记录。随后，事务A在第4步插入了一条<code>id=99</code>的记录并提交。事务B在第6步再次读取<code>id=99</code>的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取<code>id=99</code>的记录时，记录出现了。</p>
<p>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p>
<p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p>
<h3 id="默认隔离级别"><a href="#默认隔离级别" class="headerlink" title="默认隔离级别"></a>默认隔离级别</h3><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Pycharm For Linux</title>
    <url>/2019/11/28/2019-11-28-%E5%85%B3%E4%BA%8EPycharm%20For%20Linux/</url>
    <content><![CDATA[<blockquote>
<p>​    </p>
</blockquote>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>官网下载Linux版本即可。下载好的文件的名称可能是 ‘pycharm-professional-2019.2.5.tar.gz’。默认下载到“下载”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; cd ~/Downloads</span><br><span class="line">&gt; tar -xvzf pycharm-professional-2019.2.5.tar.gz -C ~</span><br></pre></td></tr></table></figure>

<p>上面的命令将会把 PyCharm 软件安装在 home 目录中。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>进入home目录下安装文件的bin文件夹进行启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; cd ~</span><br><span class="line">&gt; cd pycharm-2019.2.5/bin</span><br><span class="line">&gt; sh pycharm.sh &amp;</span><br></pre></td></tr></table></figure>



<h1 id="收藏栏固定启动图标"><a href="#收藏栏固定启动图标" class="headerlink" title="收藏栏固定启动图标"></a>收藏栏固定启动图标</h1><p>这样每次启动都比较麻烦，所以想将启动图标固定在收藏栏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; cd 桌面</span><br><span class="line">&gt; code pycharm.desktop</span><br><span class="line">这里提示我没有安装code</span><br><span class="line">&gt; sudo snap install code --classic</span><br><span class="line">code安装成功之后再次运行</span><br><span class="line">&gt; code pycharm.desktop</span><br><span class="line">会自动打开vscode,没有vscode的用vi一样</span><br></pre></td></tr></table></figure>

<p>将以下内容写到vscode中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Name=Pycharm</span><br><span class="line">Icon=/home/hpf/pycharm-2019.2.5/bin/pycharm.png</span><br><span class="line">Exec=sh /home/hpf/pycharm-2019.2.5/bin/pycharm.sh</span><br><span class="line">Terminal=false</span><br></pre></td></tr></table></figure>

<p>这时右击桌面文件设置为可运行程序， sudo chmod +x 也一样</p>
<p><img src="https://i.loli.net/2019/11/28/NgtAdQZb3RLSlOX.png" alt=""></p>
<p>双击信任一下</p>
<p><img src="https://i.loli.net/2019/11/28/T5cmAadsoLhH6pP.png" alt=""></p>
<p>这时候应该就可以打开了</p>
<p>把图标发到Application里面</p>
<p><code>sudo mv pycharm.desktop /usr/share/applications/</code></p>
<p>这时候搜索就可以查到了，右击添加到收藏夹就可以了</p>
<p><img src="https://i.loli.net/2019/11/28/7HND1ZyUYLdViO3.png" alt=""></p>
<p><img src="https://i.loli.net/2019/11/28/MD6yBSOCKYJ8oxn.png" alt=""></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Django新建APP</title>
    <url>/2019/11/28/2019-11-28-%E5%85%B3%E4%BA%8EDjango%E6%96%B0%E5%BB%BAAPP/</url>
    <content><![CDATA[<blockquote>
<p>新建APP</p>
</blockquote>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp Name</span><br></pre></td></tr></table></figure>

<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>在setting.py中加入新增加的APP</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">	………………</span><br><span class="line">    <span class="string">'honor'</span>,</span><br><span class="line">    <span class="string">'aboutus'</span>,</span><br><span class="line">    <span class="string">'news'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="修改新增APP中文件"><a href="#修改新增APP中文件" class="headerlink" title="修改新增APP中文件"></a>修改新增APP中文件</h1><h2 id="新增template-news-html"><a href="#新增template-news-html" class="headerlink" title="新增template/news.html"></a>新增template/news.html</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends 'base.html' %&#125;</span><br><span class="line">&#123;% block title %&#125;新闻资讯&#123;% endblock %&#125;</span><br><span class="line">&#123;% block nav_news_active %&#125;</span><br><span class="line">active</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; content.content|safe &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="models-py新增model"><a href="#models-py新增model" class="headerlink" title="models.py新增model"></a>models.py新增model</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> ckeditor_uploader.fields <span class="keyword">import</span> RichTextUploadingField</span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    content = RichTextUploadingField()</span><br></pre></td></tr></table></figure>

<h2 id="views-py新增view"><a href="#views-py新增view" class="headerlink" title="views.py新增view"></a>views.py新增view</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render_to_response,get_object_or_404</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> News</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_news</span><span class="params">(request)</span>:</span></span><br><span class="line">    context = &#123;&#125;</span><br><span class="line">    context[<span class="string">'content'</span>] = get_object_or_404(News, pk=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">'news.html'</span>, context)</span><br></pre></td></tr></table></figure>

<h2 id="admin-py新增admin"><a href="#admin-py新增admin" class="headerlink" title="admin.py新增admin"></a>admin.py新增admin</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> News</span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(News)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (<span class="string">'id'</span>, <span class="string">'content'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="app-py新增app"><a href="#app-py新增app" class="headerlink" title="app.py新增app"></a>app.py新增app</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = <span class="string">'news'</span></span><br></pre></td></tr></table></figure>

<h1 id="路由文件"><a href="#路由文件" class="headerlink" title="路由文件"></a>路由文件</h1><p>在项目目录下的urls.py中添加该app的路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">………………</span><br><span class="line"><span class="keyword">from</span> news.views <span class="keyword">import</span> show_news</span><br><span class="line">………………</span><br><span class="line">urlpatterns = [</span><br><span class="line">	………………</span><br><span class="line">    path(<span class="string">'news'</span>, show_news, name=<span class="string">'news'</span>),</span><br><span class="line">	………………</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h1 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h1><p>还是两个步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在base.html中就可以使用该app了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"&#123;% block nav_news_active %&#125;&#123;% endblock %&#125;"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'news' %&#125;"</span>&gt;</span>新闻资讯<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Django迁移数据库</title>
    <url>/2019/11/28/2019-11-28-%E5%85%B3%E4%BA%8EDjango%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<blockquote>
<p> Django中每一个模型model都对应于数据库中的一张表，每个模型中的字段都对应于数据库表的列。  默认是sqlite3数据库，所以我们需要将其修改成mysql数据库。     </p>
</blockquote>
<h1 id="修改settings-py配置信息"><a href="#修改settings-py配置信息" class="headerlink" title="修改settings.py配置信息"></a>修改settings.py配置信息</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Database</span></span><br><span class="line"><span class="comment"># https://docs.djangoproject.com/en/2.0/ref/settings/#databases</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库配置 默认的数据库为sqlite</span></span><br><span class="line"><span class="comment"># DATABASES = &#123;</span></span><br><span class="line"><span class="comment">#     'default': &#123;</span></span><br><span class="line"><span class="comment">#         'ENGINE': 'django.db.backends.sqlite3',</span></span><br><span class="line"><span class="comment">#         'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>, <span class="comment"># 数据库引擎</span></span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django_mysql'</span>, <span class="comment"># 数据库名</span></span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>, <span class="comment"># 账号</span></span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'root'</span>, <span class="comment"># 密码</span></span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>, <span class="comment"># HOST</span></span><br><span class="line">        <span class="string">'POST'</span>: <span class="number">3306</span>, <span class="comment"># 端口</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段名称代码中都添加了相应说明，ENGINE为MYSQL数据库引擎，这个当然不会凭空出现，需要我们去安装 。</p>
<p>需要注意的是，python3.x之后，使用原来python2.7的mysqldb已经不能连接mysql数据库了，要使用pymysql，来完成连接mysql的重任 。</p>
<h1 id="安装pymysql"><a href="#安装pymysql" class="headerlink" title="安装pymysql"></a>安装pymysql</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure>

<h1 id="项目中配置"><a href="#项目中配置" class="headerlink" title="项目中配置"></a>项目中配置</h1><p> 在项目包下的__ init __.py中进行如下配置 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">setting中的配置默认为sqlite3数据库 当需要修改成MySql时</span></span><br><span class="line"><span class="string">并且在setting.py的同级目录的__init__.py 加入如下配置</span></span><br><span class="line"><span class="string">否则会报错： Error loading MySQLdb module.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<h1 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database django_mysql;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<h1 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>

<p> 将models文件生成一个迁移文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p> 将迁移文件的内容作用到数据库中，生成表或者修改字段属性 </p>
<p>此时数据库的迁移已经完成，也可以运行成功，但是admin使用原密码无法进入。</p>
<h1 id="创建admin"><a href="#创建admin" class="headerlink" title="创建admin"></a>创建admin</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<p>输入账号、邮箱（随便）、密码即可。</p>
<h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p><img src="https://i.loli.net/2019/11/28/nGfEbWvmBItdekX.png" alt=""></p>
<p>从上至下依次为网站实际显示、Django admin后台、mysql数据库。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Django尝试</title>
    <url>/2019/11/28/2019-11-28-%E5%85%B3%E4%BA%8EDjango%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>总管负责的电磁加热宣传网站使用的 Bootstrap 和 Django，来玩玩。    </p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>基本思路：使用Pycharm打开仓库clone下来的Django项目，Project Interpreter中选择conda新建的环境。</p>
<p>但是，clone打开之后</p>
<p><img src="https://i.loli.net/2019/11/28/bNocFyG2wlK3kQW.png" alt=""></p>
<p>提示要install requirment，点击之后可以安装部分，但日志提示有一些无法安装，项目也无法运行。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>直接在控制台手动安装requirment.txt中的需求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Django==2.0</span><br><span class="line">django-ckeditor==5.4.0</span><br><span class="line">django-js-asset==1.0.0</span><br><span class="line">pillow==6.2.0</span><br><span class="line">PyQt5==5.13.1</span><br><span class="line">PyQt5-sip==12.7.0</span><br><span class="line">pytz==2017.3</span><br><span class="line">virtualenv==16.7.6</span><br></pre></td></tr></table></figure>

<p>运行命令<code>pip install -r requirements.txt</code></p>
<p>其他可以安装，但是pillow安装出现错误。</p>
<p><img src="https://i.loli.net/2019/11/28/KZYpEmNzhtuJ5Ix.png" alt=""></p>
<p>选择自己手动安装，<code>pip install pillow</code></p>
<p>此时运行<code>python manage.py runserver</code>，可以运行。</p>
<p><img src="https://i.loli.net/2019/11/28/qBizK58tMxFGLjP.png" alt=""></p>
<p>但是打开浏览器发现加载有误，需要更换迁移一下数据库：</p>
<p>依次执行</p>
<p><code>python manage.py makemigrations</code></p>
<p><code>python manage.py migrate</code></p>
<p><img src="https://i.loli.net/2019/11/28/rnfo5sSmKQgv2Al.png" alt=""></p>
<p>再次运行，打开浏览器，成功。</p>
<p>需要注意一下，以上所有控制台命令前都有(heaterWeb)，即所有包都安装在了conda新建的heaterWeb环境中。</p>
<p><img src="https://i.loli.net/2019/11/28/T2VbtZcfOkJEIQn.png" alt=""></p>
<p>/admin输入账户密码即可进入Django管理后台，用于页面内容编辑上传，内容会保存在项目关联的数据库中。</p>
<p><img src="https://i.loli.net/2019/11/28/LrfivNc3YCBV5PS.png" alt=""></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>关于网络通信</title>
    <url>/2019/11/21/2019-11-21-%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p>例子：    </p>
<p>下载资源<br>资源上传<br>从服务器（某个网络终端）取得数据<br>向其他计算机发送消息<br>接收其他计算机发送的消息<br>计算机之间的交流，计算机之间数据的传递</p>
<h1 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h1><p>简述：ip地址是网络中计算机的唯一标识。<br>举例：xx.xx.xx.xx  xx是0-255之间的一个数字<br>问题：<br>        什么是局域网ip（192.168.xx.xx），什么是外网ip（查询到全球互联网下的任一台计算机，一般为了节省地址，服务器是独立IP，其他可能一个局域网内是一个外网IP）<br>        如何查看本机ip（ipconfig）<br>ip是不能重复的<br>        局域网ip在局域网内，不可以重复。外网ip在外网环境下不可以重复<br>        每个域名，访问的其实都是某个服务器，服务器其实是一台计算机，是计算机就有一个唯一的ip地址。<br>        访问域名的时候，其实就是通过服务器的ip地址，找到服务器并获取数据。<br>        域名跟ip地址是一一对应的。<br>        ping 域名<br>        ping ip地址</p>
<p>特殊的ip地址<br>    127.0.0.1 localhost</p>
<p>什么是ipv4和ipv6</p>
<h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><p>有了地址可以找到住的地方，这个地方可能有很多人同时居住，我们还需要一个收件人。端口就相当于收件人。<br>我们的电脑上有很多运行的程序，有的程序不需要跟外界交互（单机软件）<br>有的程序需要跟外界交互，这个时候我们需要通过端口号区分我们要跟那个软件交互。<br><strong>总结</strong>：通过ip定位计算机，通过port定位哪个软件<br><strong>注意</strong>：端口号是不能重复的。端口号是一个数字。    </p>
<h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><p>两个计算机通信，也就是两个计算机交流，也就是两个计算机交流数据。</p>
<p>通信规则<br>    UDP<br>        速度快<br>        不需要建立连接<br>        不可靠<br>    TCP<br>        速度慢<br>        需要通过三次握手建立连接，四次挥手断开连接<br>        可靠<br>    举例：<br>        UDP：发短信<br>        TCP：打电话<br><strong>网络编程的三要素总结：IP地址，端口号，通信协议。</strong></p>
<h1 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h1><p>在程序中我们通过Socket进行通信，在使用Socket通信的时候<br>需要指定上面所说的几个条件（ip，port，协议）</p>
<p>数据发送分成两步<br>    第一步是监听（等待数据发送过来），用来接收数据。需要指定监听的端口号<br>    第二步是发送，需要指定发送到哪个计算机（IP地址），需要指定发送到这个计算机的哪个端口。</p>
<p>Socket中分为发送端和接收端<br>    发送端一般为客户端，接收端为服务器端。<br>    一般情况下我们会有多个客户端，一个服务器端。</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="使用UDP发送数据"><a href="#使用UDP发送数据" class="headerlink" title="使用UDP发送数据"></a>使用UDP发送数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="string">""</span>.getBytes();</span><br><span class="line"><span class="keyword">int</span> length = bys.length;</span><br><span class="line">InetAddress ip = InetAddress.getByName(<span class="string">"xx.xx.xx.xx"</span>);</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">7878</span>;</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys,length,ip,port);</span><br><span class="line">ds.send(dp);</span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>

<h2 id="使用UDP接收数据"><a href="#使用UDP接收数据" class="headerlink" title="使用UDP接收数据"></a>使用UDP接收数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">7878</span>);<span class="comment">//为什么接收的时候，需要直接指定端口号，而发送的时候，不是在这里指定</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> length = data.length;</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data,length);</span><br><span class="line">ds.receive(dp);</span><br><span class="line"><span class="keyword">byte</span>[] dataReceive = dp.getData();</span><br><span class="line"><span class="keyword">int</span> length2 = dp.getLength();</span><br><span class="line">String str = <span class="keyword">new</span> String(dataReceive,<span class="number">0</span>,length2);</span><br><span class="line">InetAddress address = dp.getAddress();</span><br><span class="line"><span class="keyword">int</span> port = dp.getPort();</span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>

<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP发送端（客户端）"><a href="#TCP发送端（客户端）" class="headerlink" title="TCP发送端（客户端）"></a>TCP发送端（客户端）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket s = <span class="keyword">new</span> Socket(<span class="string">"xx.xx.xx"</span>,port);</span><br><span class="line">OutputStream os = s.getOutputStream();</span><br><span class="line">os.write(<span class="string">"xxxx"</span>.getBytes());</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure>

<h2 id="TCP接收端（服务器端）"><a href="#TCP接收端（服务器端）" class="headerlink" title="TCP接收端（服务器端）"></a>TCP接收端（服务器端）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"></span><br><span class="line">Socket s = ss.accetp();</span><br><span class="line"></span><br><span class="line">InputStream in = s.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> length = in.read(data);</span><br><span class="line">String s = <span class="keyword">new</span> String(data,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>网络通信</tag>
      </tags>
  </entry>
  <entry>
    <title>关于多线程</title>
    <url>/2019/11/20/2019-11-20-%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p> 基本概念不多做介绍。</p>
</blockquote>
<h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><p>两种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------</span><br><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</span><br><span class="line">MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">"线程2"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------</span><br><span class="line">MyRunnable t = <span class="keyword">new</span> MyRunnable();		</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(t,<span class="string">"线程1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(t,<span class="string">"线程2"</span>);</span><br></pre></td></tr></table></figure>

<p>可以看出最明显的区别是上者多线程需要创建多个对象，而下者可以使用一个对象，这样就可以在MyRunnable中定义数据，多个线程共享，再者，java”单继承，多实现”，故下者还可以继承其他类进行扩展，所以下者用的多一些。</p>
<h1 id="线程守护"><a href="#线程守护" class="headerlink" title="线程守护"></a>线程守护</h1><p>可以把线程守护理解为保镖，用它去保护其他线程，若其他线程结束或者中断，那它也没有存在的意义，会被强制终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t2.setDaemon(<span class="keyword">true</span>); <span class="comment">//设置t2为守护线程</span></span><br></pre></td></tr></table></figure>

<h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>线程中断需要使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.interrupt();</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是此时并没有真正的中断该线程，只是将这个线程的中断状态的布尔值进行了修改，要想真正中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(interrupted()) &#123;<span class="comment">//若当前线程被设置为中断状态</span></span><br><span class="line">    <span class="comment">// System.out.println("释放资源");</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是中断前给线程一个留“临终遗言”的机会，交代完“后事”才可以真正被中断。</p>
<p>直接杀死线程的stop方法已经被弃用。</p>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p> <a href="https://blog.csdn.net/lonelyroamer/article/details/7949969" target="_blank" rel="noopener">https://blog.csdn.net/lonelyroamer/article/details/7949969</a> </p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>什么是线程安全：多个线程同时要修改一个变量的时候，引起冲突<br>线程安全问题解决</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;<span class="comment">//锁住某个对象，如果这个对象已经被锁定，那么等待。</span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;<span class="comment">//执行完之后，归还钥匙</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">………………</span><br><span class="line">lock.lock();<span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>出现线程安全问题的地方，要锁同一个对象（可以是当前对象，也可以单独创建一个对象）</p>
</li>
<li><p>锁住某个对象，如果这个对象已经被锁定，那么停止当前线程的执行，一直等待，一直等到对象被解锁。</p>
<pre><code>（保证同一个时间，只有一个线程在使用这个对象）</code></pre></li>
<li><p>创建同步方法</p>
<pre><code>同步方法锁的是哪个对象呢？锁定的是当前对象this</code></pre></li>
</ul>
<p>另补充：线程安全的类 </p>
<ul>
<li>安全：    StringBuffer     Vector </li>
<li>不安全：StringBuilder    ArrayList</li>
</ul>
<h1 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h1><p>死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>形象化例子：吃饭需要同时使用刀叉，一个人拿叉等刀，另一个人拿刀等叉。</p>
<p>产生举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (Demo07_DeadLock.lock1) &#123;</span><br><span class="line">			System.out.println(<span class="string">"取得第一把锁之后要做的事情"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (Demo07_DeadLock.lock2) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Thread1同时取得两把锁之后要做的事情"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (Demo07_DeadLock.lock2) &#123;</span><br><span class="line">			System.out.println(<span class="string">"取得第二把锁之后要做的事情"</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (Demo07_DeadLock.lock1) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Thread2同时取得两把锁之后要做的事情"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样两个进程都卡住等待</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">取得第一把锁之后要做的事情</span><br><span class="line">取得第二把锁之后要做的事情</span><br></pre></td></tr></table></figure>

<p>解决方案：将两个线程取锁的顺序换为一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (Demo07_DeadLock.lock1) &#123;			</span><br><span class="line">			<span class="keyword">synchronized</span> (Demo07_DeadLock.lock2) &#123;</span><br><span class="line">				System.out.println(<span class="string">"取得第二把锁之后要做的事情"</span>);</span><br><span class="line">				System.out.println(<span class="string">"Thread2同时取得两把锁之后要做的事情"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h1><p>线程组ThreadGroup 默认处于同一个组里面<br>使用线程组可以统一设置这个组内线程的一些东西。比如设置优先级，设置是否是守护线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"我们的线程组"</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tg,r);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tg,r);</span><br></pre></td></tr></table></figure>

<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>作用：一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。<br>使用类：Timer（定时器）和TimerTask（定时器启动之后要执行的任务）</p>
<pre><code>timer.schedule(TimerTask task, long delay) 
timer.schedule(TimerTask task, long delay, long period) 
timer.schedule(TimerTask task, Date time) 
timer.cancel();</code></pre><p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于使用JSONObject的问题</title>
    <url>/2019/11/11/2019-11-11-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8JSONObject%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在Controller中，为了给客户端直接返回json数据，使用了JSONObject，想直接返回Json格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userServiceImpl;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">register</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String userName = request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">        String userPassword = request.getParameter(<span class="string">"userPassword"</span>);</span><br><span class="line">        String userRight = request.getParameter(<span class="string">"userRight"</span>);</span><br><span class="line">        String telephoneNum = request.getParameter(<span class="string">"telephoneNum"</span>);</span><br><span class="line">        String registerTime = <span class="keyword">new</span> nowTime().nowTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> selectResult=<span class="number">0</span>;<span class="comment">//判断是否已经存在</span></span><br><span class="line">        <span class="keyword">long</span> addResult = <span class="number">0</span>;<span class="comment">//判断添加是否成功</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userServiceImpl.selectUserByuserName(userName) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            selectResult=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setUserName(userName);</span><br><span class="line">            user.setUserPassword(userPassword);</span><br><span class="line">            user.setUserRight(userRight);</span><br><span class="line">            user.setTelephoneNum(telephoneNum);</span><br><span class="line">            user.setRegisterTime(registerTime);</span><br><span class="line"></span><br><span class="line">            addResult = userServiceImpl.addUser(user);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            selectResult = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(selectResult == <span class="number">1</span>)&#123;</span><br><span class="line">            JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            result.put(<span class="string">"success"</span>,<span class="keyword">false</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>,<span class="string">"该用户名已存在！"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(addResult != <span class="number">0</span>)&#123;</span><br><span class="line">            JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            result.put(<span class="string">"success"</span>,<span class="keyword">true</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>,<span class="string">"注册成功！"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            result.put(<span class="string">"success"</span>,<span class="keyword">false</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>,<span class="string">"注册失败！请稍后再试！"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，发现Postman测试数据是可以写入数据库的，但是Postman返回却不是result，而是</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"empty"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后发现原因是：<code>pring boot uses jackson as default serializer and you&#39;re trying to return JSONObject itself. Jackson does not know how to serialize it.If you want to return dynamic json you can use Map</code></p>
<p>具体戳<a href="https://stackoverflow.com/questions/51986833/method-returning-json-emptyfalse-although-this-json-has-data/58803059#58803059" target="_blank" rel="noopener">这里</a>。</p>
<p>改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userServiceImpl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/register"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">register</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ………………………………</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(selectResult == <span class="number">1</span>)&#123;</span><br><span class="line">            Map&lt;String,Object&gt; result = <span class="keyword">new</span> HashMap();</span><br><span class="line">            result.put(<span class="string">"success"</span>,<span class="keyword">false</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>,<span class="string">"该用户名已存在！"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(addResult != <span class="number">0</span>)&#123;</span><br><span class="line">            Map&lt;String,Object&gt; result = <span class="keyword">new</span> HashMap();</span><br><span class="line">            result.put(<span class="string">"success"</span>,<span class="keyword">true</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>,<span class="string">"注册成功！"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Map&lt;String,Object&gt; result = <span class="keyword">new</span> HashMap();</span><br><span class="line">            result.put(<span class="string">"success"</span>,<span class="keyword">false</span>);</span><br><span class="line">            result.put(<span class="string">"message"</span>,<span class="string">"注册失败！请稍后再试！"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试，成功。</p>
<p><img src="https://i.loli.net/2019/11/11/IfMFrQk7nXWBbt6.png" alt=""></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习5-延迟加载及缓存</title>
    <url>/2019/11/10/2019-11-10-Mybatis%E5%AD%A6%E4%B9%A05-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h1><p>问题：在一对多中，当我们有一个用户，它有100个账户。<br>　　　　　　　在查询用户的时候，要不要把关联的账户查出来？<br>　　　　　　　在查询账户的时候，要不要把关联的用户查出来？<br>答案：在查询用户时，用户下的账户信息是，什么时候使用，什么时候查询的。<br>　　　在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来的。</p>
<h2 id="延迟加载与立即加载"><a href="#延迟加载与立即加载" class="headerlink" title="延迟加载与立即加载"></a>延迟加载与立即加载</h2><p>延迟加载：在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）；<br>立即加载：不管用不用，只要一调用方法，马上发起查询；<br>在对应的四种表关系中：一对一，一对多，多对一，多对多。<br>　　　　　　　一对多，多对多：通常情况下我们都是采用延迟加载。<br>　　　　　　　多对一，一对一：通常情况下我们都是采用立即加载。</p>
<h2 id="一对一延迟加载"><a href="#一对一延迟加载" class="headerlink" title="一对一延迟加载"></a>一对一延迟加载</h2><h3 id="1-在SqlMapConfig-xml中配置setting标签"><a href="#1-在SqlMapConfig-xml中配置setting标签" class="headerlink" title="1.在SqlMapConfig.xml中配置setting标签"></a>1.在SqlMapConfig.xml中配置setting标签</h3><p>详情看中文官网（<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#settings）" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html#settings）</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 在Mybatis配置文件中</span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置全局延迟加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在IAccoutDao-xml中添加select属性"><a href="#2-在IAccoutDao-xml中添加select属性" class="headerlink" title="2.在IAccoutDao.xml中添加select属性"></a>2.在IAccoutDao.xml中添加select属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">………………</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gsynf.dao.IAccountDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义封装Account和User的resultMap--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountUserMap"</span> <span class="attr">type</span>=<span class="string">"account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一对一的关系映射：配置封装user的内容</span></span><br><span class="line"><span class="comment">        select属性的内容，查询用户的唯一标识符</span></span><br><span class="line"><span class="comment">        column属性的内容:用户根据id查询时，所需要参数的值</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"user"</span> <span class="attr">select</span>=<span class="string">"com.gsynf.dao.IUserDao.findById"</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span>  <span class="attr">resultMap</span>=<span class="string">"accountUserMap"</span>&gt;</span></span><br><span class="line">        select * from account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="一对多延迟加载"><a href="#一对多延迟加载" class="headerlink" title="一对多延迟加载"></a>一对多延迟加载</h2><p>和一对一基本一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">……………………</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gsynf.dao.IUserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义User的resultMap--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置User对象中Account集合的映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"account"</span> <span class="attr">select</span>=<span class="string">"com.gsynf.dao.IAccountDao.findAccountByUid"</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span>  <span class="attr">resultMap</span>=<span class="string">"userAccountMap"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据Id查询用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>什么是缓存：存在于内存中的临时数据</p>
</li>
<li><p>为什么使用缓存：减少与数据库的交互次数，提高执行效率。</p>
</li>
<li><p>什么样的数据能使用缓存，什么样的数据不能使用</p>
<ul>
<li>适用于缓存：<ul>
<li>经常查询并且不经常改变的</li>
<li>数据的正确与否对最终结果影响不大的</li>
</ul>
</li>
<li>不适用于缓存：<ul>
<li>经常改变的数据</li>
<li>数据的正确与否对最终结果影响很大的。如，商品库存，银行汇率，股市牌价</li>
</ul>
</li>
</ul>
</li>
<li><p>mybatis中的一级缓存和二级缓存</p>
<ul>
<li><p>一级缓存：</p>
<ul>
<li>它指的是mybatis中SqlSession对象的缓存。</li>
<li>当我们执行查询的时候，查询的结果会同时存入到SqlSession为我们提供的一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去查询SqlSession中是否有，有的话直接拿来用。</li>
<li>当SqlSession对象消失时，mybatis的一级缓存也就消失了。</li>
</ul>
</li>
<li><p>二级缓存：</p>
<ul>
<li>它指的是mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。</li>
<li>二级缓存的使用步骤：<ul>
<li>第一步：让mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）</li>
<li>第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）</li>
<li>第三步：让当前的操作支持二级缓存（在select标签中配置）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>其实mybatis中默认就是一级缓存了（平时的测试类就是一级缓存存在SqlSession中）</p>
<p><strong>一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit()，close()，clearCache()等方法时，就会清空一级缓存。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFirstLevelCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User user1 = userDao.findById(<span class="number">41</span>);</span><br><span class="line">System.out.println(user1);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//sqlSession.clearCache();</span></span><br><span class="line">    </span><br><span class="line">User user2 = userDao.findById(<span class="number">41</span>);</span><br><span class="line">System.out.println(user2);</span><br><span class="line"></span><br><span class="line">System.out.println(user1 == user2);</span><br><span class="line">&#125;</span><br><span class="line">------------------打印结果----------------------</span><br><span class="line">User&#123;id=<span class="number">41</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">41</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>&#125;</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>



<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="1-SqlMaoConfig-xml中"><a href="#1-SqlMaoConfig-xml中" class="headerlink" title="1.SqlMaoConfig.xml中"></a>1.SqlMaoConfig.xml中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在需要使用二级缓存的实体类的mapper中"><a href="#2-在需要使用二级缓存的实体类的mapper中" class="headerlink" title="2.在需要使用二级缓存的实体类的mapper中"></a>2.在需要使用二级缓存的实体类的mapper中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启user支持二级缓存--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根据id查询用户   注意属性useCache --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"INT"</span> <span class="attr">resultType</span>=<span class="string">"user"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">       select * from user where id = #&#123;uid&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-测试类"><a href="#3-测试类" class="headerlink" title="3.测试类"></a>3.测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondLevelCacheTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InputStream in;</span><br><span class="line">    <span class="keyword">private</span>  SqlSessionFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span><span class="comment">//用于在测试方法执行之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.读取配置文件，生成字节输入流</span></span><br><span class="line">        in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//2.获取SqlSessionFactory</span></span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span><span class="comment">//用于在测试方法执行之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试二级缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSecondLevelCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession();</span><br><span class="line">        IUserDao dao1 = sqlSession1.getMapper(IUserDao.class);</span><br><span class="line">        User user1 = dao1.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">        sqlSession1.close();<span class="comment">//一级缓存消失</span></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession2 = factory.openSession();</span><br><span class="line">        IUserDao dao2 = sqlSession2.getMapper(IUserDao.class);</span><br><span class="line">        User user2 = dao2.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">        sqlSession2.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(user1 == user2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">------------------打印结果------------------------</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">00</span>,<span class="number">127</span> <span class="number">273</span>    [           main] DEBUG om.gsynf.dao.IUserDao.findById  - ==&gt;  Preparing: select * from user where id = ? </span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">00</span>,<span class="number">147</span> <span class="number">293</span>    [           main] DEBUG om.gsynf.dao.IUserDao.findById  - ==&gt; Parameters: <span class="number">41</span>(Integer)</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">00</span>,<span class="number">169</span> <span class="number">315</span>    [           main] DEBUG om.gsynf.dao.IUserDao.findById  - &lt;==      Total: <span class="number">1</span></span><br><span class="line">User&#123;id=<span class="number">41</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>&#125;</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">00</span>,<span class="number">188</span> <span class="number">334</span>    [           main] DEBUG ansaction.jdbc.JdbcTransaction  - Resetting autocommit to <span class="keyword">true</span> on JDBC Connection [com.mysql.jdbc.JDBC4Connection@<span class="number">5965</span>d37]</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">00</span>,<span class="number">188</span> <span class="number">334</span>    [           main] DEBUG ansaction.jdbc.JdbcTransaction  - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@<span class="number">5965</span>d37]</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">00</span>,<span class="number">188</span> <span class="number">334</span>    [           main] DEBUG source.pooled.PooledDataSource  - Returned connection <span class="number">93740343</span> to pool.</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">00</span>,<span class="number">191</span> <span class="number">337</span>    [           main] DEBUG         com.gsynf.dao.IUserDao  - Cache Hit Ratio [com.gsynf.dao.IUserDao]: <span class="number">0.5</span></span><br><span class="line">User&#123;id=<span class="number">41</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>&#125;</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>注意：<br>从图中可以看出来第二次findById根本没有走数据库（数据都是从SqlSessionFactory的二级缓存中拿的 不是对象！所以是新建了一个对象，打印的是false）</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习4-多表查询</title>
    <url>/2019/11/08/2019-11-08-Mybatis%E5%AD%A6%E4%B9%A04-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="表之间的关系"><a href="#表之间的关系" class="headerlink" title="表之间的关系"></a>表之间的关系</h1><ul>
<li>一对多/ 多对一/ 一对一/ 多对多</li>
</ul>
<p>举例：</p>
<ul>
<li><p>用户和订单就是一对多</p>
</li>
<li><p>订单和用户就是多对一</p>
<ul>
<li>一个用户可以下多个订单</li>
<li>多个订单属于同一个用户</li>
</ul>
</li>
<li><p>人和身份证号就是一对一</p>
<ul>
<li>一个人只能有一个身份证号</li>
<li>一个身份证号只能属于一个人</li>
</ul>
</li>
<li><p>老师和学生之间就是多对多</p>
<ul>
<li>一个学生可以被多个老师教过</li>
<li>一个老师可以交多个学生</li>
</ul>
</li>
<li><p>特例：</p>
<ul>
<li><p>如果拿出每一个订单，它都只能属于一个用户。</p>
<p>所以Mybatis就把多对一看成了一对一。</p>
</li>
</ul>
</li>
</ul>
<h1 id="一对一关系映射"><a href="#一对一关系映射" class="headerlink" title="一对一关系映射"></a>一对一关系映射</h1><p>示例：用户和账户</p>
<p>​        一个用户可以有多个账户<br>​        一个账户只能属于一个用户（多个账户也可以属于同一个用户）<br>步骤：<br>​        1、建立两张表：用户表，账户表<br>​                让用户表和账户表之间具备一对多的关系：需要使用外键在账户表中添加<br>​        2、建立两个实体类：用户实体类和账户实体类<br>​                让用户和账户的实体类能体现出来一对多的关系<br>​        3、建立两个配置文件<br>​                用户的配置文件<br>​                账户的配置文件<br>​        4、实现配置：<br>​                当我们查询用户时，可以同时得到用户下所包含的账户信息<br>​                当我们查询账户时，可以同时得到账户的所属用户信息</p>
<p>建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">  <span class="string">`birthday`</span> datetime <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地址'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`user`</span>(<span class="string">`id`</span>,<span class="string">`username`</span>,<span class="string">`birthday`</span>,<span class="string">`sex`</span>,<span class="string">`address`</span>) <span class="keyword">values</span> (<span class="number">41</span>,<span class="string">'老王'</span>,<span class="string">'2018-02-27 17:47:08'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(<span class="number">42</span>,<span class="string">'小二王'</span>,<span class="string">'2018-03-02 15:09:37'</span>,<span class="string">'女'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">43</span>,<span class="string">'小二王'</span>,<span class="string">'2018-03-04 11:34:34'</span>,<span class="string">'女'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">45</span>,<span class="string">'传智播客'</span>,<span class="string">'2018-03-04 12:04:06'</span>,<span class="string">'男'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">46</span>,<span class="string">'老王'</span>,<span class="string">'2018-03-07 17:37:26'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(<span class="number">48</span>,<span class="string">'小马宝莉'</span>,<span class="string">'2018-03-08 11:44:00'</span>,<span class="string">'女'</span>,<span class="string">'北京修正'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`account`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`account`</span> (</span><br><span class="line">  <span class="string">`ID`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`UID`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户编号'</span>,</span><br><span class="line">  <span class="string">`MONEY`</span> <span class="keyword">double</span> <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'金额'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`ID`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FK_Reference_8`</span> (<span class="string">`UID`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_Reference_8`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`UID`</span>) <span class="keyword">REFERENCES</span> <span class="string">`user`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`account`</span>(<span class="string">`ID`</span>,<span class="string">`UID`</span>,<span class="string">`MONEY`</span>) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">46</span>,<span class="number">1000</span>),(<span class="number">2</span>,<span class="number">45</span>,<span class="number">1000</span>),(<span class="number">3</span>,<span class="number">46</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>



<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>查询所有账户操作,同时获取到该账户对应的用户的信息（多表查询常用方法）</p>
<h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><p>SQL语句查询所有账户的时候同时获得当前账户的所有信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.*,a.id <span class="keyword">as</span> aid,a.uid,a.money <span class="keyword">from</span> <span class="keyword">account</span> a ,<span class="keyword">user</span> u <span class="keyword">where</span> u.id=a.uid;</span><br></pre></td></tr></table></figure>

<p>SQL语句查询所有账户的时候同时获得当前账户的所地址和姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,u.username,u.address <span class="keyword">from</span> <span class="keyword">account</span> a ,<span class="keyword">user</span> u <span class="keyword">where</span> u.id=a.uid;</span><br></pre></td></tr></table></figure>

<h3 id="1-从表实体应该包含一个主表实体的对象引用"><a href="#1-从表实体应该包含一个主表实体的对象引用" class="headerlink" title="1. 从表实体应该包含一个主表实体的对象引用"></a>1. 从表实体应该包含一个主表实体的对象引用</h3><p>在Account类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从表实体应该包含一个主表实体的对象引用</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-IAccountDao的接口中"><a href="#2-IAccountDao的接口中" class="headerlink" title="2.IAccountDao的接口中"></a>2.IAccountDao的接口中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户，并且带有用户名称和地址信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;AccountUser&gt; <span class="title">findAllAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-IAccountDao的mapper中"><a href="#3-IAccountDao的mapper中" class="headerlink" title="3.IAccountDao的mapper中"></a>3.IAccountDao的mapper中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">…………………………</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gsynf.dao.IAccountDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义封装Account和User的resultMap--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountUserMap"</span> <span class="attr">type</span>=<span class="string">"account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一对一的关系映射：配置封装user的内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有账户，并且带有用户名称和地址信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAllAccount"</span>  <span class="attr">resultType</span>=<span class="string">"accountUser"</span>&gt;</span></span><br><span class="line">        select a.*,u.username,u.address from account a, user u where u.id = a.uid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意事项中的javaType=“User” 一定要指名主体表的实体类名然后column中指名从表的外键！！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"User"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-AccountDao的测试类中"><a href="#4-AccountDao的测试类中" class="headerlink" title="4.AccountDao的测试类中"></a>4.AccountDao的测试类中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: AccountTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 账户测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InputStream in;</span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span><span class="comment">//用于在测试方法执行之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.读取配置文件，生成字节输入流</span></span><br><span class="line">        in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">// 2.获取SqlSessionFactory</span></span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        <span class="comment">// 3.获取SqlSession对象</span></span><br><span class="line">        sqlSession = factory.openSession(<span class="keyword">true</span>);     <span class="comment">//自动提交设为true,就不用自己手动提交了</span></span><br><span class="line">        <span class="comment">// 4.获取dao的代理对象</span></span><br><span class="line">        accountDao = sqlSession.getMapper(IAccountDao.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span><span class="comment">//用于在测试方法执行之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line"><span class="comment">//        sqlSession.commit();</span></span><br><span class="line">        <span class="comment">// 6.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;AccountUser&gt; aus = accountDao.findAllAccount();</span><br><span class="line">        <span class="keyword">for</span> (AccountUser au : aus) &#123;</span><br><span class="line">            System.out.println(au);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5.运行结果"></a>5.运行结果</h3><p><img src="https://i.loli.net/2019/11/10/4871aIiESCWBUJN.png" alt=""></p>
<h3 id="第二种方法是创建一个AccountUser类"><a href="#第二种方法是创建一个AccountUser类" class="headerlink" title="第二种方法是创建一个AccountUser类"></a>第二种方法是创建一个AccountUser类</h3><p>不建议使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: AccountUser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 带有用户名称和地址的账户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountUser</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">"   AccountUser&#123;"</span> +</span><br><span class="line">                <span class="string">"usernam='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一对多关系映射"><a href="#一对多关系映射" class="headerlink" title="一对多关系映射"></a>一对多关系映射</h1><p>这里还是上一个一对一中用到的例子。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>查询所有用户操作,同时获取到用户下所有账户的信息（多表查询常用方法）</p>
<h3 id="SQL语句-1"><a href="#SQL语句-1" class="headerlink" title="SQL语句"></a>SQL语句</h3><p>SQL语句查询所有账户的时候同时获得当前账户的所有信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.*,a.id <span class="keyword">as</span> aid,a.uid,a.money <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">account</span> a <span class="keyword">on</span> u.id=a.uid</span><br></pre></td></tr></table></figure>

<h3 id="1-从表实体应该包含一个主表实体的对象引用-1"><a href="#1-从表实体应该包含一个主表实体的对象引用-1" class="headerlink" title="1.从表实体应该包含一个主表实体的对象引用"></a>1.从表实体应该包含一个主表实体的对象引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一对多关系引用：主表实体应该包含从表实体的集合引用</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">getAccounts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accounts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccounts</span><span class="params">(List&lt;Account&gt; accounts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.accounts = accounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.IUserDao的接口中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户，同时获取到用户下所有账户的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-IUserDao的接口中"><a href="#2-IUserDao的接口中" class="headerlink" title="2.IUserDao的接口中"></a>2.IUserDao的接口中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户，同时获取到用户下所有账户的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-IUserDao的mapper中"><a href="#3-IUserDao的mapper中" class="headerlink" title="3.IUserDao的mapper中"></a>3.IUserDao的mapper中</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">……………………</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.gsynf.dao.IUserDao"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义User的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userAccountMap"</span> type=<span class="string">"user"</span>&gt;</span><br><span class="line">        &lt;id property="id" column="id"&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property="username" column="username"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property="address" column="address"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property="sex" column="sex"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--配置User对象中Account集合的映射--&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"accounts"</span> ofType=<span class="string">"account"</span>&gt;</span><br><span class="line">            &lt;id property="id" column="aid"&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property="uid" column="uid"&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property="money" column="money"&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--查询所有--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"findAll"</span>  resultMap=<span class="string">"userAccountMap"</span>&gt;</span><br><span class="line">        select u.*,a.id as aid,a.uid,a.money from user u left outer join account a on u.id=a.uid</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p> 注意：一对一用的是association，一对多以及多对多用的是collection。 </p>
<h3 id="4-UserDao的测试类中"><a href="#4-UserDao的测试类中" class="headerlink" title="4.UserDao的测试类中"></a>4.UserDao的测试类中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有（一个用户下的账号信息）</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findAll</span><span class="params">( )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user:users) &#123;</span><br><span class="line">            System.out.println(<span class="string">"每个用户的信息"</span>);</span><br><span class="line">            System.out.println(user);</span><br><span class="line">            System.out.println(user.getAccounts());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-运行结果-1"><a href="#5-运行结果-1" class="headerlink" title="5.运行结果"></a>5.运行结果</h3><p><img src="https://i.loli.net/2019/11/10/UskZp4NYhtCHevg.png" alt=""></p>
<h1 id="多对多关系映射"><a href="#多对多关系映射" class="headerlink" title="多对多关系映射"></a>多对多关系映射</h1><p>示例：用户和角色<br>            一个用户可以有多个角色<br>            一个角色可以赋予多个用户<br>        步骤：<br>            1、建立两张表：用户表，角色表<br>                让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。<br>            2、建立两个实体类：用户实体类和角色实体类<br>                让用户和角色的实体类能体现出来多对多的关系<br>                各自包含对方一个集合引用<br>            3、建立两个配置文件<br>                用户的配置文件<br>                角色的配置文件<br>            4、实现配置：<br>                当我们查询用户时，可以同时得到用户所包含的角色信息<br>                当我们查询角色时，可以同时得到角色的所赋予的用户信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`role`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role`</span> (</span><br><span class="line">  <span class="string">`ID`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`ROLE_NAME`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色名称'</span>,</span><br><span class="line">  <span class="string">`ROLE_DESC`</span> <span class="built_in">varchar</span>(<span class="number">60</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色描述'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`ID`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`role`</span>(<span class="string">`ID`</span>,<span class="string">`ROLE_NAME`</span>,<span class="string">`ROLE_DESC`</span>) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'院长'</span>,<span class="string">'管理整个学院'</span>),(<span class="number">2</span>,<span class="string">'总裁'</span>,<span class="string">'管理整个公司'</span>),(<span class="number">3</span>,<span class="string">'校长'</span>,<span class="string">'管理整个学校'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user_role`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> (</span><br><span class="line">  <span class="string">`UID`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户编号'</span>,</span><br><span class="line">  <span class="string">`RID`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色编号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`UID`</span>,<span class="string">`RID`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FK_Reference_10`</span> (<span class="string">`RID`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_Reference_10`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`RID`</span>) <span class="keyword">REFERENCES</span> <span class="string">`role`</span> (<span class="string">`ID`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_Reference_9`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`UID`</span>) <span class="keyword">REFERENCES</span> <span class="string">`user`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`user_role`</span>(<span class="string">`UID`</span>,<span class="string">`RID`</span>) <span class="keyword">values</span> (<span class="number">41</span>,<span class="number">1</span>),(<span class="number">45</span>,<span class="number">1</span>),(<span class="number">41</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>查询所有角色操作，同时获取角色下所有用户信息；</p>
<p>查询所有用户操作，同时获取用户对应的所有角色信息；</p>
<h3 id="SQL语句-2"><a href="#SQL语句-2" class="headerlink" title="SQL语句"></a>SQL语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.*,r.id <span class="keyword">as</span> rid,r.role_name,r.role_desc <span class="keyword">from</span> <span class="keyword">role</span> r</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> user_role ur <span class="keyword">on</span> r.id = ur.rid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> u.id = ur.uid</span><br></pre></td></tr></table></figure>

<p>新建Role实体类、IRoleDao接口、IRoleDao.xml配置文件、RoleTest这些步骤这里不再详细赘述。</p>
<h3 id="1-一个实体应该包含另一个实体的的集合引用"><a href="#1-一个实体应该包含另一个实体的的集合引用" class="headerlink" title="1.一个实体应该包含另一个实体的的集合引用"></a>1.一个实体应该包含另一个实体的的集合引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多对多的关系映射：一个角色可以赋予给多个用户</span></span><br><span class="line"><span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsers</span><span class="params">(List&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.users = users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意其中每行末尾的空格<br><strong>目的：</strong>为了查询角色下的用户信息<br><strong>步骤：</strong>以role表（别名）为主表，左外连接user_role表（别名ur,此表为中间表），连接条件r.id = ur.rid 。<br>再以这两个表组合的表左外连接user表，连接条件u.id=ur.uid 。 </p>
<p><strong>注意：</strong><a href="https://jingyan.baidu.com/article/60ccbceb9578f164cab197f4.html" target="_blank" rel="noopener">关于数据库的连接</a></p>
<h3 id="2-IRoleDao的接口中"><a href="#2-IRoleDao的接口中" class="headerlink" title="2.IRoleDao的接口中"></a>2.IRoleDao的接口中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有角色，同时包含角色下所有用户的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRoleDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Role&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-IRoleDao的mapper中"><a href="#3-IRoleDao的mapper中" class="headerlink" title="3.IRoleDao的mapper中"></a>3.IRoleDao的mapper中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">……………………</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gsynf.dao.IRoleDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义role表的resultMap--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"roleMap"</span> <span class="attr">type</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"roleId"</span> <span class="attr">column</span>=<span class="string">"rid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"ROLE_NAME"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleDesc"</span> <span class="attr">column</span>=<span class="string">"ROLE_DESC"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">ofType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">        select u.*,r.id as rid,r.role_name,r.role_desc from role r</span><br><span class="line">            left outer join user_role ur on r.id = ur.rid</span><br><span class="line">            left outer join user u on u.id = ur.uid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-RoleDao的测试类中"><a href="#4-RoleDao的测试类中" class="headerlink" title="4.RoleDao的测试类中"></a>4.RoleDao的测试类中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Role&gt; roles = roleDao.findAll();</span><br><span class="line">    <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">        System.out.println(<span class="string">"-------每个角色的信息---------"</span>);</span><br><span class="line">        System.out.println(role);</span><br><span class="line">        System.out.println(role.getUsers());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-运行结果-2"><a href="#5-运行结果-2" class="headerlink" title="5.运行结果"></a>5.运行结果</h3><p><img src="https://i.loli.net/2019/11/10/Ke5tB21dXCZA8Nk.png" alt=""></p>
<p>查询所用用户，同时得到用户的所有角色信息，与上同理。**</p>
<h3 id="6-SQL语句"><a href="#6-SQL语句" class="headerlink" title="6.SQL语句"></a>6.SQL语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.*,r.id <span class="keyword">as</span> rid,r.role_name,r.role_desc <span class="keyword">from</span> <span class="keyword">user</span> u</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> user_role ur <span class="keyword">on</span> u.id = ur.uid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">role</span> r <span class="keyword">on</span> r.id = ur.rid</span><br></pre></td></tr></table></figure>

<h3 id="7-一个实体应该包含另一个实体的的集合引用"><a href="#7-一个实体应该包含另一个实体的的集合引用" class="headerlink" title="7.一个实体应该包含另一个实体的的集合引用"></a>7.一个实体应该包含另一个实体的的集合引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多对多关系映射</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> roles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;Role&gt; roles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.roles = roles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-IUserDao的接口中"><a href="#8-IUserDao的接口中" class="headerlink" title="8.IUserDao的接口中"></a>8.IUserDao的接口中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户，同时获取到用户下所有角色的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-IUserDao的mapper中"><a href="#9-IUserDao的mapper中" class="headerlink" title="9.IUserDao的mapper中"></a>9.IUserDao的mapper中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">……………………</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gsynf.dao.IUserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义User的resultMap--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置角色集合的映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"roles"</span> <span class="attr">ofType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"roleId"</span> <span class="attr">column</span>=<span class="string">"rid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"ROLE_NAME"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleDesc"</span> <span class="attr">column</span>=<span class="string">"ROLE_DESC"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span>  <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">        select u.*,r.id as rid,r.role_name,r.role_desc from user u</span><br><span class="line">         left outer join user_role ur on u.id = ur.uid</span><br><span class="line">         left outer join role r on r.id = ur.rid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="10-UserDao的测试类中"><a href="#10-UserDao的测试类中" class="headerlink" title="10.UserDao的测试类中"></a>10.UserDao的测试类中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(<span class="string">"--------每个User的信息---------"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(user.getRoles());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-运行结果"><a href="#11-运行结果" class="headerlink" title="11.运行结果"></a>11.运行结果</h3><p><img src="https://i.loli.net/2019/11/10/ECgkGAMwxT6tJ4D.png" alt=""></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习2-基本的CRUD</title>
    <url>/2019/11/07/2019-11-07-Mybatis%E5%AD%A6%E4%B9%A02-%E5%9F%BA%E6%9C%AC%E7%9A%84CRUD/</url>
    <content><![CDATA[<h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><h2 id="1-完整接口类代码"><a href="#1-完整接口类代码" class="headerlink" title="1.完整接口类代码"></a>1.完整接口类代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.QueryVo;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id删除用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询总用户数（聚合函数，返回一行一列）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTotal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据queryVo中的条件查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUserByVo</span><span class="params">(QueryVo vo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-完整配置文件代码"><a href="#2-完整配置文件代码" class="headerlink" title="2.完整配置文件代码"></a>2.完整配置文件代码</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置properties</span></span><br><span class="line"><span class="comment">        可以在标签内部配置连接数据库的属性，也可以通过属性引用外部配置文件的信息</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbcConfig.properties"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="url" value="jdbc:mysql://192.168.1.107:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="username" value="root"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="password" value="root"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置mysql的环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置映射文件的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/gsynf/dao/IUserDao.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-完整映射文件代码"><a href="#3-完整映射文件代码" class="headerlink" title="3.完整映射文件代码"></a>3.完整映射文件代码</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gsynf.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"com.gsynf.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--主键字段的对应--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"userId"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--非主键字段的对应--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userAddress"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userSex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userBirthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.gsynf.domain.User"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">--         select id as userId,username as userName, address as userAddress,sex as userSex,birthday as userBirthday from user</span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--保存用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"saveUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.gsynf.domain.User"</span>&gt;</span></span><br><span class="line">--         配置插入操作后获取插入数据的id</span><br><span class="line">--         keyProperty表示要返回的值的名称；order取值为AFTER表示插入后的行为；resultType表示返回值的类型</span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"userId"</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">            select last_insert_id()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        insert into user(username,address,sex,birthday)values(#&#123;userName&#125;,#&#123;userAddress&#125;,#&#123;userSex&#125;,#&#123;userBirthday&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--更新用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.gsynf.domain.User"</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;userName&#125;,address=#&#123;userAddress&#125;,sex=#&#123;userSex&#125;,birthday=#&#123;userBirthday&#125; where id=#&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据Id删除用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据Id查询用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.gsynf.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据用户名模糊查询--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"com.gsynf.domain.User"</span>&gt;</span></span><br><span class="line">         select * from user where username like #&#123;uname&#125;</span><br><span class="line">--         select * from user where username like '%$&#123;value&#125;%'</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询总用户数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findTotal"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select count(id) from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据queryVo中的条件查询用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByVo"</span> <span class="attr">parameterType</span>=<span class="string">"com.gsynf.domain.QueryVo"</span> <span class="attr">resultType</span>=<span class="string">"com.gsynf.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user where username like #&#123;user.userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-完整测试类代码"><a href="#4-完整测试类代码" class="headerlink" title="4.完整测试类代码"></a>4.完整测试类代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.dao.IUserDao;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.QueryVo;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (C), 2019, NSSC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: MybatisTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试Mybatis的CRUD操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: gsynf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/7 15:17</span></span><br><span class="line"><span class="comment"> * History:</span></span><br><span class="line"><span class="comment"> * &lt;author&gt;          &lt;time&gt;          &lt;version&gt;          &lt;desc&gt;</span></span><br><span class="line"><span class="comment"> * 作者姓名           修改时间           版本号              描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  InputStream in;</span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span><span class="comment">//用于在测试方法执行之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.读取配置文件，生成字节输入流</span></span><br><span class="line">        in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">// 2.获取SqlSessionFactory</span></span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        <span class="comment">// 3.获取SqlSession对象</span></span><br><span class="line">        sqlSession = factory.openSession();</span><br><span class="line">        <span class="comment">// 4.获取dao的代理对象</span></span><br><span class="line">        userDao = sqlSession.getMapper(IUserDao.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span><span class="comment">//用于在测试方法执行之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        <span class="comment">// 6.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5.执行查询所有方法</span></span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"mybatis saveuser insertid"</span>);</span><br><span class="line">        user.setUserAddress(<span class="string">"北京市海淀区"</span>);</span><br><span class="line">        user.setUserSex(<span class="string">"男"</span>);</span><br><span class="line">        user.setUserBirthday(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"保存操作之前："</span>+user);</span><br><span class="line">        <span class="comment">// 5.执行保存方法</span></span><br><span class="line">        userDao.saveUser(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"保存操作之后："</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserId(<span class="number">54</span>);</span><br><span class="line">        user.setUserName(<span class="string">"mybatis updateuser"</span>);</span><br><span class="line">        user.setUserAddress(<span class="string">"北京市海淀区"</span>);</span><br><span class="line">        user.setUserSex(<span class="string">"女"</span>);</span><br><span class="line">        user.setUserBirthday(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行更新方法</span></span><br><span class="line">        userDao.updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5.执行删除方法</span></span><br><span class="line">        userDao.deleteUser(<span class="number">54</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5.执行查询一个方法</span></span><br><span class="line">        User user = userDao.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5.执行根据姓名模糊查询</span></span><br><span class="line">        List&lt;User&gt; users = userDao.findByName(<span class="string">"%王%"</span>);</span><br><span class="line"><span class="comment">//        List&lt;User&gt; users = userDao.findByName("王");</span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5.执行查询总用户数</span></span><br><span class="line">        <span class="keyword">int</span> count = userDao.findTotal();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserByVo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryVo vo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"%王%"</span>);</span><br><span class="line">        vo.setUser(user);</span><br><span class="line">        <span class="comment">// 5.执行根据queryVo中的条件查询用户</span></span><br><span class="line">        List&lt;User&gt; users = userDao.findUserByVo(vo);</span><br><span class="line">        <span class="keyword">for</span> (User u : users) &#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h1><h2 id="1-OGNL表达式"><a href="#1-OGNL表达式" class="headerlink" title="1.OGNL表达式"></a>1.OGNL表达式</h2><p>Object   Graphic   Navigation  Language<br>对象 　　 图　　　  导航 　　　 语言<br>它是通过对象的取值方法来获取数据。在写法上把get给省略了。<br>比如:我们获取用户的名称<br>　　　　类中的写法:user.getUsername,<br>　　　　OGNL表达式写法:user.username<br>mybatis映射文件中为什么能直接写username,而不用user.:因为在parameterType中已经提供了属性所属的类, 所以此时不需要写对象名 </p>
<h2 id="2-数据库表的元素名与实体类的属性名不对应的解决"><a href="#2-数据库表的元素名与实体类的属性名不对应的解决" class="headerlink" title="2.数据库表的元素名与实体类的属性名不对应的解决"></a>2.数据库表的元素名与实体类的属性名不对应的解决</h2><p>1.起别名：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--配置查询所有  其中id不能乱写必须是dao接口中的方法  resultType写的是实体类的全路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.gsynf.domain.User"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实体类中的属性名和数据库表中元素名字匹配不上时，使用别名即可匹配。id为数据库中表的列名，userId为实体类中属性名--&gt;</span></span><br><span class="line">    select id as userId,username as userName, address as userAddress,sex as userSex,birthday as userBirthday from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置查询结果的列名和实体类的属性名的对应关系：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"com.gsynf.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--主键字段的对应--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"userId"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非主键字段的对应--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userAddress"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userSex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userBirthday"</span> <span class="attr">column</span>=<span class="string">"bithday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">再在查询的sql语句的xml中加入配置</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-配置文件中的属性标签"><a href="#3-配置文件中的属性标签" class="headerlink" title="3.配置文件中的属性标签"></a>3.配置文件中的属性标签</h2><h3 id="3-1使用properties配置数据库连接信息"><a href="#3-1使用properties配置数据库连接信息" class="headerlink" title="3.1使用properties配置数据库连接信息"></a>3.1使用properties配置数据库连接信息</h3><p>可以在标签内部配置数据库连接信息，也可以通过外部文件来配置数据库连接信息。</p>
<p><strong>第一种url属性(不常用)</strong></p>
<p>URL属性：<br>　　URL:Uniform Resource Locator　统一资源定位符 可以唯一标志一个资源的位置<br>　　写法必须是</p>
<p>​                协议　　主机　　端口　          URI　　　　</p>
<p>​                <a href="http://localhost:8080/mybatisserver/demo1Servlet" target="_blank" rel="noopener">http://localhost:8080/mybatisserver/demo1Servlet</a><br>URI:</p>
<p>​        Uniform Resource Identifier 统一资源标识符 是在应用中可以可以唯一标志一个资源的位置<br>　　URL&gt;URI（精准性）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">url</span>=<span class="string">"file:///C:/Users/jdbcConfig.properties"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二种resource属性（常用）</strong><br>用于指定配置文件的位置，是按照类路径来写的，必须存在于类路径下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbcConfig.properties"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用typeAliases配置别名"><a href="#2-使用typeAliases配置别名" class="headerlink" title="2.使用typeAliases配置别名"></a>2.使用typeAliases配置别名</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用typeAliases配置别名，他只能配置domain中类的别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--typeAlias用于配置别名，type属性指定的是实体类中的全限定类名。alias属性指定别名，当指定了别名后不在区分大小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.gsynf.domain.User"</span> <span class="attr">alias</span>=<span class="string">"user"</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用package配置别名"><a href="#3-使用package配置别名" class="headerlink" title="3.使用package配置别名"></a>3.使用package配置别名</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于指定要配置别名的包，当指定后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.gsynf.domain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，配置映射文件位置的中也有package这个标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;mapper resource="top/zoick/dao/IUserDao.xml"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--package标签是用于指定dao接口所在的包，当指定了之后就不需要再写mapepr以及resource或者class了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.zoick.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习3-连接池、事务及动态SQL</title>
    <url>/2019/11/07/2019-11-07-Mybatis%E5%AD%A6%E4%B9%A03-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E3%80%81%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><p><strong>１、连接池：</strong><br>在实际开发中都会使用连接池。因为它可以减少我们获取连接所消耗的时间。</p>
<p>连接池就是用于存储连接的一个容器，这个容器其实就是一个集合对象。但是该集合必须是线程安全的，不能两个线程拿到同一个连接，而且满足队列特性，先进先出。</p>
<p><strong>２、mybatis中的连接池：</strong><br>mybatis连接池提供了3种配置方式：<br>配置的位置：<br>        主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。<br>type属性的值：</p>
<ul>
<li><p><strong><em>POOLED</em></strong>：采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现；</p>
<ul>
<li>其实是分为空闲池和活动池，首先到空闲池查看，如果空闲池有连接，直接拿出用即可，如果空闲池没有连接了，则去活动池寻找，查看活动池中是否到了最大连接数量，如果活动池也达到了最大连接数量，则判断活动池中哪个连接是最先进来的，则经过系列操作返回这个oldest的连接。</li>
</ul>
</li>
<li><p><strong><em>UNPOOLED</em></strong>：采用传统的获取连接的方式，虽然也实现javax.sql.DataSource接口，但是并没有使用池的思想；</p>
</li>
<li><p><strong><em>JNDI</em></strong>：采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样的；</p>
<ul>
<li><strong>注意</strong>：如果不是web或者maven的war工程，是不能使用的。学习时使用的时tomcat服务器，采用的连接池就是dbcp连接池。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis中的事务"><a href="#MyBatis中的事务" class="headerlink" title="MyBatis中的事务"></a>MyBatis中的事务</h1><p>什么是事务<br>　　事务的四大特性ACID<br>　　不考虑隔离性会产生的3个问题<br>　　解决办法：四种隔离级别</p>
<p>它是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚</p>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>主要是基于XMl配置的动态SQL语句使用，即mappers配置文件中的几个标签。</p>
<h2 id="if标签的使用"><a href="#if标签的使用" class="headerlink" title="if标签的使用"></a>if标签的使用</h2><h3 id="1-接口中定义"><a href="#1-接口中定义" class="headerlink" title="1.接口中定义"></a>1.接口中定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByCondition</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-mapper中定义"><a href="#2-mapper中定义" class="headerlink" title="2.mapper中定义"></a>2.mapper中定义</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByCondition"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user where 1=1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span></span><br><span class="line">            and username = #&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userSex != null"</span>&gt;</span></span><br><span class="line">            and sex = #&#123;userSex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中： 这条语句中，userName指的是实体类中的属性名， and username = #{userName}这里是将实体类的userName传给数据库的username</p>
<h3 id="3-测试类中测试"><a href="#3-测试类中测试" class="headerlink" title="3.测试类中测试"></a>3.测试类中测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 5.执行根据条件查询</span></span><br><span class="line">    User u = <span class="keyword">new</span> User();</span><br><span class="line">    u.setUserName(<span class="string">"老王"</span>);</span><br><span class="line">    u.setUserSex(<span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userDao.findUserByCondition(u);</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="where标签的使用"><a href="#where标签的使用" class="headerlink" title="where标签的使用"></a>where标签的使用</h2><p>为了简化上面where 1=1的条件拼装，我们可以采用&lt; where &gt;标签来简化开发。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据传入参数条件查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByCondition"</span>  <span class="attr">resultMap</span>=<span class="string">"userMap"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    --         select * from user where 1=1</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span></span><br><span class="line">            and username = #&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userSex != null"</span>&gt;</span></span><br><span class="line">            and sex = #&#123;userSex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="foreach标签的使用"><a href="#foreach标签的使用" class="headerlink" title="foreach标签的使用"></a>foreach标签的使用</h2><p>用于集合中查询的SQL：<code>select * from user where id in(41,42,45)</code><br>通过一个类中传入集合的方法<br>QueryVo类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-接口中定义-1"><a href="#1-接口中定义-1" class="headerlink" title="1.接口中定义"></a>1.接口中定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据Queryvo中提供的id集合，查询用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUserInIds</span><span class="params">(QueryVo vo)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-mapper中定义-1"><a href="#2-mapper中定义-1" class="headerlink" title="2.mapper中定义"></a>2.mapper中定义</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据queryvo中Id集合实现查询用户列表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserInIds"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span> <span class="attr">parameterType</span>=<span class="string">"queryvo"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null and ids.size()&gt;0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"and id in ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"uuuuid"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                    #&#123;uuuuid&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意if标签中的内容都是来源于ParameterType参数。</p>
<p>&lt; foreach &gt;标签用于遍历集合，它的属性： </p>
<p>​    collection:代表要遍历的集合元素，注意编写时不要写#{} </p>
<p>​    open:代表语句的开始部分 </p>
<p>​    close:代表结束部分</p>
<p>​    item:代表遍历集合的每个元素，生成的变量名 </p>
<p>​    separator:代表分隔符</p>
<h3 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3.测试代码"></a>3.测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserInIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 5.执行根据QueryVo中的Id集合进行查询</span></span><br><span class="line">    QueryVo vo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    list.add(<span class="number">41</span>);</span><br><span class="line">    list.add(<span class="number">42</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    vo.setIds(list);</span><br><span class="line">    List&lt;User&gt; users = userDao.findUserInIds(vo);</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽取重复的SQL"><a href="#抽取重复的SQL" class="headerlink" title="抽取重复的SQL"></a>抽取重复的SQL</h2><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--抽取重复的sql语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"defaultUser"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--抽取重复的sql语句--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"defaultUser"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置查询所有  其中id不能乱写必须是dao接口中的方法  resultType写的是实体类的全路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"defaultUser"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 尽量不要使用分号，SQL语句可能会拼接</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习1-简介及自定义Mybatis</title>
    <url>/2019/11/06/2019-11-06-Mybatis%E5%AD%A6%E4%B9%A01-%E7%AE%80%E4%BB%8B%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Mybatis/</url>
    <content><![CDATA[<h1 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h1><p>它是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题<br>使用框架的好处：<br>框架封装了很多的细节，使开发者可以使用极简的方式实现功能。大大提高开发效率。</p>
<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><p><strong>表现层：</strong><br>是用于展示数据的<br><strong>业务层：</strong><br>是处理业务需求<br><strong>持久层：</strong><br>是和数据库交互的</p>
<p><img src="https://i.loli.net/2019/11/06/2dtJFuqXZC6PWlb.png" alt=""></p>
<h1 id="持久层技术解决方案"><a href="#持久层技术解决方案" class="headerlink" title="持久层技术解决方案"></a>持久层技术解决方案</h1><p><strong>JDBC技术：</strong><br>Connection<br>PreparedStatement<br>ResultSet<br><strong>Spring的JdbcTemplate：</strong><br>Spring中对jdbc的简单封装<br><strong>Apache的DBUtils：</strong><br>它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装<br>以上这些都不是框架<br>JDBC是规范</p>
<p>Spring的JdbcTemplate和Apache的DBUtils都只是工具类</p>
<h1 id="mybatis的概述"><a href="#mybatis的概述" class="headerlink" title="mybatis的概述"></a>mybatis的概述</h1><p>mybatis是一个持久层框架，用java编写的。<br>它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程。<br>它使用了ORM思想实现了结果集的封装。</p>
<p><strong>ORM：</strong><br>Object Relational Mappging 对象关系映射<br>简单的说：就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。<br>user User<br>id userId<br>user_name userName</p>
<p>我们需要做到<br><em>实体类中的属性和数据库表的字段名称保持一致。</em></p>
<h1 id="mybatis的入门"><a href="#mybatis的入门" class="headerlink" title="mybatis的入门"></a>mybatis的入门</h1><h2 id="表的创建与数据的插入"><a href="#表的创建与数据的插入" class="headerlink" title="表的创建与数据的插入"></a>表的创建与数据的插入</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">  <span class="string">`birthday`</span> datetime <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地址'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`user`</span>(<span class="string">`id`</span>,<span class="string">`username`</span>,<span class="string">`birthday`</span>,<span class="string">`sex`</span>,<span class="string">`address`</span>) <span class="keyword">values</span> (<span class="number">41</span>,<span class="string">'老王'</span>,<span class="string">'2018-02-27 17:47:08'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(<span class="number">42</span>,<span class="string">'小二王'</span>,<span class="string">'2018-03-02 15:09:37'</span>,<span class="string">'女'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">43</span>,<span class="string">'小二王'</span>,<span class="string">'2018-03-04 11:34:34'</span>,<span class="string">'女'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">45</span>,<span class="string">'传智播客'</span>,<span class="string">'2018-03-04 12:04:06'</span>,<span class="string">'男'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">46</span>,<span class="string">'老王'</span>,<span class="string">'2018-03-07 17:37:26'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(<span class="number">48</span>,<span class="string">'小马宝莉'</span>,<span class="string">'2018-03-08 11:44:00'</span>,<span class="string">'女'</span>,<span class="string">'北京修正'</span>);</span><br></pre></td></tr></table></figure>



<h2 id="mybatis环境搭建demo的基本架构"><a href="#mybatis环境搭建demo的基本架构" class="headerlink" title="mybatis环境搭建demo的基本架构"></a>mybatis环境搭建demo的基本架构</h2><p><img src="https://i.loli.net/2019/11/06/x8ywdvBZoO6SRn3.png" alt=""></p>
<p><strong>第一步：创建maven工程并导入坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gsynf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>day01_mybatis_01mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步：创建实体类和dao的接口</strong></p>
<p><strong>第三步：创建Mybatis的主配置文件</strong></p>
<p><em>SqlMapConifg.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis主配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置mysql环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置事务类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置数据源（连接池）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置连接数据库的基本信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://服务器IP/mybatis"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/gsynf/dao/IUserDao.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第四步：创建映射配置文件</strong></p>
<p><em>IUserDao.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gsynf.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="环境搭建的注意事项"><a href="#环境搭建的注意事项" class="headerlink" title="环境搭建的注意事项"></a>环境搭建的注意事项</h2><p><strong>第一个：</strong> 创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。<br>在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper<br>所以：IUserDao 和 IUserMapper是一样的<br><strong>第二个：</strong> 在idea中创建目录的时候，它和包是不一样的<br>包 <em>（Package）</em> 在创建时：com.gsynf.dao它是三级结构<br>目录 <em>（Directory）</em> 在创建时：com.gsynf.dao是一级目录<br><strong>第三个：</strong> mybatis的映射配置文件位置必须和dao接口的包结构相同<br><strong>第四个：</strong> 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名<br><strong>第五个：</strong> 映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p>
<p>当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。</p>
<h2 id="mybatis的入门案例"><a href="#mybatis的入门案例" class="headerlink" title="mybatis的入门案例"></a>mybatis的入门案例</h2><p><strong>第一步：</strong> 读取配置文件<br><strong>第二步：</strong> 创建SqlSessionFactory工厂<br><strong>第三步：</strong> 创建SqlSession<br><strong>第四步：</strong> 创建Dao接口的代理对象<br><strong>第五步：</strong> 执行dao中的方法<br><strong>第六步：</strong> 释放资源</p>
<p><strong>注意事项：</strong><br>不要忘记在映射配置中告知mybatis要封装到哪个实体类中<br>配置的方式：指定实体类的全限定类名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">………………</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gsynf.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.gsynf.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>mybatis基于注解的入门案例：</strong><br>把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句<br>同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。<br><strong>明确：</strong><br>我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。<br>不管使用XML还是注解配置。但是Mybatis它是支持写dao实现类的。</p>
<p><strong>入门案例设计模式分析：</strong></p>
<p><img src="https://i.loli.net/2019/11/06/f1rPZclaoNQF7gh.png" alt=""></p>
<h1 id="自定义Mybatis的分析-执行查询所有的分析"><a href="#自定义Mybatis的分析-执行查询所有的分析" class="headerlink" title="自定义Mybatis的分析__执行查询所有的分析"></a>自定义Mybatis的分析__执行查询所有的分析</h1><p>mybatis在使用代理dao的方式实现增删改查时做什么事呢？<br>只有两件事：<br>第一：创建代理对象<br>第二：在代理对象中调用selectList</p>
<p>自定义mybatis能通过入门案例看到类<br>class　　　　Resources　　使用类加载器读取配置文件的类<br>class　　　　SqlSessionFactoryBuilder　　用于创建一个SqlsessionFactory对象<br>interface　　SqlSessionFactory　　用于打开一个新的SqlSession<br>interface　　SqlSession　　自定义MYbatis中和数据库交互的核心类</p>
<p><img src="https://i.loli.net/2019/11/06/RLpbqrec9ZGIhaA.png" alt=""></p>
<p>自定义mybatis开发流程图:</p>
<p><img src="https://i.loli.net/2019/11/07/PvWyZ4DaN29dwxT.png" alt=""></p>
<p>Project结构：</p>
<p><img src="https://i.loli.net/2019/11/07/LvpdzBsjRh89CPT.png" alt=""></p>
<p>1.读取配置文件用io包里的Resources<br>2.读出所需要的信息交给SqlSessionFactoryBuilder构建者<br>3.构建者使用工具类XMLConfigBuilder构建出DefaultSqlsessionFactory工厂对象，xml读取的信息保存在Configuration里<br>4.工厂里的openSession提供了Sqlsession方法<br>5.再在SqlSession里实现创建代理对象和查询所有的功能</p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.dao.IUserDao;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.mybatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.mybatis.sqlsession.SqlSession;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.mybatis.sqlsession.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.mybatis.sqlsession.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis的入门案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.读取配置文件</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//2.创建SqlSessionFactory工厂</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(in);</span><br><span class="line">        <span class="comment">//3.使用工厂生产SqlSession对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">//4.使用SqlSession创建Dao接口的代理对象</span></span><br><span class="line">        IUserDao userDao = session.getMapper(IUserDao.class);</span><br><span class="line">        <span class="comment">//5.使用代理对象执行方法</span></span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot框架学习2-日志</title>
    <url>/2019/11/06/2019-11-06-SpringBoot%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A02-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h1><p> 小张：开发一个大型系统；</p>
<p>​        1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？</p>
<p>​        2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；</p>
<p>​        3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar；</p>
<p>​        4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p>
<p>​        5、JDBC—数据库驱动；</p>
<p>​            写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p>
<p>​            给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p>
<p><strong>市面上的日志框架：</strong></p>
<p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p>
<table>
<thead>
<tr>
<th>日志门面  （日志的抽象层）</th>
<th>日志实现</th>
</tr>
</thead>
<tbody><tr>
<td><del>JCL（Jakarta  Commons Logging）</del>    <strong>SLF4j</strong>（Simple  Logging Facade for Java）    <del>jboss-logging</del></td>
<td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td>
</tr>
</tbody></table>
<p>左边选一个门面（抽象层）、右边来选一个实现；</p>
<p>日志门面：  SLF4J；</p>
<p>日志实现：Logback；</p>
<p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p>
<p><strong>SpringBoot选用 SLF4j和logback；</strong></p>
<h1 id="2-SLF4j使用"><a href="#2-SLF4j使用" class="headerlink" title="2.SLF4j使用"></a>2.SLF4j使用</h1><h2 id="2-1如何在系统中使用SLF4j"><a href="#2-1如何在系统中使用SLF4j" class="headerlink" title="2.1如何在系统中使用SLF4j"></a>2.1如何在系统中使用SLF4j</h2><p><a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></p>
<p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p>
<p>给系统里面导入slf4j的jar和logback的实现jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示；</p>
<p><img src="https://i.loli.net/2019/11/05/KfyHBl9J3GitqAm.png" alt=""></p>
<p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p>
<h2 id="2-2遗留问题"><a href="#2-2遗留问题" class="headerlink" title="2.2遗留问题"></a>2.2遗留问题</h2><p>A系统（slf4j+logback）:依赖的框架有 Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx，每个框架都有自己配套的日志；</p>
<p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p>
<p><img src="https://i.loli.net/2019/11/05/gZSEju9rPqva7H8.png" alt=""></p>
<p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p>
<p>1、将系统中其他日志框架先排除出去；</p>
<p>2、用中间包来替换原有的日志框架；</p>
<p>3、我们导入slf4j其他的实现；</p>
<h1 id="3-SpringBoot日志关系"><a href="#3-SpringBoot日志关系" class="headerlink" title="3.SpringBoot日志关系"></a>3.SpringBoot日志关系</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>SpringBoot使用它来做日志功能；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>底层依赖关系（pom.xml中右键，Diagrams选择Show Dependencies）</p>
<p><img src="https://i.loli.net/2019/11/05/G8ltQDiZEbs5MFJ.png" alt=""></p>
<p><strong>总结：</strong></p>
<p>​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p>
<p>​    2）、SpringBoot也把其他的日志都替换成了slf4j；</p>
<p>​    3）、中间替换包？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/05/DEnsmHx49FVjMcl.png" alt=""></p>
<p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p>
<p>​            Spring框架用的是commons-logging，SpringBoot在引入Spring核心框架时排除了commons-logging；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</strong></p>
<p><strong>注：</strong>上述日志关系引用思路不变，但具体内容可能会有所改变，比如Spring5中的日志已经没有了commons-logging，SpringBoot2底层也没有了将log4j转为slf4j的“偷天换日”包。</p>
<h1 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4.日志使用"></a>4.日志使用</h1><h2 id="4-1默认配置"><a href="#4-1默认配置" class="headerlink" title="4.1默认配置"></a>4.1默认配置</h2><p>SpringBoot默认帮我们配置好了日志，可以在测试类中测试；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志的级别；</span></span><br><span class="line">    <span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">    <span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">    logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">    logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line">    <span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">    logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">    logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">    logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<pre><code>日志输出格式：
    %d表示日期时间，
    %thread表示线程名，
    %-5level：级别从左显示5个字符宽度
    %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 
    %msg：日志消息，
    %n是换行符
示例：
%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</code></pre><p>SpringBoot修改日志的默认配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.com.gsynf</span>=<span class="string">trace</span></span><br><span class="line"><span class="comment"># path和file均不指定，则只在控制台输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定路径在当前项目下生成springboot.log日志</span></span><br><span class="line"><span class="comment"># 可以指定完整的路径；</span></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹</span></span><br><span class="line"><span class="comment"># 使用 spring.log 作为默认文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/spring/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在控制台输出的日志的格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>logging.file</th>
<th>logging.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>(none)</td>
<td>(none)</td>
<td></td>
<td>只在控制台输出</td>
</tr>
<tr>
<td>指定文件名</td>
<td>(none)</td>
<td>my.log</td>
<td>输出日志到my.log文件</td>
</tr>
<tr>
<td>(none)</td>
<td>指定目录</td>
<td>/var/log</td>
<td>输出到指定目录的 spring.log 文件中</td>
</tr>
</tbody></table>
<p><strong>注：</strong>SpringBoot2中已经更改，分别改为了 logging.file.name 和 logging.file.path 。</p>
<h2 id="4-2指定配置"><a href="#4-2指定配置" class="headerlink" title="4.2指定配置"></a>4.2指定配置</h2><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p>
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody></table>
<p>logback.xml：直接就被日志框架识别了；</p>
<p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  	可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述配置使得开发环境和非开发环境输出的日志格式不同。</p>
<p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p>
<p> <code>no applicable action for [springProfile]</code></p>
<p><strong>注：</strong>SpringBoot2中即使命名为logback.xml也可以识别上述高级功能了。</p>
<h1 id="5-切换日志框架"><a href="#5-切换日志框架" class="headerlink" title="5.切换日志框架"></a>5.切换日志框架</h1><p>首先进入依赖图谱，将原来的日志依赖删掉；再加入新的依赖即可。</p>
<p>slf4j+log4j的方式；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>切换为log4j2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>








<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot框架学习3-Web开发</title>
    <url>/2019/11/06/2019-11-06-SpringBoot%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A03-Web%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>使用SpringBoot；</p>
<p><strong>1）创建SpringBoot应用，选中我们需要的模块；</strong></p>
<p><strong>2）SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</strong></p>
<p><strong>3）自己编写业务代码；</strong></p>
<p><strong>自动配置原理？</strong></p>
<p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？…………</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxxxAutoConfiguration：帮我们给容器中自动配置组件；</span><br><span class="line">xxxxProperties:配置类来封装配置文件的内容；</span><br></pre></td></tr></table></figure>



<h1 id="2-SpringBoot对静态资源的映射规则"><a href="#2-SpringBoot对静态资源的映射规则" class="headerlink" title="2.SpringBoot对静态资源的映射规则"></a>2.SpringBoot对静态资源的映射规则</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"><span class="comment">//可以设置和静态资源有关的参数，缓存时间等</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebMvcAuotConfiguration：</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line">		<span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">			customizeResourceHandlerRegistration(</span><br><span class="line">					registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">							.addResourceLocations(</span><br><span class="line">									<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">					.setCachePeriod(cachePeriod));</span><br><span class="line">		&#125;</span><br><span class="line">		String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">         	<span class="comment">//静态资源文件夹映射</span></span><br><span class="line">		<span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">			customizeResourceHandlerRegistration(</span><br><span class="line">					registry.addResourceHandler(staticPathPattern)</span><br><span class="line">							.addResourceLocations(</span><br><span class="line">									<span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">					.setCachePeriod(cachePeriod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//配置欢迎页映射</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),</span><br><span class="line">				<span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//配置喜欢的图标</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">			mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">             	<span class="comment">//所有  **/favicon.ico </span></span><br><span class="line">			mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>,</span><br><span class="line">					faviconRequestHandler()));</span><br><span class="line">			<span class="keyword">return</span> mapping;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">			requestHandler</span><br><span class="line">					.setLocations(<span class="keyword">this</span>.resourceProperties.getFaviconLocations());</span><br><span class="line">			<span class="keyword">return</span> requestHandler;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>1）所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；</p>
<p>​        webjars：以jar包的方式引入静态资源；<a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a></p>
<p><img src="https://i.loli.net/2019/11/05/WIecDvfRTYAEHuN.png" alt=""></p>
<p>此时访问localhost:8080/webjars/jquery/3.3.1/jquery.js，发现是可以的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入jquery-webjar--&gt;</span>在访问的时候只需要写webjars下面资源的名称即可</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2）”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot; </span><br><span class="line">&quot;/&quot;：当前项目的根路径</span><br></pre></td></tr></table></figure>

<p>localhost:8080/abc ===  去静态资源文件夹里面找abc</p>
<p>3）欢迎页： 静态资源文件夹下的所有index.html页面；被”/**”映射；</p>
<p>​    localhost:8080/   找index页面</p>
<p>4）所有的 **/favicon.ico  都是在静态资源文件下找；</p>
<p>上述静态资源的路径：</p>
<p><img src="https://i.loli.net/2019/11/06/NHS8a4WJeyQxsgc.png" alt=""></p>
<p>若要修改上述静态资源的文件夹：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.resources.static-locations</span>=<span class="string">classpath:/hello/,classpath:/hi/</span></span><br></pre></td></tr></table></figure>



<h1 id="3-模板引擎"><a href="#3-模板引擎" class="headerlink" title="3.模板引擎"></a>3.模板引擎</h1><p>JSP、Velocity、Freemarker、Thymeleaf</p>
<p><img src="https://i.loli.net/2019/11/05/aIKME8f5WNwunHm.png" alt=""></p>
<p>SpringBoot推荐的Thymeleaf；</p>
<p>语法更简单，功能更强大；</p>
<h2 id="3-1引入thymeleaf"><a href="#3-1引入thymeleaf" class="headerlink" title="3.1引入thymeleaf"></a>3.1引入thymeleaf</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    2.1.6</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">切换thymeleaf版本</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- thymeleaf2   layout1--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>SpringBoot2.2.0自动安装的starter版本为3.0.11，所以不需要再自己升级了</p>
<h2 id="3-2Thymeleaf使用"><a href="#3-2Thymeleaf使用" class="headerlink" title="3.2Thymeleaf使用"></a>3.2Thymeleaf使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br><span class="line">  	<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>所以，只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染，但是需要注意的是，如果只使用@RestController注解是不会自动渲染html页面的，需要使用@Controller和@ResponseBody</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="comment">//查出一些数据在页面展示</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/success"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//classpath:/templates/success.html</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>使用：</p>
<p>1、导入thymeleaf的名称空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、使用thymeleaf语法；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--th:text 将div里面的文本内容设置为 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这是显示欢迎信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="comment">//查出一些数据在页面展示</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/success"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">success</span><span class="params">(Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="string">"hello"</span>,<span class="string">"你好"</span>);</span><br><span class="line">        <span class="comment">//classpath:/templates/success.html</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-3语法规则"><a href="#3-3语法规则" class="headerlink" title="3.3语法规则"></a>3.3语法规则</h2><p>1、th:text；改变当前元素里面的文本内容；</p>
<p>​    th：任意html属性，来替换原生属性的值；</p>
<p><img src="https://i.loli.net/2019/11/05/DZqGFHg81m5oUvc.png" alt=""></p>
<p>2、表达式？</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1.Simple</span> <span class="string">expressions:（表达式语法）</span></span><br><span class="line">    <span class="meta">1.1</span> <span class="string">Variable Expressions: $&#123;...&#125;：获取变量值；OGNL；</span></span><br><span class="line">    		<span class="attr">1）、获取对象的属性、调用方法</span></span><br><span class="line">    		<span class="attr">2）、使用内置的基本对象：</span></span><br><span class="line"><span class="comment">    			#ctx : the context object.</span></span><br><span class="line"><span class="comment">    			#vars: the context variables.</span></span><br><span class="line"><span class="comment">                #locale : the context locale.</span></span><br><span class="line"><span class="comment">                #request : (only in Web Contexts) the HttpServletRequest object.</span></span><br><span class="line"><span class="comment">                #response : (only in Web Contexts) the HttpServletResponse object.</span></span><br><span class="line"><span class="comment">                #session : (only in Web Contexts) the HttpSession object.</span></span><br><span class="line"><span class="comment">                #servletContext : (only in Web Contexts) the ServletContext object.</span></span><br><span class="line">                <span class="attr">e.g.</span></span><br><span class="line">                <span class="attr">$&#123;session.foo&#125;</span></span><br><span class="line">            <span class="attr">3）、内置的一些工具对象：</span></span><br><span class="line"><span class="comment">                #execInfo : information about the template being processed.</span></span><br><span class="line"><span class="comment">                #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.</span></span><br><span class="line"><span class="comment">                #uris : methods for escaping parts of URLs/URIs</span></span><br><span class="line"><span class="comment">                #conversions : methods for executing the configured conversion service (if any).</span></span><br><span class="line"><span class="comment">                #dates : methods for java.util.Date objects: formatting, component extraction, etc.</span></span><br><span class="line"><span class="comment">                #calendars : analogous to #dates , but for java.util.Calendar objects.</span></span><br><span class="line"><span class="comment">                #numbers : methods for formatting numeric objects.</span></span><br><span class="line"><span class="comment">                #strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span></span><br><span class="line"><span class="comment">                #objects : methods for objects in general.</span></span><br><span class="line"><span class="comment">                #bools : methods for boolean evaluation.</span></span><br><span class="line"><span class="comment">                #arrays : methods for arrays.</span></span><br><span class="line"><span class="comment">                #lists : methods for lists.</span></span><br><span class="line"><span class="comment">                #sets : methods for sets.</span></span><br><span class="line"><span class="comment">                #maps : methods for maps.</span></span><br><span class="line"><span class="comment">                #aggregates : methods for creating aggregates on arrays or collections.</span></span><br><span class="line"><span class="comment">                #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span></span><br><span class="line"></span><br><span class="line">   	<span class="meta">1.2</span> <span class="string">Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；</span></span><br><span class="line">    	<span class="meta">补充：配合</span> <span class="string">th:object="$&#123;session.user&#125;：</span></span><br><span class="line">           <span class="meta">&lt;div</span> <span class="string">th:object="$&#123;session.user&#125;"&gt;</span></span><br><span class="line">               <span class="meta">&lt;p&gt;Name</span>: <span class="string">&lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">               <span class="meta">&lt;p&gt;Surname</span>: <span class="string">&lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">               <span class="meta">&lt;p&gt;Nationality</span>: <span class="string">&lt;span th:text="*&#123;nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">           <span class="attr">&lt;/div&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">1.3</span> <span class="string">Message Expressions: #&#123;...&#125;：获取国际化内容</span></span><br><span class="line">    <span class="meta">1.4</span> <span class="string">Link URL Expressions: @&#123;...&#125;：定义URL；</span></span><br><span class="line">    		<span class="meta">@&#123;/order/process(execId</span>=<span class="string">$&#123;execId&#125;,execType='FAST')&#125;</span></span><br><span class="line">    <span class="meta">1.5</span> <span class="string">Fragment Expressions: ~&#123;...&#125;：片段引用表达式</span></span><br><span class="line">    		<span class="meta">&lt;div</span> <span class="string">th:insert="~&#123;commons :: main&#125;"&gt;...&lt;/div&gt;</span></span><br><span class="line">    		</span><br><span class="line"><span class="meta">2.Literals</span>:<span class="string">（字面量）</span></span><br><span class="line">    <span class="attr">Text</span> <span class="string">literals: 'one text' , 'Another one!' ,…</span></span><br><span class="line">    <span class="attr">Number</span> <span class="string">literals: 0 , 34 , 3.0 , 12.3 ,…</span></span><br><span class="line">    <span class="attr">Boolean</span> <span class="string">literals: true , false</span></span><br><span class="line">    <span class="attr">Null</span> <span class="string">literal: null</span></span><br><span class="line">    <span class="attr">Literal</span> <span class="string">tokens: one , sometext , main ,…</span></span><br><span class="line"><span class="meta">3.Text</span> <span class="string">operations:（文本操作）</span></span><br><span class="line">    <span class="attr">String</span> <span class="string">concatenation: +</span></span><br><span class="line">    <span class="attr">Literal</span> <span class="string">substitutions: |The name is $&#123;name&#125;|</span></span><br><span class="line"><span class="meta">4.Arithmetic</span> <span class="string">operations:（数学运算）</span></span><br><span class="line">    <span class="attr">Binary</span> <span class="string">operators: + , - , * , / , %</span></span><br><span class="line">    <span class="attr">Minus</span> <span class="string">sign (unary operator): -</span></span><br><span class="line"><span class="meta">5.Boolean</span> <span class="string">operations:（布尔运算）</span></span><br><span class="line">    <span class="attr">Binary</span> <span class="string">operators: and , or</span></span><br><span class="line">    <span class="attr">Boolean</span> <span class="string">negation (unary operator): ! , not</span></span><br><span class="line"><span class="meta">6.Comparisons</span> <span class="string">and equality:（比较运算）</span></span><br><span class="line">    <span class="attr">Comparators</span>: <span class="string">&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span></span><br><span class="line">    <span class="attr">Equality</span> <span class="string">operators: == , != ( eq , ne )</span></span><br><span class="line"><span class="meta">7.Conditional</span> <span class="string">operators:条件运算（三元运算符）</span></span><br><span class="line">    <span class="meta">If-then</span>: <span class="string">(if) ? (then)</span></span><br><span class="line">    <span class="meta">If-then-else</span>: <span class="string">(if) ? (then) : (else)</span></span><br><span class="line">    <span class="attr">Default</span>: <span class="string">(value) ?: (defaultvalue)</span></span><br><span class="line"><span class="meta">8.Special</span> <span class="string">tokens:（特殊操作）</span></span><br><span class="line">    <span class="meta">No-Operation</span>: <span class="string">_</span></span><br></pre></td></tr></table></figure>

<h1 id="4-SpringMVC自动配置"><a href="#4-SpringMVC自动配置" class="headerlink" title="4.SpringMVC自动配置"></a>4.SpringMVC自动配置</h1><p><a href="https://docs.spring.io/spring-boot/docs/2.2.0.RELEASE/reference/html/spring-boot-features.html#boot-features-developing-web-applications" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.2.0.RELEASE/reference/html/spring-boot-features.html#boot-features-developing-web-applications</a> </p>
<h2 id="4-1-Spring-MVC-auto-configuration"><a href="#4-1-Spring-MVC-auto-configuration" class="headerlink" title="4.1.Spring MVC auto-configuration"></a>4.1.Spring MVC auto-configuration</h2><p>Spring Boot 自动配置好了SpringMVC</p>
<p>以下是SpringBoot对SpringMVC的默认配置:<strong>（WebMvcAutoConfiguration）</strong></p>
<ul>
<li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li>
<li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li>
<li>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；</li>
</ul>
</li>
<li><p>Support for serving static resources, including support for WebJars.</p>
<ul>
<li>静态资源文件夹路径,webjars</li>
</ul>
</li>
<li><p>Static <code>index.html</code> support. </p>
<ul>
<li>静态首页访问</li>
</ul>
</li>
<li><p>Custom <code>Favicon</code> support .</p>
<ul>
<li>favicon.ico</li>
</ul>
</li>
<li><p>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li>
<li>Formatter： 格式化器；  2017.12.17===Date；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"date-format"</span>)<span class="comment">//在文件中配置日期格式化的规则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Formatter&lt;Date&gt; <span class="title">dateFormatter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DateFormatter(<span class="keyword">this</span>.mvcProperties.getDateFormat());<span class="comment">//日期格式化组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    自己添加的格式化器转换器，我们只需要放在容器中即可</p>
<ul>
<li><p>Support for <code>HttpMessageConverters</code>.</p>
<ul>
<li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p>
</li>
<li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p>
<p>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Automatic registration of <code>MessageCodesResolver</code> .</p>
<ul>
<li>定义错误代码生成规则</li>
</ul>
</li>
<li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean.</p>
<p>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化WebDataBinder；</span><br><span class="line">请求数据=====JavaBean；</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p>
<p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
<h2 id="4-2扩展SpringMVC"><a href="#4-2扩展SpringMVC" class="headerlink" title="4.2扩展SpringMVC"></a>4.2扩展SpringMVC</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/hello"</span> <span class="attr">view-name</span>=<span class="string">"success"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/hello"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc</strong>;</p>
<p>既保留了所有的自动配置，也能用我们扩展的配置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>​    1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p>
<p>​    2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从容器中获取所有的WebMvcConfigurer</span></span><br><span class="line">     <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">             <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">           	<span class="comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span></span><br><span class="line">           	<span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line">             <span class="comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span></span><br><span class="line">              <span class="comment">//       delegate.addViewControllers(registry);</span></span><br><span class="line">              <span class="comment">//   &#125;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    3）、容器中所有的WebMvcConfigurer都会一起起作用；</p>
<p>​    4）、我们的配置类也会被调用；</p>
<p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p>
<h2 id="4-3全面接管SpringMVC"><a href="#4-3全面接管SpringMVC" class="headerlink" title="4.3全面接管SpringMVC"></a>4.3全面接管SpringMVC</h2><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p>
<p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>为什么@EnableWebMvc自动配置就失效了；</p>
<p>1）@EnableWebMvc的核心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br></pre></td></tr></table></figure>

<p>2）、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>3）、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, DispatcherServlet.class,</span><br><span class="line">		WebMvcConfigurerAdapter.class &#125;)</span><br><span class="line"><span class="comment">//容器中没有这个组件的时候，这个自动配置类才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE + <span class="number">10</span>)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; DispatcherServletAutoConfiguration.class,</span><br><span class="line">		ValidationAutoConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p>
<p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p>
<h1 id="5-如何修改SpringBoot的默认配置"><a href="#5-如何修改SpringBoot的默认配置" class="headerlink" title="5.如何修改SpringBoot的默认配置"></a>5.如何修改SpringBoot的默认配置</h1><p>模式：</p>
<p>​    1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p>
<p>​    2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p>
<p>​    3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p>
<h1 id="6-RestfulCRUD"><a href="#6-RestfulCRUD" class="headerlink" title="6.RestfulCRUD"></a>6.RestfulCRUD</h1><h2 id="6-1默认访问首页"><a href="#6-1默认访问首页" class="headerlink" title="6.1默认访问首页"></a>6.1默认访问首页</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="comment">//@EnableWebMvc   不要接管SpringMVC</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将组件注册在容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">webMvcConfigurerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        WebMvcConfigurerAdapter adapter = <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">                registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2国际化"><a href="#6-2国际化" class="headerlink" title="6.2国际化"></a>6.2国际化</h2><p><strong>1）、编写国际化配置文件；</strong></p>
<p>2）、使用ResourceBundleMessageSource管理国际化资源文件</p>
<p>3）、在页面使用fmt:message取出国际化内容</p>
<p>步骤：</p>
<p>1）、编写国际化配置文件，抽取页面需要显示的国际化消息</p>
<p><img src="https://i.loli.net/2019/11/05/n5zAbdXc9SVgvhR.png" alt=""></p>
<p>2）、SpringBoot自动配置好了管理国际化资源文件的组件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.messages"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Comma-separated list of basenames (essentially a fully-qualified classpath</span></span><br><span class="line"><span class="comment">	 * location), each following the ResourceBundle convention with relaxed support for</span></span><br><span class="line"><span class="comment">	 * slash based locations. If it doesn't contain a package qualifier (such as</span></span><br><span class="line"><span class="comment">	 * "org.mypackage"), it will be resolved from the classpath root.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String basename = <span class="string">"messages"</span>;  </span><br><span class="line">    <span class="comment">//我们的配置文件可以直接放在类路径下叫messages.properties；</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.basename)) &#123;</span><br><span class="line">            <span class="comment">//设置国际化资源文件的基础名（去掉语言国家代码的）</span></span><br><span class="line">			messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">					StringUtils.trimAllWhitespace(<span class="keyword">this</span>.basename)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.encoding != <span class="keyword">null</span>) &#123;</span><br><span class="line">			messageSource.setDefaultEncoding(<span class="keyword">this</span>.encoding.name());</span><br><span class="line">		&#125;</span><br><span class="line">		messageSource.setFallbackToSystemLocale(<span class="keyword">this</span>.fallbackToSystemLocale);</span><br><span class="line">		messageSource.setCacheSeconds(<span class="keyword">this</span>.cacheSeconds);</span><br><span class="line">		messageSource.setAlwaysUseMessageFormat(<span class="keyword">this</span>.alwaysUseMessageFormat);</span><br><span class="line">		<span class="keyword">return</span> messageSource;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>3）、去页面获取国际化的值；</p>
<p><img src="https://i.loli.net/2019/11/05/oG1XlCD6b7SuFmi.png" alt=""></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>  <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Signin Template for Bootstrap<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"asserts/css/bootstrap.min.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Custom styles for this template --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"asserts/css/signin.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/asserts/css/signin.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-signin"</span> <span class="attr">action</span>=<span class="string">"dashboard.html"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"mb-4"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/asserts/img/bootstrap-solid.svg&#125;"</span> <span class="attr">src</span>=<span class="string">"asserts/img/bootstrap-solid.svg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"72"</span> <span class="attr">height</span>=<span class="string">"72"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"h3 mb-3 font-weight-normal"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.tip&#125;"</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.username&#125;"</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.username&#125;"</span> <span class="attr">required</span>=<span class="string">""</span> <span class="attr">autofocus</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.password&#125;"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.password&#125;"</span> <span class="attr">required</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox mb-3"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">          		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"remember-me"</span>/&gt;</span> [[#&#123;login.remember&#125;]]</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-lg btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.btn&#125;"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"mt-5 mb-3 text-muted"</span>&gt;</span>© 2017-2018<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：根据浏览器语言设置的信息切换了国际化；</p>
<p>原理：</p>
<p>​    国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"locale"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.mvcProperties</span><br><span class="line">					.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> FixedLocaleResolver(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">			&#125;</span><br><span class="line">			AcceptHeaderLocaleResolver localeResolver = <span class="keyword">new</span> AcceptHeaderLocaleResolver();</span><br><span class="line">			localeResolver.setDefaultLocale(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">			<span class="keyword">return</span> localeResolver;</span><br><span class="line">		&#125;</span><br><span class="line">默认的就是根据请求头带来的区域信息获取Locale进行国际化</span><br></pre></td></tr></table></figure>

<p>4）、点击链接切换国际化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以在连接上携带区域信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocaleResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String l = request.getParameter(<span class="string">"l"</span>);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(l))&#123;</span><br><span class="line">            String[] split = l.split(<span class="string">"_"</span>);</span><br><span class="line">            locale = <span class="keyword">new</span> Locale(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Locale locale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyLocaleResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3登陆"><a href="#6-3登陆" class="headerlink" title="6.3登陆"></a>6.3登陆</h2><p>开发期间模板引擎页面修改以后，要实时生效</p>
<p>1）、禁用模板引擎的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 禁用缓存</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure>

<p>2）、页面修改完成以后ctrl+f9：重新编译；</p>
<p>登陆错误消息的显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not #strings.isEmpty(msg)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="6-4拦截器进行登陆检查"><a href="#6-4拦截器进行登陆检查" class="headerlink" title="6.4拦截器进行登陆检查"></a>6.4拦截器进行登陆检查</h2><p>拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆检查，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//目标方法执行之前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(<span class="string">"loginUser"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//未登陆，返回登陆页面</span></span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>,<span class="string">"没有权限请先登陆"</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/index.html"</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已登陆，放行请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注册拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span></span><br><span class="line">  <span class="meta">@Bean</span> <span class="comment">//将组件注册在容器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">webMvcConfigurerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      WebMvcConfigurerAdapter adapter = <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">              registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">              registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">              registry.addViewController(<span class="string">"/main.html"</span>).setViewName(<span class="string">"dashboard"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//注册拦截器</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">              <span class="comment">//静态资源；  *.css , *.js</span></span><br><span class="line">              <span class="comment">//SpringBoot已经做好了静态资源映射</span></span><br><span class="line">              registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                      .excludePathPatterns(<span class="string">"/index.html"</span>,<span class="string">"/"</span>,<span class="string">"/user/login"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5CRUD-员工列表"><a href="#6-5CRUD-员工列表" class="headerlink" title="6.5CRUD-员工列表"></a>6.5CRUD-员工列表</h2><p>实验要求：</p>
<p>1）、RestfulCRUD：CRUD满足Rest风格；</p>
<p>URI：  /资源名称/资源标识       HTTP请求方式区分对资源CRUD操作</p>
<table>
<thead>
<tr>
<th></th>
<th>普通CRUD（uri来区分操作）</th>
<th>RestfulCRUD</th>
</tr>
</thead>
<tbody><tr>
<td>查询</td>
<td>getEmp</td>
<td>emp—GET</td>
</tr>
<tr>
<td>添加</td>
<td>addEmp?xxx</td>
<td>emp—POST</td>
</tr>
<tr>
<td>修改</td>
<td>updateEmp?id=xxx&amp;xxx=xx</td>
<td>emp/{id}—PUT</td>
</tr>
<tr>
<td>删除</td>
<td>deleteEmp?id=1</td>
<td>emp/{id}—DELETE</td>
</tr>
</tbody></table>
<p>2）、实验的请求架构;</p>
<table>
<thead>
<tr>
<th>实验功能</th>
<th>请求URI</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>查询所有员工</td>
<td>emps</td>
<td>GET</td>
</tr>
<tr>
<td>查询某个员工(来到修改页面)</td>
<td>emp/1</td>
<td>GET</td>
</tr>
<tr>
<td>来到添加页面</td>
<td>emp</td>
<td>GET</td>
</tr>
<tr>
<td>添加员工</td>
<td>emp</td>
<td>POST</td>
</tr>
<tr>
<td>来到修改页面（查出员工进行信息回显）</td>
<td>emp/1</td>
<td>GET</td>
</tr>
<tr>
<td>修改员工</td>
<td>emp</td>
<td>PUT</td>
</tr>
<tr>
<td>删除员工</td>
<td>emp/1</td>
<td>DELETE</td>
</tr>
</tbody></table>
<p>3）、员工列表：</p>
<p><strong>thymeleaf公共页面元素抽取</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、抽取公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line">&amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2、引入公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"~&#123;footer :: copy&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">~&#123;templatename::selector&#125;：模板名::选择器</span><br><span class="line">~&#123;templatename::fragmentname&#125;:模板名::片段名</span><br><span class="line"></span><br><span class="line">3、默认效果：</span><br><span class="line">insert的公共片段在div标签中</span><br><span class="line">如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：</span><br><span class="line">行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]；</span><br></pre></td></tr></table></figure>



<p>三种引入公共片段的th属性：</p>
<p><strong>th:insert</strong>：将公共片段整个插入到声明引入的元素中</p>
<p><strong>th:replace</strong>：将声明引入的元素替换为公共片段</p>
<p><strong>th:include</strong>：将被引入的片段的内容包含进这个标签中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line">&amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">引入方式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:include</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    &amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">&amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&amp;copy; 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>引入片段的时候传入参数： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"col-md-2 d-none d-md-block bg-light sidebar"</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sidebar-sticky"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav flex-column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link active"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">th:class</span>=<span class="string">"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/main.html&#125;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">width</span>=<span class="string">"24"</span> <span class="attr">height</span>=<span class="string">"24"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 24 24"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"currentColor"</span> <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">stroke-linecap</span>=<span class="string">"round"</span> <span class="attr">stroke-linejoin</span>=<span class="string">"round"</span> <span class="attr">class</span>=<span class="string">"feather feather-home"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"9 22 9 12 15 12 15 22"</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Dashboard <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入侧边栏;传入参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"commons/bar::#sidebar(activeUri='emps')"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-6CRUD-员工添加"><a href="#6-6CRUD-员工添加" class="headerlink" title="6.6CRUD-员工添加"></a>6.6CRUD-员工添加</h2><p>添加页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan@atguigu.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span>  <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span>  <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>5<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提交的数据格式不对：生日：日期；</p>
<p>2017-12-12；2017/12/12；2017.12.12；</p>
<p>日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;</p>
<p>2017-12-12—Date； 类型转换，格式化;</p>
<p>默认日期是按照/的方式；</p>
<h2 id="6-7CRUD-员工修改"><a href="#6-7CRUD-员工修改" class="headerlink" title="6.7CRUD-员工修改"></a>6.7CRUD-员工修改</h2><p>修改添加二合一表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--需要区分是员工修改还是添加；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/emp&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发送put请求修改员工数据--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）</span></span><br><span class="line"><span class="comment">2、页面创建一个post表单</span></span><br><span class="line"><span class="comment">3、创建一个input项，name="_method";值就是我们指定的请求方式</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"put"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;emp!=null&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;emp!=null&#125;"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp.id&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan@atguigu.com"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.email&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">th:checked</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">th:checked</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--提交的是部门的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"department.id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:selected</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;dept.id&#125;"</span> <span class="attr">th:each</span>=<span class="string">"dept:$&#123;depts&#125;"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;dept.departmentName&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"birth"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp!=null&#125;?'修改':'添加'"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-8CRUD-员工删除"><a href="#6-8CRUD-员工删除" class="headerlink" title="6.8CRUD-员工删除"></a>6.8CRUD-员工删除</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"emp:$&#123;emps&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;emp.lastName&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.email&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.gender&#125;==0?'女':'男'"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.department.departmentName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-primary"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/emp/&#125;+$&#123;emp.id&#125;"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">th:attr</span>=<span class="string">"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;"</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-danger deleteBtn"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">".deleteBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//删除当前员工的</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#deleteEmpForm"</span>).attr(<span class="string">"action"</span>,$(<span class="keyword">this</span>).attr(<span class="string">"del_uri"</span>)).submit();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="7-错误处理机制"><a href="#7-错误处理机制" class="headerlink" title="7.错误处理机制"></a>7.错误处理机制</h1><h2 id="7-1SpringBoot默认的错误处理机制"><a href="#7-1SpringBoot默认的错误处理机制" class="headerlink" title="7.1SpringBoot默认的错误处理机制"></a>7.1SpringBoot默认的错误处理机制</h2><p>默认效果：</p>
<p>​        1）、浏览器，返回一个默认的错误页面</p>
<p><img src="https://i.loli.net/2019/11/05/FObqpdHT24RtZAi.png" alt=""></p>
<p>  浏览器发送请求的请求头：</p>
<p><img src="https://i.loli.net/2019/11/05/2LDId3cOYBnrbev.png" alt=""></p>
<p>​        2）、如果是其他客户端，默认响应一个json数据</p>
<p><img src="https://i.loli.net/2019/11/05/my9MbZqdCOB14vh.png" alt=""></p>
<p>​        <img src="https://i.loli.net/2019/11/05/4qRcWgoOT5BJAlU.png" alt=""></p>
<p>原理：</p>
<p>​    可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；</p>
<pre><code>给容器中添加了以下组件</code></pre><p>​    1、DefaultErrorAttributes：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">帮我们在页面共享信息；</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">		errorAttributes.put(<span class="string">"timestamp"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">		addStatus(errorAttributes, requestAttributes);</span><br><span class="line">		addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);</span><br><span class="line">		addPath(errorAttributes, requestAttributes);</span><br><span class="line">		<span class="keyword">return</span> errorAttributes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>​    2、BasicErrorController：处理默认/error请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(produces = <span class="string">"text/html"</span>)<span class="comment">//产生html类型的数据；浏览器发送的请求来到这个方法处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">		response.setStatus(status.value());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去哪个页面作为错误页面；包含页面地址和页面内容</span></span><br><span class="line">		ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">		<span class="keyword">return</span> (modelAndView == <span class="keyword">null</span> ? <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model) : modelAndView);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span></span><br><span class="line">	<span class="meta">@ResponseBody</span>    <span class="comment">//产生json数据，其他客户端来到这个方法处理；</span></span><br><span class="line">	<span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">				isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>​    3、ErrorPageCustomizer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;error.path:/error&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String path = <span class="string">"/error"</span>;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）</span><br></pre></td></tr></table></figure>



<p>​    4、DefaultErrorViewResolver：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">			Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">		ModelAndView modelAndView = resolve(String.valueOf(status), model);</span><br><span class="line">		<span class="keyword">if</span> (modelAndView == <span class="keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">			modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ModelAndView <span class="title">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认SpringBoot可以去找到一个页面？  error/404</span></span><br><span class="line">		String errorViewName = <span class="string">"error/"</span> + viewName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模板引擎可以解析这个页面地址就用模板引擎解析</span></span><br><span class="line">		TemplateAvailabilityProvider provider = <span class="keyword">this</span>.templateAvailabilityProviders</span><br><span class="line">				.getProvider(errorViewName, <span class="keyword">this</span>.applicationContext);</span><br><span class="line">		<span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(errorViewName, model);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span></span><br><span class="line">		<span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>​    步骤：</p>
<p>​        一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被<strong>BasicErrorController</strong>处理；</p>
<p>​        1）响应页面；去哪个页面是由<strong>DefaultErrorViewResolver</strong>解析得到的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有的ErrorViewResolver得到ModelAndView</span></span><br><span class="line">   <span class="keyword">for</span> (ErrorViewResolver resolver : <span class="keyword">this</span>.errorViewResolvers) &#123;</span><br><span class="line">      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);</span><br><span class="line">      <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> modelAndView;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2如果定制错误响应："><a href="#7-2如果定制错误响应：" class="headerlink" title="7.2如果定制错误响应："></a>7.2如果定制错误响应：</h2><h3 id="7-2-1如何定制错误的页面；"><a href="#7-2-1如何定制错误的页面；" class="headerlink" title="7.2.1如何定制错误的页面；"></a><strong>7.2.1如何定制错误的页面；</strong></h3><p>​            <strong>1）、有模板引擎的情况下；error/状态码;</strong> 【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到  对应的页面；</p>
<p>​            我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；        </p>
<p>​            页面能获取的信息；</p>
<p>​                timestamp：时间戳</p>
<p>​                status：状态码</p>
<p>​                error：错误提示</p>
<p>​                exception：异常对象</p>
<p>​                message：异常消息</p>
<p>​                errors：JSR303数据校验的错误都在这里</p>
<p>​            2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</p>
<p>​            3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；</p>
<h3 id="7-2-2如何定制错误的json数据；"><a href="#7-2-2如何定制错误的json数据；" class="headerlink" title="7.2.2如何定制错误的json数据；"></a>7.2.2如何定制错误的json数据；</h3><p>​        1）、自定义异常处理&amp;返回定制json数据；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">        map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有自适应效果...</span></span><br></pre></td></tr></table></figure>



<p>​        2）、转发到/error进行自适应响应效果处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(Exception e, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Integer statusCode = (Integer) request</span></span><br><span class="line"><span class="comment">        .getAttribute("javax.servlet.error.status_code");</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>,<span class="number">500</span>);</span><br><span class="line">       map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">       map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">       <span class="comment">//转发到/error</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"forward:/error"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-3将我们的定制数据携带出去；"><a href="#7-2-3将我们的定制数据携带出去；" class="headerlink" title="7.2.3将我们的定制数据携带出去；"></a>7.2.3将我们的定制数据携带出去；</h3><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；</p>
<p>​    1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</p>
<p>​    2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p>
<p>​            容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；</p>
<p>自定义ErrorAttributes</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给容器中加入我们自己定义的ErrorAttributes</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>.getErrorAttributes(requestAttributes, includeStackTrace);</span><br><span class="line">        map.put(<span class="string">"company"</span>,<span class="string">"atguigu"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</p>
<p><img src="https://i.loli.net/2019/11/05/rivEpLfSIM6RyAc.png" alt=""></p>
<h1 id="8-配置嵌入式Servlet容器"><a href="#8-配置嵌入式Servlet容器" class="headerlink" title="8.配置嵌入式Servlet容器"></a>8.配置嵌入式Servlet容器</h1><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p>
<p><img src="https://i.loli.net/2019/11/06/6AIfox1EznHrSQb.png" alt=""></p>
<p>问题？</p>
<h2 id="8-1如何定制和修改Servlet容器的相关配置"><a href="#8-1如何定制和修改Servlet容器的相关配置" class="headerlink" title="8.1如何定制和修改Servlet容器的相关配置"></a>8.1如何定制和修改Servlet容器的相关配置</h2><p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">server.context-path</span>=<span class="string">/crud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">//通用的Servlet容器设置</span></span><br><span class="line"><span class="attr">server.xxx</span></span><br><span class="line"><span class="attr">//Tomcat的设置</span></span><br><span class="line"><span class="attr">server.tomcat.xxx</span></span><br></pre></td></tr></table></figure>

<p>2、编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  <span class="comment">//一定要将这个定制器加入到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">embeddedServletContainerCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定制嵌入式的Servlet容器相关的规则</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">            container.setPort(<span class="number">8083</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#8-2注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="8.2注册Servlet三大组件【Servlet、Filter、Listener】"></a>8.2注册Servlet三大组件【Servlet、Filter、Listener】</h2><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p>
<p>注册三大组件用以下方式</p>
<p>ServletRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册三大组件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FilterRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    registrationBean.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServletListenerRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyListener());</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p>
<p>DispatcherServletAutoConfiguration中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      DispatcherServlet dispatcherServlet)</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">         dispatcherServlet, <span class="keyword">this</span>.serverProperties.getServletMapping());</span><br><span class="line">    <span class="comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span></span><br><span class="line">    <span class="comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span></span><br><span class="line">    </span><br><span class="line">   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">   registration.setLoadOnStartup(</span><br><span class="line">         <span class="keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.multipartConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">      registration.setMultipartConfig(<span class="keyword">this</span>.multipartConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）、SpringBoot能不能支持其他的Servlet容器；</p>
<h2 id="8-3替换为其他嵌入式Servlet容器"><a href="#8-3替换为其他嵌入式Servlet容器" class="headerlink" title="8.3替换为其他嵌入式Servlet容器"></a>8.3替换为其他嵌入式Servlet容器</h2><p><img src="https://i.loli.net/2019/11/06/pRyeUqOLbDzh8w7.png" alt=""></p>
<p>默认支持：</p>
<p>Tomcat（默认使用）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Jetty</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Undertow</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-4嵌入式Servlet容器自动配置原理；"><a href="#8-4嵌入式Servlet容器自动配置原理；" class="headerlink" title="8.4嵌入式Servlet容器自动配置原理；"></a>8.4嵌入式Servlet容器自动配置原理；</h2><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@Import</span>(BeanPostProcessorsRegistrar.class)</span><br><span class="line"><span class="comment">//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件</span></span><br><span class="line"><span class="comment">//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：</span></span><br><span class="line"><span class="comment">//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Tomcat.class &#125;)<span class="comment">//判断当前是否引入了Tomcat依赖；</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)<span class="comment">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">tomcatEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Jetty is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Server.class, Loader.class,</span><br><span class="line">			WebAppContext.class &#125;)</span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedJetty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> JettyEmbeddedServletContainerFactory <span class="title">jettyEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JettyEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Undertow is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)</span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedUndertow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="title">undertowEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> UndertowEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmbeddedServletContainerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取嵌入式的Servlet容器</span></span><br><span class="line">   <span class="function">EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         ServletContextInitializer... initializers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/06/PmHKtEOhpV1TnBJ.png" alt=""></p>
<p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）</p>
<p><img src="https://i.loli.net/2019/11/06/iuf8Rs1Edht7WwK.png" alt=""></p>
<p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Tomcat</span></span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置Tomcat的基本环节</span></span><br><span class="line">   File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">         : createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">   tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">   tomcat.getService().addConnector(connector);</span><br><span class="line">   customizeConnector(connector);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line">   tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">   configureEngine(tomcat.getEngine());</span><br><span class="line">   <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">      tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">   &#125;</span><br><span class="line">   prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span></span><br><span class="line">   <span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）、我们对嵌入式容器的配置修改是怎么生效？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerProperties、EmbeddedServletContainerCustomizer</span><br></pre></td></tr></table></figure>



<p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p>
<p>怎么修改的原理？</p>
<p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化之前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span></span><br><span class="line">   <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postProcessBeforeInitialization</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableEmbeddedServletContainer bean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span></span><br><span class="line">    <span class="keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;</span><br><span class="line">        customizer.customize(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="title">getCustomizers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customizers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Look up does not include the parent context</span></span><br><span class="line">        <span class="keyword">this</span>.customizers = <span class="keyword">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(</span><br><span class="line">            <span class="keyword">this</span>.beanFactory</span><br><span class="line">            <span class="comment">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span></span><br><span class="line">            <span class="comment">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span></span><br><span class="line">            .getBeansOfType(EmbeddedServletContainerCustomizer.class,</span><br><span class="line">                            <span class="keyword">false</span>, <span class="keyword">false</span>)</span><br><span class="line">            .values());</span><br><span class="line">        Collections.sort(<span class="keyword">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        <span class="keyword">this</span>.customizers = Collections.unmodifiableList(<span class="keyword">this</span>.customizers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.customizers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerProperties也是定制器</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p>
<p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p>
<p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p>
<p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p>
<p>###5）、嵌入式Servlet容器启动原理；</p>
<p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p>
<p>获取嵌入式的Servlet容器工厂：</p>
<p>1）、SpringBoot应用启动运行run方法</p>
<p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p>
<p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p>
<p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p>
<p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p>
<p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p>
<p>​    从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p>
<p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
<p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p>
<p><strong>==IOC容器启动创建嵌入式的Servlet容器==</strong></p>
<h1 id="9-使用外置的Servlet容器"><a href="#9-使用外置的Servlet容器" class="headerlink" title="9.使用外置的Servlet容器"></a>9.使用外置的Servlet容器</h1><p>嵌入式Servlet容器：应用打成可执行的jar</p>
<p>​        优点：简单、便携；</p>
<p>​        缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p>
<p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包；</p>
<h2 id="9-1步骤"><a href="#9-1步骤" class="headerlink" title="9.1步骤"></a>9.1步骤</h2><p>1）、必须创建一个war项目；（利用idea创建好目录结构）</p>
<p>2）、将嵌入式的Tomcat指定为provided；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3）、必须编写一个<strong>SpringBootServletInitializer</strong>的子类，并调用configure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">      <span class="keyword">return</span> application.sources(SpringBoot04WebJspApplication.class);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）、启动服务器就可以使用；</p>
<h2 id="9-2原理"><a href="#9-2原理" class="headerlink" title="9.2原理"></a>9.2原理</h2><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p>
<p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p>
<p>servlet3.0（Spring注解版）：</p>
<p>8.2.4 Shared libraries / runtimes pluggability：</p>
<p>规则：</p>
<p>​    1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p>
<p>​    2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p>
<p>​    3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p>
<p>流程：</p>
<p>1）、启动Tomcat</p>
<p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p>
<p>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p>
<p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；</p>
<p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p>
<p><img src="https://i.loli.net/2019/11/06/ZDuymMfWLchzKG5.png" alt=""></p>
<p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p>
<p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建SpringApplicationBuilder</span></span><br><span class="line">   SpringApplicationBuilder builder = createSpringApplicationBuilder();</span><br><span class="line">   StandardServletEnvironment environment = <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">   environment.initPropertySources(servletContext, <span class="keyword">null</span>);</span><br><span class="line">   builder.environment(environment);</span><br><span class="line">   builder.main(getClass());</span><br><span class="line">   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);</span><br><span class="line">   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"Root context already created (using as parent)."</span>);</span><br><span class="line">      servletContext.setAttribute(</span><br><span class="line">            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">null</span>);</span><br><span class="line">      builder.initializers(<span class="keyword">new</span> ParentContextApplicationContextInitializer(parent));</span><br><span class="line">   &#125;</span><br><span class="line">   builder.initializers(</span><br><span class="line">         <span class="keyword">new</span> ServletContextApplicationContextInitializer(servletContext));</span><br><span class="line">   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来</span></span><br><span class="line">   builder = configure(builder);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用builder创建一个Spring应用</span></span><br><span class="line">   SpringApplication application = builder.build();</span><br><span class="line">   <span class="keyword">if</span> (application.getSources().isEmpty() &amp;&amp; AnnotationUtils</span><br><span class="line">         .findAnnotation(getClass(), Configuration.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      application.getSources().add(getClass());</span><br><span class="line">   &#125;</span><br><span class="line">   Assert.state(!application.getSources().isEmpty(),</span><br><span class="line">         <span class="string">"No SpringApplication sources have been defined. Either override the "</span></span><br><span class="line">               + <span class="string">"configure method or add an @Configuration annotation"</span>);</span><br><span class="line">   <span class="comment">// Ensure error pages are registered</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.registerErrorPageFilter) &#123;</span><br><span class="line">      application.getSources().add(ErrorPageFilterConfiguration.class);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//启动Spring应用</span></span><br><span class="line">   <span class="keyword">return</span> run(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7）、Spring的应用就启动并且创建IOC容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//刷新IOC容器</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动Servlet容器，再启动SpringBoot应用</strong></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习2-原理分析级配置文件</title>
    <url>/2019/11/05/2019-11-05-SpringBoot%E5%AD%A6%E4%B9%A02-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%BA%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-SpringBoot原理分析"><a href="#1-SpringBoot原理分析" class="headerlink" title="1.SpringBoot原理分析"></a>1.SpringBoot原理分析</h1><h2 id="1-1-起步依赖原理分析"><a href="#1-1-起步依赖原理分析" class="headerlink" title="1.1 起步依赖原理分析"></a>1.1 起步依赖原理分析</h2><h3 id="1-1-1-分析spring-boot-starter-parent"><a href="#1-1-1-分析spring-boot-starter-parent" class="headerlink" title="1.1.1 分析spring-boot-starter-parent"></a>1.1.1 分析spring-boot-starter-parent</h3><p>按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.15.3<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.63<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">atomikos.version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">atomikos.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">bitronix.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">bitronix.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">build-helper-maven-plugin.version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">build-helper-maven-plugin.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">byte-buddy.version</span>&gt;</span>1.7.11<span class="tag">&lt;/<span class="name">byte-buddy.version</span>&gt;</span></span><br><span class="line">  	... ... ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      	... ... ...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kotlin-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;kotlin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jooq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jooq.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          	... ... ...</span><br><span class="line">    	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。</p>
<h3 id="1-1-2-分析spring-boot-starter-web"><a href="#1-1-2-分析spring-boot-starter-web" class="headerlink" title="1.1.2 分析spring-boot-starter-web"></a>1.1.2 分析spring-boot-starter-web</h3><p>按住Ctrl点击pom.xml中的spring-boot-starter-web，跳转到了spring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Boot Web Starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.9.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。也就是说，springboot是针对功能进行导包。</p>
<h2 id="1-2-自动配置原理解析"><a href="#1-2-自动配置原理解析" class="headerlink" title="1.2 自动配置原理解析"></a>1.2 自动配置原理解析</h2><p>按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringBootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MySpringBootApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@SpringBootApplication的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	... ... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<p>@SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类；</p>
<p>@ComponentScan：确定要扫描的包，即当前类所在的包及其子包下所有的类；</p>
<p>@EnableAutoConfiguration：SpringBoot自动配置功能开启</p>
<p>按住Ctrl点击查看注解@EnableAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">	... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，@Import(AutoConfigurationImportSelector.class) 导入了AutoConfigurationImportSelector类</p>
<p>按住Ctrl点击查看AutoConfigurationImportSelector源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看上述的getCandidateConfigurations方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">				getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，SpringFactoriesLoader.loadFactoryNames 方法的作用就是从META-INF/spring.factories文件中读取指定类对应的类名称列表 </p>
<p><img src="https://i.loli.net/2019/11/04/xVGfwO1snXHKkBp.png" alt=""></p>
<p>spring.factories 文件中有关自动配置的配置信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... ... ...</span><br><span class="line"></span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line"></span><br><span class="line">... ... ...</span><br></pre></td></tr></table></figure>

<p>上面配置文件存在大量的以Configuration为结尾的类名称，这些类就是存有自动配置信息的类，而SpringApplication在获取这些类名后再加载</p>
<p>我们以ServletWebServerFactoryAutoConfiguration为例来分析源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ServletRequest.class)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ServerProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerFactoryAutoConfiguration</span> </span>&#123;</span><br><span class="line">	... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<p>@EnableConfigurationProperties(ServerProperties.class) 代表加载ServerProperties服务器配置属性类</p>
<p>进入ServerProperties.class源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Server HTTP port.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Network address to which the server should bind.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> InetAddress address;</span><br><span class="line">  </span><br><span class="line">  	... ... ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<p>prefix = “server” 表示SpringBoot配置文件中的前缀，SpringBoot会将配置文件中以server开始的属性映射到该类的字段中。默认映射关系可以查看：</p>
<p><img src="https://i.loli.net/2019/11/04/uoI6WUarJ9ynfgi.png" alt=""></p>
<p>点开json文件，搜索可得，所以默认端口是8080，</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">………………</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"server.port"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"java.lang.Integer"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"Server HTTP port."</span>,</span><br><span class="line">    <span class="attr">"sourceType"</span>: <span class="string">"org.springframework.boot.autoconfigure.web.ServerProperties"</span>,</span><br><span class="line">    <span class="attr">"defaultValue"</span>: <span class="number">8080</span></span><br><span class="line">&#125;,</span><br><span class="line">………………</span><br></pre></td></tr></table></figure>

<p>知道上述关系后，若要覆盖，则可自己在配置文件中修改映射关系如下：</p>
<p><img src="https://i.loli.net/2019/11/04/FdwI19u3lZeUOjb.png" alt=""></p>
<h1 id="2、SpringBoot的配置文件"><a href="#2、SpringBoot的配置文件" class="headerlink" title="2、SpringBoot的配置文件"></a>2、SpringBoot的配置文件</h1><h2 id="2-1-SpringBoot配置文件类型"><a href="#2-1-SpringBoot配置文件类型" class="headerlink" title="2.1 SpringBoot配置文件类型"></a>2.1 SpringBoot配置文件类型</h2><h3 id="2-1-1-SpringBoot配置文件类型和作用"><a href="#2-1-1-SpringBoot配置文件类型和作用" class="headerlink" title="2.1.1 SpringBoot配置文件类型和作用"></a>2.1.1 SpringBoot配置文件类型和作用</h3><p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。</p>
<p>SpringBoot默认会从Resources目录下加载application.properties或application.yml（application.yaml）文件</p>
<p>其中，application.properties文件是键值对类型的文件，之前一直在使用，所以此处不在对properties文件的格式进行阐述。除了properties文件外，SpringBoot还可以使用yml文件进行配置，下面对yml文件进行讲解。</p>
<h3 id="2-1-2-application-yml配置文件"><a href="#2-1-2-application-yml配置文件" class="headerlink" title="2.1.2 application.yml配置文件"></a>2.1.2 application.yml配置文件</h3><h4 id="2-1-2-1-yml配置文件简介"><a href="#2-1-2-1-yml配置文件简介" class="headerlink" title="2.1.2.1 yml配置文件简介"></a>2.1.2.1 yml配置文件简介</h4><p>YML文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。</p>
<p>YML文件的扩展名可以使用.yml或者.yaml。</p>
<h4 id="2-1-2-2-yml配置文件的语法"><a href="#2-1-2-2-yml配置文件的语法" class="headerlink" title="2.1.2.2 yml配置文件的语法"></a>2.1.2.2 yml配置文件的语法</h4><h5 id="2-1-2-2-1-配置普通数据"><a href="#2-1-2-2-1-配置普通数据" class="headerlink" title="2.1.2.2.1 配置普通数据"></a>2.1.2.2.1 配置普通数据</h5><ul>
<li><p>语法： key: value</p>
</li>
<li><p>示例代码：</p>
</li>
<li><pre><code class="yaml"><span class="attr">name:</span> <span class="string">haohao</span>
<span class="string"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：value之前有一个空格</span><br><span class="line"></span><br><span class="line">##### 2.1.2.2.2 配置对象数据</span><br><span class="line"></span><br><span class="line">- 语法： </span><br><span class="line"></span><br><span class="line">  ​	key: </span><br><span class="line"></span><br><span class="line">  ​		key1: value1</span><br><span class="line"></span><br><span class="line">  ​		key2: value2</span><br><span class="line"></span><br><span class="line">  ​	或者：</span><br><span class="line"></span><br><span class="line">  ​	key: &#123;key1: value1,key2: value2&#125;</span><br><span class="line"></span><br><span class="line">- 示例代码：</span><br><span class="line"></span><br><span class="line">- ```yaml</span><br><span class="line">  person:</span><br><span class="line">    name: haohao</span><br><span class="line">    age: 31</span><br><span class="line">    addr: beijing</span><br><span class="line">  </span><br><span class="line">  #或者</span><br><span class="line">  </span><br><span class="line">  person: &#123;name: haohao,age: 31,addr: beijing&#125;</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><p>注意：key1前面的空格个数不限定，在yml语法中，相同缩进代表同一个级别</p>
</li>
</ul>
<h5 id="2-1-2-2-2-配置Map数据"><a href="#2-1-2-2-2-配置Map数据" class="headerlink" title="2.1.2.2.2 配置Map数据"></a>2.1.2.2.2 配置Map数据</h5><p>同上面的对象写法</p>
<h5 id="2-1-2-2-3-配置数组（List、Set）数据"><a href="#2-1-2-2-3-配置数组（List、Set）数据" class="headerlink" title="2.1.2.2.3 配置数组（List、Set）数据"></a>2.1.2.2.3 配置数组（List、Set）数据</h5><ul>
<li><p>语法： </p>
<p>​    key: </p>
<p>​        - value1</p>
<p>​        - value2</p>
<p>或者：</p>
<p>​    key: [value1,value2]</p>
</li>
<li><p>示例代码：</p>
</li>
<li><pre><code class="yaml"><span class="attr">city:</span>
<span class="bullet">  -</span> <span class="string">beijing</span>
<span class="bullet">  -</span> <span class="string">tianjin</span>
<span class="bullet">  -</span> <span class="string">shanghai</span>
<span class="bullet">  -</span> <span class="string">chongqing</span>

<span class="comment">#或者</span>

<span class="attr">city:</span> <span class="string">[beijing,tianjin,shanghai,chongqing]</span>

<span class="comment">#集合中的元素是对象形式</span>
<span class="attr">student:</span>
<span class="attr">  - name:</span> <span class="string">zhangsan</span>
<span class="attr">    age:</span> <span class="number">18</span>
<span class="attr">    score:</span> <span class="number">100</span>
<span class="attr">  - name:</span> <span class="string">lisi</span>
<span class="attr">    age:</span> <span class="number">28</span>
<span class="attr">    score:</span> <span class="number">88</span>
<span class="attr">  - name:</span> <span class="string">wangwu</span>
<span class="attr">    age:</span> <span class="number">38</span>
<span class="attr">    score:</span> <span class="number">90</span>
<span class="string"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：value1与之间的 - 之间存在一个空格</span><br><span class="line"></span><br><span class="line">### 2.1.3 SpringBoot配置信息的查询</span><br><span class="line"></span><br><span class="line">上面提及过，SpringBoot的配置文件，主要的目的就是对配置信息进行修改的，但在配置时的key从哪里去查询呢？我们可以查阅SpringBoot的官方文档</span><br><span class="line"></span><br><span class="line">文档URL：https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties</span><br><span class="line"></span><br><span class="line">常用的配置摘抄如下：</span><br><span class="line"></span><br><span class="line">```properties</span><br><span class="line"># QUARTZ SCHEDULER (QuartzProperties)</span><br><span class="line">spring.quartz.jdbc.initialize-schema=embedded # Database schema initialization mode.</span><br><span class="line">spring.quartz.jdbc.schema=classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span><br><span class="line">spring.quartz.job-store-type=memory # Quartz job store type.</span><br><span class="line">spring.quartz.properties.*= # Additional Quartz Scheduler properties.</span><br><span class="line"></span><br><span class="line"># ----------------------------------------</span><br><span class="line"># WEB PROPERTIES</span><br><span class="line"># ----------------------------------------</span><br><span class="line"></span><br><span class="line"># EMBEDDED SERVER CONFIGURATION (ServerProperties)</span><br><span class="line">server.port=8080 # Server HTTP port.</span><br><span class="line">server.servlet.context-path= # Context path of the application.</span><br><span class="line">server.servlet.path=/ # Path of the main dispatcher servlet.</span><br><span class="line"></span><br><span class="line"># HTTP encoding (HttpEncodingProperties)</span><br><span class="line">spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not set explicitly.</span><br><span class="line"></span><br><span class="line"># JACKSON (JacksonProperties)</span><br><span class="line">spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.</span><br><span class="line"></span><br><span class="line"># SPRING MVC (WebMvcProperties)</span><br><span class="line">spring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the dispatcher servlet.</span><br><span class="line">spring.mvc.static-path-pattern=/** # Path pattern used for static resources.</span><br><span class="line">spring.mvc.view.prefix= # Spring MVC view prefix.</span><br><span class="line">spring.mvc.view.suffix= # Spring MVC view suffix.</span><br><span class="line"></span><br><span class="line"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span><br><span class="line">spring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span><br><span class="line">spring.datasource.password= # Login password of the database.</span><br><span class="line">spring.datasource.url= # JDBC URL of the database.</span><br><span class="line">spring.datasource.username= # Login username of the database.</span><br><span class="line"></span><br><span class="line"># JEST (Elasticsearch HTTP client) (JestProperties)</span><br><span class="line">spring.elasticsearch.jest.password= # Login password.</span><br><span class="line">spring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.</span><br><span class="line">spring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.</span><br><span class="line">spring.elasticsearch.jest.read-timeout=3s # Read timeout.</span><br><span class="line">spring.elasticsearch.jest.username= # Login username.</span><br></pre></td></tr></table></figure></span>
</code></pre>
</li>
</ul>
<p>我们可以通过配置application.poperties 或者 application.yml 来修改SpringBoot的默认配置</p>
<p>例如：</p>
<p>application.properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8888</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">demo</span></span><br></pre></td></tr></table></figure>

<p>application.yml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">  servlet:</span></span><br><span class="line"><span class="attr">    context-path:</span> <span class="string">/demo</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-配置文件与配置类的属性映射方式"><a href="#2-2-配置文件与配置类的属性映射方式" class="headerlink" title="2.2 配置文件与配置类的属性映射方式"></a>2.2 配置文件与配置类的属性映射方式</h2><h3 id="2-2-1-使用注解-Value映射"><a href="#2-2-1-使用注解-Value映射" class="headerlink" title="2.2.1 使用注解@Value映射"></a>2.2.1 使用注解@Value映射</h3><p>我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上</p>
<p>例如：</p>
<p>application.properties配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">person</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age</span>: <span class="string">18</span></span><br></pre></td></tr></table></figure>

<p>或者，application.yml配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>实体Bean代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.age&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/quick"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"springboot 访问成功! name="</span>+name+<span class="string">",age="</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器访问地址：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 结果如下：</p>
<p><img src="https://i.loli.net/2019/11/04/VeF18UocuONTdR6.png" alt=""></p>
<h3 id="2-2-2-使用注解-ConfigurationProperties映射"><a href="#2-2-2-使用注解-ConfigurationProperties映射" class="headerlink" title="2.2.2 使用注解@ConfigurationProperties映射"></a>2.2.2 使用注解@ConfigurationProperties映射</h3><p>通过注解@ConfigurationProperties(prefix=”配置文件中的key的前缀”)可以将配置文件中的配置自动与实体进行映射</p>
<p>application.properties配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">person</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age</span>: <span class="string">18</span></span><br></pre></td></tr></table></figure>

<p>或者，application.yml配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>实体Bean代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/quick"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"springboot 访问成功! name="</span>+name+<span class="string">",age="</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器访问地址：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 结果如下：</p>
<p><img src="https://i.loli.net/2019/11/04/VeF18UocuONTdR6.png" alt=""></p>
<p>注意：使用@ConfigurationProperties方式可以进行配置文件与实体字段的自动映射，但需要字段必须提供set方法才可以，而使用@Value注解修饰的字段不需要提供set方法。实体Bean会显示有红条，提示没有执行器，点击<code>Open Documentation</code>，复制其中的Maven依赖，放到pom.xml中即可，这样再在配置文件中配置时就会有提示。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习3-SpringBoot与整合其他技术</title>
    <url>/2019/11/05/2019-11-05-SpringBoot%E5%AD%A6%E4%B9%A03-SpringBoot%E4%B8%8E%E6%95%B4%E5%90%88%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="1-SpringBoot整合Mybatis"><a href="#1-SpringBoot整合Mybatis" class="headerlink" title="1. SpringBoot整合Mybatis"></a>1. SpringBoot整合Mybatis</h1><h2 id="1-1-添加Mybatis的起步依赖"><a href="#1-1-添加Mybatis的起步依赖" class="headerlink" title="1.1 添加Mybatis的起步依赖"></a>1.1 添加Mybatis的起步依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-添加数据库驱动坐标"><a href="#1-2-添加数据库驱动坐标" class="headerlink" title="1.2 添加数据库驱动坐标"></a>1.2 添加数据库驱动坐标</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MySQL连接驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-添加数据库连接信息"><a href="#1-3-添加数据库连接信息" class="headerlink" title="1.3 添加数据库连接信息"></a>1.3 添加数据库连接信息</h2><p>在application.properties中添加数据量的连接信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DB Configuration:</span></span><br><span class="line"><span class="meta">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-创建user表"><a href="#1-4-创建user表" class="headerlink" title="1.4 创建user表"></a>1.4 创建user表</h2><p>在test数据库中创建user表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for `user`</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">10</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'zhangsan'</span>, <span class="string">'123'</span>, <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'lisi'</span>, <span class="string">'123'</span>, <span class="string">'李四'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="1-5-创建实体Bean"><a href="#1-5-创建实体Bean" class="headerlink" title="1.5 创建实体Bean"></a>1.5 创建实体Bean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主键</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//此处省略getter和setter方法 .. ..</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-编写Mapper"><a href="#1-6-编写Mapper" class="headerlink" title="1.6 编写Mapper"></a>1.6 编写Mapper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：@Mapper标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文中</p>
<h2 id="1-7-配置Mapper映射文件"><a href="#1-7-配置Mapper映射文件" class="headerlink" title="1.7 配置Mapper映射文件"></a>1.7 配置Mapper映射文件</h2><p>在src\main\resources\mapper路径下加入UserMapper.xml配置文件”</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.itheima.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryUserList"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-8-在application-properties中添加mybatis的信息"><a href="#1-8-在application-properties中添加mybatis的信息" class="headerlink" title="1.8 在application.properties中添加mybatis的信息"></a>1.8 在application.properties中添加mybatis的信息</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#spring集成Mybatis环境</span></span><br><span class="line"><span class="comment">#pojo别名扫描包</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.itheima.domain</span></span><br><span class="line"><span class="comment">#加载Mybatis映射文件</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*Mapper.xml</span></span><br></pre></td></tr></table></figure>

<h2 id="1-9-编写测试Controller"><a href="#1-9-编写测试Controller" class="headerlink" title="1.9 编写测试Controller"></a>1.9 编写测试Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/queryUser"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryUserList();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-测试"><a href="#1-10-测试" class="headerlink" title="1.10 测试"></a>1.10 测试</h2><p><img src="https://i.loli.net/2019/11/04/JM5UAQgEuhNw6mZ.png" alt=""></p>
<h1 id="2-SpringBoot整合Junit"><a href="#2-SpringBoot整合Junit" class="headerlink" title="2 .SpringBoot整合Junit"></a>2 .SpringBoot整合Junit</h1><h2 id="2-1-添加Junit的起步依赖"><a href="#2-1-添加Junit的起步依赖" class="headerlink" title="2.1 添加Junit的起步依赖"></a>2.1 添加Junit的起步依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--测试的起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-编写测试类"><a href="#2-2-编写测试类" class="headerlink" title="2.2 编写测试类"></a>2.2 编写测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: MybatisTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试mybatis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = Springboot03mybatisApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryUserList();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，@SpringBootTest的属性指定的是引导类的字节码对象</p>
<h2 id="2-3-控制台打印信息"><a href="#2-3-控制台打印信息" class="headerlink" title="2.3 控制台打印信息"></a>2.3 控制台打印信息</h2><p><img src="https://i.loli.net/2019/11/04/E7WDdlk3HUeY6fZ.png" alt=""></p>
<h1 id="3-SpringBoot整合Spring-Data-JPA"><a href="#3-SpringBoot整合Spring-Data-JPA" class="headerlink" title="3. SpringBoot整合Spring Data JPA"></a>3. SpringBoot整合Spring Data JPA</h1><h2 id="3-1-添加Spring-Data-JPA的起步依赖"><a href="#3-1-添加Spring-Data-JPA的起步依赖" class="headerlink" title="3.1 添加Spring Data JPA的起步依赖"></a>3.1 添加Spring Data JPA的起步依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- springBoot JPA的起步依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-添加数据库驱动依赖"><a href="#3-2-添加数据库驱动依赖" class="headerlink" title="3.2 添加数据库驱动依赖"></a>3.2 添加数据库驱动依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MySQL连接驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-在application-properties中配置数据库和jpa的相关属性"><a href="#3-3-在application-properties中配置数据库和jpa的相关属性" class="headerlink" title="3.3 在application.properties中配置数据库和jpa的相关属性"></a>3.3 在application.properties中配置数据库和jpa的相关属性</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DB Configuration:</span></span><br><span class="line"><span class="meta">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#JPA Configuration:</span></span><br><span class="line"><span class="meta">spring.jpa.database</span>=<span class="string">MySQL</span></span><br><span class="line"><span class="meta">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.jpa.generate-ddl</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming_strategy</span>=<span class="string">org.hibernate.cfg.ImprovedNamingStrategy</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-创建实体配置实体"><a href="#3-4-创建实体配置实体" class="headerlink" title="3.4 创建实体配置实体"></a>3.4 创建实体配置实体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主键</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//此处省略setter和getter方法... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-编写UserRepository"><a href="#3-5-编写UserRepository" class="headerlink" title="3.5 编写UserRepository"></a>3.5 编写UserRepository</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-编写测试类"><a href="#3-6-编写测试类" class="headerlink" title="3.6 编写测试类"></a>3.6 编写测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = Springboot04jpaApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; all = userRepository.findAll();</span><br><span class="line">        System.out.println(all);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-控制台打印信息"><a href="#3-7-控制台打印信息" class="headerlink" title="3.7 控制台打印信息"></a>3.7 控制台打印信息</h2><p><img src="https://i.loli.net/2019/11/04/aO4JtcLKRyuVqlY.png" alt=""></p>
<p>注意：如果是jdk9，执行报错如下：</p>
<p><img src="https://i.loli.net/2019/11/04/l6ZI9oJiHwr2WT3.png" alt=""></p>
<p>原因：jdk缺少相应的jar</p>
<p>解决方案：手动导入对应的maven坐标，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jdk9需要导入如下坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里JDK11测试不需要再导入。</p>
<h1 id="4-SpringBoot整合Redis"><a href="#4-SpringBoot整合Redis" class="headerlink" title="4. SpringBoot整合Redis"></a>4. SpringBoot整合Redis</h1><h2 id="4-1-添加redis的起步依赖"><a href="#4-1-添加redis的起步依赖" class="headerlink" title="4.1 添加redis的起步依赖"></a>4.1 添加redis的起步依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置使用redis启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-配置redis的连接信息"><a href="#4-2-配置redis的连接信息" class="headerlink" title="4.2 配置redis的连接信息"></a>4.2 配置redis的连接信息</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-注入RedisTemplate测试redis操作"><a href="#4-3-注入RedisTemplate测试redis操作" class="headerlink" title="4.3 注入RedisTemplate测试redis操作"></a>4.3 注入RedisTemplate测试redis操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = SpringbootJpaApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//从redis缓存中获得指定的数据</span></span><br><span class="line">        String userListData = redisTemplate.boundValueOps(<span class="string">"user.findAll"</span>).get();</span><br><span class="line">        <span class="comment">//如果redis中没有数据的话</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==userListData)&#123;</span><br><span class="line">            <span class="comment">//查询数据库获得数据</span></span><br><span class="line">            List&lt;User&gt; all = userRepository.findAll();</span><br><span class="line">            <span class="comment">//转换成json格式字符串</span></span><br><span class="line">            ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            userListData = om.writeValueAsString(all);</span><br><span class="line">            <span class="comment">//将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库</span></span><br><span class="line">            redisTemplate.boundValueOps(<span class="string">"user.findAll"</span>).set(userListData);</span><br><span class="line">            System.out.println(<span class="string">"===============从数据库获得数据==============="</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"===============从redis缓存中获得数据==============="</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(userListData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习1-简介及入门</title>
    <url>/2019/11/05/2019-11-05-SpringBoot%E5%AD%A6%E4%B9%A01-%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>相比于之前尚硅谷视频，黑马的这个课程更加简便一些，先学习这个，此系列和之前可能会有重复，也算是温故而知新。</p>
</blockquote>
<h1 id="一、SpringBoot简介"><a href="#一、SpringBoot简介" class="headerlink" title="一、SpringBoot简介"></a>一、SpringBoot简介</h1><h2 id="1-1-原有Spring优缺点分析"><a href="#1-1-原有Spring优缺点分析" class="headerlink" title="1.1  原有Spring优缺点分析"></a>1.1  原有Spring优缺点分析</h2><h3 id="1-1-1-Spring的优点分析"><a href="#1-1-1-Spring的优点分析" class="headerlink" title="1.1.1 Spring的优点分析"></a>1.1.1 Spring的优点分析</h3><p>Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。</p>
<h3 id="1-1-2-Spring的缺点分析"><a href="#1-1-2-Spring的缺点分析" class="headerlink" title="1.1.2 Spring的缺点分析"></a>1.1.2 Spring的缺点分析</h3><p>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。</p>
<p>所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。</p>
<p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p>
<h2 id="1-2-SpringBoot的概述"><a href="#1-2-SpringBoot的概述" class="headerlink" title="1.2 SpringBoot的概述"></a>1.2 SpringBoot的概述</h2><h3 id="1-2-1-SpringBoot解决上述Spring的缺点"><a href="#1-2-1-SpringBoot解决上述Spring的缺点" class="headerlink" title="1.2.1 SpringBoot解决上述Spring的缺点"></a>1.2.1 SpringBoot解决上述Spring的缺点</h3><p>SpringBoot对上述Spring的缺点进行的改善和优化，<strong>基于约定优于配置</strong>的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p>
<h3 id="1-2-2-SpringBoot的特点"><a href="#1-2-2-SpringBoot的特点" class="headerlink" title="1.2.2 SpringBoot的特点"></a>1.2.2 SpringBoot的特点</h3><ul>
<li>为基于Spring的开发提供更快的入门体验</li>
<li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li>
<li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等</li>
<li>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</li>
</ul>
<h3 id="1-2-3-SpringBoot的核心功能"><a href="#1-2-3-SpringBoot的核心功能" class="headerlink" title="1.2.3 SpringBoot的核心功能"></a>1.2.3 SpringBoot的核心功能</h3><ul>
<li><p>起步依赖</p>
<p>起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</p>
<p>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p>
</li>
<li><p>自动配置</p>
<p>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p>
</li>
</ul>
<h1 id="二、SpringBoot快速入门"><a href="#二、SpringBoot快速入门" class="headerlink" title="二、SpringBoot快速入门"></a>二、SpringBoot快速入门</h1><h2 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1 代码实现"></a>2.1 代码实现</h2><h3 id="2-1-1-创建Maven工程"><a href="#2-1-1-创建Maven工程" class="headerlink" title="2.1.1 创建Maven工程"></a>2.1.1 创建Maven工程</h3><p>使用idea工具创建一个maven工程，该工程为普通的java工程即可。</p>
<h3 id="2-1-2-添加SpringBoot的起步依赖"><a href="#2-1-2-添加SpringBoot的起步依赖" class="headerlink" title="2.1.2 添加SpringBoot的起步依赖"></a>2.1.2 添加SpringBoot的起步依赖</h3><p>SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-1-3-编写SpringBoot引导类"><a href="#2-1-3-编写SpringBoot引导类" class="headerlink" title="2.1.3 编写SpringBoot引导类"></a>2.1.3 编写SpringBoot引导类</h3><p>要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: MySpringBootApplication</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: SpringBoot引导类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//声明该类是一个SpringBoot的引导类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringBootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main方法是java的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run方法，表示运行SpringBoot的引导类，参数就是SpringBoot的引导类的字节码对象</span></span><br><span class="line">        SpringApplication.run(MySpringBootApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-编写Controller"><a href="#2-1-4-编写Controller" class="headerlink" title="2.1.4 编写Controller"></a>2.1.4 编写Controller</h3><p>在引导类MySpringBootApplication同级包或者子级包中创建QuickStartController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/quick"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"springboot 访问成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-测试"><a href="#2-1-5-测试" class="headerlink" title="2.1.5 测试"></a>2.1.5 测试</h3><p>执行SpringBoot起步类的主方法，控制台打印日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::        (v2.0.1.RELEASE)</span><br><span class="line"></span><br><span class="line">2018-05-08 14:29:59.714  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Starting MySpringBootApplication on DESKTOP-RRUNFUH with PID 5672 (C:\Users\muzimoo\IdeaProjects\IdeaTest\springboot_quick\target\classes started by muzimoo in C:\Users\muzimoo\IdeaProjects\IdeaTest)</span><br><span class="line">... ... ...</span><br><span class="line">o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span><br><span class="line">2018-05-08 14:30:03.126  INFO 5672 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup</span><br><span class="line">2018-05-08 14:30:03.196  INFO 5672 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &apos;&apos;</span><br><span class="line">2018-05-08 14:30:03.206  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Started MySpringBootApplication in 4.252 seconds (JVM running for 5.583)</span><br></pre></td></tr></table></figure>

<p>通过日志发现，Tomcat started on port(s): 8080 (http) with context path ‘’</p>
<p>tomcat已经起步，端口监听8080，web应用的虚拟工程名称为空</p>
<p>打开浏览器访问url地址为：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a></p>
<p><img src="D:/Tech/SpringBoot/SpringBoot%E5%9F%BA%E7%A1%80/%E8%AE%B2%E4%B9%89(md,pdf)/img/5.png" alt=""></p>
<h2 id="2-2-快速入门解析"><a href="#2-2-快速入门解析" class="headerlink" title="2.2 快速入门解析"></a>2.2 快速入门解析</h2><h3 id="2-2-2-SpringBoot代码解析"><a href="#2-2-2-SpringBoot代码解析" class="headerlink" title="2.2.2 SpringBoot代码解析"></a>2.2.2 SpringBoot代码解析</h3><ul>
<li>@SpringBootApplication：标注SpringBoot的启动类，该注解具备多种功能（后面详细剖析）</li>
<li>SpringApplication.run(MySpringBootApplication.class) 代表运行SpringBoot的启动类，参数为SpringBoot启动类的字节码对象</li>
</ul>
<h3 id="2-2-3-SpringBoot工程热部署"><a href="#2-2-3-SpringBoot工程热部署" class="headerlink" title="2.2.3 SpringBoot工程热部署"></a>2.2.3 SpringBoot工程热部署</h3><p>我们在开发中反复修改类、页面等资源，每次修改后都是需要重新启动才生效，这样每次启动都很麻烦，浪费了大量的时间，我们可以在修改代码后不重启就能生效，在 pom.xml 中添加如下配置就可以实现这样的功能，我们称之为热部署。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--热部署配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：IDEA进行SpringBoot热部署失败原因</p>
<p>出现这种情况，并不是热部署配置问题，其根本原因是因为Intellij IEDA默认情况下不会自动编译，需要对IDEA进行自动编译的设置，如下：</p>
<p><img src="https://i.loli.net/2019/11/04/lQ5kApIt72KBD1n.png" alt=""></p>
<p>然后 Shift+Ctrl+Alt+/，选择Registry</p>
<p><img src="https://i.loli.net/2019/11/04/DntMvjaWOHzr7yN.png" alt=""></p>
<h3 id="2-2-4-使用idea快速创建SpringBoot项目"><a href="#2-2-4-使用idea快速创建SpringBoot项目" class="headerlink" title="2.2.4 使用idea快速创建SpringBoot项目"></a>2.2.4 使用idea快速创建SpringBoot项目</h3><p><img src="https://i.loli.net/2019/11/04/l6BfzweqcOrRKgb.png" alt=""></p>
<p><img src="https://i.loli.net/2019/11/04/oWdDNOaUmhMu7r3.png" alt=""></p>
<p>我这里选取了Web以及用于热部署的devTools。</p>
<p><img src="https://i.loli.net/2019/11/04/xpLuaAkh4Yrmtev.png" alt=""></p>
<p><img src="https://i.loli.net/2019/11/04/wALgD5qa8N1IKrX.png" alt=""></p>
<p><img src="https://i.loli.net/2019/11/04/oCFwZhyjVmbiWOf.png" alt=""></p>
<p>通过IDEA快速创建的SpringBoot项目的pom.xml中已经导入了我们选择的web的起步依赖的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gsynf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot_02quick2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot_02quick2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用快速入门的方式创建Controller进行访问，此处不再赘述。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>解析Java框架中entity层，mapper层，service层，controller各层作用</title>
    <url>/2019/11/05/2019-11-05-%E8%A7%A3%E6%9E%90Java%E6%A1%86%E6%9E%B6%E4%B8%ADentity%E5%B1%82%EF%BC%8Cmapper%E5%B1%82%EF%BC%8Cservice%E5%B1%82%EF%BC%8Ccontroller%E5%90%84%E5%B1%82%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>转：<a href="https://blog.csdn.net/u011095110/article/details/86088976" target="_blank" rel="noopener">CSDN</a>，个人感觉讲的比较清晰。</p>
</blockquote>
<h1 id="一、entity层"><a href="#一、entity层" class="headerlink" title="一、entity层"></a>一、entity层</h1><p>别名： model层 ，domain层<br>用途： 实体层，用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。<br>例子：user表的实体User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户昵称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String nick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头像地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"head_image_url"</span>)</span><br><span class="line">    <span class="keyword">private</span> String headImageUrl;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> id - 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置用户id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户昵称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> nick - 用户昵称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置用户昵称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nick 用户昵称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNick</span><span class="params">(String nick)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nick = nick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取手机号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mobile - 手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置手机号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mobile 手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMobile</span><span class="params">(String mobile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取头像地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> head_image_url - 头像地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHeadImageUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headImageUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置头像地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headImageUrl 头像地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeadImageUrl</span><span class="params">(String headImageUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headImageUrl = headImageUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、mapper层"><a href="#二、mapper层" class="headerlink" title="二、mapper层"></a>二、mapper层</h1><p>别名： dao层<br>用途： 现在用mybatis逆向工程生成的mapper层，其实就是dao层。对数据库进行数据持久化操作，(数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中)，他的方法语句是直接针对数据库操作的，主要实现一些增删改查操作，在mybatis中方法主要与与xxx.xml内相互一一映射。<br>示例：userMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">userMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(user record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(user record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">user <span class="title">selectByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(user record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(user record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、service层"><a href="#三、service层" class="headerlink" title="三、service层"></a>三、service层</h1><p>用途：业务service层， 存放业务逻辑处理，给controller层的类提供接口进行调用。一般就是自己写的方法封装起来，就是声明一下，具体实现在serviceImpl中，在接口的实现方法中需要导入mapper层 。<br>示例：UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">Service</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、controller层"><a href="#四、controller层" class="headerlink" title="四、controller层"></a>四、controller层</h1><p>别名：web 层<br>用途： 控制层，负责具体模块的业务流程控制，需要调用service逻辑设计层的接口来控制业务流程。因为service中的方法是我们使用到的，controller通过接收前端H5或者App传过来的参数进行业务操作，再将处理结果返回到前端。<br>示例：UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userService.save(user);</span><br><span class="line">        <span class="keyword">return</span> ResultGenerator.genSuccessResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">delete</span><span class="params">(@RequestParam Integer id)</span> </span>&#123;</span><br><span class="line">        userService.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> ResultGenerator.genSuccessResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userService.update(user);</span><br><span class="line">        <span class="keyword">return</span> ResultGenerator.genSuccessResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/detail"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">detail</span><span class="params">(@RequestParam Integer id)</span> </span>&#123;</span><br><span class="line">        User user = userService.findById(id);</span><br><span class="line">        <span class="keyword">return</span> ResultGenerator.genSuccessResult(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">list</span><span class="params">(@RequestParam(defaultValue = <span class="string">"0"</span>)</span> Integer page, @<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"0"</span>)</span> Integer size) </span>&#123;</span><br><span class="line">        PageHelper.startPage(page, size);</span><br><span class="line">        List&lt;User&gt; list = userService.findAll();</span><br><span class="line">        PageInfo pageInfo = <span class="keyword">new</span> PageInfo(list);</span><br><span class="line">        <span class="keyword">return</span> ResultGenerator.genSuccessResult(pageInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习10-Spring5新特性</title>
    <url>/2019/11/04/2019-11-04-Spring%E5%AD%A6%E4%B9%A010-Spring5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="与JDK相关的升级"><a href="#与JDK相关的升级" class="headerlink" title="与JDK相关的升级"></a>与JDK相关的升级</h2><h3 id="JDK版本要求："><a href="#JDK版本要求：" class="headerlink" title="JDK版本要求："></a>JDK版本要求：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring5.0 在 2017 年 9 月发布了它的 GA（通用）版本。该版本是基于 jdk8 编写的，所以 jdk8 以下版本将无法使用。同时，可以兼容 jdk9 版本。tomcat 版本要求 8.5 及以上。</span><br><span class="line">注：	</span><br><span class="line">	我们使用 jdk8 构建工程，可以降版编译。但是不能使用 jdk8 以下版本构建工程。	</span><br><span class="line">	由于 jdk 和 tomcat 版本的更新，我们的 IDE 也需要同时更新。</span><br></pre></td></tr></table></figure>

<h3 id="利用JDK8版本更新的内容"><a href="#利用JDK8版本更新的内容" class="headerlink" title="利用JDK8版本更新的内容"></a>利用JDK8版本更新的内容</h3><p>第一：基于 JDK8 的反射增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//循环次数定义：10亿次</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> loopCnt = <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//输出jdk的版本</span></span><br><span class="line">		System.out.println(<span class="string">"java.version="</span> + System.getProperty(<span class="string">"java.version"</span>));</span><br><span class="line">		t1();</span><br><span class="line">		t2();</span><br><span class="line">		t3();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次重新生成对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopCnt; i++) &#123;</span><br><span class="line">			Person p = <span class="keyword">new</span> Person();</span><br><span class="line">			p.setAge(<span class="number">31</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"循环10亿次创建对象的时间："</span> + (e - s));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同一个对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopCnt; i++) &#123;</span><br><span class="line">			p.setAge(<span class="number">32</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"循环10亿次给同一对象赋值的时间： "</span> + (e - s));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用反射创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">		Class&lt;Person&gt; c = Person.class;</span><br><span class="line">		Person p = c.newInstance();</span><br><span class="line">		Method m = c.getMethod(<span class="string">"setAge"</span>, Integer.class);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopCnt; i++) &#123;</span><br><span class="line">			m.invoke(p, <span class="number">33</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"循环10亿次反射创建对象的时间："</span> + (e - s));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> age;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk1.8 版本（就是 JDK8）运行时间如下：</p>
<p>当切换到 jdk1.7 版本之后，运行时间如下：</p>
<p>有此我们可以看出，在反射创建对象上，jdk8 确实做了加强。</p>
<p>第二：@NonNull 注解和@Nullable 注解的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用 @Nullable 和 @NotNull 注解来显示表明可为空的参数和以及返回值。这样就够在编译的时候处理空值而不是在运行时抛出 NullPointerExceptions。</span><br></pre></td></tr></table></figure>

<p>第三：日志记录方面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Spring Framework 5.0 带来了 Commons Logging 桥接模块的封装, 它被叫做 spring-jcl 而不是标准的 Commons Logging。当然，无需任何额外的桥接，新版本也会对 Log4j 2.x, SLF4J, JUL( java.util.logging) 进行自动检测。</span><br></pre></td></tr></table></figure>

<h2 id="核心容器的更新"><a href="#核心容器的更新" class="headerlink" title="核心容器的更新"></a>核心容器的更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Spring Framework 5.0 现在支持候选组件索引作为类路径扫描的替代方案。该功能已经在类路径扫描器中添加，以简化添加候选组件标识的步骤。应用程序构建任务可以定义当前项目自己的 META-INF/spring.components 文件。在编译时，源模型是自包含的，JPA 实体和 Spring 组件是已被标记的。从索引读取实体而不是扫描类路径对于小于 200 个类的小型项目是没有明显差异。但对大型项目影响较大。加载组件索引开销更低。因此，随着类数的增加，索引读取的启动时间将保持不变。加载组件索引的耗费是廉价的。因此当类的数量不断增长，加上构建索引的启动时间仍然可以维持一个常数,不过对于组件扫描而言，启动时间则会有明显的增长。这个对于我们处于大型 Spring 项目的开发者所意味着的，是应用程序的启动时间将被大大缩减。虽然 20或者 30 秒钟看似没什么，但如果每天要这样登上好几百次，加起来就够你受的了。使用了组件索引的话，就能帮助你每天过的更加高效。你可以在Spring的Jira上了解更多关于组件索引的相关信息。</span><br></pre></td></tr></table></figure>

<h2 id="JetBrains-Kotlin语言支持"><a href="#JetBrains-Kotlin语言支持" class="headerlink" title="JetBrains Kotlin语言支持"></a>JetBrains Kotlin语言支持</h2><p>Kolin概述：是一种支持函数式编程编程风格的面向对象语言。Kotlin 运行在 JVM 之上，但运行环境并不限于 JVM。</p>
<p>Kolin 的示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	(<span class="string">"/movie"</span> and accept(TEXT_HTML)).nest &#123;</span><br><span class="line">		GET(<span class="string">"/"</span>, movieHandler::findAllView)</span><br><span class="line">		GET(<span class="string">"/&#123;card&#125;"</span>, movieHandler::findOneView)</span><br><span class="line">	&#125;</span><br><span class="line">	(<span class="string">"/api/movie"</span> and accept(APPLICATION_JSON)).nest &#123;</span><br><span class="line">		GET(<span class="string">"/"</span>, movieApiHandler::findAll)</span><br><span class="line">		GET(<span class="string">"/&#123;id&#125;"</span>, movieApiHandler::findOne)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kolin 注册 bean 对象到 spring 容器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> context = GenericApplicationContext &#123;</span><br><span class="line">	registerBean()</span><br><span class="line">	registerBean &#123; Cinema(it.getBean()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应式编程风格"><a href="#响应式编程风格" class="headerlink" title="响应式编程风格"></a>响应式编程风格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此次 Spring 发行版本的一个激动人心的特性就是新的响应式堆栈 WEB 框架。这个堆栈完全的响应式且非阻塞，适合于事件循环风格的处理，可以进行少量线程的扩展。Reactive Streams 是来自于 Netflix, Pivotal, Typesafe, Red Hat, Oracle, Twitter 以及Spray.io 的工程师特地开发的一个 API。它为响应式编程实现的实现提供一个公共的 API，好实现Hibernate 的 JPA。这里 JPA 就是这个 API, 而 Hibernate 就是实现。Reactive Streams API 是 Java 9 的官方版本的一部分。在 Java 8 中, 你会需要专门引入依赖来使用 Reactive Streams API。Spring Framework 5.0 对于流式处理的支持依赖于 Project Reactor 来构建, 其专门实现了Reactive Streams API。Spring Framework 5.0 拥有一个新的 spring-webflux 模块，支持响应式 HTTP 和 WebSocket 客户端。Spring Framework 5.0 还提供了对于运行于服务器之上，包含了 REST, HTML, 以及 WebSocket 风格交互的响应式网页应用程序的支持。</span><br><span class="line">在 spring-webflux 中包含了两种独立的服务端编程模型：	</span><br><span class="line">	基于注解：使用到了@Controller 以及 Spring MVC 的其它一些注解；	</span><br><span class="line">	使用 Java 8 lambda 表达式的函数式风格的路由和处理。有 了 Spring Webflux, 你 现 在 可 以创建出 WebClient, 它是响应式且非阻塞的，可以 作为RestTemplate 的一个替代方案。</span><br></pre></td></tr></table></figure>

<p>这里有一个使用 Spring 5.0 的 REST 端点的 WebClient 实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebClient webClient = WebClient.create();</span><br><span class="line">Mono person = webClient.get()</span><br><span class="line">				.uri(&quot;http://localhost:8080/movie/42&quot;)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .exchange()</span><br><span class="line">                .then(response -&gt; response.bodyToMono(Movie.class));</span><br></pre></td></tr></table></figure>

<h2 id="Junit5的支持"><a href="#Junit5的支持" class="headerlink" title="Junit5的支持"></a>Junit5的支持</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完全支持 JUnit 5 Jupiter，所以可以使用 JUnit 5 来编写测试以及扩展。此外还提供了一个编程以及扩展模型，Jupiter 子项目提供了一个测试引擎来在 Spring 上运行基于 Jupiter 的测试。</span><br><span class="line">另外，Spring Framework 5 还提供了在 Spring TestContext Framework 中进行并行测试的扩展。</span><br><span class="line">针对响应式编程模型， spring-test 现在还引入了支持 Spring WebFlux 的 WebTestClient 集成测试的支持，类似于 MockMvc，并不需要一个运行着的服务端。使用一个模拟的请求或者响应， WebTestClient就可以直接绑定到 WebFlux 服务端设施。</span><br><span class="line">你可以在这里找到这个激动人心的 TestContext 框架所带来的增强功能的完整列表。</span><br><span class="line">当然， Spring Framework 5.0 仍然支持我们的老朋友 JUnit! 在我写这篇文章的时候， JUnit 5 还只是发展到了 GA 版本。对于 JUnit4， Spring Framework 在未来还是要支持一段时间的。</span><br></pre></td></tr></table></figure>

<h2 id="依赖类库的更新"><a href="#依赖类库的更新" class="headerlink" title="依赖类库的更新"></a>依赖类库的更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">终止支持的类库</span><br><span class="line">    Portlet.</span><br><span class="line">    Velocity.</span><br><span class="line">    JasperReports.</span><br><span class="line">    XMLBeans.</span><br><span class="line">    JDO.</span><br><span class="line">    Guava.</span><br><span class="line">支持的类库</span><br><span class="line">    Jackson 2.6+</span><br><span class="line">    EhCache 2.10+ / 3.0 GA</span><br><span class="line">    Hibernate 5.0+</span><br><span class="line">    JDBC 4.0+</span><br><span class="line">    XmlUnit 2.x+</span><br><span class="line">    OkHttp 3.x+</span><br><span class="line">    Netty 4.1+</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>博客翻页显示修复</title>
    <url>/2019/11/04/2019-11-04-%E5%8D%9A%E5%AE%A2%E7%BF%BB%E9%A1%B5%E6%98%BE%E7%A4%BA%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="关于问题"><a href="#关于问题" class="headerlink" title="关于问题"></a>关于问题</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"hexo generate"</span>,</span><br><span class="line">    <span class="attr">"clean"</span>: <span class="string">"hexo clean"</span>,</span><br><span class="line">    <span class="attr">"deploy"</span>: <span class="string">"hexo deploy"</span>,</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"hexo server"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"4.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^4.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-deployer-git"</span>: <span class="string">"^2.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-searchdb"</span>: <span class="string">"^1.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-helper-live2d"</span>: <span class="string">"^3.1.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^2.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^1.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-wordcount"</span>: <span class="string">"^6.0.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是目前使用的hexo的package.json，可以看到使用的是4.0版本，在翻页存在bug。</p>
<p><img src="https://i.loli.net/2019/11/04/4PBXDtr3wZi79Uf.png" alt=""></p>
<p>类似这样，原因在于hexo的pagination函数存在问题。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-theme-next&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;5.1.2&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Elegant theme for Hexo&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;directories&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;gulp&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https://github.com/iissnan/hexo-theme-next.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;NexT&quot;,</span><br><span class="line">    &quot;Hexo&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;iissnan &lt;iissnan@gmail.com&gt;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/iissnan/hexo-theme-next/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://theme-next.iissnan.com&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;coffee-script&quot;: &quot;^1.10.0&quot;,</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.0&quot;,</span><br><span class="line">    &quot;gulp-jshint&quot;: &quot;^1.12.0&quot;,</span><br><span class="line">    &quot;gulp-shell&quot;: &quot;^0.6.1&quot;,</span><br><span class="line">    &quot;js-yaml&quot;: &quot;^3.8.1&quot;,</span><br><span class="line">    &quot;jshint-stylish&quot;: &quot;^2.1.0&quot;,</span><br><span class="line">    &quot;stylint&quot;: &quot;^1.5.9&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;live2d-widget-model-wanko&quot;: &quot;^1.0.5&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是目前使用的Next主题的package.json，可以看到使用的是5.1的版本，后续版本在主题中解决了hexo中的pagination问题，但是Next主题的升级目前又要配置一番且新版本还会存在另外Bug，所以找到了简单方法：</p>
<p>将\next\layout_partials\pagination.swig文件进行替换，替换成最新版Next中的该文件即可解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">  &lt;nav class=&quot;pagination&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &apos;&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;&apos;,</span><br><span class="line">        next_text: &apos;&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;&apos;,</span><br><span class="line">        mid_size: 1</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;%- if page.prev or page.next %&#125;</span><br><span class="line">  &lt;nav class=&quot;pagination&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &apos;&lt;i class=&quot;fa fa-angle-left&quot; aria-label=&quot;&apos;+__(&apos;accessibility.prev_page&apos;)+&apos;&quot;&gt;&lt;/i&gt;&apos;,</span><br><span class="line">        next_text: &apos;&lt;i class=&quot;fa fa-angle-right&quot; aria-label=&quot;&apos;+__(&apos;accessibility.next_page&apos;)+&apos;&quot;&gt;&lt;/i&gt;&apos;,</span><br><span class="line">        mid_size : 1,</span><br><span class="line">        escape   : false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/04/ZKq1pdTYDXR9rOg.png" alt=""></p>
<p>在此编译，显示正常。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习9-JdbcTemplate及事务控制</title>
    <url>/2019/11/03/2019-11-03-Spring%E5%AD%A6%E4%B9%A09-JdbcTemplate%E5%8F%8A%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="什么是JdbcTemplate"><a href="#什么是JdbcTemplate" class="headerlink" title="什么是JdbcTemplate"></a>什么是JdbcTemplate</h1><p>首先这里看一张图</p>
<p><img src="https://i.loli.net/2019/11/03/X45YWbMKx937ARV.jpg" alt="持久层总图"></p>
<h2 id="JdbcTemplate概述"><a href="#JdbcTemplate概述" class="headerlink" title="JdbcTemplate概述"></a>JdbcTemplate概述</h2><p>它是spring框架中提供的一个对象，是对原始Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。 </p>
<ul>
<li><p>操作关系型数据的： JdbcTemplate HibernateTemplate </p>
</li>
<li><p>操作nosql数据库的： RedisTemplate </p>
</li>
<li><p>操作消息队列的： JmsTemplate </p>
</li>
</ul>
<p>我们今天的主角在spring-jdbc-5.2.0.RELEASE.jar中，我们在导包的时候，除了要导入这个jar包外，还需要导入一个spring-tx-5.2.0.RELEASE.jar（它是和事务相关的）。</p>
<h2 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h2><h3 id="最基本方法"><a href="#最基本方法" class="headerlink" title="最基本方法"></a>最基本方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.jdbctemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: JdbcTemplateDemo1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: JdbcTemplate最基本用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备数据源：spring的内置数据源</span></span><br><span class="line">        DriverManagerDataSource ds = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        ds.setUrl(<span class="string">"jdbc:mysql://服务器IP:3306/spring5?useSSl:false"</span>);</span><br><span class="line">        ds.setUsername(<span class="string">"账户"</span>);</span><br><span class="line">        ds.setPassword(<span class="string">"密码"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建JdbcTemplate对象</span></span><br><span class="line">        JdbcTemplate jt = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">        <span class="comment">// 给jt设置数据源</span></span><br><span class="line">        jt.setDataSource(ds);</span><br><span class="line">        <span class="comment">// 2.执行操作</span></span><br><span class="line">        jt.execute(<span class="string">"insert into account (name,money)values('ddd',1000)"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用IoC配置"><a href="#使用IoC配置" class="headerlink" title="使用IoC配置"></a>使用IoC配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置JdbcTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://服务器IP:3306/spring5?useSSL=false"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"账户"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"密码"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.jdbctemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: JdbcTemplateDemo2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: JdbcTemplate的IoC配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取容器</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">// 2. 获取对象</span></span><br><span class="line">        JdbcTemplate jt = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line">        <span class="comment">// 3. 执行操作</span></span><br><span class="line">        jt.execute(<span class="string">"insert into account (name,money)values('eee',1000)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现CRUD操作"><a href="#实现CRUD操作" class="headerlink" title="实现CRUD操作"></a>实现CRUD操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.jdbctemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: JdbcTemplateDemo3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: JdbcTemplateCRUD操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取容器</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">// 2. 获取对象</span></span><br><span class="line">        JdbcTemplate jt = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line">        <span class="comment">// 3. 执行操作</span></span><br><span class="line">        <span class="comment">//保存</span></span><br><span class="line"><span class="comment">//        jt.update("insert into account(name,money)values(?,?)","fff",3333f );</span></span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line"><span class="comment">//        jt.update("update account set name=?,money=? where id=?","test",4567,5);</span></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line"><span class="comment">//        jt.update("delete from account where id = ?",7);</span></span><br><span class="line">        <span class="comment">//查询所有</span></span><br><span class="line"><span class="comment">////        List&lt;Account&gt; accounts = jt.query("select * from account where money &gt; ?",new AccountRowMapper(),1000f);</span></span><br><span class="line"><span class="comment">//        List&lt;Account&gt; accounts = jt.query("select * from account where money &gt; ?",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1000f);</span></span><br><span class="line"><span class="comment">//        for (Account account : accounts)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(account);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//查询一个</span></span><br><span class="line"><span class="comment">//        List&lt;Account&gt; accounts = jt.query("select * from account where id = ?",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),5);</span></span><br><span class="line"><span class="comment">//        System.out.println(accounts.isEmpty()?"没有内容":accounts.get(0));</span></span><br><span class="line">        <span class="comment">//查询返回一行一列（使用聚合函数，但不加group by子句）</span></span><br><span class="line">        Long count = jt.queryForObject(<span class="string">"select count(*) from account where money &gt; ?"</span>,Long.class,<span class="number">1000</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Account的封装策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把结果集中的数据封装到Account中，然后由spring把每个Account加到集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setId(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">        account.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">        account.setMoney(resultSet.getFloat(<span class="string">"money"</span>));</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在Dao中的使用"><a href="#在Dao中的使用" class="headerlink" title="在Dao中的使用"></a>在Dao中的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: AccountDaoImpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 持久层接口实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJdbcTemplate</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="string">"select * from account where id = ?"</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty()?<span class="keyword">null</span>:accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="string">"select * from account where name = ?"</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);</span><br><span class="line">        <span class="keyword">if</span> (accounts.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"结果集不唯一"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update account set name=?,money=? where id = ?"</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.jdbctemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: JdbcTemplateDemo4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: JdbcTemplate的IoC配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取容器</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">// 2. 获取对象</span></span><br><span class="line">        IAccountDao accountDao = ac.getBean(<span class="string">"accountDao"</span>,IAccountDao.class);</span><br><span class="line"></span><br><span class="line">        Account account = accountDao.findAccountById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line"></span><br><span class="line">        account.setMoney(<span class="number">1000f</span>);</span><br><span class="line">        accountDao.updateAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring中的事务控制"><a href="#Spring中的事务控制" class="headerlink" title="Spring中的事务控制"></a>Spring中的事务控制</h1><h2 id="Spring事务控制要明确的"><a href="#Spring事务控制要明确的" class="headerlink" title="Spring事务控制要明确的"></a>Spring事务控制要明确的</h2><ul>
<li><p>第一：JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了分层设计业务层的事务处理解决方案。 </p>
</li>
<li><p>第二：spring框架为我们提供了一组事务控制的接口。具体在后面介绍。这组接口是在spring-tx-5.0.2.RELEASE.jar中。 </p>
</li>
<li><p>第三：spring的事务控制都是基于AOP的，它既可以使用编程的方式实现，也可以使用配置的方式实现。我们学习的重点是使用配置的方式实现。</p>
</li>
</ul>
<h2 id="基于XML"><a href="#基于XML" class="headerlink" title="基于XML"></a>基于XML</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置业务层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置账户的持久层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置dataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://服务器IP:3306/spring5?useSSL=false"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"账户"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"密码"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring中基于XML的声明式事务管理配置步骤</span></span><br><span class="line"><span class="comment">            1.配置事务管理器</span></span><br><span class="line"><span class="comment">            2.配置事务的通知: 此时需要导入tx的名称和约束，同时也需要AOP的</span></span><br><span class="line"><span class="comment">            3.配置AOP中的通用切入点表达式</span></span><br><span class="line"><span class="comment">            4.建立事务通知和切入点表达式的对应关系</span></span><br><span class="line"><span class="comment">            5.配置事务的属性：在事务的通知tx:advice标签内部</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务属性</span></span><br><span class="line"><span class="comment">                isolation:指定事务的隔离级别，默认值是DEFAULT，表示使用数据库的默认隔离级别；</span></span><br><span class="line"><span class="comment">                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS;</span></span><br><span class="line"><span class="comment">                read-only：用于指定事务是否只读。只有查询方法才能设为true，默认为false;</span></span><br><span class="line"><span class="comment">                timeout：用于指定事务的超时时间，默认值是-1，表示永不超时，如指定数值，单位为秒；</span></span><br><span class="line"><span class="comment">                no-rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚；</span></span><br><span class="line"><span class="comment">                rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值。表示任何异常都回滚；</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"transfer"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.gsynf.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立切入点表达式和事务通知的对应关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置spring创建容器时要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gsynf"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置JdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置dataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://服务器IP:3306/spring5?useSSL=false"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"账户"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"密码"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring中基于注解的声明式事务管理配置步骤</span></span><br><span class="line"><span class="comment">            1.配置事务管理器</span></span><br><span class="line"><span class="comment">            2.开启spring对注解事务的支持</span></span><br><span class="line"><span class="comment">            3.在需要事务支持的地方使用@Transactional注解</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启spring对注解事务的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.gsynf.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立切入点表达式和事务通知的对应关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: AccountService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.SUPPORTS,readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED,readOnly = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"transfer…………"</span>);</span><br><span class="line">        <span class="comment">// 2.1根据名称查询转入账户</span></span><br><span class="line">        Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">        <span class="comment">// 2.2根据名称查询转入账户</span></span><br><span class="line">        Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">        <span class="comment">// 2.3转出账户减钱</span></span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        <span class="comment">// 2.4转入账户加钱</span></span><br><span class="line">        target.setMoney(target.getMoney() + money);</span><br><span class="line">        <span class="comment">// 2.5更新转出账户</span></span><br><span class="line">        accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//故意加错，模拟转账异常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.6更新转入账户</span></span><br><span class="line">        accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于纯注解"><a href="#基于纯注解" class="headerlink" title="基于纯注解"></a>基于纯注解</h2><p>和基于注解相比，主要变化：</p>
<p>新建config包，下有SpringConfiguration/JdbcConfig/TransactionConfig，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: SpringConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: spring的配置类，相当于bean.xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.gsynf"</span>)</span><br><span class="line"><span class="meta">@Import</span>(&#123;JdbcConfig.class,TransactionConfig.class&#125;)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"jdbcConfig.properties"</span>)</span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: JdbcConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 和连接数据库相关的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建JdbcTemplate对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个数据源对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DriverManagerDataSource ds = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(username);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: TransactionConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 事务控制配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建事务管理器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">createCransactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resource下新建JdbcConfig.properties，</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://服务器IP:3306/spring5?useSSL=false</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">账户</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">密码</span></span><br></pre></td></tr></table></figure>

<p>Test中修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(classes = SpringConfiguration.class)</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习8-AOP</title>
    <url>/2019/11/02/2019-11-02-Spring%E5%AD%A6%E4%B9%A08-AOP/</url>
    <content><![CDATA[<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><p><strong>面向切面的程序设计</strong>（Aspect-oriented programming ），简单来讲就是把程序重复的代码抽取出来，在需要执行的时候，使用<strong>动态代理</strong>的技术，在不修改源码的基础上，对我们的已有方法进行增强。</p>
<h2 id="AOP作用及优势"><a href="#AOP作用及优势" class="headerlink" title="AOP作用及优势"></a>AOP作用及优势</h2><p>作用： </p>
<ul>
<li>在程序运行期间，不修改源码对已有方法进行增强。 </li>
</ul>
<p>优势： </p>
<ul>
<li>减少重复代码 </li>
<li>提高开发效率</li>
<li>维护方便</li>
</ul>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>回顾上一篇即可</p>
<h1 id="Spring中的AOP"><a href="#Spring中的AOP" class="headerlink" title="Spring中的AOP"></a>Spring中的AOP</h1><h2 id="案例总结回顾"><a href="#案例总结回顾" class="headerlink" title="案例总结回顾"></a>案例总结回顾</h2><p>首先来整理一下整个案例的思路，最初我们在账户的业务层实现类中实现了对账户的增删改查，每个功能其实都是执行一条SQL语句，问题就是：这里事务被自动控制了。换言之，我们使用了connection对象的setAutoCommit(true) 此方式控制事务，如果我们每次都执行一条sql语句，没有问题，但是如果业务方法一次要执行多条sql语句，这种方式就无法实现功能了。例如在业务层实现类增加一个转账的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"transfer…………"</span>);</span><br><span class="line">    <span class="comment">// 2.1根据名称查询转入账户</span></span><br><span class="line">    Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">    <span class="comment">// 2.2根据名称查询转入账户</span></span><br><span class="line">    Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">    <span class="comment">// 2.3转出账户减钱</span></span><br><span class="line">    source.setMoney(source.getMoney() - money);</span><br><span class="line">    <span class="comment">// 2.4转入账户加钱</span></span><br><span class="line">    target.setMoney(target.getMoney() + money);</span><br><span class="line">    <span class="comment">// 2.5更新转出账户</span></span><br><span class="line">    accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//故意加错，模拟转账异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.6更新转入账户</span></span><br><span class="line">    accountDao.updateAccount(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就会出问题，转出账户钱少了，但是转入账户更新被打断并没有执行，所以转入账户钱没有增加，原因就是每执行一条SQL语句都去连接池获取一次，每次执行持久层方法都是独立事务，导致无法实现事务控制（不符合事务的一致性）。</p>
<p>为了解决上述问题，就加入了事务控制。让业务层来控制事务的提交和回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.utils.TransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事务控制应该都在业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl_OLD</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="keyword">private</span> TransactionManager tsManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTsManager</span><span class="params">(TransactionManager tsManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tsManager = tsManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.开启事务</span></span><br><span class="line">            tsManager.beginTransaction();</span><br><span class="line">            <span class="comment">//2.执行操作</span></span><br><span class="line">            List&lt;Account&gt; accounts = accountDao.findAllAccount();</span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            tsManager.commit();</span><br><span class="line">            <span class="comment">//4.返回结果</span></span><br><span class="line">            <span class="keyword">return</span> accounts;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//5.回滚操作</span></span><br><span class="line">            tsManager.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放连接</span></span><br><span class="line">            tsManager.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.开启事务</span></span><br><span class="line">            tsManager.beginTransaction();</span><br><span class="line">            <span class="comment">//2.执行操作</span></span><br><span class="line">            Account account = accountDao.findAccountById(accountId);</span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            tsManager.commit();</span><br><span class="line">            <span class="comment">//4.返回结果</span></span><br><span class="line">            <span class="keyword">return</span> account;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//5.回滚操作</span></span><br><span class="line">            tsManager.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放连接</span></span><br><span class="line">            tsManager.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.开启事务</span></span><br><span class="line">            tsManager.beginTransaction();</span><br><span class="line">            <span class="comment">//2.执行操作</span></span><br><span class="line">            accountDao.saveAccount(account);</span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            tsManager.commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//5.回滚操作</span></span><br><span class="line">            tsManager.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放连接</span></span><br><span class="line">            tsManager.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.开启事务</span></span><br><span class="line">            tsManager.beginTransaction();</span><br><span class="line">            <span class="comment">//2.执行操作</span></span><br><span class="line">            accountDao.updateAccount(account);</span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            tsManager.commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//5.回滚操作</span></span><br><span class="line">            tsManager.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放连接</span></span><br><span class="line">            tsManager.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer acccountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.开启事务</span></span><br><span class="line">            tsManager.beginTransaction();</span><br><span class="line">            <span class="comment">//2.执行操作</span></span><br><span class="line">            accountDao.deleteAccount(acccountId);</span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            tsManager.commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//5.回滚操作</span></span><br><span class="line">            tsManager.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放连接</span></span><br><span class="line">            tsManager.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.开启事务</span></span><br><span class="line">            tsManager.beginTransaction();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.执行操作</span></span><br><span class="line">            <span class="comment">// 2.1根据名称查询转入账户</span></span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            <span class="comment">// 2.2根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            <span class="comment">// 2.3转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney() - money);</span><br><span class="line">            <span class="comment">// 2.4转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney() + money);</span><br><span class="line">            <span class="comment">// 2.5更新转出账户</span></span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//故意加错，打断</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.6更新转入账户</span></span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            tsManager.commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//5.回滚操作</span></span><br><span class="line">            tsManager.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放连接</span></span><br><span class="line">            tsManager.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: connectionUtils</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 连接的工具类，用于实现从数据源中获取一个连接，并且实现和线程的绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程上的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.先从ThreadLocal上获取</span></span><br><span class="line">            Connection conn = tl.get();</span><br><span class="line">            <span class="comment">// 2.判断当前线程上是否有连接</span></span><br><span class="line">                <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 3.从数据源中获取一个连接，并且存入ThreadLocal中</span></span><br><span class="line">                    conn = dataSource.getConnection();</span><br><span class="line">                    tl.set(conn);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 4.返回当前线程上的连接</span></span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将连接和线程解绑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.utils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: TransactionManager</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 和事务管理相关的工具类，包含开启事务、提交事务、回滚事务、释放连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().rollback();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().close();<span class="comment">//还回连接池中</span></span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对业务层改造，已经可以实现事务控制了，但是由于我们添加了事务控制，也产生了一个新的问题： 业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦合了。 试想一下，如果我们此时提交，回滚，释放资源中任何一个方法名变更，都需要修改业务层的代码，况且这还只是一个业务层实现类，而实际的项目中这种业务层实现类可能有十几个甚至几十个。为了解决这个问题，引入了动态代理，详见上一篇关于动态代理的文章对具体案例的分析。当我们改造完成之后，业务层用于控制事务的重复代码就都可以删掉了。</p>
<h2 id="细节与说明"><a href="#细节与说明" class="headerlink" title="细节与说明"></a>细节与说明</h2><p>在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p>
<p>这里就是通过配置的方式，实现上述案例的功能。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li><strong>Joinpoint(连接点)</strong>: <ul>
<li>所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。 </li>
<li>具体来讲，就是业务层接口中的方法，他们是业务方法和增强方法（事务控制）的连接点，可以使业务方法增加事务控制，形成完整的业务逻辑。</li>
</ul>
</li>
<li><strong>Pointcut(切入点):</strong> <ul>
<li>所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。</li>
<li>具体来讲，业务层接口中每一个方法都是连接点，但是只有每一个被增强的方法才是切入点，不是所有方法都需要增强，如果有的方法不增强，它就不是切入点。</li>
<li>连接点是动态代理中的所有方法，切入点是其中被增强的方法。</li>
</ul>
</li>
<li><strong>Advice(通知/增强):</strong> <ul>
<li>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 </li>
<li>具体来讲，就是invoke方法拦截之后要做的事，这里就是TransactionManger，invoke拦截之后要进行的就是一系列的事务操作。</li>
<li>通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 </li>
<li>具体来讲，找到明确调用业务层的method.invoke()方法，之前的就是前置通知，之后的就是后置通知，catch中的就是异常通知，finally中的就是最终通知。整个invoke方法在执行就是环绕通知。</li>
</ul>
</li>
<li><strong>Introduction(引介):</strong> <ul>
<li>引介是一种特殊的通知，在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。 </li>
</ul>
</li>
<li><strong>Target(目标对象):</strong><ul>
<li>代理的目标对象，也就是被代理对象。 </li>
<li>具体来讲，就是<code>accountService</code>。</li>
</ul>
</li>
<li><strong>Weaving(织入):</strong> <ul>
<li>是指把增强应用到目标对象来创建新的代理对象的过程。</li>
<li>具体来讲，本来的对象<code>accountService</code>没有事务支持，为了事务支持加入了动态代理，返回了一个代理对象<code>(IAccountService) Proxy.newProxyInstance</code>，在其中加入了事务控制，整个这个过程就是Weaving。</li>
<li>spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。 </li>
</ul>
</li>
<li><strong>Proxy（代理)：</strong><ul>
<li>一个类被AOP织入增强后，就产生一个结果代理类。</li>
<li>具体来讲，就是创建出来的代理对象<code>(IAccountService) Proxy.newProxyInstance</code>。 </li>
</ul>
</li>
<li><strong>Aspect(切面):</strong><ul>
<li>是切入点和通知（引介）的结合。</li>
</ul>
</li>
</ul>
<h3 id="要明确的事"><a href="#要明确的事" class="headerlink" title="要明确的事"></a>要明确的事</h3><ul>
<li><p>a、开发阶段（我们做的） </p>
<ul>
<li>编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。 </li>
<li>把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。 </li>
<li>在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。</li>
</ul>
</li>
<li><p>b、运行阶段（Spring框架完成的） </p>
<ul>
<li>Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</li>
</ul>
</li>
</ul>
<h2 id="基于XML的AOP配置"><a href="#基于XML的AOP配置" class="headerlink" title="基于XML的AOP配置"></a>基于XML的AOP配置</h2><p>案例：增加一个打印日志的通知，让其在切入点方法执行之前执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: AccountServiceImpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了更新"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了删除"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Logger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 用于记录日志的工具类，里面提供了公共的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于打印日志，计划让其在切入点方法执行之前执行（切入点方法就是业务层方法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Logger类中的printLog方法开始记录日志了………………"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置spring的IoC，把service对象配置进来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring中基于XML的AOP配置步骤</span></span><br><span class="line"><span class="comment">        1.把通知bean也交给spring管理</span></span><br><span class="line"><span class="comment">        2.使用aop:config标签表明开始AOP的配置</span></span><br><span class="line"><span class="comment">        3.使用aop:aspect标签表明配置切面</span></span><br><span class="line"><span class="comment">                id属性：是给切面提供一个唯一标识</span></span><br><span class="line"><span class="comment">                ref属性：是指定通知类bean的Id</span></span><br><span class="line"><span class="comment">        4.在aop:aspect标签内部使用对应的标签来配置通知的类型</span></span><br><span class="line"><span class="comment">                我们现在是实例是让printLog方法在切入点方法执行之前执行，所以是前置通知</span></span><br><span class="line"><span class="comment">                        aop:before：表示前置通知</span></span><br><span class="line"><span class="comment">                        pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强</span></span><br><span class="line"><span class="comment">                切入点表达式写法：</span></span><br><span class="line"><span class="comment">                        关键字：execution（表达式）</span></span><br><span class="line"><span class="comment">                        表达式：</span></span><br><span class="line"><span class="comment">                            访问修饰符 返回值 包名.包名.包名…………类名.方法名（参数列表）</span></span><br><span class="line"><span class="comment">                        标准的表达式写法：</span></span><br><span class="line"><span class="comment">                            public void com.gsynf.service.impl.AccountServiceImpl.saveAccount()</span></span><br><span class="line"><span class="comment">                        改进：</span></span><br><span class="line"><span class="comment">                        访问修饰符可以省略；</span></span><br><span class="line"><span class="comment">                        返回值可以使用通配符，表示任意返回值；</span></span><br><span class="line"><span class="comment">                        包名可以使用通配符，表示任意包，但是有几级包，就需要写几个*. ;</span></span><br><span class="line"><span class="comment">                        包名可以使用..表示当前包及其子包；</span></span><br><span class="line"><span class="comment">                        类名和方法名都可以使用*实现统配；</span></span><br><span class="line"><span class="comment">                        参数列表</span></span><br><span class="line"><span class="comment">                            可以直接写数据类型：</span></span><br><span class="line"><span class="comment">                                基本类型直接写名称 int</span></span><br><span class="line"><span class="comment">                                引用类型写包名.类名 java.lang.String</span></span><br><span class="line"><span class="comment">                            可以使用通配符*表示任意类型，但是必须有参数</span></span><br><span class="line"><span class="comment">                            可以使用..表示有无参数均可，有参数可以是任意类型</span></span><br><span class="line"><span class="comment">                        全通配写法：</span></span><br><span class="line"><span class="comment">                            * *..*.*(..)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        实际开发中切入点表达式的通常写法：</span></span><br><span class="line"><span class="comment">                            切到业务层实现类下的所有方法</span></span><br><span class="line"><span class="comment">                                * com.gsynf.service.impl.*.*(..)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置通知类，也就是Logger类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logger"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.utils.Logger"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:before method="printLog" pointcut="execution(public void com.gsynf.service.impl.AccountServiceImpl.saveAccount())"&gt;&lt;/aop:before&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;aop:before method="printLog" pointcut="execution(* *..*.*(..))"&gt;&lt;/aop:before&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"printLog"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.gsynf.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加一个Test:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.NoSuchBeanDefinitionException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.MessageSourceResolvable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.NoSuchMessageException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ResolvableType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: AOPTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试AOP配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AOPTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取容器</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">// 2.获取对象</span></span><br><span class="line">        IAccountService as = (IAccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        <span class="comment">// 3.执行方法</span></span><br><span class="line">        as.saveAccount();</span><br><span class="line">        as.updateAccount(<span class="number">1</span>);</span><br><span class="line">        as.deleteAccount();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Logger类中的printLog方法开始记录日志了………………</span><br><span class="line">执行了保存</span><br><span class="line">Logger类中的printLog方法开始记录日志了………………</span><br><span class="line">执行了更新1</span><br><span class="line">Logger类中的printLog方法开始记录日志了………………</span><br><span class="line">执行了删除</span><br></pre></td></tr></table></figure>

<h3 id="spring中基于XML的AOP配置步骤"><a href="#spring中基于XML的AOP配置步骤" class="headerlink" title="spring中基于XML的AOP配置步骤"></a>spring中基于XML的AOP配置步骤</h3><p>详见bean.xml中的注释。</p>
<h3 id="不同类型通知的配置"><a href="#不同类型通知的配置" class="headerlink" title="不同类型通知的配置"></a>不同类型通知的配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--前置通知：在切入点方法执行之前执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforePrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--后置通知：在切入点方法执行之后执行，和异常通知只能执行一个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturningPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--异常通知：在切入点方法执行产生异常之后执行，和后置通知只能执行一个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowingPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--最终通知：无论切入点方法是否正常执行它都会在其后执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置切入点表达式</span></span><br><span class="line"><span class="comment">                此标签写在aop:aspect标签内部只能在当前切面使用；写在外部所有切面可用</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.gsynf.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>环绕通知这里单独说一下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在bean.xml中的配置和其他通知一样，在Logger类中加入aroundPrintLog方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundPrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行，会发现当配置了环绕通知之后，aroundPrintLog方法中的语句打印了，而“执行了保存”没有打印，即切入点方法没有执行，而通知方法执行了。原因是什么呢？通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法，即method.invoke()，而此处的代码中没有。那么如何解决呢？Spring框架提供了一个接口：ProceedingJoinPoint.该接口有一个方法proceed()，该方法就相当于明确调用切入点方法。该方法可以作为环绕通知的方法参数，在程序执行时，Spring框架会为我们提供该接口的实现类供我们调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">    Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] args = pjp.getArgs(); <span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………前置"</span>);</span><br><span class="line"></span><br><span class="line">        rtValue = pjp.proceed(args); <span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………后置"</span>);</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………异常"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………最终"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行，会发现结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Logger类中的aroundPrintLog方法开始记录日志了………………前置</span><br><span class="line">执行了保存</span><br><span class="line">Logger类中的aroundPrintLog方法开始记录日志了………………后置</span><br><span class="line">Logger类中的aroundPrintLog方法开始记录日志了………………最终</span><br></pre></td></tr></table></figure>

<p>也就是说，在环绕通知中可以实现前置、后置、异常、最终这几种通知，其实，Spring中环绕通知另一种理解：它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式，换句话说，其他通知除了可以自己配，还可以在环绕通知中配，这就和动态代理中讲到的通知很类似了。</p>
<h2 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h2><h3 id="普通注解"><a href="#普通注解" class="headerlink" title="普通注解"></a>普通注解</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置spring创建容器时要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gsynf"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP,改为注解--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置spring开启注解AOP的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>业务层实现类加注解<code>@Service(&quot;accountService&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">………………Logger.java………………</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//表示当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.gsynf.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知：Logger类中的beforePrintLog方法开始记录日志了………………"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningPrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知：Logger类中的afterReturningPrintLog方法开始记录日志了………………"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingPrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常通知：Logger类中的afterThrowingPrintLog方法开始记录日志了………………"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"最终通知：Logger类中的afterPrintLog方法开始记录日志了………………"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@Around("pt1()")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args = pjp.getArgs(); <span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………前置"</span>);</span><br><span class="line"></span><br><span class="line">            rtValue = pjp.proceed(args); <span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………后置"</span>);</span><br><span class="line">            <span class="keyword">return</span> rtValue;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………异常"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Logger类中的aroundPrintLog方法开始记录日志了………………最终"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行Test，会发现输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前置通知：Logger类中的beforePrintLog方法开始记录日志了………………</span><br><span class="line">执行了保存</span><br><span class="line">最终通知：Logger类中的afterPrintLog方法开始记录日志了………………</span><br><span class="line">后置通知：Logger类中的afterReturningPrintLog方法开始记录日志了………………</span><br></pre></td></tr></table></figure>

<p>这里最终通知和后置通知是反的，这里目前是无法更改的，所以在选用时比较推荐使用环绕方式配置，因为何时调用全由自己控制，所以不会有问题。</p>
<h3 id="纯注解"><a href="#纯注解" class="headerlink" title="纯注解"></a>纯注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages=<span class="string">"com.gsynf"</span>) </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习7-动态代理</title>
    <url>/2019/11/01/2019-11-01-Spring%E5%AD%A6%E4%B9%A07-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>AOP的原理就是Java的动态代理机制，在Java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。 </p>
<p><strong>动态代理的基础 :</strong> 必须有接口.</p>
<p>Java中使用接口来定义统一的行为规范 : <code>接口</code></p>
<p><strong>动态代理作用 :</strong> 拦截和控制 <code>被代理对象</code> 的所有行为. </p>
<h1 id="Proxy-代理类"><a href="#Proxy-代理类" class="headerlink" title="Proxy 代理类"></a>Proxy 代理类</h1><p><strong>Class Proxy</strong> <em>代理类</em> 是在运行时创建的实现指定的接口列表（称为<em>代理接口）的类</em> 。 <em>代理实例</em>是代理类的一个实例。 每个代理实例都有一个关联的<em>调用处理程序</em>对象，它实现接口<code>InvocationHandler</code> 。 通过其代理接口之一的代理实例上的方法调用将被分派到实例调用处理程序的<code>invoke</code>方法</p>
<p><code>static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code> 返回指定接口的代理实例，该代理实例将方法调用分派给指定的调用处理程序。</p>
<h1 id="InvocationHandler-调用处理器接口"><a href="#InvocationHandler-调用处理器接口" class="headerlink" title="InvocationHandler 调用处理器接口"></a>InvocationHandler 调用处理器接口</h1><p><strong>Interface InvocationHandler</strong> 每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的<code>invoke</code>方法。</p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>消费者和生产商之间加入了代理商，代理商会收取代理费。</p>
<h2 id="动态代理的特点"><a href="#动态代理的特点" class="headerlink" title="动态代理的特点"></a>动态代理的特点</h2><p>字节码随用随创建，随用随加载。它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。动态代理在不修改源码的基础上对方法增强。</p>
<h2 id="动态代理常用的两种方式"><a href="#动态代理常用的两种方式" class="headerlink" title="动态代理常用的两种方式"></a>动态代理常用的两种方式</h2><ul>
<li><p>基于接口的动态代理提供者：</p>
<p>JDK 官方的 Proxy 类。</p>
<p>要求：被代理类最少实现一个接口。</p>
</li>
<li><p>基于子类的动态代理</p>
<p>提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。</p>
<p>要求：被代理类不能用 final 修饰的类（最终类）。</p>
</li>
</ul>
<h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><ul>
<li>涉及的类：Proxy</li>
<li>提供者：JDK官方</li>
<li>如何创建代理对象<ul>
<li>使用Proxy类中的newProxyInstance方法</li>
<li>创建代理对象的要求：被代理对象最少实现一个接口，如果没有则不能使用</li>
<li>newProxyInstance方法的参数：<ul>
<li>ClassLoader:类加载器:用于加载代理对象字节码的，和被代理对象使用相同的类加载器。固定写法</li>
<li>Class[]:字节码数组:用于让代理对象和被代理对象有相同的接口。固定写法。</li>
<li>InvocationHandler:代理增强:用于写如何代理。一般写一个接口的实现类，通常都是内部匿名类，但不必须。此接口的实现类都是谁用谁写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IProducer.java</span></span><br><span class="line"><span class="keyword">package</span> com.gsynf.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对生产厂家要求的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer.java</span></span><br><span class="line"><span class="keyword">package</span> com.gsynf.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销售产品，并拿到钱："</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提供售后服务，并拿到钱："</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.gsynf.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 作用：执行被代理对象的任何接口</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy         代理对象的引用</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method    当前执行的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args   当前执行的方法所需的参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>          和被代理对象方法有相同的返回值</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">//提供增强的代码,例如代理商拿20%</span></span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                        Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">                            returnValue = method.invoke(producer, money*<span class="number">0.8f</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyProducer.saleProduct(<span class="number">10000f</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><ul>
<li><p>涉及的类：Enhancer</p>
</li>
<li><p>提供者：第三方cglib库</p>
</li>
<li><p>如何创建代理对象</p>
<ul>
<li>使用Enhancer类中的create方法</li>
<li>创建代理对象的要求：被代理类不能是最终类</li>
<li>create方法的参数：<ul>
<li>Class:字节码： 用于指定被代理对象的字节码。</li>
<li>Callback:代理增强：用于写如何代理。一般写一个接口的实现类，通常都是内部匿名类，但不必须。 此接口的实现类都是谁用谁写。 一般写的都是该接口的子接口实现类：MethodInterceptor</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer.java\</span></span><br><span class="line">同上</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.gsynf.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.proxy.IProducer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line"></span><br><span class="line">        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">             *          以上三个参数和基于接口的动态代理中的invoke相同</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy：当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//提供增强的代码,例如代理商拿20%</span></span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money*<span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cglibProducer.saleProduct(<span class="number">20000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决案例中的问题"><a href="#解决案例中的问题" class="headerlink" title="解决案例中的问题"></a>解决案例中的问题</h3><p>案例会在下一篇中做总结回顾，这里新建factory/BeanFactory.java，将业务层与事务控制完全分离。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.utils.TransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 用于创建Service的代理对象的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IAccountService accountService;</span><br><span class="line">    <span class="keyword">private</span> TransactionManager tsManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAccountService</span><span class="params">(IAccountService accountService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountService = accountService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTsManager</span><span class="params">(TransactionManager tsManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tsManager = tsManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Service代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">getAccountService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),</span><br><span class="line">                accountService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 添加事务的支持</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="comment">//1.开启事务</span></span><br><span class="line">                            tsManager.beginTransaction();</span><br><span class="line">                            <span class="comment">//2.执行操作</span></span><br><span class="line">                            rtValue = method.invoke(accountService,args);</span><br><span class="line">                            <span class="comment">//3.提交事务</span></span><br><span class="line">                            tsManager.commit();</span><br><span class="line">                            <span class="comment">//4.返回结果</span></span><br><span class="line">                            <span class="keyword">return</span> rtValue;</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="comment">//5.回滚操作</span></span><br><span class="line">                            tsManager.rollback();</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">//6.释放连接</span></span><br><span class="line">                            tsManager.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习6-纯注解及测试类</title>
    <url>/2019/10/30/2019-10-30-Spring%E5%AD%A6%E4%B9%A06-%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>基于一个实例，实现客户信息的增删改查。</p>
</blockquote>
<h1 id="dbUtils-中的各种-Handler"><a href="#dbUtils-中的各种-Handler" class="headerlink" title="dbUtils 中的各种 Handler"></a>dbUtils 中的各种 Handler</h1><ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个对象数组，再存放到List中。</li>
<li>BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li>BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler：将结果集中的每一行数据都封装到一个Map里，然后再根据指定的key把每个Map再存放到一个Map里。</li>
<li>MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li>MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List。</li>
<li>ScalarHandler：将结果集中某一条记录的其中某一列的数据存成Object。</li>
</ul>
<h1 id="业务层测试"><a href="#业务层测试" class="headerlink" title="业务层测试"></a>业务层测试</h1><p>项目搭建完毕，还没有进行spring的配置，为了查看业务层是否有问题，新建测试类，在业务层接口右键，新建JUnit Test Case，放到test目录下，next，全选，finish。此时结构目录为：</p>
<p><img src="https://i.loli.net/2019/10/30/beuDRCaE45YHi2Q.png" alt=""></p>
<h1 id="纯注解"><a href="#纯注解" class="headerlink" title="纯注解"></a>纯注解</h1><h2 id="目前问题"><a href="#目前问题" class="headerlink" title="目前问题"></a>目前问题</h2><p>使用上一节使用的注解，我们可以实现部分注解，即替换bean.xml中的配置业务层和持久层的内容，基于注解的 IoC 配置已经完成，但是大家都发现了一个问题：我们依然离不开 spring 的 xml 配置文件，那么能不能不写这个 bean.xml，所有配置都用注解来实现呢？</p>
<p>当然，也需要注意一下，我们选择哪种配置的原则是简化开发和配置方便，而非追求某种技术。</p>
<p>我们发现，之所以我们现在离不开 xml 配置文件，是因为我们有一句很关键的配置： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告知spring框架在，读取配置文件，创建容器时，扫描注解，依据注解创建对象，并存入容器中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gsynf"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，数据源和 JdbcTemplate 的配置也需要靠注解来实现。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置QueryRunner --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置C3p0连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://服务器IP:3306/spring5?useSSL=false"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"账户名"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"密码"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  	</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="新注解"><a href="#新注解" class="headerlink" title="新注解"></a>新注解</h2><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p><strong>作用：</strong><br>用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的：<br><code>&lt;context:component-scan base-package=&quot;com.gsynf&quot;&gt;&lt;/context:component-scan&gt;</code>是一样的。<br><strong>属性：</strong><br>basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p><strong>作用：</strong><br>用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration 注解的类.class)。<br><strong>属性：</strong><br>value:用于指定配置类的字节码</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p><strong>作用：</strong><br>该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。<br><strong>属性：</strong><br>name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。</p>
<p><strong>注意：</strong></p>
<p>我们已经把数据源和连接池从配置文件中移除了，此时可以删除 bean.xml 了。但是由于没有了配置文件，创建数据源的配置又都写死在类中了。如何把它们配置出来呢？请看下一个注解。 </p>
<h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><p><strong>作用：</strong>用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。<br><strong>属性：</strong>value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath</p>
<p><strong>注意：</strong><br>此时我们已经有了两个配置类，但是他们还没有关系。如何建立他们的关系呢？请看下一个注解。 </p>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p><strong>作用：</strong><br>用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。<br><strong>属性：</strong><br>value[]：用于指定其他配置类的字节码。</p>
<p><strong>注意：</strong><br>我们已经把要配置的都配置好了，但是新的问题产生了，由于没有配置文件了，如何获取容器呢？如下。</p>
<h3 id="通过注解获取容器"><a href="#通过注解获取容器" class="headerlink" title="通过注解获取容器"></a>通过注解获取容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac =new AnnotationConfigApplicationContext(SpringConfiguration.class);</span><br></pre></td></tr></table></figure>

<h1 id="测试类中的问题和解决思路"><a href="#测试类中的问题和解决思路" class="headerlink" title="测试类中的问题和解决思路"></a>测试类中的问题和解决思路</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在测试类中，每个测试方法都有以下两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">IAccountService as = ac.getBean(<span class="string">"accountService"</span>,IAccountService.class);</span><br></pre></td></tr></table></figure>

<p>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p>
<h2 id="解决思路分析"><a href="#解决思路分析" class="headerlink" title="解决思路分析"></a>解决思路分析</h2><p>针对上述问题，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建spring 容器，我们就无须手动创建了，问题也就解决了。<br>我们都知道，junit 单元测试的原理，但显然，junit 是无法实现的，因为它自己都无法知晓我们是否使用了 spring 框架，更不用说帮我们创建 spring 容器了。不过好在，junit 给我们暴露了一个注解，可以让我们替换掉它的运行器。<br>这时，我们需要依靠 spring 框架，因为它提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。</p>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="第一步：拷贝整合junit的必备jar包到lib目录"><a href="#第一步：拷贝整合junit的必备jar包到lib目录" class="headerlink" title="第一步：拷贝整合junit的必备jar包到lib目录"></a>第一步：拷贝整合junit的必备jar包到lib目录</h3><p>jar包为<code>spring-test-xxx.RELEASE.jar</code>。</p>
<h3 id="第二步：使用-RunWith注解替换原有运行器"><a href="#第二步：使用-RunWith注解替换原有运行器" class="headerlink" title="第二步：使用@RunWith注解替换原有运行器"></a>第二步：使用@RunWith注解替换原有运行器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;SpringConfiguration.class&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第三步：使用-ContextConfiguration指定Spring配置文件的位置"><a href="#第三步：使用-ContextConfiguration指定Spring配置文件的位置" class="headerlink" title="第三步：使用@ContextConfiguration指定Spring配置文件的位置"></a>第三步：使用@ContextConfiguration指定Spring配置文件的位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;SpringConfiguration.class&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>@ContextConfiguration 注解：</strong><br><strong>locations 属性：</strong>用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明<br><strong>classes 属性：</strong>用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置。</p>
<h3 id="第四步：使用-Autowired给测试类中的变量注入数据"><a href="#第四步：使用-Autowired给测试类中的变量注入数据" class="headerlink" title="第四步：使用@Autowired给测试类中的变量注入数据"></a>第四步：使用@Autowired给测试类中的变量注入数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ICustomerService cs =<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>另：</strong></p>
<p>以上并不适合我，因为我是spring5整合JUint5，解决方案如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line">………………</span><br><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;SpringConfiguration.class&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>官方解释</strong>：<code>The *SpringExtension* class is provided by Spring 5 and integrates the Spring TestContext Framework into JUnit 5. The *@ExtendWith* annotation accepts any class that implements the *Extension* interface.</code></p>
<h2 id="为什么不把测试类配置到xml中"><a href="#为什么不把测试类配置到xml中" class="headerlink" title="为什么不把测试类配置到xml中"></a>为什么不把测试类配置到xml中</h2><p>在解释这个问题之前，先解除大家的疑虑，配到 XML 中能不能用呢？<br>答案是肯定的，没问题，可以使用。<br>那么为什么不采用配置到 xml 中的方式呢？<br><strong>这个原因是这样的：</strong><br><strong>第一：</strong>当我们在 xml 中配置了一个 bean，spring 加载配置文件创建容器时，就会创建对象。<br><strong>第二：</strong>测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。<br>所以，基于以上两点，我们不应该把测试配置到 xml 文件中。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习5-注解配置IoC</title>
    <url>/2019/10/29/2019-10-29-Spring%E5%AD%A6%E4%B9%A05-%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEIoC/</url>
    <content><![CDATA[<blockquote>
<p>基于注解配置的IoC和基于xml配置文件配置的IoC效果和目的都是一样的，都是为了解耦，只是换了一种方式而已。</p>
</blockquote>
<h1 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h1><h2 id="用于创建对象的"><a href="#用于创建对象的" class="headerlink" title="用于创建对象的"></a>用于创建对象的</h2><p><strong>@Component</strong></p>
<ul>
<li><p>作用：相当于在spring的xml配置文件中写了一个bean标签。</p>
</li>
<li><p>属性：</p>
<ul>
<li>value：用于指定bean的id。当不写时，默认值是当前类名首字母改小写。例如：accountServiceImpl</li>
</ul>
</li>
<li><p>由此衍生的三个注解：</p>
<ul>
<li>@Controller：一般用于业务层</li>
</ul>
<ul>
<li><p>@Service：一般用于表现层</p>
</li>
<li><p>@Repository：一般用于持久层</p>
<p>  他们的作用以及属性和@Component完全一样。他们的出现是spring框架为我们提供更明确的语义化来指定不同层的bean对象。</p>
</li>
</ul>
</li>
</ul>
<h2 id="用于注入数据的"><a href="#用于注入数据的" class="headerlink" title="用于注入数据的"></a>用于注入数据的</h2><h3 id="用于注入其他bean类型的"><a href="#用于注入其他bean类型的" class="headerlink" title="用于注入其他bean类型的"></a>用于注入其他bean类型的</h3><p><strong>@Autowired</strong></p>
<ul>
<li>作用：自动按照类型注入。根据要注入的数据的数据类型去容器中寻找，只要容器中有唯一类型匹配，则可以自动注入。</li>
<li>如果有多个类型匹配，会先按照类型找到符合条件的对象，然后再用变量名作为bean的id，从容器中继续查找，如果找到则仍可以注入成功，否则报错</li>
<li>当使用此注解注入时，set方法就可以省略了。</li>
<li>属性：<ul>
<li>required:是否必须注入成功。默认值为true，没有匹配的对象就报错</li>
</ul>
</li>
</ul>
<p><strong>@Qualifier</strong></p>
<ul>
<li>作用：在自动按照类型注入的基础之上，再按照bean的id注入。在给类成员注入时，它不能独立使用。</li>
<li>属性：<ul>
<li>value:用于指定bean的id</li>
</ul>
</li>
</ul>
<p><strong>@Resource</strong></p>
<ul>
<li>作用：直接按照bean的id注入,由J2EE提供，需要导入包javax.annotation.Resource,去mvn仓库下载jar包即可。</li>
<li>属性：<ul>
<li>name:用于指定bean的id</li>
</ul>
</li>
</ul>
<p><strong>以上三个注解都只能用于注入其他bean类型，而不能注入基本类型和String</strong></p>
<h3 id="用于注入基本类型和String类型的"><a href="#用于注入基本类型和String类型的" class="headerlink" title="用于注入基本类型和String类型的"></a>用于注入基本类型和String类型的</h3><p><strong>@Value</strong></p>
<ul>
<li>作用：注入基本类型和String类型数据。</li>
<li>属性：<ul>
<li>value:用于指定要注入的数据，它支持SpringEL表达式。</li>
<li>spring的el表达式：${表达式}</li>
</ul>
</li>
</ul>
<h2 id="用于改变作用范围的"><a href="#用于改变作用范围的" class="headerlink" title="用于改变作用范围的"></a>用于改变作用范围的</h2><p><strong>@Scope</strong></p>
<ul>
<li>作用：用于改变bean的作用范围，取值的范围和xml中的配置相同。</li>
<li>属性：<ul>
<li>value: 用于指定范围。</li>
</ul>
</li>
</ul>
<h2 id="和生命周期相关的-了解"><a href="#和生命周期相关的-了解" class="headerlink" title="和生命周期相关的(了解)"></a>和生命周期相关的(了解)</h2><p><strong>@PostContruct</strong></p>
<ul>
<li>作用：用于指定初始化方法，和配置文件中init-method属性是一样的。</li>
</ul>
<p><strong>@PreDestroy</strong></p>
<ul>
<li>作用：用于指定销毁方法，和配置文件中destroy-method属性是一样的。</li>
</ul>
<h1 id="注解与XML比较"><a href="#注解与XML比较" class="headerlink" title="注解与XML比较"></a>注解与XML比较</h1><ul>
<li>注解的优势： 配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。</li>
<li>XML的优势： 修改时，不用改源码。不涉及重新编译和部署。</li>
</ul>
<p><img src="https://i.loli.net/2019/10/30/5oGcx8A9YuvdhCM.png" alt=""></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习3-bean对象</title>
    <url>/2019/10/28/2019-10-28-Spring%E5%AD%A6%E4%B9%A03-bean%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="bean对象的三种创建方式"><a href="#bean对象的三种创建方式" class="headerlink" title="bean对象的三种创建方式"></a>bean对象的三种创建方式</h1><h2 id="通过调用构造函数来创建bean对象"><a href="#通过调用构造函数来创建bean对象" class="headerlink" title="通过调用构造函数来创建bean对象"></a>通过调用构造函数来创建bean对象</h2><p>默认情况下，当我们在spring的配置文件中写了一个bean标签并提供了class属性，spring就会调用默认构造函数创建对象。<br>如果没有构造函数，则创建失败。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置业务层对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client.java</span></span><br><span class="line">IAccountService as = (IAccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br></pre></td></tr></table></figure>



<h1 id="通过静态工厂创建bean对象"><a href="#通过静态工厂创建bean对象" class="headerlink" title="通过静态工厂创建bean对象"></a>通过静态工厂创建bean对象</h1><p>工厂类中提供一个静态方法，可以返回要用的bean对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 静态工厂创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"staticAccountService"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.factory.StaticBeanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/com/gsynf/factory/StaticBeanFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IAccountService <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client.java</span></span><br><span class="line">IAccountService as = (IAccountService) ac.getBean(<span class="string">"staticAccountService"</span>);</span><br></pre></td></tr></table></figure>



<h2 id="通过实例工厂创建bean对象"><a href="#通过实例工厂创建bean对象" class="headerlink" title="通过实例工厂创建bean对象"></a>通过实例工厂创建bean对象</h2><p>工厂类中提供一个普通方法，可以返回要用的bean对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实例工厂创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.factory.InstanceBeanFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceAccountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/com/gsynf/factory/InstanceBeanFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceBeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IAccountService <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client.java</span></span><br><span class="line">IAccountService as = (IAccountService) ac.getBean(<span class="string">"instanceAccountService"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="bean对象的作用范围"><a href="#bean对象的作用范围" class="headerlink" title="bean对象的作用范围"></a>bean对象的作用范围</h1><p>它是可以通过配置的方式指定的。配置的属性：bean标签的scope属性。属性的取值：</p>
<ul>
<li>singleton：单例范围，默认值；</li>
<li>prototype：多例对象；</li>
<li>request：请求范围，也就是只在该次请求和请求的转发中可用，WEB项目中，将Spring创建的bean对象存入到request域中；</li>
<li>session：会话范围，也就是在一次会话的范围中，WEB项目中，将Spring创建的bean对象存入到session域中；</li>
<li>global-session：全局会话范围；</li>
</ul>
<h1 id="bean对象的生命周期"><a href="#bean对象的生命周期" class="headerlink" title="bean对象的生命周期"></a>bean对象的生命周期</h1><p>生命周期要具体分为单例对象和多例对象：</p>
<ul>
<li><p>单例对象：</p>
<ul>
<li><p>出生：容器创建，对象出生；</p>
</li>
<li><p>活着：容器存在，对象就一直可用；</p>
</li>
<li><p>死亡：容器销毁，对象消亡；</p>
</li>
</ul>
</li>
<li><p>多例对象：</p>
<ul>
<li>出生：每次使用时，容器会创建对象；</li>
<li>活着：只要对象在使用过程中，就一直活在；</li>
<li>死亡：当对象长时间不用并且也没有其他对象引用时，由java的垃圾回收器回收；</li>
</ul>
</li>
</ul>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习4-依赖注入</title>
    <url>/2019/10/28/2019-10-28-Spring%E5%AD%A6%E4%B9%A04-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="依赖注入概念"><a href="#依赖注入概念" class="headerlink" title="依赖注入概念"></a>依赖注入概念</h1><p>依赖注入： Dependency Injection ，它是spring框架核心IoC的具体实现。</p>
<p>通过控制反转，把对象的创建交给了spring，但是代码中不可能出现没有依赖的情况，IoC解耦只是降低他们的依赖关系，但不会消除。例如业务层仍会调用持久层的方法，那么使用spring去维护这种业务层和持久层的依赖关系，就是DI的作用。</p>
<p>简单的说，就是坐等框架把对象传入，而不用我们自己去获取。</p>
<h1 id="注入的方式"><a href="#注入的方式" class="headerlink" title="注入的方式"></a>注入的方式</h1><h2 id="通过构造函数注入"><a href="#通过构造函数注入" class="headerlink" title="通过构造函数注入"></a>通过构造函数注入</h2><p>  涉及的标签：constructor-arg，该标签是写在bean标签内部的子标签<br>  标签的属性：</p>
<ul>
<li>type:指定要注入的参数在构造函数中的类型</li>
<li>index：指定要注入的参数在构造函数的索引位置</li>
<li>name：指定参数在构造函数中的名称</li>
<li>value：指定注入的数据内容，只能指定基本类型数据和String类型数据</li>
<li>ref：指定其他bean类型数据，写的是其他bean的id，其他bean指的是存在于spring容器中的bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务层</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, Integer age, Date birthday)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">   		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"gsynf"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="通过set方法注入"><a href="#通过set方法注入" class="headerlink" title="通过set方法注入"></a>通过set方法注入</h2><p>涉及的标签：property，该标签是写在bean标签内部的子标签<br>标签的属性：</p>
<ul>
<li>name：指定的是set方法的名称，匹配的是类中set后面的部分</li>
<li>value：指定注入的数据内容，只能指定基本类型数据和String类型数据</li>
<li>ref：指定其他bean类型数据，写的是其他bean的id，其他bean指的是存在于spring容器中的bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务层</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService2"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl2"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"gsynf"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 约束中导入p名称空间 --&gt;</span></span><br><span class="line">……</span><br><span class="line">xmlns:p="http://www.springframework.org/schema/p"</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用p名称空间注入</span></span><br><span class="line"><span class="comment">   			它的本质仍然是需要类中提供set方法，同时在配置文件中要导入p名称空间 --&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService3"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl3"</span></span></span><br><span class="line"><span class="tag">   			<span class="attr">p:name</span>=<span class="string">"gsynf"</span> <span class="attr">p:age</span>=<span class="string">"18"</span> <span class="attr">p:birthday-ref</span>=<span class="string">"now"</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="通过注解方式注入"><a href="#通过注解方式注入" class="headerlink" title="通过注解方式注入"></a>通过注解方式注入</h2><p>这部分在spring的注解会讲到。</p>
<h1 id="注入的内容"><a href="#注入的内容" class="headerlink" title="注入的内容"></a>注入的内容</h1><h2 id="基本类型和String类型"><a href="#基本类型和String类型" class="headerlink" title="基本类型和String类型"></a>基本类型和String类型</h2><p>如上</p>
<h2 id="其他的bean类型"><a href="#其他的bean类型" class="headerlink" title="其他的bean类型"></a>其他的bean类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务层</span></span><br><span class="line"><span class="keyword">private</span> IAccountDao accountDao = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以后开发中，业务层调用持久层交给spring处理会经常采用这种类型。</p>
<h2 id="复杂类型（集合类型）"><a href="#复杂类型（集合类型）" class="headerlink" title="复杂类型（集合类型）"></a>复杂类型（集合类型）</h2><p>这个和注入方式没有关系，只是注入的内容变得复杂。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	 <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService4"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl4"</span>&gt;</span></span><br><span class="line">	 	<span class="comment">&lt;!-- 给数组注入数据 --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span>	</span><br><span class="line">	 	<span class="comment">&lt;!-- 给list集合注入数据 --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	 	<span class="comment">&lt;!-- 给Set集合注入数据 --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	 	<span class="comment">&lt;!-- 给Map集合注入数据 --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testA"</span> <span class="attr">value</span>=<span class="string">"AAA"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testB"</span> <span class="attr">value</span>=<span class="string">"BBB"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testC"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	 	<span class="comment">&lt;!-- 给property集合注入数据 --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testA"</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testB"</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testC"</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  	 	</span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务层</span></span><br><span class="line">	<span class="keyword">private</span> String[] myStrs;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; myList;</span><br><span class="line">	<span class="keyword">private</span> Set&lt;String&gt; mySet;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String,String&gt; myMap;</span><br><span class="line">	<span class="keyword">private</span> Properties myProps;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyStrs</span><span class="params">(String[] myStrs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myStrs = myStrs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyList</span><span class="params">(List&lt;String&gt; myList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myList = myList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMySet</span><span class="params">(Set&lt;String&gt; mySet)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mySet = mySet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyMap</span><span class="params">(Map&lt;String, String&gt; myMap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myMap = myMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyProps</span><span class="params">(Properties myProps)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myProps = myProps;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Arrays.toString(myStrs));</span><br><span class="line">		System.out.println(myList);</span><br><span class="line">		System.out.println(mySet);</span><br><span class="line">		System.out.println(myMap);</span><br><span class="line">		System.out.println(myProps);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 运行结果</span><br><span class="line">[AAA, BBB, CCC]</span><br><span class="line">[AAA, BBB, CCC]</span><br><span class="line">[AAA, BBB, CCC]</span><br><span class="line">&#123;testA=AAA, testB=BBB, testC=CCC&#125;</span><br><span class="line">&#123;testB=BBB, testC=CCC, testA=AAA&#125;</span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习2-对spring解耦机制的理解</title>
    <url>/2019/10/28/2019-10-28-Spring%E5%AD%A6%E4%B9%A02-%E5%AF%B9spring%E8%A7%A3%E8%80%A6%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h1><p>个人理解，spring首先创建一个bean.xml的配置文件，创建一个核心容器，然后根据配置文件中bean的id来创建对象，通过这种方式来实现解耦，这和通过工厂模式创建一个bean.propertie配置文件，然后创建map容器存放bean对象是同一种思想：</p>
<p><strong>工厂模式</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ACCOUNTSERVICE</span>=<span class="string">com.gsynf.service.impl.AccountServiceImpl</span></span><br><span class="line"><span class="attr">ACCOUNTDAO</span>=<span class="string">com.gsynf.dao.impl.AccountDaoImpl</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: BeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 用于创建Bean对象的工厂</span></span><br><span class="line"><span class="comment"> * Bean:在我们工程中，就可以看成是一些对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: gsynf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年10月26日 下午5:20:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.它可以用来读取properties文件；</span></span><br><span class="line">	<span class="comment">// 2.它只能用于读取，不能用于写入；</span></span><br><span class="line">	<span class="comment">// 3.它只能读取类路径下的，不在类路径下的不能都读取；</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">"config.bean"</span>);	<span class="comment">//参数指的是properties文件的位置，写法是包名.类名，不要写扩展名</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义一个容器，用于存放所有的bean对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beans = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用静态代码块，给容器填充内容</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.读取所有的key</span></span><br><span class="line">			Enumeration&lt;String&gt; keys =bundle.getKeys();</span><br><span class="line">			<span class="comment">// 2.遍历所有的key</span></span><br><span class="line">			<span class="keyword">while</span>(keys.hasMoreElements()) &#123;</span><br><span class="line">				<span class="comment">//取出key</span></span><br><span class="line">				String key = keys.nextElement();</span><br><span class="line">				<span class="comment">//根据key获取value</span></span><br><span class="line">				String beanPath = bundle.getString(key);</span><br><span class="line">				<span class="comment">//反射创建bean对象</span></span><br><span class="line">				Object value = Class.forName(beanPath).newInstance();</span><br><span class="line">				<span class="comment">//把创建出来的对象和key存入map中</span></span><br><span class="line">				beans.put(key, value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"初始化容器失败！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Title</span>: getBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>: 用于创建bean对象的方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName  容器中bean的key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>			对应的bean对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>: Object</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> beans.get(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>spring</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 导入spring的约束</span></span><br><span class="line"><span class="comment">spring的IOC约束：beans</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">   	<span class="comment">&lt;!-- 配置业务层对象</span></span><br><span class="line"><span class="comment">   		bean标签：</span></span><br><span class="line"><span class="comment">   			作用：用于让spring帮我们读取配置后创建对象</span></span><br><span class="line"><span class="comment">   			属性：</span></span><br><span class="line"><span class="comment">   				id:对象的唯一标识</span></span><br><span class="line"><span class="comment">   				class:要创建的对象的全限定类名</span></span><br><span class="line"><span class="comment">   	 --&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   	</span><br><span class="line">   	<span class="comment">&lt;!-- 配置持久层对象</span></span><br><span class="line"><span class="comment">   				创建的反射对象存在哪里了呢？core container</span></span><br><span class="line"><span class="comment">   	 --&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"com.gsynf.dao.impl.AccountDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   	</span><br><span class="line">   	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gsynf.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gsynf.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> com.gsynf.service.impl.AccountServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 模拟一个表现层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: gsynf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019年10月26日 下午5:14:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Title</span>: main</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>: 获取spring的核心容器，并且根据bean的id获取对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1.获取spring的核心容器</span></span><br><span class="line">		ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">		<span class="comment">// 2.根据bean的id获取对象</span></span><br><span class="line">		IAccountService as = (IAccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">		IAccountDao adao = ac.getBean(<span class="string">"accountDao"</span>, IAccountDao.class);</span><br><span class="line">		</span><br><span class="line">		System.out.println(as);</span><br><span class="line">		System.out.println(adao);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另：获取spring核心容器详解</p>
<p><img src="https://i.loli.net/2019/10/28/oarFqh6v4Q9dMtz.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ApplicationContext:BeanFactory子接口的子接口，较为常用</span><br><span class="line">	特点：创建bean对象时，采用立即加载的策略。（当读取完xml配置文件，配置文件中所有的bean对象都已经创建完成）</span><br><span class="line">	使用场景：对象只创建一次，例如单例对象</span><br><span class="line">BeanFactory:springIoc容器的顶层接口</span><br><span class="line">	特点：创建bean对象时，采用延迟加载的策略。（当真正要从容器中获取bean对象时才创建，读取完xml配置文件并不创建）</span><br><span class="line">	使用场景：对象创建多次，例如多例对象</span><br><span class="line"></span><br><span class="line">ClassPathXmlApplicationContext：</span><br><span class="line">	它是通过读取类路径下的配置文件创建spring容器，要求配置文件必须在类路径下。</span><br><span class="line">FileSystemXmlApplicationContext：</span><br><span class="line">	它是通过读取文件系统中的配置文件创建spring容器，要求配置文件必须在文件系统中。</span><br></pre></td></tr></table></figure>

<h1 id="控制反转-Inversion-of-Control"><a href="#控制反转-Inversion-of-Control" class="headerlink" title="控制反转 Inversion of Control"></a>控制反转 Inversion of Control</h1><p>原来：</p>
<p>​         我们在获取对象时，都是采用new的方式。是主动的。</p>
<p>​          <img src="https://i.loli.net/2019/10/28/Om19taSPNLYBKF2.png" alt=""></p>
<p>​       现在：</p>
<p>​         我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。</p>
<p>​           <img src="https://i.loli.net/2019/10/28/7NgP4CrKkTYG3sX.png" alt=""></p>
<p>​    这种被动接收的方式获取对象的思想就是控制反转，它是spring框架的核心之一。</p>
<p>​    它的作用只有一个：削减计算机程序的耦合。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Class.forName()的作用与使用总结</title>
    <url>/2019/10/27/2019-10-27-Class.forName()%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p> 原文链接：<a href="https://blog.csdn.net/fengyuzhengfan/article/details/38086743" target="_blank" rel="noopener">https://blog.csdn.net/fengyuzhengfan/article/details/38086743</a> </p>
</blockquote>
<h1 id="Class类简介"><a href="#Class类简介" class="headerlink" title="Class类简介"></a>Class类简介</h1><p>Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</p>
<p>Class 没有公共构造方法。Class 对象是在加载类时由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 </p>
<p>虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<p>基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。 </p>
<p>每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p>
<p>一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。</p>
<p><strong>一、如何得到Class的对象呢？有三种方法可以的获取：</strong></p>
<ol>
<li><p>调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。例如：</p>
<pre><code>MyObject x;
Class c1 = x.getClass();</code></pre></li>
<li><p>使用Class类的中静态forName()方法获得与字符串对应的Class对象。例如： </p>
<pre><code>Class c2=Class.forName(&quot;MyObject&quot;),Employee必须是接口或者类的名字。</code></pre></li>
<li><p>获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。例如</p>
<pre><code>Class cl1 = Manager.class;
Class cl2 = int.class;
Class cl3 = Double[].class;
注意：Class对象实际上描述的只是类型，而这类型未必是类或者接口。例如上面的int.class是一个Class类型的对象。由于历史原因，数组类型的getName方法会返回奇怪的名字。</code></pre></li>
</ol>
<p><strong>二、Class类的常用方法</strong></p>
<ol>
<li><p>getName() </p>
<p>一个Class对象描述了一个特定类的属性，Class类中最常用的方法getName以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。</p>
</li>
<li><p>newInstance()</p>
<p>Class还有一个有用的方法可以为类创建一个实例，这个方法叫做newInstance()。例如：</p>
<pre><code>x.getClass.newInstance()，创建了一个同x一样类型的新实例。newInstance()方法调用默认构造器（无参数构造器）初始化新建对象。</code></pre></li>
<li><p>getClassLoader() </p>
</li>
</ol>
<p>返回该类的类加载器。</p>
<ol start="4">
<li><p>getComponentType() </p>
<pre><code>返回表示数组组件类型的 Class。</code></pre></li>
<li><p>getSuperclass() </p>
<pre><code>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。</code></pre></li>
<li><p>isArray() </p>
<pre><code>判定此 Class 对象是否表示一个数组类。</code></pre></li>
</ol>
<p><strong>三、Class的一些使用技巧</strong></p>
<ol>
<li><p>forName和newInstance结合起来使用，可以根据存储在字符串中的类名创建对象。例如</p>
<pre><code>Object obj = Class.forName(s).newInstance();</code></pre></li>
<li><p>虚拟机为每种类型管理一个独一无二的Class对象。因此可以使用==操作符来比较类对象。例如：</p>
<pre><code>if(e.getClass() == Employee.class)...</code></pre></li>
</ol>
<h1 id="Class-forName-方法"><a href="#Class-forName-方法" class="headerlink" title="Class.forName()方法"></a>Class.forName()方法</h1><p>Class.forName：返回与给定的字符串名称相关联类或接口的Class对象。</p>
<p>Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。</p>
<p><img src="https://i.loli.net/2019/10/27/rLGJsXIljkepoqy.png" alt=""></p>
<p><strong>说明：</strong></p>
<p>publicstatic Class&lt;?&gt; forName(String className)</p>
<p>Returns the Class object associated withthe class or interface with the given string name. Invokingthis method is equivalent to:</p>
<p>Class.forName(className,true, currentLoader)</p>
<p>where currentLoader denotes the definingclass loader of the current class.</p>
<p>For example, thefollowing code fragment returns the runtime Class descriptor for theclass named java.lang.Thread:</p>
<p>Class t =Class.forName(“java.lang.Thread”)</p>
<p>A call to forName(“X”) causes theclass named X to beinitialized.</p>
<p><strong>Parameters</strong>:</p>
<p>className - the fully qualifiedname of the desired class.</p>
<p><strong>Returns</strong>:</p>
<p>the Class object for the classwith the specified name.</p>
<p>从官方给出的API文档中可以看出:</p>
<p>Class.forName(className)实际上是调用Class.forName(className,true, this.getClass().getClassLoader())。第二个参数，是指Class被loading后是不是必须被初始化。可以看出，使用Class.forName（className）加载类时则已初始化。</p>
<p>所以Class.forName(className)可以简单的理解为：获得字符串参数中指定的类，并初始化该类。</p>
<p> <strong>一.首先你要明白在java里面任何class都要装载在虚拟机上才能运行。</strong></p>
<ol>
<li><p>forName这句话就是装载类用的(new是根据加载到内存中的类创建一个实例，要分清楚)。 </p>
</li>
<li><p>至于什么时候用，可以考虑一下这个问题，给你一个字符串变量，它代表一个类的包名和类名，你怎么实例化它？</p>
<p>   A a = (A)Class.forName(“pacage.A”).newInstance();这和 A a =new A();是一样的效果。</p>
</li>
<li><p>jvm在装载类时会执行类的静态代码段，要记住静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了，而且以后不会再执行这段静态代码了。</p>
</li>
<li><p>Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。</p>
</li>
<li><p>动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象</p>
<p>String str = 用户输入的字符串  </p>
<p>Class t = Class.forName(str);  </p>
<p>t.newInstance(); </p>
<p><strong>二.在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？</strong></p>
</li>
<li><p>它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。</p>
</li>
<li><p>那么为什么会有两种创建对象方式？</p>
</li>
</ol>
<p>这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。<br>Java中工厂模式经常使用newInstance()方法来创建对象，因此从为什么要使用工厂模式上可以找到具体答案。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>= Class.forName(“Example”);  </span><br><span class="line">factory = (ExampleInterface)c.newInstance();</span><br></pre></td></tr></table></figure>

<p>   其中ExampleInterface是Example的接口，可以写成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = <span class="string">"Example"</span>;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>= Class.forName(className);  </span><br><span class="line">factory = (ExampleInterface)c.newInstance();</span><br></pre></td></tr></table></figure>

<p>  进一步可以写成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = readfromXMlConfig;<span class="comment">//从xml 配置文件中获得字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>= Class.forName(className);  </span><br><span class="line">factory = (ExampleInterface)c.newInstance();</span><br></pre></td></tr></table></figure>
<p>上面代码已经不存在Example的类名称，它的优点是，无论Example类怎么变化，上述代码不变，甚至可以更换Example的兄弟类Example2 , Example3 , Example4……，只要他们继承ExampleInterface就可以。  </p>
<ol start="3">
<li><p>从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。  但是使用newInstance()方法的时候，</p>
<p> 就必须保证：</p>
</li>
</ol>
<ul>
<li><p>这个类已经加载；</p>
</li>
<li><p>这个类已经连接了。</p>
</li>
</ul>
<p>而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。  </p>
<p>现在可以看出，newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。这样分步的好处是显而易见的。我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种降耦的手段。 </p>
<p><strong>三.最后用最简单的描述来区分new关键字和newInstance()方法的区别：</strong> </p>
<ol>
<li>newInstance: 弱类型。低效率。只能调用无参构造;</li>
<li>new: 强类型。相对高效。能调用任何public构造。</li>
</ol>
<h1 id="应用情景"><a href="#应用情景" class="headerlink" title="应用情景"></a>应用情景</h1><p><strong>情景一：加载数据库驱动的时候</strong></p>
<p>Class.forName的一个很常见的用法是在加载数据库驱动的时候。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.microsoft.sqlserver.jdbc.SQLServerDriver"</span>);</span><br><span class="line">Connection con=DriverManager.getConnection(<span class="string">"jdbc:sqlserver://localhost:1433;DatabaseName==JSP"</span>,<span class="string">"jph"</span>,<span class="string">"jph"</span>);</span><br></pre></td></tr></table></figure>

<p>为什么在我们加载数据库驱动包的时候有的却没有调用newInstance( )方法呢？<br>即有的jdbc连接数据库的写法里是Class.forName(xxx.xx.xx);而有一些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？ </p>
<p>刚才提到，Class.forName(“”);的作用是要求JVM查找并加载指定的类，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码段。</p>
<p>而在JDBC规范中明确要求这个Driver类必须向DriverManager注册自己，即任何一个JDBCDriver的Driver类的代码都必须类似如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">          <span class="keyword">public</span> classMyJDBCDriver implements Driver &#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">   DriverManager.registerDriver(<span class="keyword">new</span> MyJDBCDriver());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>既然在静态初始化器的中已经进行了注册，所以我们在使用JDBC时只需要Class.forName(XXX.XXX);就可以了。</p>
<p><strong>情景二：使用AIDL与电话管理Servic进行通信</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method method =Class.forName(<span class="string">"android.os.ServiceManager"</span>)</span><br><span class="line">     .getMethod(<span class="string">"getService"</span>,String.class);</span><br><span class="line"><span class="comment">// 获取远程TELEPHONY_SERVICE的IBinder对象的代理</span></span><br><span class="line">IBinder binder =(IBinder) method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; TELEPHONY_SERVICE&#125;);</span><br><span class="line"><span class="comment">// 将IBinder对象的代理转换为ITelephony对象</span></span><br><span class="line">ITelephonytelephony = ITelephony.Stub.asInterface(binder);</span><br><span class="line"><span class="comment">// 挂断电话</span></span><br><span class="line">telephony.endCall();</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习1</title>
    <url>/2019/10/26/2019-10-26-Spring%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<blockquote>
<p>直接学习springboot发现有些困难，还是按部就班从spring开始。这里总结一些问题。课程中老师为了解释什么是耦合使用了jdbc。</p>
</blockquote>
<h1 id="一、数据库无法连接"><a href="#一、数据库无法连接" class="headerlink" title="一、数据库无法连接"></a>一、数据库无法连接</h1><p>之前使用Navicat连接的数据库无法连接，去“服务器”查看数据库没问题，突然想到了看看连接的IP，<code>ifconfig</code> 果然IP变了，前几天实验室重新进行了网络规划，之前的ip变了，重连即可；</p>
<h1 id="二、Launch-Error"><a href="#二、Launch-Error" class="headerlink" title="二、Launch Error"></a>二、Launch Error</h1><p>程序写好，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.gsynf.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: JdbcDemo1</span><br><span class="line"> * @Description: Jdbc的使用，目的为了理解什么是耦合</span><br><span class="line"> * @author: gsynf</span><br><span class="line"> * @date: 2019年10月25日 下午9:18:27</span><br><span class="line"> */</span><br><span class="line">public class JdbcDemo1 &#123;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	  create table account(</span><br><span class="line">	  		id int primary key auto_increment,</span><br><span class="line">	  		name varchar(20),</span><br><span class="line">	  		money float</span><br><span class="line">	  		);</span><br><span class="line">	 * @Title: main</span><br><span class="line">	 * @Description: TODO</span><br><span class="line">	 * @param args</span><br><span class="line">	 * @return: void</span><br><span class="line">	 * @throws SQLException </span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">		// 1.注册驱动</span><br><span class="line">		DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span><br><span class="line">		// 2.获取连接</span><br><span class="line">		Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://IP地址:3306/spring5&quot;,&quot;账户&quot;,&quot;密码&quot;);</span><br><span class="line">		// 3.获取操作数据库的预处理对象</span><br><span class="line">		PreparedStatement pstm = conn.prepareStatement(&quot;select * from account&quot;);</span><br><span class="line">		// 4.执行SQL语句（如果有结果集，得到结果集）</span><br><span class="line">		ResultSet rs = pstm.executeQuery();</span><br><span class="line">		// 5.遍历结果集。封装</span><br><span class="line">		while(rs.next()) &#123;</span><br><span class="line">			System.out.println(rs.getString(&quot;name&quot;)+&quot;,&quot;+rs.getFloat(&quot;money&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		// 6.释放资源</span><br><span class="line">		rs.close();</span><br><span class="line">		pstm.close();</span><br><span class="line">		conn.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常编译，莫名其妙的弹出<code>Launch Error</code>，应该是JVM无法启动，百度谷歌了一圈也没找着，重新建了一个工程，建了一个类直接编译也还是一样，最后发现是JRE和JDK的版本不相应的问题，新建项目时，我的JRE选择的是本机安装的默认的11</p>
<p><img src="https://i.loli.net/2019/10/26/bjDSmdTXtKn5icr.png" alt=""></p>
<p>此时，下方会弹出一个警告</p>
<p><img src="https://i.loli.net/2019/10/26/bus4Il6VTR1LA3U.png" alt=""></p>
<p>大致意思是现在选择的JRE是11版本，但是默认的JDK是12版本，不匹配，点击Configure将JDK也选择为11即可。</p>
<p><img src="https://i.loli.net/2019/10/26/Uc612C3HuAopIvQ.png" alt=""></p>
<h1 id="三、SSL警告"><a href="#三、SSL警告" class="headerlink" title="三、SSL警告"></a>三、SSL警告</h1><p> 使用mysql-jdbc连接MySQL出现如下警告 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Establishing SSL connection without server&apos;s identityverification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+requirements SSL connection must be established by default if explicit optionisn&apos;t set. For compliance with existing applications not using SSL theverifyServerCertificate property is set to &apos;false&apos;. You need either toexplicitly disable SSL by setting useSSL=false, or set useSSL=true and providetruststore for server certificate verification.</span><br></pre></td></tr></table></figure>

<p>原因是MySQL在高版本需要指明是否进行SSL连接。解决方案如下：</p>
<p>在mysql连接字符串url中加入ssl=true或者false即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://IP地址:3306/spring5?useSSL=false&quot;,&quot;账户&quot;,&quot;密码&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="四、Spring配置文件中提示的配置"><a href="#四、Spring配置文件中提示的配置" class="headerlink" title="四、Spring配置文件中提示的配置"></a>四、Spring配置文件中提示的配置</h1><p>复制路径:</p>
<p>* <a href="http://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans.xsd</a></p>
<p>另存为xsd格式，esclipse中Windows-Preference，查找XML Catalog，选择User Specified Entries，添加刚才下载的xsd文件，spring中的xml文件选择以Spring Config Enditor打开即可。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot框架学习1-入门及配置</title>
    <url>/2019/10/21/2019-10-21-SpringBoot%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01-%E5%85%A5%E9%97%A8%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>springboot诞生于2014年，伴随着spring4.0产生，其实就是整合spring整个的技术栈，简化spring开发，实现J2EE一站式开发。</p>
<h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><p>–快速创建独立运行的Spring项目以及与主流框架集成<br>–使用嵌入式的Servlet容器，应用无需打成WAR包<br>–starters自动依赖与版本控制<br>–大量的自动配置，简化开发，也可修改默认值<br>–无需配置XML，无代码生成，开箱即用<br>–准生产环境的运行时应用监控<br>–与云计算的天然集成</p>
<p>-入门容易精通难，要想深入了解它是如何封装的需要熟练掌握Spring的API</p>
<h2 id="3-微服务"><a href="#3-微服务" class="headerlink" title="3.微服务"></a>3.微服务</h2><p>2014年， <a href="https://martinfowler.com/" target="_blank" rel="noopener">Martin Fowler</a> 的一篇<a href="https://martinfowler.com/microservices/" target="_blank" rel="noopener">博客</a>阐明了微服务是一种架构风格，一个应用是一组小型服务，可以通过http的方式进行互通。</p>
<p>与传统单体应用比较：</p>
<p><img src="https://i.loli.net/2019/10/21/Sy4ntGruHcTLxap.png" alt=""></p>
<p><img src="https://i.loli.net/2019/10/21/STFnlNzgapqCOvW.png" alt=""></p>
<p>微服务最终每一个功能单元都是一个可独立替换和独立升级的软件单元；</p>
<h2 id="4-环境"><a href="#4-环境" class="headerlink" title="4.环境"></a>4.环境</h2><p>JDK:Jdk-11.0.4</p>
<p>MAVEN:apache-maven-3.3.9</p>
<p>IntelliJIDEA:IntelliJ IDEA 2019.2.3</p>
<p>SpringBoot: 2.2.0  (current GA)</p>
<h1 id="二、Spring-Boot-HelloWorld"><a href="#二、Spring-Boot-HelloWorld" class="headerlink" title="二、Spring Boot HelloWorld"></a>二、Spring Boot HelloWorld</h1><p>一个功能：</p>
<p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p>
<h2 id="1、创建一个maven工程；（jar）"><a href="#1、创建一个maven工程；（jar）" class="headerlink" title="1、创建一个maven工程；（jar）"></a>1、创建一个maven工程；（jar）</h2><h2 id="2、导入spring-boot相关的依赖"><a href="#2、导入spring-boot相关的依赖" class="headerlink" title="2、导入spring boot相关的依赖"></a>2、导入spring boot相关的依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、编写一个主程序；启动Spring-Boot应用"><a href="#3、编写一个主程序；启动Spring-Boot应用" class="headerlink" title="3、编写一个主程序；启动Spring Boot应用"></a>3、编写一个主程序；启动Spring Boot应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h2><h2 id="6、简化部署"><a href="#6、简化部署" class="headerlink" title="6、简化部署"></a>6、简化部署</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将这个应用打成jar包，直接使用java -jar的命令进行执行；</p>
<h2 id="7、Hello-World探究"><a href="#7、Hello-World探究" class="headerlink" title="7、Hello World探究"></a>7、Hello World探究</h2><h3 id="1、POM文件"><a href="#1、POM文件" class="headerlink" title="1、POM文件"></a>1、POM文件</h3><h4 id="1、父项目"><a href="#1、父项目" class="headerlink" title="1、父项目"></a>1、父项目</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目是</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">他来真正管理Spring Boot应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure>

<p>Spring Boot的版本仲裁中心；</p>
<p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p>
<h4 id="2、启动器"><a href="#2、启动器" class="headerlink" title="2、启动器"></a>2、启动器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>spring-boot-starter-web</strong>：</p>
<p>​    spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p>
<p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<h3 id="2、主程序类，主入口类"><a href="#2、主程序类，主入口类" class="headerlink" title="2、主程序类，主入口类"></a>2、主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>

<p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p>
<p>​        标注在某个类上，表示这是一个Spring Boot的配置类；</p>
<p>​        @<strong>Configuration</strong>:配置类上来标注这个注解；</p>
<p>​            配置类 —–  配置文件；配置类也是容器中的一个组件；@Component</p>
<p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p>
<p>​        以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

<p>​          @<strong>AutoConfigurationPackage</strong>：自动配置包</p>
<p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p>
<p>​        Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p>
<p>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</p>
<p>​    @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p>
<p>​        给容器中导入组件？</p>
<p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p>
<p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p>
<p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；        </p>
<p><img src="https://i.loli.net/2019/10/24/ZPzlA2a9OF4XMG6.png" alt="自动配置类"></p>
<p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p>
<p>​        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p>
<p><strong>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；</strong>以前我们需要自己配置的东西，自动配置类都帮我们；</p>
<p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p>
<h2 id="8、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#8、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="8、使用Spring Initializer快速创建Spring Boot项目"></a>8、使用Spring Initializer快速创建Spring Boot项目</h2><h3 id="1、IDEA：使用-Spring-Initializer快速创建项目"><a href="#1、IDEA：使用-Spring-Initializer快速创建项目" class="headerlink" title="1、IDEA：使用 Spring Initializer快速创建项目"></a>1、IDEA：使用 Spring Initializer快速创建项目</h3><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p>
<p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p>
<p>默认生成的Spring Boot项目；</p>
<ul>
<li>主程序已经生成好了，我们只需要我们自己的逻辑</li>
<li>resources文件夹中目录结构<ul>
<li>static：保存所有的静态资源； js css  images；</li>
<li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li>
<li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li>
</ul>
</li>
</ul>
<h3 id="2、STS使用-Spring-Starter-Project快速创建项目"><a href="#2、STS使用-Spring-Starter-Project快速创建项目" class="headerlink" title="2、STS使用 Spring Starter Project快速创建项目"></a>2、STS使用 Spring Starter Project快速创建项目</h3><hr>
<h1 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h1><h2 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p>
<p>•application.properties</p>
<p>•application.yml</p>
<p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p>
<p>YAML（YAML Ain’t Markup Language）</p>
<p>​    YAML  A Markup Language：是一个标记语言</p>
<p>​    YAML   isn’t Markup Language：不是一个标记语言；</p>
<p>标记语言：</p>
<p>​    以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p>
<p>​    YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p>
<p>​    YAML：配置例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>

<p>​    XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2、YAML语法："><a href="#2、YAML语法：" class="headerlink" title="2、YAML语法："></a>2、YAML语法：</h2><h3 id="2-1基本语法"><a href="#2-1基本语法" class="headerlink" title="2.1基本语法"></a>2.1基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p>
<p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>

<p>属性和值也是大小写敏感；</p>
<h3 id="2-2值的写法"><a href="#2-2值的写法" class="headerlink" title="2.2值的写法"></a>2.2值的写法</h3><h4 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h4><p>​    k: v：字面直接来写；</p>
<p>​        字符串默认不用加上单引号或者双引号；</p>
<p>​        “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
<p>​                name:   “zhangsan \n lisi”：输出：zhangsan \n  lisi</p>
<p>​        ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<p>​                name:   ‘zhangsan \n lisi’：输出：zhangsan 换行  lisi</p>
<h4 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h4><p>​    k: v：在下一行来写对象的属性和值的关系；注意缩进</p>
<p>​        对象还是k: v的方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">		<span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">		<span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>行内写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h4><p>用- 值表示数组中的一个元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure>

<p>行内写法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure>



<h2 id="3、配置文件值注入"><a href="#3、配置文件值注入" class="headerlink" title="3、配置文件值注入"></a>3、配置文件值注入</h2><p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">    lastName:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">    boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">    maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">    lists:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">    dog:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">小狗</span></span><br><span class="line"><span class="attr">      age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>javaBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>



<p>我们可以导入配置文件处理器，以后编写配置就有提示了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1properties配置文件在idea中默认utf-8可能会乱码"><a href="#3-1properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="3.1properties配置文件在idea中默认utf-8可能会乱码"></a>3.1properties配置文件在idea中默认utf-8可能会乱码</h4><p>调整</p>
<p><img src="https://i.loli.net/2019/10/24/Cuh1DGPHzvrJAnw.png" alt="IDEA配置文件乱码"></p>
<h4 id="3-2-Value获取值和-ConfigurationProperties获取值比较"><a href="#3-2-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="3.2@Value获取值和@ConfigurationProperties获取值比较"></a>3.2@Value获取值和@ConfigurationProperties获取值比较</h4><table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>配置文件yml还是properties他们都能获取到值；</p>
<p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p>
<p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p>
<h4 id="3-3配置文件注入值数据校验"><a href="#3-3配置文件注入值数据校验" class="headerlink" title="3.3配置文件注入值数据校验"></a>3.3配置文件注入值数据校验</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>



<h4 id="3-4-PropertySource-amp-ImportResource-amp-Bean"><a href="#3-4-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="3.4@PropertySource &amp; @ImportResource &amp; @Bean"></a>3.4@PropertySource &amp; @ImportResource &amp; @Bean</h4><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person")默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure>



<p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p>
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，如下，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也不能自动识别；</p>
<p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure>



<p>但是，SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p>
<p>1、配置类<strong>@Configuration</strong>——&gt;Spring配置文件</p>
<p>2、使用<strong>@Bean</strong>给容器中添加组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件，现在使用<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、配置文件占位符"><a href="#4、配置文件占位符" class="headerlink" title="4、配置文件占位符"></a>4、配置文件占位符</h2><h3 id="4-1随机数"><a href="#4-1随机数" class="headerlink" title="4.1随机数"></a>4.1随机数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2获取之前配置的值"><a href="#4-2获取之前配置的值" class="headerlink" title="4.2获取之前配置的值"></a>4.2获取之前配置的值</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2017/12/15</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">14</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="comment">#如果没有可以是用:指定默认值</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;_dog</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure>



<h2 id="5、Profile"><a href="#5、Profile" class="headerlink" title="5、Profile"></a>5、Profile</h2><h3 id="5-1多Profile文件"><a href="#5-1多Profile文件" class="headerlink" title="5.1多Profile文件"></a>5.1多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p>
<p>默认使用application.properties的配置；</p>
<h3 id="5-2yml支持多文档块方式"><a href="#5-2yml支持多文档块方式" class="headerlink" title="5.2yml支持多文档块方式"></a>5.2yml支持多文档块方式</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3激活指定profile"><a href="#5-3激活指定profile" class="headerlink" title="5.3激活指定profile"></a>5.3激活指定profile</h3><p>​    1、在配置文件中指定  spring.profiles.active=dev</p>
<p>​    2、命令行：</p>
<p>​        <code>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</code>；</p>
<p>​        可以直接在测试的时候，在IDE的Run/Debug Configurations的Program arguments中配置传入命令行参数<code>--spring.profiles.active=dev</code></p>
<p>​    3、虚拟机参数；</p>
<p>​        在IDE的Run/Debug Configurations的VM options中配置传入命令行参数<code>-Dspring.profiles.active=dev</code></p>
<h2 id="6、配置文件加载位置"><a href="#6、配置文件加载位置" class="headerlink" title="6、配置文件加载位置"></a>6、配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<p>–file:./config/</p>
<p>–file:./</p>
<p>–classpath:/config/</p>
<p>–classpath:/</p>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p>
<p><strong>我们还可以通过spring.config.location来改变默认的配置文件位置</strong></p>
<p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p>
<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties</p>
<h2 id="7、外部配置加载顺序"><a href="#7、外部配置加载顺序" class="headerlink" title="7、外部配置加载顺序"></a>7、外部配置加载顺序</h2><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p>
<p><strong>1.命令行参数</strong></p>
<p>所有的配置都可以在命令行上进行指定</p>
<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p>
<p>多个配置用空格分开； –配置项=值</p>
<p>2.来自java:comp/env的JNDI属性</p>
<p>3.Java系统属性（System.getProperties()）</p>
<p>4.操作系统环境变量</p>
<p>5.RandomValuePropertySource配置的random.*属性值</p>
<p><strong>由jar包外向jar包内进行寻找；</strong></p>
<p><strong>优先加载带profile</strong></p>
<p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>
<p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>
<p><strong>再来加载不带profile</strong></p>
<p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
<p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
<p>10.@Configuration注解类上的@PropertySource</p>
<p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p>
<p>所有支持的配置加载来源；</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p>
<h2 id="8、自动配置原理"><a href="#8、自动配置原理" class="headerlink" title="8、自动配置原理"></a>8、自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p>
<h3 id="8-1自动配置原理："><a href="#8-1自动配置原理：" class="headerlink" title="8.1自动配置原理："></a>8.1<strong>自动配置原理：</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==</p>
<p><strong>2）、@EnableAutoConfiguration 作用：</strong></p>
<ul>
<li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</li>
</ul>
<ul>
<li><p>可以查看selectImports()方法的内容；</p>
</li>
<li><p>List&lt; String &gt; configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</p>
<ul>
<li><pre><code class="java">SpringFactoriesLoader.loadFactoryNames()
扫描所有jar包类路径下  META-INF/spring.factories
把扫描到的这些文件的内容包装成properties对象
从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中

&lt;!--￼<span class="number">27</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p>
<p>3）、每一个自动配置类进行自动配置功能；</p>
<p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties.class)  <span class="comment">//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter.class)  <span class="comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter.class) <span class="comment">//判断容器没有这个组件？</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">		filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">		filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">		filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>根据当前不同的条件判断，决定这个配置类是否生效？</p>
<p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p>
<p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>



<p><strong>精髓：</strong></p>
<p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p>
<p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p>
<p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p>
<p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p>
<p>xxxxAutoConfigurartion：自动配置类；</p>
<p>给容器中添加组件</p>
<p>xxxxProperties:封装配置文件中相关属性；</p>
<h3 id="8-2细节"><a href="#8-2细节" class="headerlink" title="8.2细节"></a>8.2细节</h3><p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th>@Conditional扩展注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody></table>
<p><strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p>我们怎么知道哪些自动配置类生效；</p>
<p><strong>我们可以通过在配置文件中启用 debug=true属性；来让控制台打印自动配置报告</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode使用editorconfig</title>
    <url>/2019/10/18/2019-10-18-vscode%E4%BD%BF%E7%94%A8editorconfig/</url>
    <content><![CDATA[<p> EditorConfig  是一个名称为.editorconfig的自定义文件。 文件中的设置用于在基本代码库中维持一致的编码风格和设置，例如缩进样式、选项卡宽度、行尾字符以及编码等，而无需考虑使用的编辑器或 IDE 。 该文件用来定义项目的编码规范，编辑器的行为会与.editorconfig 文件中定义的一致，并且其优先级比编辑器自身的设置要高，这在多人合作开发项目时十分有用而且必要 。 有些编辑器默认支持editorConfig，如webstorm；而有些编辑器则需要安装editorConfig插件，如ATOM、Sublime、VS Code等 。</p>
<h1 id="配置-editorconfig"><a href="#配置-editorconfig" class="headerlink" title="配置.editorconfig"></a>配置.editorconfig</h1><p>参考，本人vuex项目的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .editorconfig </span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf-8</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br><span class="line">end_of_line = lf</span><br><span class="line">insert_final_newline = true</span><br><span class="line">trim_trailing_whitespace = true</span><br></pre></td></tr></table></figure>

<h1 id="安装-EditorConfig扩展"><a href="#安装-EditorConfig扩展" class="headerlink" title="安装 EditorConfig扩展"></a>安装 EditorConfig扩展</h1><p> 在vscode里面安装EditorConfig 插件：</p>
<p><img src="https://i.loli.net/2019/10/18/wByVis1cjQWFHxd.png" alt=""></p>
<p> EditorConfig扩展的作用是读取第一步创建的editorconfig文件中定义的规则，并覆盖user/workspace settings中的对应配置 。</p>
<h1 id="全局安装或局部安装"><a href="#全局安装或局部安装" class="headerlink" title="全局安装或局部安装"></a>全局安装或局部安装</h1><p>editorconfig依赖包(npm install -g editorconfig | npm install -D editorconfig)<br>安装editorconfig依赖包主要是因为EditorConfig依赖于editorconfig包，不安装的可能会导致EditorConfig无法正常解析我们在第一步定义的editorconfig文件使用</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>打开需要格式化的文件并手动格式化代码（shift+alt+f）</p>
<p>（安装完毕一般自动就进行使用）</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>EditorConfig</tag>
      </tags>
  </entry>
  <entry>
    <title>关于npm audit fix</title>
    <url>/2019/10/16/2019-10-16-%E5%85%B3%E4%BA%8Enpm%20audit%20fix/</url>
    <content><![CDATA[<p> 其实之前也遇到过，一直没注意，今天安装vuex，<code>npm install vuex --save</code>出现如下提醒 </p>
<p><img src="https://i.loli.net/2019/10/16/SJFRPQtyCkHgx4D.png" alt=""></p>
<p> 执行 <code>npm audit fix</code>  </p>
<p><img src="https://i.loli.net/2019/10/16/YkSTBdZgepCRDIW.png" alt=""></p>
<p>出于好奇，从npm官网上查阅了对于<strong>npm audit fix</strong>的相关介绍。 npm@6 的一大更新是新增了 <code>npm audit</code> 命令 ,  <code>npm aduit</code> 主要动作就是在 <code>npm install</code> 完成之后把需要检查的包的信息发送给一个官方接口, 再根据返回信息生成一个包含包名称、漏洞严重性、简介, 路径等的报告。 该命令会在项目中更新或者下载新的依赖包之后会自动运行，如果你在项目中使用了具有已知安全问题的依赖，就收到官方的警告通知。 </p>
<p> ps. 一般不要直接运行 <code>--force</code> ，对于没能自动修复的问题，说明肯定出现了 <code>SEMVER WARNING</code> 之类的警告，这意味着推荐的修复版本存在让代码出问题的可能，主要发生在依赖包更改了 API 或者升级了大版本的情况下（semantic version major change）。这时候就需要格外的小心甚至需要改动一些自己的代码了。 </p>
<p>其他一些具体命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 扫描项目漏洞把不安全的依赖项自动更新到兼容性版本</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br><span class="line"># 在不修改 node_modules 的情况下执行 audit fix，仍然会更改 pkglock</span><br><span class="line">npm audit fix --package-lock-only</span><br><span class="line"></span><br><span class="line"># 跳过更新 devDependencies</span><br><span class="line">npm audit fix --only=prod</span><br><span class="line"></span><br><span class="line"># 强制执行 audit fix 安装最新的依赖项（toplevel）</span><br><span class="line">npm audit fix --force</span><br><span class="line"></span><br><span class="line"># 单纯的获取 audit fix 会做的事，并以 json 格式输出。</span><br><span class="line">npm audit fix --dry-run --json</span><br><span class="line"></span><br><span class="line"># 获取详情</span><br><span class="line">npm audit</span><br><span class="line"></span><br><span class="line"># 以 JSON 格式打印报告</span><br><span class="line">npm audit --json</span><br></pre></td></tr></table></figure>

<p>至于如何关闭安全检查，可以采用以下方式：</p>
<ul>
<li>安装单个包关闭安全审查: <code>npm install example-package-name --no-audit</code></li>
<li>安装所有包关闭安全审查 - 运行 <code>npm set audit false</code> - 手动将 <code>~/.npmrc</code> 配置文件中的 <code>audit</code> 修改为 <code>false</code></li>
</ul>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列笔记5</title>
    <url>/2019/10/16/2019-10-16-Vue%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<blockquote>
<p>学习参考：coderwhy教学视频，整个系列可能会比较混乱，学到哪里觉得有需要的记录一下，可能和之前的java笔记类似。</p>
</blockquote>
<ol>
<li>Vuex是一个专为Vue.js专用程序开发的状态管理模式。其实，可以简单的将其看作把需要多个组件共享的变量全部存储到一个对象里面，然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。而且最重要的是，这个对象是响应式的；</li>
</ol>
<p><img src="https://i.loli.net/2019/10/16/s5lRSpZxtOwaGLy.png" alt=""></p>
<ol start="2">
<li>一般什么状态需要多个组件之间共享呢？例如用户的登录状态、用户名称、头像，例如商品的收藏、购物车中商品等；</li>
<li>简单使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/index.js</span></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        counter: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="comment">// 方法</span></span><br><span class="line">        increament(state) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.counter++</span><br><span class="line">          &#125;,</span><br><span class="line">          decreament(state) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.counter--</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// APP.js</span></span><br><span class="line">……</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addition() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.commit(<span class="string">'increament'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    subtraction() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.commit(<span class="string">'decreament'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>Vuex的store状态的更新唯一方式：提交mutation，mutation中回调函数的第一个参数就是state，传递的参数可以在state后边，被称作载荷(Payload)。</p>
<ol start="4">
<li>Vuex五大核心：state、mutations、actions、getters、modules：其中state就是存储管理变量、mutations类似methods，其中定义一些方法，对状态变量进行操作，但是只能是同步、actions针对异步操作、getters类似于computed，对状态变量进行一些计算或者筛选、modules主要是对state进行分流，随着要管理的变量增加，state会越来越臃肿，但是Vuex要求单一状态树(单一数据源)，所以就可以利用modules进行分模块，每个模块里又可以定义上述state、mutations等；</li>
<li>ES6新语法，对象的解构：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	name: <span class="string">'gsynf'</span>,</span><br><span class="line">	age: <span class="number">18</span>,</span><br><span class="line">	height: <span class="number">1.88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const name = obj.name;</span></span><br><span class="line"><span class="comment">// const age = obj.age;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name, age&#125; = obj</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Vue中发送网络请求有很多方式：<ul>
<li>传统的Ajax是基于XMLHttpRequest（XHR）；</li>
<li>比传统的Ajax更好用的jQuery-Ajax;</li>
<li>官方在Vue1.x时期，推出了Vue-resource；</li>
<li>在宣布Vue-resource不再维护时，推荐了axios；</li>
</ul>
</li>
<li>使用JSONP最主要的原因是为了解决跨域访问的问题；</li>
</ol>
<p><img src="https://i.loli.net/2019/10/17/hoG4mk1qQUCLbf6.png" alt=""></p>
<ol start="8">
<li>axios功能特点：</li>
</ol>
<ul>
<li>在浏览器中发送XMLHttpRequests请求；</li>
<li>在node.js中发送http请求；</li>
<li>支持Promise API；</li>
<li>拦截请求和响应；</li>
<li>转换请求和响应数据；</li>
</ul>
<ol start="9">
<li>axios最基本的使用：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1.基本使用</span><br><span class="line">// axios(config)</span><br><span class="line">axios(&#123;</span><br><span class="line">  url: &apos;httpbin.org/&apos;</span><br><span class="line">  // 默认就是get</span><br><span class="line">  method: &apos;GET&apos;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// axios.get(&apos;httpbin.org/&apos;).then(res =&gt; &#123;</span><br><span class="line">//   console.log(res);</span><br><span class="line">// &#125;)</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>发送并发请求可以使用axios.all([])，传入的参数和返回的结果都是一个数组。传入参数的数组内每个对象就是上述每个单一的axios请求。</li>
<li>axios常见配置选项：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求地址</span><br><span class="line">url: &apos;/user&apos;,</span><br><span class="line"></span><br><span class="line">请求类型</span><br><span class="line">method: &apos;get&apos;,</span><br><span class="line"></span><br><span class="line">请根路径</span><br><span class="line">baseURL: &apos;http://www.mt.com/api&apos;,</span><br><span class="line"></span><br><span class="line">请求前的数据处理</span><br><span class="line">transformRequest:[function(data)&#123;&#125;],</span><br><span class="line"></span><br><span class="line">请求后的数据处理</span><br><span class="line">transformResponse: [function(data)&#123;&#125;],</span><br><span class="line"></span><br><span class="line">自定义的请求头</span><br><span class="line">headers:&#123;&apos;x-Requested-With&apos;:&apos;XMLHttpRequest&apos;&#125;,</span><br><span class="line"></span><br><span class="line">URL查询对象</span><br><span class="line">params:&#123; id: 12 &#125;,</span><br><span class="line"></span><br><span class="line">查询对象序列化函数</span><br><span class="line">paramsSerializer: function(params)&#123; &#125;</span><br><span class="line"></span><br><span class="line">request body</span><br><span class="line">data: &#123; key: &apos;aa&apos;&#125;,</span><br><span class="line"></span><br><span class="line">超时设置s</span><br><span class="line">timeout: 1000,</span><br><span class="line"></span><br><span class="line">跨域是否带Token</span><br><span class="line">withCredentials: false,</span><br><span class="line"></span><br><span class="line">自定义请求处理</span><br><span class="line">adapter: function(resolve, reject, config)&#123;&#125;,</span><br><span class="line"></span><br><span class="line">身份验证信息</span><br><span class="line">auth: &#123; uname: &apos;&apos;, pwd: &apos;12&apos;&#125;,</span><br><span class="line"></span><br><span class="line">响应的数据格式 json / blob /document /arraybuffer / text / stream</span><br><span class="line">responseType: &apos;json&apos;,</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>意识：凡是对第三方框架，都不要在每一个组件内都加入依赖，这样一旦第三方框架停止维护，整个项目的维护将是一个巨大的工程，一般都要将对第三方框架进行一个封装。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// network/request.js</span><br><span class="line">export function request(config) &#123;</span><br><span class="line">    // 1. 创建axios实例</span><br><span class="line">    const instance = axios.create(&#123;</span><br><span class="line">        baseURL: &apos;http://123.207.32.32:8000/api/v1&apos;,</span><br><span class="line">        timeout: 5000</span><br><span class="line">    &#125;)</span><br><span class="line">    // 2.发送真正的网络请求</span><br><span class="line">    return instance(config)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">request(&#123;</span><br><span class="line">  url: &apos;/home/multidata&apos;,</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">  </span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>axios提供了拦截器，用于在发送每次请求或者得到响应后，进行对应的处理；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1 请求拦截</span><br><span class="line">instance.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">    console.log(config);</span><br><span class="line">    // 1.比如config中的一些信息不符合服务器的要求</span><br><span class="line">    // 2.比如每次发送网络请求时，在界面显示一个请求图标</span><br><span class="line">    // 3.某些网络请求，例如登录（token），必须携带一些特殊的信息</span><br><span class="line">    return config</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    console.log(err);   </span><br><span class="line">&#125;);</span><br><span class="line">// 2 响应拦截</span><br><span class="line">instance.interceptors.response.use(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return res.data</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列笔记4</title>
    <url>/2019/10/14/2019-10-14-Vue%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<blockquote>
<p>学习参考：coderwhy教学视频，整个系列可能会比较混乱，学到哪里觉得有需要的记录一下，可能和之前的java笔记类似。</p>
</blockquote>
<ol>
<li>前端渲染和后端渲染/前端路由和后端路由：</li>
</ol>
<ul>
<li>早期，服务器收到URL通过正则进行匹配，交给Controller进行处理，利用JSP等技术，直接生产渲染好对应的HTML页面，不仅有html、css，还有获取数据的java代码，返回给客户端进行展示，这就是后端渲染，在后端处理URL和页面之间的映射关系，即后端路由；</li>
<li>随着Ajax出现，有了前后端分离的开发模式，客户端通过URL发起请求，去静态资源服务器请求资源，请求回的资源包括html+css+js，前两者浏览器进行渲染，js浏览器执行，执行到API接口时，再去请求提供API接口的服务器，请求回之后由其他js代码进行处理，这就是前端渲染；</li>
<li>再发展就是单页面富应用阶段，最主要的特点就是在前后端分离的基础上加了一层前端路由，整个网站只有一个html页面，浏览器向静态资源网站请求时将所有资源全部请求下来，前端路由监听浏览器，当URL改变，就将请求的全部资源进行抽离但不进行页面整体刷新也就是不再进行新的请求，显示该显示的部分，也就是一个网页，这种一个URL和一个网页的映射就是前端路由；</li>
</ul>
<ol start="2">
<li>如何改变URL而页面不刷新呢？有两种方法，一种为利用URL的hash，另一种为html5的history模式。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Console</span><br><span class="line">&gt;location.hash = &apos;foo&apos;</span><br><span class="line">&gt;history.pushState(&#123;&#125;,&apos;&apos;,&apos;foo&apos;) //这个push有点类似于入栈，history.back()或者history.go(-1)或者history.forward()或者浏览器返回类似于出栈</span><br><span class="line">&gt;history.replaceState(&#123;&#125;,&apos;&apos;,&apos;foo&apos;)//很明显，相比于上，这个直接是代替，不会留下history记录</span><br></pre></td></tr></table></figure>

<p>Vue默认使用hash，但是会发现hash的URL会有#，看起来不是很舒服，可以改为history模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;&apos;,</span><br><span class="line">    // redirect 重定向</span><br><span class="line">    redirect: &apos;/home&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/home&apos;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/about&apos;,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;,    </span><br><span class="line">],</span><br><span class="line">mode: &apos;history&apos;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>&lt;router-link&gt;该标签是vue-router中已经内置的一个标签，会被渲染成&lt;a&gt;标签，&lt;router-view&gt;该标签根据当前的路径，动态渲染不同组件，当路由切换，切换的是&lt;router-view&gt;挂载的组件，其他内容不会发送改变。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>&lt;router-link&gt;除了to属性，还有其他属性，例如tag属性，可以决定它会被渲染成除a意外的其他什么组件；replace属性，不会留下history记录，后退返回键不能用，也就是将默认的pushState改为了replaceState；active-class属性，当对应路由匹配成功，某组件会处于活跃状态，会自动给该元素设置一个router-link-active的class，active-class可以改这个class名字，但一般不做修改；</p>
<ol start="4">
<li><p>项目打包后会在dist文件夹下看到static/index.html，其中，static文件夹下有css/js，css文件夹下是将各个vue的css代码进行整合，js文件夹下有三个js文件，分别为app.js/manifest.js/vendor.js，分别是当前应用开发的所有业务代码、为了打包代码做的底层支撑代码、第三方（供应商）代码，如vue/axios/bs等；</p>
</li>
<li><p>随着业务逻辑的增多，会使得打包的app.js越来越大，这样用户请求加载时间变长，所以需要用到懒加载，一般一个vue打包成一个js，用到时才加载</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//router/index.js</span><br><span class="line"></span><br><span class="line">// import Home from &apos;../components/Home.vue&apos;</span><br><span class="line">// import About from &apos;../components/About.vue&apos;</span><br><span class="line">// import User from &apos;../components/User.vue&apos;</span><br><span class="line"></span><br><span class="line">// 懒加载</span><br><span class="line">const Home = () =&gt; import(&apos;../components/Home.vue&apos;)</span><br><span class="line">const About = () =&gt; import(&apos;../components/About.vue&apos;)</span><br><span class="line">const User = () =&gt; import(&apos;../components/User.vue&apos;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>路由传递参数：params类型和query类型</li>
</ol>
<ul>
<li>前者就是动态路由的方法 <ul>
<li>配置路由格式：/router/:id</li>
<li>传递的方式：在path后面跟上对应的值</li>
<li>传递后形成的路径：/router/123，/user/gsynf</li>
</ul>
</li>
<li>后者就是query<ul>
<li>配置路由格式：/router</li>
<li>传递的方式：对象中使用query的key作为传递方式</li>
<li>传递后形成的路径：/router?id=123，/user?id=gsynf</li>
</ul>
</li>
</ul>
<ol start="7">
<li>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免搭环境：它有两个非常重要的属性：<ul>
<li>include-字符串或正则表达式，只有匹配的组件会被缓存</li>
<li>exclude-字符串或正则表达式，任何匹配的组件都不会被缓存</li>
</ul>
</li>
</ol>
<ul>
<li>router-view也是一个组件，如果直接被包在keep-alive里面，所有路径匹配到的视图组件都会被缓存；</li>
</ul>
<ol start="8">
<li>Promise是ES6的新特性，是异步编程的一种解决方案。</li>
<li>什么情况下会用到Promise？一般情况下是有异步操作尤其是比较复杂的数据请求时，使用Promise对这个异步操作进行封装。执行过程，在new Promise时，会执行构造函数，一方面保存了一些状态信息，另一方面会执行传入的函数，在执行传入的回调函数时，会传入两个参数，resolve和reject，这两个参数本身又是函数，一旦调用resolve，就跳到then()，一旦调用reject，就跳到catch()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout((date) =&gt; &#123;</span><br><span class="line">        //请求中，等待状态，pending</span><br><span class="line">        </span><br><span class="line">        // 请求成功，满足状态，fulfill，调用resolve</span><br><span class="line">        resolve(data)</span><br><span class="line">        // 请求失败，拒绝状态，reject，调用reject</span><br><span class="line">        reject(&apos;error message&apos;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">    // 此处处理请求的data</span><br><span class="line">&#125;).catch((error) =&gt; &#123;</span><br><span class="line">    // 此处处理error</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/10/15/YVRXhBEdS3MnfHI.png" alt=""></p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列笔记3</title>
    <url>/2019/10/10/2019-10-10-Vue%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<blockquote>
<p>学习参考：coderwhy教学视频，整个系列可能会比较混乱，学到哪里觉得有需要的记录一下，可能和之前的java笔记类似。</p>
</blockquote>
<ol>
<li>同一个项目中可能有多个js，这样就存在全局变量重名的问题，虽然通过函数闭包可以解决，但是又导致了不同js之间代码不可复用，所以就有了模块化的概念；</li>
<li>常用的模块化规范：CommonJS、AMD、CMD、ES6的Modules;</li>
<li>CommonJS导出写法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//aaa.js</span><br><span class="line">modules.exports = &#123;</span><br><span class="line">	//要导出的部分</span><br><span class="line">	flag,</span><br><span class="line">	sum,</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CommonJS导入写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var/let &#123;flag,sum&#125; = require(&apos;./aaa.js&apos;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>ES6的modules：首先在html代码中要引入js文件，并且类型设置为module，然后在要导出的js文件中使用export指令导出模块对外提供的接口，在要引入的js文件中通过import命令来加载。</li>
<li>遇到本地Ajax跨域报错Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.原因在于使用了File协议，应该使用它提示的http, data, chrome, chrome-extension, https这些协议。使用webstorm或是visual studio这种重量级的IDE，应该不会遇到这种问题，这类IDE都内置了HTTP服务器。针对VSCode，可以安装<strong>Live Server</strong>插件，这个插件功能十分强大，不止可以解决ajax不支持file协议的问题，还可以实现在编辑器里保存修改后，页面自动刷新的功能。</li>
<li>什么是webpack，从本质上讲，webpack是一个现代的JavaScript应用的静态模块打包工具，分两点来讲，就是模块和打包。webpack其中一个核心就是让我们可以进行模块化开发，并且帮助我们处理模块间的依赖关系；打包就是将webpack中的各种资源模块进行打包合并成一个或多个包，并且在打包过程中，还可以对资源进行处理，例如压缩图片，ES5转成ES6等；</li>
</ol>
<p><img src="https://i.loli.net/2019/10/11/I7D6mBGlnfUhOxj.png" alt=""></p>
<ol start="7">
<li><p>grunt/gulp的核心是Task，更加强调的是前端流程的自动化，模块化不是它的核心；webpack更加强调模块化的开发管理，而grunt/gulp的文件压缩合并、预处理、转换等功能只是它附带的功能；</p>
</li>
<li><p>webpack为了正常运行，必须依赖node环境，node环境为了可以正常执行很多代码，其中必须包含各种依赖的包，为了便于安装管理这些包，需要npm（node package manager）工具。</p>
</li>
<li><p>全局安装webpack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack@3.6.0 -g</span><br></pre></td></tr></table></figure>

<p>但是一般情况下，每个项目都要局部安装自己所对应需要的webpack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack@3.6.0 --save-dev</span><br><span class="line">//--save-dev安装的是开发时依赖，而不是运行时依赖，这个安装完成后在package.json可以看出来</span><br><span class="line">//–save 将依赖包名称添加到 package.json 文件的 dependencies 键下</span><br><span class="line">//–save-dev 则添加到 package.json 文件的 devDependencies 键下</span><br></pre></td></tr></table></figure>

<p>然后需要在npm init创建的package.json中加入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;build&quot;: &quot;webpack&quot;</span><br></pre></td></tr></table></figure>

<p>这样，在终端输入npm run dev即可，而且优先使用本地webpack而非全局。</p>
</li>
<li><p>loader是webpack中一个非常核心的概念，webpack可以处理JS代码和相互之间的依赖，但在开发中，不仅仅有基础的JS代码，还有CSS、图片加载、将高级的ES6转化为ES5等，此时就需要给webpack扩展对应的loader：</p>
</li>
</ol>
<ul>
<li>通过npm安装所需要的loader</li>
<li>在webpack.config.js中的modules关键字中进行配置</li>
<li>具体安装什么loader可以在webpack官方文档进行查询</li>
</ul>
<ol start="11">
<li><p>plugin时webpack中另一个重要的核心，webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等，loader主要用于转换某些类型的模块，它是一个转换器，plugin是插件，它是对webpack本身的扩展，是一个扩展器。</p>
</li>
<li><p>webpack配置文件的分离，再weback.config.js中，许多配置只是在开发中用到，在实际发布时并不需要，所以最好将这些配置抽离出来，便于后期管理：</p>
</li>
</ol>
<ul>
<li>创建base.config,js/dev.config.js/prod.config.js，将weback.config.js中内容进行分离，npm install webpack-merge –save-dev安装js合并工具，接下来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//dev.config.js</span><br><span class="line">const WebpackMerge = require(&apos;webpack-merge&apos;)</span><br><span class="line">const baseConfig = require(&apos;./base.config&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = WebpackMerge(baseConfig,&#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      contentBase: &apos;./dist&apos;,</span><br><span class="line">      inline: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在package.json中指定一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;build&quot;: &quot;webpack --config ./build/prod.config.js&quot;,</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ol start="13">
<li><p>使用vue开发大型项目，需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等，为了提高效率，通常会用到一些脚手架工具来帮助完成，CLI是Command-Line Interface，翻译为命令行界面，俗称脚手架。使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置。</p>
</li>
<li><p>e2e–&gt;e to e –&gt;end to end</p>
</li>
<li><p>Vue CLI2新建项目</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/10/12/eTxIybH9tGXiCz4.png" alt=""></p>
<ol start="16">
<li><p>脚手架安装了ESlint如何关闭：config==&gt;index==&gt;useEslint改为false，重新编译一下项目;</p>
</li>
<li><p>Vue程序运行过程</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/10/12/diyYvSRof14FgCI.png" alt=""></p>
<ol start="18">
<li><ul>
<li>runtime-compiler—&gt;代码中可以有template</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// template -&gt; ast -&gt; render -&gt; vdom -&gt; UI</span><br><span class="line">//main.js</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code>* runtime-only---&gt;代码中不可以有任何的template，性能更好，代码量更少，少6KB。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// render -&gt; vdom -&gt; UI</span><br><span class="line">//main.js</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

​    </code></pre><ol start="19">
<li>npm run build/dev具体执行示意</li>
</ol>
<p><img src="https://i.loli.net/2019/10/13/qBbNAZ9kwSX5oml.png" alt=""></p>
<p><img src="C:%5CUsers%5Cgsynf%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1570934287208.png" alt="1570934287208"></p>
<ol start="20">
<li>Vue CLI3 创建项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create my-vue-project</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/10/13/5MzCDKqNBlLSZiG.png" alt=""></p>
<ol start="21">
<li><p>Vue CLI3管理配置文件及其他可以通过vue ui命令启动GUI界面进行可视化管理；</p>
<p>Vue CLI3的配置文件其实并不是没有，而是“隐藏”起来了，在node_modules-&gt;@vue-&gt;cli-service;</p>
<p>若要修改，可在工程目录下创建vue.config.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会自动将手动的配置和默认的配置进行合并。</p>
</li>
<li><p>前端渲染和后端渲染/前端路由和后端路由：</p>
</li>
</ol>
<ul>
<li>早期，服务器收到URL通过正则进行匹配，交给Controller进行处理，利用JSP等技术，直接生产渲染好对应的HTML页面，不仅有html、css，还有获取数据的java代码，返回给客户端进行展示，这就是后端渲染，在后端处理URL和页面之间的映射关系，即后端路由；</li>
<li>随着Ajax出现，有了前后端分离的开发模式，客户端通过URL发起请求，去静态资源服务器请求资源，请求回的资源包括html+css+js，前两者浏览器进行渲染，js浏览器执行，执行到API接口时，再去请求提供API接口的服务器，请求回之后由其他js代码进行处理，这就是前端渲染；</li>
<li>再发展就是单页面富应用阶段，最主要的特点就是在前后端分离的基础上加了一层前端路由，整个网站只有一个html页面，浏览器向静态资源网站请求时将所有资源全部请求下来，前端路由监听浏览器，当URL改变，就将请求的全部资源进行抽离但不进行页面整体刷新也就是不再进行新的请求，显示该显示的部分，也就是一个网页，这种一个URL和一个网页的映射就是前端路由；</li>
</ul>
<ol start="23">
<li>如何改变URL而页面不刷新呢？有两种方法，一种为利用URL的hash，另一种为html5的history模式。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Console</span><br><span class="line">&gt;location.hash = &apos;foo&apos;</span><br><span class="line">&gt;history.pushState(&#123;&#125;,&apos;&apos;,&apos;foo&apos;) //这个push有点类似于入栈，history.back()或者history.go(-1)或者history.forward()或者浏览器返回类似于出栈</span><br><span class="line">&gt;history.replaceState(&#123;&#125;,&apos;&apos;,&apos;foo&apos;)//很明显，相比于上，这个直接是代替</span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列笔记2</title>
    <url>/2019/10/08/2019-10-08-Vue%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<blockquote>
<p>学习参考：coderwhy教学视频，整个系列可能会比较混乱，学到哪里觉得有需要的记录一下，可能和之前的java笔记类似。</p>
</blockquote>
<ol>
<li>如果将一个页面中所有的处理逻辑全部放到一起，处理起来就会变得非常复杂，而且不利于后续管理和扩展；但如果将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，之后整个页面的管理和维护就变得容易许多；</li>
</ol>
<p><img src="https://i.loli.net/2019/10/08/8rs7zERUAZK4eMk.png" alt=""></p>
<ol start="2">
<li>组件化提供了一种抽象，可以开发出一个个独立可复用的小组件来构造应用，任何的应用都会被抽象成一颗组件树；</li>
</ol>
<p><img src="https://i.loli.net/2019/10/08/YZB3fdb4Mcr79Jl.png" alt=""></p>
<ol start="3">
<li>组件的使用可以分成三个步骤：创建组件构造器，注册组件，使用组件；</li>
</ol>
<p><img src="C:%5CUsers%5Cgsynf%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1570496438265.png" alt="1570496438265"></p>
<ol start="4">
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &lt;!DOCTYPE html&gt;</span><br><span class="line">   &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">       &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">       &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">       &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">           &lt;!-- 3.使用组件 --&gt;</span><br><span class="line">           &lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line">           &lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line">           &lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">       &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">       &lt;script&gt;</span><br><span class="line">           //1.创建组件构造器对象</span><br><span class="line">           const cpnContructor = Vue.extend(&#123;</span><br><span class="line">              template: `</span><br><span class="line">                   &lt;div&gt;</span><br><span class="line">                       &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">                       &lt;p&gt;我是内容，哈哈哈哈&lt;/p&gt;</span><br><span class="line">                       &lt;p&gt;我是内容，呵呵呵呵&lt;/p&gt;</span><br><span class="line">                   &lt;/div&gt;`</span><br><span class="line">           &#125;)</span><br><span class="line">           //2.注册组件</span><br><span class="line">           Vue.component(&apos;my-cpn&apos;, cpnContructor)</span><br><span class="line">   </span><br><span class="line">           const app = new Vue(&#123;</span><br><span class="line">               el: &apos;#app&apos;,</span><br><span class="line">               data: &#123;</span><br><span class="line">                   message: &apos;Hello!&apos;,</span><br><span class="line">               &#125;,</span><br><span class="line">   </span><br><span class="line">           &#125;)</span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>Vue.extend()创建的是一个组件构造器，通常在创建组件构造器时，传入template代表我们自定义组件的模板。该模板就是在使用到组件的地方，要显示的HTML代码，事实上，这种写法在Vue 2.x的文档中就几乎看不到了，它会直接使用下面的语法糖，但这种方式是基础。</p>
<p>Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。</p>
<p>组件使用时必须挂载在某个Vue实例下，否则它不会生效。</p>
</li>
<li><p>全局组件和局部组件:上述方法构建的为全局组件。局部组件需要挂载到Vue实例下，只有该实例对应的app才可以使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">           el: &apos;#app&apos;,</span><br><span class="line">           //2.局部组件注册</span><br><span class="line">           components: &#123;</span><br><span class="line">               cpn: cpnC</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>父组件和子组件：要求子组件在父组件中进行注册：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.创建第一个组件构造器(子组件)</span><br><span class="line">        const cpnC1 = Vue.extend(&#123;</span><br><span class="line">            template:`</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是标题1&lt;/h2&gt;</span><br><span class="line">                    &lt;p&gt;我是内容，哈哈哈哈&lt;/p&gt;</span><br><span class="line">                &lt;/div&gt;`</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        //2.创建第二个组件构造器(父组件)</span><br><span class="line">        const cpnC2 = Vue.extend(&#123;</span><br><span class="line">            template:`</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;我是标题2&lt;/h2&gt;</span><br><span class="line">                    &lt;p&gt;我是内容，呵呵呵呵&lt;/p&gt;</span><br><span class="line">                    &lt;cpn1&gt;&lt;/cpn1&gt;</span><br><span class="line">                &lt;/div&gt;`</span><br><span class="line">            ,</span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn1: cpnC1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>组件注册的语法糖，将上述创建组件构造器和注册组件合并：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;cpn1&apos;, &#123;</span><br><span class="line">    template: `</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;我是标题1&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;我是内容，哈哈哈哈&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;`</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>组件模板的抽离写法，可以看出来，上边的js代码中嵌套HTML，看起来比较乱，所以需要抽离，有两种写法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn1&gt;&lt;/cpn1&gt;</span><br><span class="line">        &lt;cpn2&gt;&lt;/cpn2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 1.通过script标签，但是注意类型必须是text/x-template --&gt;</span><br><span class="line">    &lt;script type=&quot;text/x-template&quot; id=&quot;cpn1&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是标题1&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;我是内容，哈哈哈哈&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 2.template标签 --&gt;</span><br><span class="line">   &lt;template id=&quot;cpn2&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;我是标题2&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;我是内容，呵呵呵呵&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(&apos;cpn1&apos;, &#123;</span><br><span class="line">            template: &apos;#cpn1&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">        Vue.component(&apos;cpn2&apos;, &#123;</span><br><span class="line">            template: &apos;#cpn2&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &apos;#app&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>组件中的数据不应该也不能放在全局的data中，应该放在自己的data中，但是需要注意组件的data属性必须是一个函数，且要求返回一个实例对象，对象内部保存着数据。</p>
</li>
<li><p>在开发中，往往一些数据确实需要从上层传到下层，例如在一个页面中，从服务器请求了许多数据，其中一部分数据并非整个页面的大组件来展示，而是需要下面的小组件来展示，这时，并不会让小组件再发一次网络请求，而是让大组件将数据传给小组件，这是就涉及到父子组件之间的通信，有两种方式：通过props向子组件传递数据和通过事件向父组件发送消息。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/10/08/7NDfCeuZXOgqELG.png" alt=""></p>
<ol start="11">
<li>在组件中，使用选项props来声明需要从父级接受的数据。</li>
</ol>
<p>props的值有两种方式：</p>
<p>1）字符串数组，数组中的字符串就是传递时的名称；</p>
<p>2）对象，对象可以设置传递时的类型，也可以设置默认值等；</p>
<p><img src="https://i.loli.net/2019/10/08/kbKwUJmEgjFx9HI.png" alt=""></p>
<ol start="12">
<li>子组件向父组件发送数据：子组件内部先通过&amp;emit()定义发射事件，父组件中监听（类似于系统自带的click等监听），监听到后执行相应的响应函数即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//子组件</span><br><span class="line">            methods: &#123;</span><br><span class="line">                btnClick(item) &#123;</span><br><span class="line">                    //发射事件(自定义事件)</span><br><span class="line">                    this.$emit(&apos;item-click&apos;, item)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">//监听</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;!-- 监听事件 --&gt;</span><br><span class="line">        &lt;cpn @item-click=&quot;cpnClick&quot;&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">//父组件</span><br><span class="line">            methods: &#123;</span><br><span class="line">                cpnClick(item) &#123;</span><br><span class="line">                    console.log(item);                 </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li><p>父子组件的访问：父组件访问子组件使用$children或者$refs；子组件访问父组件使用$parent；子组件访问根组件使用$root</p>
</li>
<li><p>在实际开发中，refs用的比较多一些，因为使用children需要使用下标，但是组件顺序可能会有更改，不利于维护</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;cpn ref=&quot;aaa&quot;&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">………………</span><br><span class="line">            methods: &#123;</span><br><span class="line">            btnClick() &#123;</span><br><span class="line">                // 1.$children</span><br><span class="line">                // console.log(this.$children);</span><br><span class="line">                // this.$children[0].showMessage();</span><br><span class="line">                // console.log(this.$children[1].name);</span><br><span class="line"></span><br><span class="line">                //2.$refs</span><br><span class="line">                this.$refs.aaa.showMessage();</span><br><span class="line">                console.log(this.$refs.aaa.name);  </span><br><span class="line">            &#125;</span><br><span class="line"> ………………</span><br><span class="line">          components: &#123;</span><br><span class="line">            cpn: &#123;</span><br><span class="line">                template: &apos;#cpn&apos;,</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        name: &apos;我是子组件的name&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    showMessage() &#123;</span><br><span class="line">                        console.log(&apos;aaaaaaaa&apos;);</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="15">
<li><p>$parent在实际开发中应用不多，因为组件强调的是复用性，在组件中使用$parent可能会导致其和父组件的耦合度太高。</p>
</li>
<li><p>组件的插槽slot是为了让组件有更强的扩展性，往往需要的一些组件之间有很多区别，但也有很多共性，每个都封装成一个单独的不太合理，将所有的都封装成一个也不合理，这里就需要用到slot，slot就是占位，具体占好位置放什么可以由调用者决定；</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;cpn&gt;</span><br><span class="line">        &lt;p&gt;哦哦哦&lt;/p&gt;</span><br><span class="line">        &lt;i&gt;呵呵呵&lt;/i&gt;</span><br><span class="line">    &lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是组件&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;我是组件，嘿嘿嘿&lt;/p&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ol start="17">
<li>作用域插槽：举例：子组件中包含一组数据，pLanguages: [‘JavaScript’,’Python’,’Java’,’C++’]，要求进行不同的展示效果，例如以列表形式展示，以水平方向展示等等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 默认以列表进行展示 --&gt;</span><br><span class="line">    &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">    &lt;!-- 以水平方式进行展示 --&gt;</span><br><span class="line">    &lt;cpn&gt;</span><br><span class="line">        &lt;!-- 目的是获取子组件的pLanguages --&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;slot&quot;&gt;</span><br><span class="line">            &lt;!-- &lt;span v-for=&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125; ** &lt;/span&gt; --&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123;slot.data.join(&apos; * &apos;)&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/cpn&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cpn&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;slot :data=&quot;pLanguages&quot;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li v-for=&quot;item in pLanguages&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列笔记1</title>
    <url>/2019/09/26/2019-09-26-Vue%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<blockquote>
<p>学习参考：coderwhy教学视频，整个系列可能会比较混乱，学到哪里觉得有需要的记录一下，可能和之前的java笔记类似。</p>
</blockquote>
<ol>
<li>语法糖：简写</li>
</ol>
<p><img src="https://i.loli.net/2019/09/27/DnTr2avz4EOPiAC.png" alt=""></p>
<ol start="2">
<li>MVVM：model，view，viewmodel;</li>
<li>回调函数举例：</li>
</ol>
<p><img src="https://i.loli.net/2019/09/27/b6P58HUcry7tIVR.png" alt=""></p>
<ol start="4">
<li>Vue生命周期</li>
</ol>
<img src="https://i.loli.net/2019/09/27/e7agZw2QWuEcdFn.png" alt="官方图" style="zoom: 50%;" />

<p><img src="https://i.loli.net/2019/09/27/OZzk7YPsFjd16Tb.png" alt="coderwhy的图"></p>
<ol start="5">
<li><p>代码规范：在前端代码中，一般缩进2个空格而非4个；</p>
</li>
<li><p>将data中的数据插入到HTML中，Mustache语法，也就是双大括号；</p>
</li>
<li><p>computed和methods对比：往往会发现，在computed中定义的方法在methods中同样可以定义，那么computed意义何在呢?其实计算属性会进行缓存，如果多次使用，计算属性只会调用一次，而methods每次都会调用；</p>
</li>
<li><p>ES5中，var没有块级作用域，if和for没有作用域，只有函数有作用域；ES6中let有块级作用域，if和for也有作用域；</p>
</li>
<li><p>在ES6开发中，优先使用const，只有在需要改变某一标识符的时候才用let；</p>
</li>
<li><p>什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。</p>
</li>
<li><p>v-if：当条件为false，包含v-if指令的元素，根本就不会存在于dom中，所以推荐在切换频率不高时使用；</p>
<p>v-show：当条件为false，包含v-show指令的元素，只是增加了一个行内元素，display = none，所以推荐在切换频率较高时使用；</p>
</li>
<li><p>官方推荐在使用v-for时，给对应的元素或组件添加一个key属性。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;li v-for=&quot;item in letters&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>过滤器filters，举例将价格由整数变为带￥的两位小数：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">    showPrice(price) &#123;</span><br><span class="line">        return &apos;￥&apos; + price.toFixed(2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总价格：&#123;&#123;totalPrice | showPrice&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="14">
<li><p>编程范式：命令式编程/声明式编程</p>
<p>编程范式：面向对象编程（第一公民：对象）/函数式编程（第一公民：函数）</p>
</li>
<li><p>三个高阶函数：filter、map、reduce</p>
</li>
</ol>
<p>1)）filter过滤函数用于过滤数组中的某部分，传的参数需是一个回调函数，回调函数有一个要求：必须返回一个boolean值，当返回true时，函数内部会自动将这次回调的n加入到新的数组中，当返回false时，函数内部会过滤掉这次的n。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//过滤小于100的数字</span><br><span class="line">const nums = [10,234,50,678,90]</span><br><span class="line">let newNums = nums.filter(function (n) &#123;</span><br><span class="line">	return n &lt; 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2）map映射函数用于对数组中所有元素进行统一操作，传的参数同样是一个回调函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将newNums中的数字全部乘以2</span><br><span class="line">let new2Nums = newNums.map(function(n) &#123;</span><br><span class="line">	return n*2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3）reduce函数用于对数组中所有的内容进行汇总，传的参数至少需要两个，第一个参数同样是一个回调函</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将new2Nums中的数字全部相加</span><br><span class="line">//0就是perValue初始化的值，以后的preValue就是上一次return的值</span><br><span class="line">let total = new2Nums.reduce(function(preValue,n) &#123;</span><br><span class="line">	return preValue + n</span><br><span class="line">&#125;, 0)</span><br></pre></td></tr></table></figure>

<p>以上三部分可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const nums = [10,234,50,678,90]</span><br><span class="line">let total = nums.filter(function (n) &#123;</span><br><span class="line">	return n &lt; 100</span><br><span class="line">&#125;).map(function(n) &#123;</span><br><span class="line">	return n*2</span><br><span class="line">&#125;).reduce(function(preValue,n) &#123;</span><br><span class="line">	return preValue + n</span><br><span class="line">&#125;, 0)</span><br></pre></td></tr></table></figure>

<p>甚至可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const nums = [10,234,50,678,90]</span><br><span class="line">let total = nums.filter(n =&gt; n &lt; 100).map(n =&gt; n*2).reduce((preValue,n) =&gt; preValue + n)</span><br></pre></td></tr></table></figure>



<ol start="14">
<li>vue中使用v-model指令来实现表单元素和数据的双向绑定。所谓双向绑定，就是原来利用 Mustache将内容进行响应式显示，手动更改显示数据无法改变原数据，双向绑定则可以实现。</li>
<li>radio的name相同才会互斥，但是如果v-model绑定相同的，可以不加name。</li>
<li>v-model三个修饰符：lazy、number、trim：</li>
</ol>
<p>1）lazy：默认情况下，v-model是在input事件中同步输入框的数据也就是一旦数据发生改变data中的数据就会自动发生改变，加入lazy修饰符可以让数据在失去焦点或者回车时才更新；</p>
<p>2）number：默认情况下，在输入框无论输入字母还是数字，都会被当作字符串进行处理，number修饰符可以让输入框输入的内容自动转换为数字类型；</p>
<p>3）trim：如果输入的内容首尾有很多空格，通常我们希望将其去除，trim修饰符可以过滤内容左右两边的空格；</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb5</title>
    <url>/2019/09/24/2019-09-24-JavaWeb5/</url>
    <content><![CDATA[<h1 id="创建DrawImage-Servlet"><a href="#创建DrawImage-Servlet" class="headerlink" title="创建DrawImage Servlet"></a>创建DrawImage Servlet</h1><h1 id="一、创建DrawImage-Servlet"><a href="#一、创建DrawImage-Servlet" class="headerlink" title="一、创建DrawImage Servlet"></a>一、创建DrawImage Servlet</h1><p>用来生成验证码图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 package gacl.response.study;</span><br><span class="line">  2 import java.awt.Color;</span><br><span class="line">  3 import java.awt.Font;</span><br><span class="line">  4 import java.awt.Graphics;</span><br><span class="line">  5 import java.awt.Graphics2D;</span><br><span class="line">  6 import java.awt.image.BufferedImage;</span><br><span class="line">  7 import java.io.IOException;</span><br><span class="line">  8 import java.util.Random;</span><br><span class="line">  9 import javax.imageio.ImageIO;</span><br><span class="line"> 10 import javax.servlet.ServletException;</span><br><span class="line"> 11 import javax.servlet.http.HttpServlet;</span><br><span class="line"> 12 import javax.servlet.http.HttpServletRequest;</span><br><span class="line"> 13 import javax.servlet.http.HttpServletResponse;</span><br><span class="line"> 14 /**</span><br><span class="line"> 15  * 生成随机图片，用来作为验证码</span><br><span class="line"> 16  */</span><br><span class="line"> 17 public class DrawImage extends HttpServlet &#123;</span><br><span class="line"> 18     private static final long serialVersionUID = 3038623696184546092L;</span><br><span class="line"> 19     </span><br><span class="line"> 20     public static final int WIDTH = 120;//生成的图片的宽度</span><br><span class="line"> 21     public static final int HEIGHT = 30;//生成的图片的高度</span><br><span class="line"> 22 </span><br><span class="line"> 23     public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line"> 24             throws ServletException, IOException &#123;</span><br><span class="line"> 25         this.doPost(request, response);</span><br><span class="line"> 26     &#125;</span><br><span class="line"> 27 </span><br><span class="line"> 28     public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line"> 29             throws ServletException, IOException &#123;</span><br><span class="line"> 30         String createTypeFlag = request.getParameter(&quot;createTypeFlag&quot;);//接收客户端传递的createTypeFlag标识</span><br><span class="line"> 31         //1.在内存中创建一张图片</span><br><span class="line"> 32         BufferedImage bi = new BufferedImage(WIDTH, HEIGHT,BufferedImage.TYPE_INT_RGB);</span><br><span class="line"> 33         //2.得到图片</span><br><span class="line"> 34         Graphics g = bi.getGraphics();</span><br><span class="line"> 35         //3.设置图片的背影色</span><br><span class="line"> 36         setBackGround(g);</span><br><span class="line"> 37         //4.设置图片的边框</span><br><span class="line"> 38         setBorder(g);</span><br><span class="line"> 39         //5.在图片上画干扰线</span><br><span class="line"> 40         drawRandomLine(g);</span><br><span class="line"> 41         //6.写在图片上随机数</span><br><span class="line"> 42         //String random = drawRandomNum((Graphics2D) g,&quot;ch&quot;);//生成中文验证码图片</span><br><span class="line"> 43         //String random = drawRandomNum((Graphics2D) g,&quot;nl&quot;);//生成数字和字母组合的验证码图片</span><br><span class="line"> 44         //String random = drawRandomNum((Graphics2D) g,&quot;n&quot;);//生成纯数字的验证码图片</span><br><span class="line"> 45         //String random = drawRandomNum((Graphics2D) g,&quot;l&quot;);//生成纯字母的验证码图片</span><br><span class="line"> 46         String random = drawRandomNum((Graphics2D) g,createTypeFlag);//根据客户端传递的createTypeFlag标识生成验证码图片</span><br><span class="line"> 47         //7.将随机数存在session中</span><br><span class="line"> 48         request.getSession().setAttribute(&quot;checkcode&quot;, random);</span><br><span class="line"> 49         //8.设置响应头通知浏览器以图片的形式打开</span><br><span class="line"> 50         response.setContentType(&quot;image/jpeg&quot;);//等同于response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);</span><br><span class="line"> 51         //9.设置响应头控制浏览器不要缓存</span><br><span class="line"> 52         response.setDateHeader(&quot;expries&quot;, -1);</span><br><span class="line"> 53         response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span><br><span class="line"> 54         response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class="line"> 55         //10.将图片写给浏览器</span><br><span class="line"> 56         ImageIO.write(bi, &quot;jpg&quot;, response.getOutputStream());</span><br><span class="line"> 57     &#125;</span><br><span class="line"> 58 </span><br><span class="line"> 59     /**</span><br><span class="line"> 60      * 设置图片的背景色</span><br><span class="line"> 61      * @param g</span><br><span class="line"> 62      */</span><br><span class="line"> 63     private void setBackGround(Graphics g) &#123;</span><br><span class="line"> 64         // 设置颜色</span><br><span class="line"> 65         g.setColor(Color.WHITE);</span><br><span class="line"> 66         // 填充区域</span><br><span class="line"> 67         g.fillRect(0, 0, WIDTH, HEIGHT);</span><br><span class="line"> 68     &#125;</span><br><span class="line"> 69 </span><br><span class="line"> 70     /**</span><br><span class="line"> 71      * 设置图片的边框</span><br><span class="line"> 72      * @param g</span><br><span class="line"> 73      */</span><br><span class="line"> 74     private void setBorder(Graphics g) &#123;</span><br><span class="line"> 75         // 设置边框颜色</span><br><span class="line"> 76         g.setColor(Color.BLUE);</span><br><span class="line"> 77         // 边框区域</span><br><span class="line"> 78         g.drawRect(1, 1, WIDTH - 2, HEIGHT - 2);</span><br><span class="line"> 79     &#125;</span><br><span class="line"> 80 </span><br><span class="line"> 81     /**</span><br><span class="line"> 82      * 在图片上画随机线条</span><br><span class="line"> 83      * @param g</span><br><span class="line"> 84      */</span><br><span class="line"> 85     private void drawRandomLine(Graphics g) &#123;</span><br><span class="line"> 86         // 设置颜色</span><br><span class="line"> 87         g.setColor(Color.GREEN);</span><br><span class="line"> 88         // 设置线条个数并画线</span><br><span class="line"> 89         for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"> 90             int x1 = new Random().nextInt(WIDTH);</span><br><span class="line"> 91             int y1 = new Random().nextInt(HEIGHT);</span><br><span class="line"> 92             int x2 = new Random().nextInt(WIDTH);</span><br><span class="line"> 93             int y2 = new Random().nextInt(HEIGHT);</span><br><span class="line"> 94             g.drawLine(x1, y1, x2, y2);</span><br><span class="line"> 95         &#125;</span><br><span class="line"> 96     &#125;</span><br><span class="line"> 97 </span><br><span class="line"> 98     /**</span><br><span class="line"> 99      * 画随机字符</span><br><span class="line">100      * @param g</span><br><span class="line">101      * @param createTypeFlag</span><br><span class="line">102      * @return</span><br><span class="line">103      * String... createTypeFlag是可变参数，</span><br><span class="line">104      * Java1.5增加了新特性：可变参数：适用于参数个数不确定，类型确定的情况，java把可变参数当做数组处理。注意：可变参数必须位于最后一项</span><br><span class="line">105      */</span><br><span class="line">106     private String drawRandomNum(Graphics2D g,String... createTypeFlag) &#123;</span><br><span class="line">107         // 设置颜色</span><br><span class="line">108         g.setColor(Color.RED);</span><br><span class="line">109         // 设置字体</span><br><span class="line">110         g.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 20));</span><br><span class="line">111         //常用的中国汉字</span><br><span class="line">112         String baseChineseChar = &quot;\u7684\u4e00\u4e86\u662f\u6211\u4e0d\u5728\u4eba\u4eec\u6709\u6765\u4ed6\u8fd9\u4e0a\u7740\u4e2a\u5730\u5230\u5927\u91cc\u8bf4\u5c31\u53bb\u5b50\u5f97\u4e5f\u548c\u90a3\u8981\u4e0b\u770b\u5929\u65f6\u8fc7\u51fa\u5c0f\u4e48\u8d77\u4f60\u90fd\u628a\u597d\u8fd8\u591a\u6ca1\u4e3a\u53c8\u53ef\u5bb6\u5b66\u53ea\u4ee5\u4e3b\u4f1a\u6837\u5e74\u60f3\u751f\u540c\u8001\u4e2d\u5341\u4ece\u81ea\u9762\u524d\u5934\u9053\u5b83\u540e\u7136\u8d70\u5f88\u50cf\u89c1\u4e24\u7528\u5979\u56fd\u52a8\u8fdb\u6210\u56de\u4ec0\u8fb9\u4f5c\u5bf9\u5f00\u800c\u5df1\u4e9b\u73b0\u5c71\u6c11\u5019\u7ecf\u53d1\u5de5\u5411\u4e8b\u547d\u7ed9\u957f\u6c34\u51e0\u4e49\u4e09\u58f0\u4e8e\u9ad8\u624b\u77e5\u7406\u773c\u5fd7\u70b9\u5fc3\u6218\u4e8c\u95ee\u4f46\u8eab\u65b9\u5b9e\u5403\u505a\u53eb\u5f53\u4f4f\u542c\u9769\u6253\u5462\u771f\u5168\u624d\u56db\u5df2\u6240\u654c\u4e4b\u6700\u5149\u4ea7\u60c5\u8def\u5206\u603b\u6761\u767d\u8bdd\u4e1c\u5e2d\u6b21\u4eb2\u5982\u88ab\u82b1\u53e3\u653e\u513f\u5e38\u6c14\u4e94\u7b2c\u4f7f\u5199\u519b\u5427\u6587\u8fd0\u518d\u679c\u600e\u5b9a\u8bb8\u5feb\u660e\u884c\u56e0\u522b\u98de\u5916\u6811\u7269\u6d3b\u90e8\u95e8\u65e0\u5f80\u8239\u671b\u65b0\u5e26\u961f\u5148\u529b\u5b8c\u5374\u7ad9\u4ee3\u5458\u673a\u66f4\u4e5d\u60a8\u6bcf\u98ce\u7ea7\u8ddf\u7b11\u554a\u5b69\u4e07\u5c11\u76f4\u610f\u591c\u6bd4\u9636\u8fde\u8f66\u91cd\u4fbf\u6597\u9a6c\u54ea\u5316\u592a\u6307\u53d8\u793e\u4f3c\u58eb\u8005\u5e72\u77f3\u6ee1\u65e5\u51b3\u767e\u539f\u62ff\u7fa4\u7a76\u5404\u516d\u672c\u601d\u89e3\u7acb\u6cb3\u6751\u516b\u96be\u65e9\u8bba\u5417\u6839\u5171\u8ba9\u76f8\u7814\u4eca\u5176\u4e66\u5750\u63a5\u5e94\u5173\u4fe1\u89c9\u6b65\u53cd\u5904\u8bb0\u5c06\u5343\u627e\u4e89\u9886\u6216\u5e08\u7ed3\u5757\u8dd1\u8c01\u8349\u8d8a\u5b57\u52a0\u811a\u7d27\u7231\u7b49\u4e60\u9635\u6015\u6708\u9752\u534a\u706b\u6cd5\u9898\u5efa\u8d76\u4f4d\u5531\u6d77\u4e03\u5973\u4efb\u4ef6\u611f\u51c6\u5f20\u56e2\u5c4b\u79bb\u8272\u8138\u7247\u79d1\u5012\u775b\u5229\u4e16\u521a\u4e14\u7531\u9001\u5207\u661f\u5bfc\u665a\u8868\u591f\u6574\u8ba4\u54cd\u96ea\u6d41\u672a\u573a\u8be5\u5e76\u5e95\u6df1\u523b\u5e73\u4f1f\u5fd9\u63d0\u786e\u8fd1\u4eae\u8f7b\u8bb2\u519c\u53e4\u9ed1\u544a\u754c\u62c9\u540d\u5440\u571f\u6e05\u9633\u7167\u529e\u53f2\u6539\u5386\u8f6c\u753b\u9020\u5634\u6b64\u6cbb\u5317\u5fc5\u670d\u96e8\u7a7f\u5185\u8bc6\u9a8c\u4f20\u4e1a\u83dc\u722c\u7761\u5174\u5f62\u91cf\u54b1\u89c2\u82e6\u4f53\u4f17\u901a\u51b2\u5408\u7834\u53cb\u5ea6\u672f\u996d\u516c\u65c1\u623f\u6781\u5357\u67aa\u8bfb\u6c99\u5c81\u7ebf\u91ce\u575a\u7a7a\u6536\u7b97\u81f3\u653f\u57ce\u52b3\u843d\u94b1\u7279\u56f4\u5f1f\u80dc\u6559\u70ed\u5c55\u5305\u6b4c\u7c7b\u6e10\u5f3a\u6570\u4e61\u547c\u6027\u97f3\u7b54\u54e5\u9645\u65e7\u795e\u5ea7\u7ae0\u5e2e\u5566\u53d7\u7cfb\u4ee4\u8df3\u975e\u4f55\u725b\u53d6\u5165\u5cb8\u6562\u6389\u5ffd\u79cd\u88c5\u9876\u6025\u6797\u505c\u606f\u53e5\u533a\u8863\u822c\u62a5\u53f6\u538b\u6162\u53d4\u80cc\u7ec6&quot;;</span><br><span class="line">113         //数字和字母的组合</span><br><span class="line">114         String baseNumLetter = &quot;0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">115         //纯数字</span><br><span class="line">116         String baseNum = &quot;0123456789&quot;;</span><br><span class="line">117         //纯字母</span><br><span class="line">118         String baseLetter = &quot;ABCDEFGHJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">119         //createTypeFlag[0]==null表示没有传递参数</span><br><span class="line">120         if (createTypeFlag.length &gt; 0 &amp;&amp; null != createTypeFlag[0]) &#123;</span><br><span class="line">121             if (createTypeFlag[0].equals(&quot;ch&quot;)) &#123;</span><br><span class="line">122                 // 截取汉字</span><br><span class="line">123                 return createRandomChar(g, baseChineseChar);</span><br><span class="line">124             &#125;else if (createTypeFlag[0].equals(&quot;nl&quot;)) &#123;</span><br><span class="line">125                 // 截取数字和字母的组合</span><br><span class="line">126                 return createRandomChar(g, baseNumLetter);</span><br><span class="line">127             &#125;else if (createTypeFlag[0].equals(&quot;n&quot;)) &#123;</span><br><span class="line">128                 // 截取数字</span><br><span class="line">129                 return createRandomChar(g, baseNum);</span><br><span class="line">130             &#125;else if (createTypeFlag[0].equals(&quot;l&quot;)) &#123;</span><br><span class="line">131                 // 截取字母</span><br><span class="line">132                 return createRandomChar(g, baseLetter);</span><br><span class="line">133             &#125;</span><br><span class="line">134         &#125;else &#123;</span><br><span class="line">135             // 默认截取数字和字母的组合</span><br><span class="line">136             return createRandomChar(g, baseNumLetter);</span><br><span class="line">137         &#125;</span><br><span class="line">138         </span><br><span class="line">139         return &quot;&quot;;</span><br><span class="line">140     &#125;</span><br><span class="line">141 </span><br><span class="line">142     /**</span><br><span class="line">143      * 创建随机字符</span><br><span class="line">144      * @param g</span><br><span class="line">145      * @param baseChar</span><br><span class="line">146      * @return 随机字符</span><br><span class="line">147      */</span><br><span class="line">148     private String createRandomChar(Graphics2D g,String baseChar) &#123;</span><br><span class="line">149         StringBuffer sb = new StringBuffer();</span><br><span class="line">150         int x = 5;</span><br><span class="line">151         String ch =&quot;&quot;;</span><br><span class="line">152         // 控制字数</span><br><span class="line">153         for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">154             // 设置字体旋转角度</span><br><span class="line">155             int degree = new Random().nextInt() % 30;</span><br><span class="line">156             ch = baseChar.charAt(new Random().nextInt(baseChar.length())) + &quot;&quot;;</span><br><span class="line">157             sb.append(ch);</span><br><span class="line">158             // 正向角度</span><br><span class="line">159             g.rotate(degree * Math.PI / 180, x, 20);</span><br><span class="line">160             g.drawString(ch, x, 20);</span><br><span class="line">161             // 反向角度</span><br><span class="line">162             g.rotate(-degree * Math.PI / 180, x, 20);</span><br><span class="line">163             x += 30;</span><br><span class="line">164         &#125;</span><br><span class="line">165         return sb.toString();</span><br><span class="line">166     &#125;</span><br><span class="line">167 &#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、在Form表单中使用验证码图片"><a href="#二、在Form表单中使用验证码图片" class="headerlink" title="二、在Form表单中使用验证码图片"></a>二、在Form表单中使用验证码图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"> 2 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</span><br><span class="line"> 3 &lt;html&gt;</span><br><span class="line"> 4   &lt;head&gt;</span><br><span class="line"> 5     &lt;title&gt;在Form表单中使用验证码&lt;/title&gt;</span><br><span class="line"> 6     &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> 7     //刷新验证码</span><br><span class="line"> 8     function changeImg()&#123;</span><br><span class="line"> 9         document.getElementById(&quot;validateCodeImg&quot;).src=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?&quot;+Math.random();</span><br><span class="line">10     &#125;</span><br><span class="line">11     &lt;/script&gt;</span><br><span class="line">12   &lt;/head&gt;</span><br><span class="line">13   </span><br><span class="line">14   &lt;body&gt;</span><br><span class="line">15         &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet&quot; method=&quot;post&quot;&gt;</span><br><span class="line">16             验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt;</span><br><span class="line">17             &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage&quot; id=&quot;validateCodeImg&quot; onclick=&quot;changeImg()&quot;&gt;</span><br><span class="line">18             &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;changeImg()&quot;&gt;看不清，换一张&lt;/a&gt;</span><br><span class="line">19             &lt;br/&gt;</span><br><span class="line">20             &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">21         &lt;/form&gt;</span><br><span class="line">22   &lt;/body&gt;</span><br><span class="line">23 &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>DrawImage Servlet除了可以生成的字母和数字的组合的验证码图片之外，还可以生成汉字，纯数字，纯字母的验证码图片，只需要向DrawImage Servlet传递约定好的生成标识符参数即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"> 2 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</span><br><span class="line"> 3 &lt;html&gt;</span><br><span class="line"> 4   &lt;head&gt;</span><br><span class="line"> 5     &lt;title&gt;在Form表单中使用验证码&lt;/title&gt;</span><br><span class="line"> 6     &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> 7     //刷新验证码</span><br><span class="line"> 8     function changeImg(obj,createTypeFlag)&#123;</span><br><span class="line"> 9         document.getElementById(obj.id).src=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=&quot;+createTypeFlag+&quot;&amp;&quot;+Math.random();</span><br><span class="line">10     &#125;</span><br><span class="line">11     &lt;/script&gt;</span><br><span class="line">12   &lt;/head&gt;</span><br><span class="line">13   </span><br><span class="line">14   &lt;body&gt;</span><br><span class="line">15         &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet&quot; method=&quot;post&quot;&gt;</span><br><span class="line">16             数字字母混合验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt;</span><br><span class="line">17             &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage&quot; id=&quot;validateCodeImg1&quot; onclick=&quot;changeImg(this,&apos;nl&apos;)&quot;&gt;</span><br><span class="line">18             &lt;br/&gt;</span><br><span class="line">19             中文验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt;</span><br><span class="line">20             &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=ch&quot; id=&quot;validateCodeImg2&quot; onclick=&quot;changeImg(this,&apos;ch&apos;)&quot;&gt;</span><br><span class="line">21             &lt;br/&gt;</span><br><span class="line">22             英文验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt;</span><br><span class="line">23             &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=l&quot; id=&quot;validateCodeImg3&quot; onclick=&quot;changeImg(this,&apos;l&apos;)&quot;&gt;</span><br><span class="line">24             &lt;br/&gt;</span><br><span class="line">25             数字验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt;</span><br><span class="line">26             &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=n&quot; id=&quot;validateCodeImg4&quot; onclick=&quot;changeImg(this,&apos;n&apos;)&quot;&gt;</span><br><span class="line">27             &lt;br/&gt;</span><br><span class="line">28             &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">29         &lt;/form&gt;</span><br><span class="line">30   &lt;/body&gt;</span><br><span class="line">31 &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="三、服务器端对form表单提交上来的验证码处理"><a href="#三、服务器端对form表单提交上来的验证码处理" class="headerlink" title="三、服务器端对form表单提交上来的验证码处理"></a><strong>三、服务器端对form表单提交上来的验证码处理</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 package gacl.response.study;</span><br><span class="line"> 2 import java.io.IOException;</span><br><span class="line"> 3 import javax.servlet.ServletException;</span><br><span class="line"> 4 import javax.servlet.http.HttpServlet;</span><br><span class="line"> 5 import javax.servlet.http.HttpServletRequest;</span><br><span class="line"> 6 import javax.servlet.http.HttpServletResponse;</span><br><span class="line"> 7 /**</span><br><span class="line"> 8  * @author gacl</span><br><span class="line"> 9  * 服务器端接收到验证码后的处理</span><br><span class="line">10  */</span><br><span class="line">11 public class CheckServlet extends HttpServlet &#123;</span><br><span class="line">12     public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">13             throws ServletException, IOException &#123;</span><br><span class="line">14         String clientCheckcode = request.getParameter(&quot;validateCode&quot;);//接收客户端浏览器提交上来的验证码</span><br><span class="line">15         String serverCheckcode = (String) request.getSession().getAttribute(&quot;checkcode&quot;);//从服务器端的session中取出验证码</span><br><span class="line">16         if (clientCheckcode != null &amp;&amp; serverCheckcode != null &amp;&amp; clientCheckcode.equals(serverCheckcode)) &#123;//将客户端验证码和服务器端验证比较，如果相等，则表示验证通过</span><br><span class="line">17             System.out.println(&quot;验证码验证通过！&quot;);</span><br><span class="line">18         &#125;else &#123;</span><br><span class="line">19             System.out.println(&quot;验证码验证失败！&quot;);</span><br><span class="line">20         &#125;</span><br><span class="line">21     &#125;</span><br><span class="line">22 </span><br><span class="line">23     public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">24             throws ServletException, IOException &#123;</span><br><span class="line">25         doGet(request, response);</span><br><span class="line">26     &#125;</span><br><span class="line">27 </span><br><span class="line">28 &#125;</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb4</title>
    <url>/2019/09/23/2019-09-23-JavaWeb4/</url>
    <content><![CDATA[<h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><p>会话可以简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。</p>
<p>每个用户与服务器进行交互的过程中，各自会有一些数据，程序要想办法保存每个用户的数据。可以通过两种方式：Cookie/Session。</p>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器，当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去，这样，web资源处理的就是用户各自的数据了。</p>
<p>javax.servlet.http.Cookie类用于创建以一个Cookie，response接口中也定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段，同样，request接口中也定义了一个getCookie方法，它用于获取客户端提交的Cookie。</p>
<h2 id="显示上次访问时间并可清除"><a href="#显示上次访问时间并可清除" class="headerlink" title="显示上次访问时间并可清除"></a>显示上次访问时间并可清除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PrintWrite out = response.getWrite();</span><br><span class="line">out.print(&quot;&lt;a href=&apos;/ProjectName/servlet/DeleteCookieServlet&apos;&gt;清除上次访问时间&lt;/a&gt;&lt;br/&gt;&quot;);</span><br><span class="line">out.print(&quot;您上次访问时间是：&quot;);</span><br><span class="line">//获得用户的时间cookie</span><br><span class="line">Cookie cookies[] = request.getCookie();</span><br><span class="line">for(int i=0;cookies != null &amp;&amp; i &lt; cookies.length;i++)&#123;</span><br><span class="line">	if(cookies[i].getName().equals(&quot;lastAccessTime&quot;))&#123;</span><br><span class="line">		long cookieValue = Long.parseLong(cookies.getValue());		//得到用户上次访问时间</span><br><span class="line">		Date date = new Date(cookieValue);</span><br><span class="line">		out.print(date.toLocalString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//给用户回送最新的访问时间</span><br><span class="line">Cookie cookie = new Cookie(&quot;lastAccessTime&quot;,System.currentTimeMillis()+&quot;&quot;);</span><br><span class="line">cookie.setMaxAge(1*30*24*3600);		//一个月期限</span><br><span class="line">cookie.setPath(&quot;/ProjectName&quot;);		//访问网站下所以资源都带cookie来</span><br><span class="line"></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">//DeleteCookieServlet</span><br><span class="line">Cookie cookie = new Cookie(&quot;lastAccessTime&quot;,System.currentTimeMillis()+&quot;&quot;);</span><br><span class="line">cookie.setMaxAge(0);		</span><br><span class="line">cookie.setPath(&quot;/ProjectName&quot;);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">response.sendRedirect(&quot;/ProjectName/servlet/CookieDemoServlet&quot;);</span><br></pre></td></tr></table></figure>

<p>tip：如果创建了一个cookie，并将它发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器内存 中），用户退出浏览器之后即被删除，若希望浏览器将该cookie存储在硬盘上，需使用setMaxAge，并给出一个以秒为单位的时间，将最大失效设为0则是命令浏览器删除该cookie，注意删除cookie时，path必须一致，否则不会删除。</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session是服务器端技术，利这个技术，服务器在运行时可以为每一个用户的浏览器创建一个独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其他资源时，其他web资源再从用户各自的session中取出数据为用户服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//buySession</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(&quot;name&quot;,&quot;洗衣机&quot;);</span><br><span class="line">------------------------------------------------------</span><br><span class="line">//paySession</span><br><span class="line">PrintWrite out = response.getWrite();</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">String product = session.getAttribute(&quot;name&quot;);</span><br><span class="line">out.write(&quot;您购买的商品为：&quot; + product);</span><br></pre></td></tr></table></figure>

<p>session对象在调用getSession方法时创建，在30分钟内没有再次使用，浏览器会自动销毁，手动摧毁使用invalidate()方法即可。</p>
<h2 id="session工作原理"><a href="#session工作原理" class="headerlink" title="session工作原理"></a>session工作原理</h2><p>session工作是基于cookie的。服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。</p>
<p><img src="https://i.loli.net/2019/09/23/7JlrZYh8SNizCe5.png" alt=""></p>
<p>现在有个问题，Sun公司在设计getSession方法时，默认使用cookie没有使用期限，也就是随着浏览器关闭，cookie也就销毁，也就意味着标识每一个session的唯一ID被销毁，这样就无法使session存留30分钟。</p>
<p>解决办法：</p>
<p>在获得session之后获取到ID号，重写对应的cookie，覆盖掉本来的即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">String sessionid = session.getId();</span><br><span class="line">Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionid);</span><br><span class="line">cookie.setPath(&quot;/ProjectName&quot;);</span><br><span class="line">cookie.setMaxAge(30*60);		</span><br><span class="line"></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<h2 id="防止表单重复提交"><a href="#防止表单重复提交" class="headerlink" title="防止表单重复提交"></a>防止表单重复提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//form.jsp</span><br><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Form表单&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DoFormServlet&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//DoFormServlet</span><br><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Form表单&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DoFormServlet&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>但是会有如下三种情况的表单重复提交：</p>
<ol>
<li>在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交；</li>
<li>表单提交后用户点击【刷新】按钮导致表单重复提交；</li>
<li>用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交；</li>
</ol>
<p>解决方案：</p>
<ol>
<li>利用JavaScript防止表单重复提交</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Form表单&lt;/title&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var isCommitted = false;//表单是否已经提交标识，默认为false</span><br><span class="line">        function dosubmit()&#123;</span><br><span class="line">            if(isCommitted==false)&#123;</span><br><span class="line">                isCommitted = true;//提交表单后，将表单是否已经提交标识设置为true</span><br><span class="line">                return true;//返回true让表单正常提交</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;//返回false那么表单将不提交</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DoFormServlet&quot; onsubmit=&quot;return dosubmit()&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>或者，表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dosubmit()&#123;</span><br><span class="line">    //获取表单提交按钮</span><br><span class="line">    var btnSubmit = document.getElementById(&quot;submit&quot;);</span><br><span class="line">    //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮</span><br><span class="line">    btnSubmit.disabled= &quot;disabled&quot;;</span><br><span class="line">    //返回true让表单可以正常提交</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题。</p>
<ol start="2">
<li>利用Session防止表单重复提交</li>
</ol>
<p>具体的做法：<strong>在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。</strong><br>　　在下列情况下，服务器程序将拒绝处理用户提交的表单请求：</p>
<ol>
<li><strong>存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。</strong></li>
<li><strong>当前用户的Session中不存在Token(令牌)。</strong></li>
<li><strong>用户提交的表单数据中没有Token(令牌)。</strong></li>
</ol>
<p>首先，创建FormServlet，用于生成<strong>Token(令牌)</strong>和跳转到form.jsp页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package xdp.gacl.session;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">public class FormServlet extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = -884689940866074733L;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        String token = TokenProccessor.getInstance().makeToken();//创建令牌</span><br><span class="line">        System.out.println(&quot;在FormServlet中生成的token：&quot;+token);</span><br><span class="line">        request.getSession().setAttribute(&quot;token&quot;, token);  //在服务器使用session保存token(令牌)</span><br><span class="line">        request.getRequestDispatcher(&quot;/form.jsp&quot;).forward(request, response);//跳转到form.jsp页面</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在form.jsp中使用隐藏域来存储<strong>Token(令牌)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;form表单&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DoFormServlet&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;%--使用隐藏域存储生成的token--%&gt;</span><br><span class="line">        &lt;%--</span><br><span class="line">            &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;) %&gt;&quot;&gt;</span><br><span class="line">        --%&gt;</span><br><span class="line">        &lt;%--使用EL表达式取出存储在session中的token--%&gt;</span><br><span class="line">        &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;$&#123;token&#125;&quot;/&gt; </span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; </span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>DoFormServlet处理表单提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package xdp.gacl.session;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">public class DoFormServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">                throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">            boolean b = isRepeatSubmit(request);//判断用户是否是重复提交</span><br><span class="line">            if(b==true)&#123;</span><br><span class="line">                System.out.println(&quot;请不要重复提交&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            request.getSession().removeAttribute(&quot;token&quot;);//移除session中的token</span><br><span class="line">            System.out.println(&quot;处理用户提交请求！！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * 判断客户端提交上来的令牌和服务器端生成的令牌是否一致</span><br><span class="line">         * @param request</span><br><span class="line">         * @return </span><br><span class="line">         *         true 用户重复提交了表单 </span><br><span class="line">         *         false 用户没有重复提交表单</span><br><span class="line">         */</span><br><span class="line">        private boolean isRepeatSubmit(HttpServletRequest request) &#123;</span><br><span class="line">            String client_token = request.getParameter(&quot;token&quot;);</span><br><span class="line">            //1、如果用户提交的表单数据中没有token，则用户是重复提交了表单</span><br><span class="line">            if(client_token==null)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            //取出存储在Session中的token</span><br><span class="line">            String server_token = (String) request.getSession().getAttribute(&quot;token&quot;);</span><br><span class="line">            //2、如果当前用户的Session中不存在Token(令牌)，则用户是重复提交了表单</span><br><span class="line">            if(server_token==null)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            //3、存储在Session中的Token(令牌)与表单提交的Token(令牌)不同，则用户是重复提交了表单</span><br><span class="line">            if(!client_token.equals(server_token))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成Token的工具类TokenProccessor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package xdp.gacl.session;</span><br><span class="line"></span><br><span class="line">import java.security.MessageDigest;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">public class TokenProccessor &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     *单例设计模式（保证类的对象在内存中只有一个）</span><br><span class="line">     *1、把类的构造函数私有</span><br><span class="line">     *2、自己创建一个类的对象</span><br><span class="line">     *3、对外提供一个公共的方法，返回类的对象</span><br><span class="line">     */</span><br><span class="line">    private TokenProccessor()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static final TokenProccessor instance = new TokenProccessor();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 返回类的对象</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static TokenProccessor getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 生成Token</span><br><span class="line">     * Token：Nv6RRuGEVvmGjB+jimI/gw==</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String makeToken()&#123;  //checkException</span><br><span class="line">        //  7346734837483  834u938493493849384  43434384</span><br><span class="line">        String token = (System.currentTimeMillis() + new Random().nextInt(999999999)) + &quot;&quot;;</span><br><span class="line">        //数据指纹   128位长   16个字节  md5</span><br><span class="line">        try &#123;</span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(&quot;md5&quot;);</span><br><span class="line">            byte md5[] =  md.digest(token.getBytes());</span><br><span class="line">            //base64编码--任意二进制编码明文字符   adfsdfsdfsf</span><br><span class="line">            BASE64Encoder encoder = new BASE64Encoder();</span><br><span class="line">            return encoder.encode(md5);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式处理表单重复提交，可以解决上述的场景二和场景三中出现的表单重复提交问题。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb3</title>
    <url>/2019/09/20/2019-09-20-JavaWeb3/</url>
    <content><![CDATA[<h1 id="response"><a href="#response" class="headerlink" title="response"></a>response</h1><h2 id="response的OutputStream输出数据"><a href="#response的OutputStream输出数据" class="headerlink" title="response的OutputStream输出数据"></a>response的OutputStream输出数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String data = &quot;中国&quot;;</span><br><span class="line">OutputStream out = response.getOutputStream();		//字节流</span><br><span class="line">out.write(data.getByte());		//这样在浏览器显示是正确的</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">out.write(data.getBytes(“UTF-8&quot;);	//这样浏览器反而显示乱码</span><br><span class="line">//原因：浏览器拿到response解析时默认用的码表时GB2312，并不是UTF-8，所以可以修改浏览器的码表，但实际开发显然不会这样做，需要在响应头指定码表。(新版谷歌浏览器默认UTF-8且无法更换)</span><br><span class="line">response.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">String data =……</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>

<p>或者利用html的meta标签模拟一个HTTP响应头，来控制浏览器行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">out.write(&quot;&lt;meta http-equiv=&apos;Content-type&apos; content=&apos;text/html;charset=UTF-8&apos;&gt;&quot;.getBytes());</span><br></pre></td></tr></table></figure>

<h2 id="response的Writer输出数据"><a href="#response的Writer输出数据" class="headerlink" title="response的Writer输出数据"></a>response的Writer输出数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String data = &quot;中国&quot;;</span><br><span class="line">PrintWriter out = response.getWriter();		//字符流</span><br><span class="line">out.write(data);		//这样在浏览器显示??</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">//原因：servlet将“中国”写入response，response默认使用ISO8859码表，在码表中找“中国”，无法找到，所以返回两个“？”对应的数字，浏览器拿到response返回的数字解析显示“？”，所以修改response码表即可。</span><br><span class="line">response.setCharacterEncoding(“UTF-8&quot;);</span><br><span class="line">response.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">String data =……</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>

<h2 id="response下载文件"><a href="#response下载文件" class="headerlink" title="response下载文件"></a>response下载文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String path = this.getServletContext().getRealPath(&quot;/download/1.jpg&quot;);	//得到资源文件1.jpg在硬盘中的地址</span><br><span class="line">String filename = path.substring(path.lastIndexOf(&quot;\\&quot;)+1);		//截取文件名</span><br><span class="line">response.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot; + filename);	//告诉浏览器下载文件</span><br><span class="line">//如果下载文件中是中文文件，需要经过URL编码</span><br><span class="line">//response.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot; + URLEncoder.encode(filename, &quot;UTF-8&quot;);</span><br><span class="line">//读资源文件</span><br><span class="line">InputStream in = null;</span><br><span class="line">OutputStream out = null;</span><br><span class="line">try&#123;</span><br><span class="line">	in =  new FileInputStream(path);</span><br><span class="line">	int len = 0;</span><br><span class="line">	byte buffer[] = new byte[1024];</span><br><span class="line">	out = response.getOutputStream();</span><br><span class="line">	while((len = in.read(buffer)) &gt; 0) (</span><br><span class="line">		out.write(buffer, 0, len);</span><br><span class="line">	)</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">	if (in != null) &#123;</span><br><span class="line">		try(</span><br><span class="line">			in.close();</span><br><span class="line">		)catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (out != null) &#123;</span><br><span class="line">		try(</span><br><span class="line">			out.close();</span><br><span class="line">		)catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="response控制浏览器定时刷新"><a href="#response控制浏览器定时刷新" class="headerlink" title="response控制浏览器定时刷新"></a>response控制浏览器定时刷新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;refersh&quot;,3);	//每隔3s刷新一次</span><br></pre></td></tr></table></figure>

<p>实际开发中，一般这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String message = &quot;&lt;meta http-squiv=&apos;refresh&apos; content=&apos;3;url=/ProjectName/index.jsp&apos;&gt;恭喜你，登陆成功，本浏览器将在3s后跳转到主页面&quot;;</span><br><span class="line">this.getServletContext().setAttribute(&quot;message&quot;,message);</span><br><span class="line">this.getServletContext().getRequestDispatcher(&quot;/message.jsp&quot;).forward(request,response);</span><br></pre></td></tr></table></figure>

<h2 id="response控制浏览器缓存"><a href="#response控制浏览器缓存" class="headerlink" title="response控制浏览器缓存"></a>response控制浏览器缓存</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setDateHeader(&quot;expires&quot;, System.currentTimeMillis()+1000*3600);	//缓存1h</span><br></pre></td></tr></table></figure>

<h2 id="response实现请求重定向"><a href="#response实现请求重定向" class="headerlink" title="response实现请求重定向"></a>response实现请求重定向</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setStatus(302);	</span><br><span class="line">response.setHeader(&quot;location&quot;, &quot;/ProjectName/index.jsp&quot;);	//重定向到首页</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">response.setRedirect(&quot;/ProjectName/index.jsp&quot;);	//相当于上边两句</span><br></pre></td></tr></table></figure>

<p>重定向向服务器发送两次请求，通过浏览器地址栏自动改变就可以看出来，这样对服务器压力较大，所以除了登录跳转和购物下单跳转购物车一般不介意采用。</p>
<h2 id="response一些细节"><a href="#response一些细节" class="headerlink" title="response一些细节"></a>response一些细节</h2><ol>
<li><p>getOutputStream()和getWriter()方法分别用于得到输出二进制数据、输出文本数据的ServletOutputStream、Printwriter对象，这两个方法互斥，调用了其中一个就不能调用另一个；</p>
</li>
<li><p>Servlet程序向ServletOutputStream或Printwriter对象写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端；</p>
</li>
<li><p>Servlet的service方法结束后，Servlet引擎将检查getWriter()或getOutputStream()方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关于该输出流对象；</p>
</li>
</ol>
<h1 id="request"><a href="#request" class="headerlink" title="request"></a>request</h1><p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求投中的所有信息都封装在这个对象中，开发人员通过这个对象的方法，可以获得客户端的信息。</p>
<h2 id="RUL和URI"><a href="#RUL和URI" class="headerlink" title="RUL和URI"></a>RUL和URI</h2><p>URL：用于标识某个互联网资源，如<a href="http://www.sina.com/news/1.html；" target="_blank" rel="noopener">http://www.sina.com/news/1.html；</a></p>
<p>URI：用于标识某个资源，如/news/1.html；C:\abc\d.txt；</p>
<p>判断这两个区别的用处：权限拦截、访问次数统计等</p>
<h2 id="request获取请求头和请求数据"><a href="#request获取请求头和请求数据" class="headerlink" title="request获取请求头和请求数据"></a>request获取请求头和请求数据</h2><p>获取请求头：request.getHeader()/request.getHeaders()/request.getHeaderNames()；</p>
<p>获取客户端带来的数据：</p>
<p>首先，客户端一般有两种方式带数据</p>
<p>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//通过超链接</span><br><span class="line">&lt;a href=&quot;RequestDemo?username=xxx&quot;&gt;点我&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//通过表单</span><br><span class="line">&lt;form action=&quot;RequestDemo&quot; method=&quot;post&quot;&gt;</span><br><span class="line">	用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;</span><br><span class="line">	&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>request获取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String value = request.getParameter(&quot;username&quot;);</span><br><span class="line">//tip:获取请求数据要先检查再使用，如先判断输入是否为空或者是否为空格</span><br><span class="line">if(value != null &amp;&amp; !value,trim().equals(&quot;&quot;))&#123;</span><br><span class="line">	System.out.println(values);</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------</span><br><span class="line">//所有name和对应的value</span><br><span class="line">Enumeration e = request.getParameterNames();</span><br><span class="line">while(e.hasMoreElements()) &#123;</span><br><span class="line">	String name = (String)e.nextElement();</span><br><span class="line">	value = request.getParameter(name);</span><br><span class="line">	System.out.println(name+&quot;=&quot;+value);	</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------</span><br><span class="line">//一个name的所有value</span><br><span class="line">String[] values = request.getParameterValues(“username”)；</span><br><span class="line">for(int i = 0;values != null &amp;&amp; i &lt; values.length;i++)&#123;</span><br><span class="line">	System.out.println(values[i]);	</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">//存到Map中</span><br><span class="line">//需要首先先建好一个User.java的对象</span><br><span class="line">Map map = request.getParameterMap();</span><br><span class="line">User user = new User();</span><br><span class="line">//需要导入commons-beanutils.jar和commons-logging,jar</span><br><span class="line">BeanUtils.populate(user,map);</span><br><span class="line">//有异常try……catch……</span><br><span class="line">System.out.println(user);</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">//流的方式，但即使获取到也需要解析，因为获取到的格式为“uername=xxx&amp;password=yyy”</span><br><span class="line">InputStream in = request.getInputStream();</span><br><span class="line">int len = 0;</span><br><span class="line">byte buffer[] = new byte[1024];</span><br><span class="line">while((len=in.read(buffer))&gt;0)&#123;</span><br><span class="line">	System.out.println(new String(buffer,0,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="request中文乱码"><a href="#request中文乱码" class="headerlink" title="request中文乱码"></a>request中文乱码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(&quot;UTF-8&quot;);		//只对post提交有效</span><br><span class="line">username = new String(username.getBytes(&quot;iso8859-1&quot;),&quot;UTF-8&quot;);	//解决get提交乱码</span><br></pre></td></tr></table></figure>

<h2 id="request实现请求转发"><a href="#request实现请求转发" class="headerlink" title="request实现请求转发"></a>request实现请求转发</h2><p>请求转发指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。</p>
<p>request对象提供了一个getRequestDispatcher方法，该方法返回一个 RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String data = &quot;aaaaa&quot;;</span><br><span class="line">request.setAttribute(&quot;data&quot;,data);</span><br><span class="line">request.getRequestDispatcher(&quot;/1.jsp&quot;).forward(request，response);</span><br></pre></td></tr></table></figure>

<p>request对象同时也是一个域对象，开发人员通过request对象在实现转发时，把数据通过request对象带给其他web资源处理。</p>
<p>MVC：model-javabean;view-jsp;controller-servlet，流程：jsp收到请求产生数据，数据通过JavaBean封装，JavaBean不适合做输出，会存在request域，jsp再从request中取出进行输出。</p>
<p>细节一：</p>
<p>如果在调用forward方法之前，在servlet程序中写入的部分内容已经被真正的传送到了客户端，forward方法将抛出IIIegalStateException异常，例如。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">	request.getRequestDispatcher(&quot;/1.jsp&quot;).forward(request，response);</span><br><span class="line">&#125;</span><br><span class="line">request.getRequestDispatcher(&quot;/2.jsp&quot;).forward(request，response);</span><br><span class="line">//解决方案：在第一个forward后加入return;</span><br></pre></td></tr></table></figure>

<p>细节二：</p>
<p>如果在调用forward方法之前向servlet引擎的缓冲区，即response中写入了客户端，只要写入到缓冲区中的内容还没有被真正输出到客户端，forward方法就可以被正常执行，原来写入response的内容将被清空，但是，已写入到HttpServletResponse对象中的响应头字段信息保持有效。</p>
<p>细节三：</p>
<p>RequestDispatcher对象除了forward方法之外还有一个方法，include方法，例如。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//例如，每个界面的头脚都一样，单独写一个head.jsp和foot.jsp，在需要的界面引用即可</span><br><span class="line">request.getRequestDispatcher(&quot;/head.jsp&quot;).include(request，response);</span><br><span class="line">response.getWriter().write(&quot;aaaaa&quot;);</span><br><span class="line">request.getRequestDispatcher(&quot;/foot.jsp&quot;).include(request，response);</span><br><span class="line">//注意被包含的页面，也就是head.jsp和foot.jsp不要包含全局架构标签</span><br></pre></td></tr></table></figure>

<h1 id="web工程各类地址写法"><a href="#web工程各类地址写法" class="headerlink" title="web工程各类地址写法"></a>web工程各类地址写法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.</span><br><span class="line">request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request，response);</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">response.sendRedirect(&quot;/ProjectName/index.jsp&quot;);</span><br><span class="line"></span><br><span class="line">//3.</span><br><span class="line">this.getServletContext().getRealPath(&quot;/index.jsp&quot;);</span><br><span class="line"></span><br><span class="line">//4.</span><br><span class="line">this.getServletContext().getResourceAsStream(&quot;/index.jsp&quot;);</span><br><span class="line"></span><br><span class="line">//5.</span><br><span class="line">/*</span><br><span class="line">&lt;a href=&quot;/ProjectName/index.jsp&quot;&gt;点击&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;/ProjectName/index.jsp&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>写地址先写一个斜杠(/)，如果地址是写给服务器用的，这个斜杠就代表web应用；如果地址是写给浏览器的，这个斜杠就代表网站；</p>
<h1 id="利用referer防盗链"><a href="#利用referer防盗链" class="headerlink" title="利用referer防盗链"></a>利用referer防盗链</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String referer = request.getHeader(&quot;referer&quot;);		//获得访问链接</span><br><span class="line">//判断如果是盗链者跳转到首页</span><br><span class="line">if(referer==null || referer.startsWith(&quot;https://localhost&quot;))&#123;</span><br><span class="line">	response.sendRedirect(&quot;/ProjectName/index.jsp&quot;);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装JDK以及多个Tomcat服务器</title>
    <url>/2019/09/17/2019-09-17-Centos%E5%AE%89%E8%A3%85JDK%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AATomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一、JDK"><a href="#一、JDK" class="headerlink" title="一、JDK"></a>一、JDK</h1><p>下载地址:<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p> 注意下载版本   　　  linux环境下    jdkxxxxxx_bin.tar.gz</p>
<p>通过Xftp登陆时注意新建一个root用户的会话，否则一会儿文件无法传输。</p>
<p>配置环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//进入root</span><br><span class="line">su root </span><br><span class="line">password:</span><br><span class="line">mkdir     /usr/local/java</span><br><span class="line">//通过Xftp将下载好的tar.gz压缩包传到新建的这个文件夹下</span><br><span class="line">//进入文件夹</span><br><span class="line">cd /usr/local/java</span><br><span class="line">//解压</span><br><span class="line">tar -zxvf jdk..._bin.tar.gz</span><br><span class="line">//可删可不删   随意</span><br><span class="line">rm -rf jdk..._bin.tar.gz </span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line">//在最下面加上如下配置，注意JAVA_HOME路径即解压好的jdk路径</span><br><span class="line">//键盘 按i 输入或复制以下内容</span><br><span class="line">#java config</span><br><span class="line">JAVA_HOME=/usr/local/java/jdk-11.0.4</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">//最后    esc +   :wq    保存退出</span><br><span class="line"></span><br><span class="line">//让配置立即生效  或者重启服务器也行</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>验证JDK是否安装成功，在命令行，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p>回车，若打印出JDK版本，则成功。</p>
<h1 id="二、安装多个Tomcat服务器"><a href="#二、安装多个Tomcat服务器" class="headerlink" title="二、安装多个Tomcat服务器"></a>二、安装多个Tomcat服务器</h1><p>下载地址：<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a></p>
<p>上传、解压和刚才基本相同，这里放在了/usr/local/tomcat/tomcat1和/usr/local/tomcat/tomcat2。</p>
<h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>同样是操作/etc/profile 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#vi  /etc/profile</span><br></pre></td></tr></table></figure>

<p>然后在文件最后一行，即刚刚添加JDK环境变量的后边添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#tomcat1</span><br><span class="line">export CATALINA_HOME1=/usr/local/tomcat/tomcat1/apache-tomcat-8.5.45</span><br><span class="line">export CATALINA_BASE1=/usr/local/tomcat/tomcat1/apache-tomcat-8.5.45</span><br><span class="line">export TOMCAT_HOME1=/usr/local/tomcat/tomcat1/apache-tomcat-8.5.45</span><br><span class="line"></span><br><span class="line">#tomcat2</span><br><span class="line">export CATALINA_HOME2=/usr/local/tomcat/tomcat2/apache-tomcat-8.5.45</span><br><span class="line">export CATALINA_BASE2=/usr/local/tomcat/tomcat2/apache-tomcat-8.5.45</span><br><span class="line">export TOMCAT_HOME2=/usr/local/tomcat/tomcat2/apache-tomcat-8.5.45</span><br></pre></td></tr></table></figure>

<p>最后    esc +   :wq    保存退出，source /etc/profile  配置立即生效。</p>
<h2 id="修改tomcat1-2中的server-xml文件"><a href="#修改tomcat1-2中的server-xml文件" class="headerlink" title="修改tomcat1/2中的server.xml文件"></a>修改tomcat1/2中的server.xml文件</h2><p>tomcat1：修改tomcat1的server.xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、修改Server prot 默认为8005－－》修改为8001</span><br><span class="line"></span><br><span class="line">&lt;Server port=&quot;8001&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;</span><br><span class="line">  &lt;!-- Security listener. Documentation at /docs/config/listeners.html</span><br><span class="line">  --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、修改Connector port HTTP/1.1  默认为8080－－》修改为8081</span><br><span class="line"></span><br><span class="line">&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">connectionTimeout=&quot;20000&quot;</span><br><span class="line">redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、修改Connector port AJP/1.3 默认为8009－－》修改为8011</span><br><span class="line"></span><br><span class="line">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span><br><span class="line">    &lt;Connector port=&quot;8011&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>同样，修改tomcat2的server.xml文件，3个端口号分别修改为8002，8082，8012。</p>
<h2 id="修改tomcat1-2中的startup-sh-和-shutdown-sh文件"><a href="#修改tomcat1-2中的startup-sh-和-shutdown-sh文件" class="headerlink" title="修改tomcat1/2中的startup.sh 和 shutdown.sh文件"></a>修改tomcat1/2中的startup.sh 和 shutdown.sh文件</h2><p>tomcat1：修改tomcat1中bin下startup.sh 和 shutdown.sh 两个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、tomcat1中bin下startup.sh</span><br><span class="line">命令： vi startup.sh</span><br><span class="line">加入：</span><br><span class="line">export CATALINA_BASE=$CATALINA_BASE1</span><br><span class="line">export CATALINA_HOME=$CATALINA_HOME1</span><br><span class="line">export TOMCAT_HOME=TOMCAT_HOME1</span><br><span class="line"></span><br><span class="line">2、tomcat1中bin下shutdown.sh</span><br><span class="line">命令： vi shutdown.sh</span><br><span class="line">加入：</span><br><span class="line">export CATALINA_BASE=$CATALINA_BASE1</span><br><span class="line">export CATALINA_HOME=$CATALINA_HOME1</span><br><span class="line">export TOMCAT_HOME=TOMCAT_HOME1</span><br></pre></td></tr></table></figure>

<p>tomcat2：修改tomcat3中bin下startup.sh 和 shutdown.sh 两个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、tomcat2中bin下startup.sh</span><br><span class="line">命令： vi startup.sh</span><br><span class="line">加入：</span><br><span class="line">export CATALINA_BASE=$CATALINA_BASE2</span><br><span class="line">export CATALINA_HOME=$CATALINA_HOME2</span><br><span class="line">export TOMCAT_HOME=TOMCAT_HOME2</span><br><span class="line"></span><br><span class="line">2、tomcat2中bin下shutdown.sh</span><br><span class="line">命令： vi shutdown.sh</span><br><span class="line">加入：</span><br><span class="line">export CATALINA_BASE=$CATALINA_BASE2</span><br><span class="line">export CATALINA_HOME=$CATALINA_HOME2</span><br><span class="line">export TOMCAT_HOME=TOMCAT_HOME2</span><br></pre></td></tr></table></figure>

<h2 id="开放防火墙"><a href="#开放防火墙" class="headerlink" title="开放防火墙"></a>开放防火墙</h2><p>和之前MySQL开放防火墙3306端口操作一样。</p>
<p>【1】查看目前防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<p>【2】开放8081端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=8081/tcp	//8082同理</span><br></pre></td></tr></table></figure>

<p>【3】重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service firewalld restart</span><br></pre></td></tr></table></figure>

<h2 id="开启并测试"><a href="#开启并测试" class="headerlink" title="开启并测试"></a>开启并测试</h2><p>在相应bin目录下分别运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh startup.sh	//关闭为shutdown.sh</span><br></pre></td></tr></table></figure>

<p>然后在远程浏览器地址栏输入:　ip:port，比如192.168.1.152:8081或192.168.1.152:8082弹出Tomcat页面即说明成功，测试成功记得关闭服务器。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>TomcatJDK</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb2</title>
    <url>/2019/09/15/2019-09-15-JavaWeb2/</url>
    <content><![CDATA[<blockquote>
<p>动态资源分为Servlet和JSP，前者是基础。</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Sun公司在其API中提供了一个Servlet接口，用户若想开发一个动态web资源（即开发一个java程序向浏览器输出数据），需要完成以下两个步骤：</p>
<ul>
<li>编写一个Java类，实现Servlet接口；</li>
<li>把开发好的Java类部署到web服务器；</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>如同人一样，六岁上学，十八岁上大学，三十岁结婚，六十岁退休……这些事件是和人这个对象的生命周期相关的，到了某个特定时间就会做。同样，Servlet中有些方法和Servlet的生命周期也是相关的，文档中原文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This interface defines methods to initialize a servlet, to service requests, and to remove a servlet from the server. These are known as life-cycle methods and are called in the following sequence: </span><br><span class="line"></span><br><span class="line">1. The servlet is constructed, then initialized with the init method. </span><br><span class="line">2. Any calls from clients to the service method are handled. </span><br><span class="line">3. The servlet is taken out of service, then destroyed with the destroy method, then garbage collected and finalized.</span><br></pre></td></tr></table></figure>

<p>也就是初始化init()、响应请求service()、移除destory()这些方法在某个特定时刻必定会执行。具体来说，客户端第一次访问web资源时会创建一个servlet对象，随后init方法会完成对象的初始化，servlet对象不会随着此次访问结束而摧毁，而是留于内存中，客户端访问调用service方法，调用service方法时先创建request对象和response对象，直至关闭服务器或者web应用从服务器删除才会调用servlet的destory()方法。</p>
<p><img src="https://i.loli.net/2019/09/18/J7SmpFgCARqaV4s.png" alt=""></p>
<h2 id="初试"><a href="#初试" class="headerlink" title="初试"></a>初试</h2><ol>
<li>在tomcat中新建一个servlettest应用，在应用中新建一个WEB-INF/classes目录；</li>
<li>在classes目录中新建一个FirstServlet.java</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcast;</span><br><span class="line">import java.io.*;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line"></span><br><span class="line">public class FirstServlet extends GenericServlet &#123;</span><br><span class="line">	public void service(ServletRequest req,ServletResponse res) throws ServletException,java.io.IOException</span><br><span class="line">	&#123;</span><br><span class="line">		OutputStream out = res.getOutputStream();</span><br><span class="line">		out.write(&quot;hello world&quot;.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入classes文件夹，进行编译，但需先导入jar包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set classpath=%classpath%;E:\apache-tomcat-8.5.45\lib\servlet-api.jar</span><br></pre></td></tr></table></figure>

<p>再进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -d . FirstServlet.java</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写配置文件，在WEB-INF目录下新建web.xml，配置servlet对外访问路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee</span><br><span class="line">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">    version=&quot;3.1&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.itcast.FirstServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/FirstServlet&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动服务器，浏览器地址栏输入<a href="http://localhost:8080/servlettest/FirstServlet即可。" target="_blank" rel="noopener">http://localhost:8080/servlettest/FirstServlet即可。</a></li>
</ol>
<h2 id="在Eclipse中初始"><a href="#在Eclipse中初始" class="headerlink" title="在Eclipse中初始"></a>在Eclipse中初始</h2><p>参考这几个博客：</p>
<ol>
<li><a href="https://blog.csdn.net/ldw4033/article/details/18313281" target="_blank" rel="noopener">https://blog.csdn.net/ldw4033/article/details/18313281</a></li>
</ol>
<p>这篇介绍的最基本的，截至2.3都是没问题的，但是按照他的方法启动有些问题，浏览器一直404，也可能是自己启动方法不对；</p>
<ol start="2">
<li><a href="https://blog.csdn.net/u014079773/article/details/51397850" target="_blank" rel="noopener">https://blog.csdn.net/u014079773/article/details/51397850</a></li>
</ol>
<p>这篇主要参考设置服务器，也就是第10项；</p>
<ol start="3">
<li><a href="https://www.cnblogs.com/SamWeb/p/7627044.html" target="_blank" rel="noopener">https://www.cnblogs.com/SamWeb/p/7627044.html</a></li>
</ol>
<p>这篇主要参考最后总结修改class文件生成路径部分；</p>
<ol start="4">
<li><p>参考以上，最后右击项目，Run As=&gt;Run on Server，成功。</p>
</li>
<li><p>但是有一个问题，在工程的web.xml下也没有对servlet进行配置，如何成功的呢？这里存疑。</p>
<p>（找到了！！！在servlet3.0后，eclipse中开发服务器的时候，Eclipse不会自动在web.xml中生成该Servlet对应的mapping信息，而是在Servlet代码中加入注解@WebServlet。）</p>
</li>
</ol>
<h1 id="Servlet接口实现类"><a href="#Servlet接口实现类" class="headerlink" title="Servlet接口实现类"></a>Servlet接口实现类</h1><p>Servlet接口Sun公司定义了两个默认实现类，分别为：GenericServlet和HttpServlet，前者就是之前讲过的，后者指能够处理HTTP请求的servlet，它在原有接口上添加了一些与HTTP协议处理方法，它比servlet接口的功能更为强大，因此在开发过程中，通常应该继承这个类，在刚才Eclipse自动创建servlet对象中也是继承的这个类。</p>
<p>HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用doGet方法；如为POST请求，则调用doPost方法，因此，在实际开发中，通常只需要覆写这两种方法，而不去覆写service方法。</p>
<h1 id="Servlet的一些细节"><a href="#Servlet的一些细节" class="headerlink" title="Servlet的一些细节"></a>Servlet的一些细节</h1><h2 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h2><p>这部分内容其实已经不需要了，但是为了深入了解，还是在此记录，简单学习一下。</p>
<p>由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用&lt; servlet &gt;元素和&lt; servlet-mapping &gt;元素完成。</p>
<p>&lt; servlet &gt;元素用于注册Servlet，它包含两个主要的元素：&lt; servlet-name &gt;和&lt; servlet-class &gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。</p>
<p>&lt; servlet-mapping &gt;元素用于映射一个已注册的Servlet的一个对外访问路径，也就是说同一个Servlet可以被映射到多个URL上，每一个&lt; servlet-mapping &gt;包含两个子元素：&lt; servlet-name &gt;和&lt; url-pattern &gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。</p>
<p><img src="https://i.loli.net/2019/09/19/kSoKL5EMvOy6AWq.png" alt=""></p>
<p>如果在&lt; servlet &gt;元素中配置了一个&lt; load-on-startup &gt;元素，那么web应用程序在启动时，就会装载并创建Servlet的实例对象以及调用Servlet实例对象的init()方法，&lt; load-on-startup &gt;2&lt; /load-on-startup &gt;中的数字代表创建的优先级，正整数越小代表优先级越高。</p>
<h2 id="Servlet引擎"><a href="#Servlet引擎" class="headerlink" title="Servlet引擎"></a>Servlet引擎</h2><p>需要说明的是，Servlet是一个供其他Java程序调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。这里的Servlet引擎其实就是调用它的其他Java程序，也就是web服务器。</p>
<h2 id="缺省Servlet"><a href="#缺省Servlet" class="headerlink" title="缺省Servlet"></a>缺省Servlet</h2><p>如果某个Servlet的映射路径仅仅为一个正斜杠/，那么这个Servlet就成为当前web应用的缺省Servlet。</p>
<p>凡是在web.xml文件中找不到匹配的&lt; servlet-mapping &gt;元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理其他Servlet都不处理的访问请求。</p>
<p>当访问Tomcat服务器中某个静态HTML文件或者图片时，实际上是在访问这个缺省Servlet。也就是说你在浏览器中输入动态web资源也好，静态web资源也好，其实浏览器客户端都交给了Servlet，只不过输入静态web资源，例如访问xxxxxxxx/a.html，这个a.html资源并没有在&lt; servlet-mapping &gt;中进行映射，所以调用缺省Servlet，缺省Servlet寻找同名的a.html进行显示，若缺省Servlet也找不到，则返回404界面。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Webtest extends HttpServlet &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	protected void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		i++;</span><br><span class="line">		try&#123;</span><br><span class="line">			Thread.sleep(1000*10);</span><br><span class="line">		&#125;catch(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		response.getOutputStream().write((i+&quot;&quot;).getBytes());</span><br><span class="line">	&#125;</span><br><span class="line">	protected void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		doGet(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有两个用户，第一个用户的页面应该输出1，但是假如在该用户线程休眠过程中有另一个用户访问，则最后输出2，这样就涉及到了线程安全，当然，可以通过synchronized()方法来保证线程安全</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized(this)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		try&#123;</span><br><span class="line">			Thread.sleep(1000*10);</span><br><span class="line">		&#125;catch(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		response.getOutputStream().write((i+&quot;&quot;).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，很显然在实际开发中，不可能这么做，否则一个用户访问其他用户只能等待。还有另外一种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Webtest extends HttpServlet implements SingleThreadModel</span><br></pre></td></tr></table></figure>

<p>SingleThreadModel接口中没有定义任何内容，称为标记接口，相当于只是给该类贴了一个线程安全的标签，这种方法在servlet 2.4之后就已经Deprecated。</p>
<p>线程安全问题很大部分是由实例变量造成的，只要在Servlet里面的任何方法里面都不使用实例变量，那么该Servlet就是线程安全的。<strong>所以，在Servlet中避免使用实例变量是保证Servlet线程安全的最佳选择。</strong></p>
<p>Java 内存模型中，方法中的临时变量是在栈上分配空间，而且每个线程都有自己私有的栈空间，所以它们不会影响线程的安全。</p>
<h1 id="Servlet对象"><a href="#Servlet对象" class="headerlink" title="Servlet对象"></a>Servlet对象</h1><p>服务器在创建Servlet时，除了有request、response对象，还有ServletConfig、ServletContext、Session、Cookie等对象。</p>
<h2 id="ServletConfig对象"><a href="#ServletConfig对象" class="headerlink" title="ServletConfig对象"></a>ServletConfig对象</h2><p>在Servlet配置文件中，可以在&lt; servlet &gt;元素中使用一个或多个&lt; init-param &gt;标签为Servlet配置一些初始化参数，配置之后，web容器在创建Servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用init()方法时，将ServletConfig对象传递给servlet，进而，开发人员通过ServletConfig对象就可以得到当前servlet的初始化参数信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">	&lt;param-name&gt;date&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;2019&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></table></figure>

<p>java程序中调用即可得到“2019”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String value = this.getServletConfig().getInitParameter(&quot;data&quot;);</span><br></pre></td></tr></table></figure>

<p>在实际开发中，例如字符码表、要连接的数据库以及读取哪个配置文件等不适合在程序中显示，就用到了ServletConfig。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">	&lt;param-name&gt;charset&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">	&lt;param-name&gt;url&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">	&lt;param-name&gt;username&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;root&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">	&lt;param-name&gt;password&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;root&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">	&lt;param-name&gt;config&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;/struts-config.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><p> web容器在启动时，会为每个web应用都创建一个ServletContext对象，ServletConfig对象中维护ServletContext对象的引用，可以通过ServletConfig().ServletContext()方法获得ServletContext对象。、</p>
<p>由于一个web应用中所有Servlet共用一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象实现通讯。ServletContext对象通常也称之为context域对象。</p>
<p>在实际开发中，ServletContext具体有以下几个应用：</p>
<ul>
<li>多个servlet之间实现数据共享，一个写入，其他就可以读到；</li>
<li>获取WEB应用的初始化参数，和上边ServletConfig设置初始化参数类似，只不过这里设置的是整个web应用，使用&lt; context-param &gt;</li>
<li>实现servlet转发，关于转发和重定向的区别，打个比方，你找我借钱，我让你去找他借，这是重定向；你找我借钱，我帮你去找他借，这是转发。在开发中，转发用的很多，比如servlet的内容肯定要转发，让html去排版再在浏览器显示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RequestDispatcher rd = this.getServletContext().getRequestDispatcher(&quot;/1.jsp&quot;);</span><br><span class="line">rd.forward(request，response);</span><br></pre></td></tr></table></figure>

<ul>
<li>读取资源文件</li>
</ul>
<p>假设读取应用下的db.properties：(常见的两种配置文件，如果配置文件内数据有关联，则用xml，否则properties)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/test</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure>

<p>在servlet中读取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream in = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;);</span><br><span class="line">//不能使用传统方法</span><br><span class="line">//FileInputStream in = new FileInputStream(&quot;classes/db.properties&quot;);</span><br><span class="line">//因为执行这行代码的是JVM，也就是说相对路径是以Tomcat下startup.bat来看的，此时并没有classes目录</span><br><span class="line">//要想使用，应该采用如下方法;</span><br><span class="line">//String path = this.getServletContext().getRealPath(&quot;/WEB-INF/classes/db.properties&quot;);</span><br><span class="line">//FileInputStream in = new FileInputStream(path);</span><br><span class="line">Properties props = new properties();	//map</span><br><span class="line">props.load(in);		//将in的内容装载到props</span><br><span class="line"></span><br><span class="line">String url = props.getProperty(&quot;url&quot;);</span><br><span class="line">String username = props.getProperty(&quot;username&quot;);</span><br><span class="line">String password = props.getProperty(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(url);</span><br><span class="line">System.out.println(username);</span><br><span class="line">System.out.println(password);</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">&gt;&gt;jdbc:mysql://localhost:3306/test</span><br><span class="line">&gt;&gt;root</span><br><span class="line">&gt;&gt;root</span><br></pre></td></tr></table></figure>

<p>如果读取资源文件的不是servlet，而是普通的Java文件，就只能通过<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">类加载器</a>，例如在dao读取db.properties:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#servlet</span><br><span class="line">……………………</span><br><span class="line">UserDao dao = new UserDao();</span><br><span class="line">dao.update();</span><br><span class="line">……………………</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#UserDao.java</span><br><span class="line">package cn.itcast.dao;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class UserDao(</span><br><span class="line">	public void update() throws IOException &#123;</span><br><span class="line">		InputStream in = UserDao.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);</span><br><span class="line">		Properties props = new properties();	</span><br><span class="line">		props.load(in);		</span><br><span class="line">		</span><br><span class="line">		String url = props.getProperty(&quot;url&quot;);</span><br><span class="line">		String username = props.getProperty(&quot;username&quot;);</span><br><span class="line">		String password = props.getProperty(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">		System.out.println(url);</span><br><span class="line">		System.out.println(username);</span><br><span class="line">		System.out.println(password);</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>扩展一：</p>
<p>类加载器读取的文件不能太大，因为类加载器加载的文件直接存在内存中，文件太大会导致内存溢出，JVM爆掉。</p>
<p>扩展二：</p>
<p>UserDao.java中除了update方法还可能有find、delete等方法，但是这写方法只加载一次就可以，不用每个方法里都加载，所以可以写成静态代码块，实际开发中常这样写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDao(</span><br><span class="line">	private static Properties dbconfig = new Properties();</span><br><span class="line">	static &#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			InputStream in = UserDao.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);</span><br><span class="line">			dbconfig.load(in);		</span><br><span class="line">		&#125;catch (Exception e)&#123;</span><br><span class="line">			throw new ExceptionInInitializerError(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public void update() throws IOException &#123;</span><br><span class="line">			System.out.println(dbconfig.getProperty(&quot;url&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">	public void find()  &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>扩展三：</p>
<p>这样的话，启动服务器后，在db.properties中进行修改，这边是无法更新的，因为类加载加载到内存中，要想更新，只能重启服务器，显然不是想要的，所以应该如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDao(</span><br><span class="line">	public void update() throws IOException &#123;</span><br><span class="line">	//通过类装载的方式得到资源文件的位置，再通过传统方式读取资源文件的数据，这样可以读取到更新后的数据</span><br><span class="line">			String path = UserDao.class.getClassLoader().getResource(&quot;db.properties&quot;).getPath();</span><br><span class="line">			FileInputStream in = new FileInputStream(path);</span><br><span class="line">			Properties dbconfig = new Properties();</span><br><span class="line">			dbconfig.load(in);</span><br><span class="line">			System.out.println(dbconfig.getProperty(&quot;url&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">	public void find()  &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb1</title>
    <url>/2019/09/10/2019-09-10-JavaWeb1/</url>
    <content><![CDATA[<h1 id="Web开发相关概念"><a href="#Web开发相关概念" class="headerlink" title="Web开发相关概念"></a>Web开发相关概念</h1><ol>
<li><p>静态Web资源开发技术：Html</p>
<p>动态Web资源开发技术：JSP/Servlet、ASP、PHP等，在Java中，动态web资源开发统称为JavaWeb。</p>
</li>
<li><p>常见Web服务器：WebLogic，目前应用最广泛，商业；WebSphere，IBM，商业；Tomcat，APache，免费；</p>
</li>
<li><p>一个Web应用由多个静态Web资源和多个动态Web资源组成，如html、css、js文件以及Jsp文件、java程序、支持jar包和配置文件等；</p>
</li>
<li><p>Web应用开发好之后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚拟目录的映射，<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/context.html#Defining_a_context" target="_blank" rel="noopener">详情</a>，目前已经不推荐直接在server.xml中直接修改 &lt; Context &gt;，例如直接写入&lt; Context path=“/login” docBase=”C:\login” /&gt;，这样直接浏览器输入<a href="http://localhost:8080/login/1.html" target="_blank" rel="noopener">http://localhost:8080/login/1.html</a> 就可以直接访问C盘login文件夹下的1.html资源了，但是这样一旦修改server.xml，服务器就必须重启；</p>
</li>
<li><p>补充小知识：互联网上一些协议及常用的端口：http-80;smtp-25;pop3-110;ftp-23;https-443;mysql-3306;oracle-1521;</p>
</li>
</ol>
<h1 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h1><h2 id="服务器目录结构"><a href="#服务器目录结构" class="headerlink" title="服务器目录结构"></a>服务器目录结构</h2><p>bin：存放启动和关闭Tomcat的脚本文件；</p>
<p>conf：存放Tomcat服务器的各种配置文件，最重要的是server.xml；</p>
<p>lib：存放Tomcat服务器支持的jar包；</p>
<p>logs：存放Tomcat服务器的日志文件，若启动不成功无法通过控制台查看问题的话可查看日志文件；</p>
<p>temp：存放Tomcat服务器产生的临时文件；</p>
<p>webapps：web应用所在目录，即供外界访问的web资源的存放目录，对于开发人员最重要的目录；</p>
<p>work：存放Tomcat服务器的工作目录，JSP需要用到；</p>
<h2 id="web应用的组成结构"><a href="#web应用的组成结构" class="headerlink" title="web应用的组成结构"></a>web应用的组成结构</h2><p>webapps下的web应用需要严格按照以下存放规则</p>
<p><img src="https://i.loli.net/2019/09/10/T5ry6kOdICmjUXs.png" alt=""></p>
<p>web.xml文件是整个web应用中最重要的配置文件，必须放在WEB-INF目录中，在开发web应用时，但凡涉及到对web应用中某个web资源的配置，往往都在web.xml中进行设置。例如把某个资源配置成网站首页，直接参考Tomcat中自带的Web.xml文件，取头取尾即可。</p>
<p>应用发布到服务器上时需要打包成war包，这样服务器会自动解析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//进入应用目录</span><br><span class="line">jar -cvf xxx.war xxx</span><br></pre></td></tr></table></figure>

<p>打包后的war文件直接放到服务器的webapps目录，会看到自动解析出xxx文件。</p>
<h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>所谓配置虚拟主机，就是在tomcat服务器中配置一个网站，一个tomcat服务器中可以放置多个文档，在Web服务器中配置一个网站，需使用Host元素在server.xml进行配置，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Host name=&quot;www.google.com&quot; appBase=&quot;C:\login&quot;&gt;&lt;/Host&gt;</span><br></pre></td></tr></table></figure>

<p>但是配置的主机要想被外界访问，必须在DNS进行注册IP，很显然，<a href="http://www.google.com是不能再被注册的，但是浏览器在询问DNS之前会先询问Windows系统，这个主机名是否在系统中注册IP，所以可以修改C:\Windows\System32\drivers\etc下的hosts文件，将本机IP映射成为www.google.com，这样本机浏览器访问www.google.com就可以访问自己C盘下的login应用。" target="_blank" rel="noopener">www.google.com是不能再被注册的，但是浏览器在询问DNS之前会先询问Windows系统，这个主机名是否在系统中注册IP，所以可以修改C:\Windows\System32\drivers\etc下的hosts文件，将本机IP映射成为www.google.com，这样本机浏览器访问www.google.com就可以访问自己C盘下的login应用。</a></p>
<h2 id="配置https连接器"><a href="#配置https连接器" class="headerlink" title="配置https连接器"></a>配置https连接器</h2><p>主要用于表单等提交时的加密，设计密码学尤其是非对称加密，这部分略过。</p>
<p>首先需要为网站生产一份数字证书（公钥），cmd命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias tomcat -keyalg RSA</span><br></pre></td></tr></table></figure>

<p>系统将产生的数字证书保存到密钥库。然后将这份密钥库文件拷贝到Tomcat安装目录下的conf文件夹下，之后在server.xml中进行配置，也就是使网站自动提取密钥库中的密钥给网站使用用户。具体配置可以打开server.xml文件中关于8443端口的部分，这部分视频使用的方法在Tomcat官方文档中显示deprecated，故不记录，另外，这里配置的只是单向加密连接器，实际开发中应配置https双向加密连接器。</p>
<h2 id="Tomcat管理器"><a href="#Tomcat管理器" class="headerlink" title="Tomcat管理器"></a>Tomcat管理器</h2><p>在官方文档首先有Manger APP，点击需要用户名密码。这个在复制文件中可以进行配置，打开tomcat-users.xml可以看到几个注释的用户名密码，可以用这几个或者自己再配置。注意默认正好无权限，需要加一个manager的角色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;role rolename=&quot;tomcat&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;role1&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;tomcat,manager&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;both&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;tomcat,role1&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;role1&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;role1&quot;/&gt;</span><br></pre></td></tr></table></figure>



<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>客户端连上web服务器之后，若想要获得web服务器中某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通讯的格式，时TCP/IP协议的一个应用层协议。</p>
<p>可以使用windows自带的telnet程序连上web服务器并使用HTTP协议获取某个页面或者浏览器的一些插件也可以实现查看HTTP的请求和响应。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>客户端连上服务器后，向服务器请求某个web资源，称之为客户端向服务器发送了一个HTTP请求，一个完整的HTTP请求包括：一个请求行、若干请求头、以及实体内容。请求行用于描述客户端的请求方式、请求的资源名称以及使用的HTTP协议版本号；请求头用于描述客户端请求哪台主机以及客户端的一些环境信息等；实体内容为表单请求的数据等。</p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行中常用的请求方式有GET和POST，如果用户没有设置，默认都是GET，用户想把请求方式改为POST，可通过更改表单的提交方式实现。GET在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /mail/1.html?name=abc&amp;password=123456 HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>其数据容量通常不能超过1K，POST传送的数据量无限制。</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>Accept：用于告诉服务器，客户机支持的数据类型；</p>
<p>Accept-Charset：用于告诉服务器，客户机采用的编码；</p>
<p>Accept-Encoding：用于告诉服务器，客户机支持的数据压缩格式；</p>
<p>Accept-Language：用于告诉服务器，客户机的语言环境；</p>
<p>Host：客户机通过这个头告诉服务器，想访问的主机名；</p>
<p>If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间；</p>
<p>Referer：客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的（主要用于防盗链）；</p>
<p>User-Agent：客户机通过这个头告诉服务器，客户机的软件环境；</p>
<p>Cookie：客户机通过这个头可以向服务器带一点数据；</p>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>一个HTTP响应代表服务器向客户端回送的数据。HTTP响应包括：一个状态行、若干响应头、以及实体内容。状态行用于描述服务器对于请求的处理结果；响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据；实体内容为服务器向客户端回送的数据。</p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数，响应状态码分为三类：</p>
<p><img src="https://i.loli.net/2019/09/15/gyEoDF23zGwltV9.png" alt=""></p>
<p>例如302：服务器告诉客户端去其他地址找；304/307：服务器告诉客户端去找缓存；404：服务器告诉客户端资源找不到；403：服务器告诉客户端没有权限访问该资源；</p>
<p>响应头</p>
<p>Location：这个头配合302状态码使用，用于告诉客户端找谁，实现请求重定向；</p>
<p>Server：通过这个头，告诉浏览器服务器的类型；</p>
<p>Context-Type：通过这个头，告诉浏览器回送数据的类型，不同的文件类型对应的具体书写格式可在Tomcat/conf/web.xml中查看；</p>
<p>Refresh：通过这个头，服务器告诉浏览器多久刷新一次；</p>
<p>Content-Disposition：通过这个头，服务器告诉浏览器以下载方式打开数据；</p>
<p>ETag：缓存相头的头；</p>
<p>Expirse：通过这个头，服务器告诉浏览器把回送的资源缓存多长时间，-1或0代表不缓存；</p>
<p>Set-Cookie、Cache-Control、Pragma等其他一些头和缓存相关；</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2019/09/09/2019-09-09-XML/</url>
    <content><![CDATA[<blockquote>
<p>XML语言出现的根本目标在于描述在现实生活中经常出现的有关系的数据。在XML语言中，它允许用户自定义标签。除了用于保存有关系的数据，还经常用作软件配置文件，以描述程序模块之间的关系。</p>
</blockquote>
<h1 id="XML内容"><a href="#XML内容" class="headerlink" title="XML内容"></a>XML内容</h1><ul>
<li><p>文档申明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>元素</p>
<p>XML元素指的就是XML文件中出现的标签，一个标签分为开始标签和结束标签，格式良好的XML文档必须有且仅有一个根标签，其他标签都是这个根标签的子孙标签。</p>
<p>由于在XML中，空格和换行都作为原始内容被处理，所以，在编写XML文件时，使用换行和缩进等方式让原文件内容清晰可读的习惯可能要被迫改变。</p>
</li>
<li><p>属性</p>
<p>一个标签可以有多个属性，每个属性都有它自己名称和取值，在XML中，标签属性所代表的信息也可以被改成用子元素的形式来描述，例如下面两种写法是一样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>text<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释</p>
<p>需要注意XML声明之前不能有注释。</p>
</li>
<li><p>CDATA区</p>
<p>在编写XML文件时，有些内容可能不想让解析引擎解析执行，而是当作原始数据处理。在这种情况下，就把这些内容放在CDATA区里，对于CDATA区域里的内容，XML解析程序不会处理，而是直接原封不动的输出。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">x&lt;![CDATA[</span><br><span class="line">	内容</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理指令</p>
</li>
</ul>
<p>处理指令用来指挥解析引擎如何解析XML文档内容，处理指令必须以&lt; ? 开头，以? &gt;作为结尾，XML声明语句是最常见的处理指令。另外，在XML文档中可以使用xml-stylesheet指令通知XML解析引擎，应用css文件显示xml文档内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/css" href="1.css"?&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="XML约束"><a href="#XML约束" class="headerlink" title="XML约束"></a>XML约束</h1><p>在XML技术里，可以编写一个文档来约束一个XML文档的书写规范，这称之为XML约束。常用的约束技术包括XML DTD和XML Schema</p>
<h2 id="XML-DTD"><a href="#XML-DTD" class="headerlink" title="XML DTD"></a>XML DTD</h2><p>DTD:Document Type Definition，举例：</p>
<p>book.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 书架 SYSTEM &quot;book.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>book.dtd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 书架（书+）&gt;</span><br><span class="line">	&lt;!ELEMENT 书（书名，作者，售价）&gt;</span><br><span class="line">	&lt;!ELEMENT 书名（#PCDATA）&gt;</span><br><span class="line">	&lt;!ELEMENT 作者（#PCDATA）&gt;</span><br><span class="line">	&lt;!ELEMENT 售价（#PCDATA）&gt;</span><br></pre></td></tr></table></figure>

<p>查看一份XML文档是否遵循对应的DTD约束，可以使用Eclipse进行校验，DTD文件应该使用UTF-8或者Unicode。</p>
<p>具体DTD的语法在此略过。</p>
<h2 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h2><ul>
<li><p>XML Schema符合XML语法，也就是说它本身就是一个XML文档，但它扩展名为.xsd，同时，它也必须有一个根节点，名称为chema；</p>
</li>
<li><p>XML Schema对<strong>名称空间</strong>支持得很好；</p>
</li>
<li><p>XML Schema比DTD支持更多的数据类型，并支持用户自定义新的数据类型；</p>
</li>
<li><p>XML Schema定义约束的能力非常强大，可以对XML实例文档作出细致的语义限制；</p>
</li>
<li><p>XML Schema不能像DTD一样定义实体，比DTD更复杂，但已成为W3C标准，正逐步取代DTD;</p>
</li>
<li><p>编写一个XML Schema约束文档之后，需要把这个文件中声明的元素绑定到一个URI地址上，这个地址，也就是所谓的名称空间，以后XML文件就可以通过这个URL来告诉解析引擎，xml文档中编写的元素来自哪里，被谁约束。</p>
</li>
<li><p>关于名称空间：每个约束模式文档都可以被赋予一个唯一的名称空间，用一个唯一的URI表示。在XML文件中书写标签时，可以通过名称空间声明（xmlns）,来声明当前编写的标签来自哪个Schema约束文档。如：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;gsynf:书架 xmlns:gsynf=&quot;http://gsynf.github.io&quot;&gt;</span><br><span class="line">	&lt;gsynf:书&gt;……&lt;/gsynf:书&gt;</span><br><span class="line">&lt;/gsynf:书架&gt;</span><br></pre></td></tr></table></figure>

<p>此处使用gsynf来指向声明的名称，方便后面对名称空间的引用。</p>
<p>注意：名称空间的名字语法 很容易让人混淆，尽管以http://开始，那个URL并不指向一个包含模式定义的文件。事实上，这个URL：http ://gsynf.github.io 根本没有指向任何文件，只是一个分配的名字。</p>
<p>为了在一个XML文档中声明它所遵循的Schema文件的具体位置，通常需要在Xml文档中的根节点使用schemaLocation属性来指定，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gsynf:书架</span> <span class="attr">xmlns:gsynf</span>=<span class="string">"http://gsynf.github.io"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://gsynf.github.io"</span> <span class="attr">book.xsd</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>schemaLocation此属性有两个值，第一个值是需要的命名空间，第二个值是供命名空间使用的XML Schema文件位置。</p>
<h1 id="XML编程"><a href="#XML编程" class="headerlink" title="XML编程"></a>XML编程</h1><p>所谓XML编程，其实就是CRUD（create,read,update,delete）。</p>
<h2 id="XMl解析方式"><a href="#XMl解析方式" class="headerlink" title="XMl解析方式"></a>XMl解析方式</h2><p>DOM：W3C官方推荐的解析方式；</p>
<p>SAX：社区事实上的标准；</p>
<p>XML解析开发包：Jaxp(sun)、Jdom、dom4j</p>
<h3 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h3><p>把XML中的节点均变为对象，标签成为Element对象，文本成为Text对象，属性成为Attribute对象，然后根据这些对象之间的关系生成DOM树。DOM解析对增删改查比较容易，DOM解析对内存资源占用较大，不适用于较大的文档对象。</p>
<p>以JAXP为例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建解析工厂</span></span><br><span class="line">DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line"><span class="comment">//2.得到dom解析器</span></span><br><span class="line">DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line"><span class="comment">//3.解析xml文档，得到代表文档的document</span></span><br><span class="line">Document document = builder.parse(<span class="string">"src/book.xml"</span>);</span><br><span class="line"><span class="comment">//4.调用Document方法获取某个节点内容</span></span><br><span class="line">NodeList list = document.getElementsByTagName(<span class="string">"书名"</span>);</span><br><span class="line">Node node = list.item(<span class="number">1</span>);</span><br><span class="line">String content = node.getTextContent();</span><br><span class="line"><span class="comment">//5.对某个节点进行操作，例如增加一个属性</span></span><br><span class="line">Element price = document.creatElement(<span class="string">"售价"</span>);</span><br><span class="line">price.setTextContent(<span class="string">"59元"</span>);</span><br><span class="line">Element book = (Element) document.getElementsByTagName(<span class="string">"书"</span>).item(<span class="number">0</span>);<span class="comment">//把创建的节点挂到第一本书上</span></span><br><span class="line">book.appendChild(price);</span><br></pre></td></tr></table></figure>

<h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><p>从上向下读取，读取一行处理一行。所以对内存压力较小，解析速度快，但是只适合读取，不适合增删改查。</p>
<p>SAX采用事件处理的方式解析XML文档，利用SAX解析文档，涉及两个部分：解析器和事件处理器。</p>
<ul>
<li><p>解析器可以使用JAXP的API创建，创建出解析器之后，就可以指定解析器去解析某个XML文档</p>
</li>
<li><p>解析器采用SAX方式在解析某个XML文档时，只要解析到XML文档中的一个组成部分，都会调用事件处理器的一个方法，解析器在调用事件处理器的方法时，会把当前解析到的xml文档内容作为方法的参数传递给事件处理器；</p>
</li>
<li><p>事件处理器由程序员编写，通过事件处理器中方法的参数，就可以轻松得到sax解析器解析到的数据，从而决定如何对数据进行处理。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/09/10/6JRPor4UqTduI27.png" alt=""></p>
<p>以JAXP为例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建解析工厂</span></span><br><span class="line">SAXParserFactory factory = SAXParseFactory.newInstance();</span><br><span class="line"><span class="comment">//2.得到解析器</span></span><br><span class="line">SAXParser sp = factory.newSAXParser();</span><br><span class="line"><span class="comment">//3.得到读取器</span></span><br><span class="line">XMLReader reader = sp.getXMLReader();</span><br><span class="line"><span class="comment">//4.设置内容处理器</span></span><br><span class="line">reader.SetContentHandler();</span><br><span class="line"><span class="comment">//5.读取xml文档</span></span><br><span class="line">reader.parse(<span class="string">"src/book.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>除了JAXP，dom4j是一个简单、灵活的开放源代码的第三方库，使用接口和抽象基类，性能优异、功能强大，目前使用最多。</p>
<h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><p>快速定位需要找到的节点：</p>
<ul>
<li><p>如果路径以斜线/开始，表示到一个元素的绝对路径；</p>
</li>
<li><p>如果路径以双斜线//开始，表示选择文档中所有满足双斜线//之后规则的元素（无论层级关系）；</p>
</li>
<li><p>星号*表示选择所有由星号之前的路径所定位的元素；</p>
</li>
<li><p>方块中的表达式可以进一步指定元素，其中数字表示元素在选择集里的位置，而last()函数则表示选择集中的最后一个元素；</p>
</li>
<li><p>[@ATT]找到有特定属性的元素，还可以选择属性值[@ATT=‘att’];</p>
</li>
<li><p>……………………………………</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/AAA/BBB  找到AAA下的所有BBB</span><br><span class="line">//AAA/BBB  选择所有父元素是AAA的BBB元素</span><br><span class="line">/AAA/BBB/*  选择所有路径依附于/AAA/BBB的元素</span><br><span class="line">/AAA/BBB[1]  选择AAA的第一个BBB子元素</span><br><span class="line">//BBB[@name]  选择有name属性的BBB元素</span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java零散笔记</title>
    <url>/2019/09/05/2019-09-05-Java%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>Java学习内容较多，在此零散记录一些需要注意的地方，尤其是其他语言没有的东西，不作为系统学习Java的教程。</p>
</blockquote>
<ol>
<li><p>A obj = new A();，obj可以看作是内存对象中的一个对象（包括若干个数据）的句柄，在C/C++中，obj称为指针，在Java中成为Reference,需要注意的是对象比较庞大，所以对象赋值是Refenence赋值，也就是两个Reference会指向同一个东西，而如int等基本对象比较简单，他们的赋值是直接拷贝。</p>
</li>
<li><p>String是不可变对象，而StringBuffer和StringBuilder是可变对象。也就是使用StringBuilder append(任意类型)方法可以实现添加数据并返回对象本身。StringBuilder reverse（）同理，但是String没有这两个常用的方法，所以涉及到相互转换：通过toString()就可以实现把StringBuilder转换为String；反之，通过构造方法StringBuilder(String s)。</p>
</li>
<li><p>短路逻辑运算符<br>逻辑与&amp;，无论左边真假，右边都要执行；短路与&amp;&amp;，如果左边为真，右边执行，如果左边为假，右边短路不执行。<br>逻辑或与短路或同理。</p>
</li>
<li><p>成员变量在类中方法外，存放于堆内存，有默认的初始化值；而局部变量存在于方法内或方法声明上，存放于栈内存，没有默认初始化值，必须先定义，赋值，才能使用。</p>
</li>
<li><p>Java构造函数的名称必须和类名一样，且没有返回值，定义时不能有void，写了就成为了普通函数；Java有构造函数但是没有析构函数，也就是每个变量都有生命周期，它只能存储在离它最近的一对{}中，当变量被创建时，变量将占据内存；当变量消亡时，系统将回收内存。每个Java类必须有构造函数，如果没有显式的定义构造函数，Java编译器自动为该类产生一个空的无形参的构造函数。一个类可以有多个构造函数，只要形参列表不相同即可，和重载函数一样。</p>
</li>
<li><p>面向对象有一个法则：信息隐藏，也就是类的成员属性是私有的private，类的方法是共有的public，通过方法修改成员属性的值。外界对类成员的操作只能通过get和set方法，可以用Java IDE快速生成，如Eclipse中Source-Generate Getters and Setters可以自动快速地对类中的成员生产get和set方法，且遵循驼峰命名法。</p>
</li>
<li><p>this不仅可以负责指向本类中的成员变量和成员方法，还可以代替本类的构造方法。</p>
</li>
<li><p>在Java语言设计中，针对C++中方法指代不清的问题进行改进，特意强调了单根继承的原则，也就是每个类只能继承一个类。继承如果不写extends，Java都默认继承java.lang.Object类，也就是Java所有类都从java.lang.Object开始，构建出一个类型继承树，Object类里面默认就有clone、equals、hashCode、toString等方法。另外，每个子类的构造函数第一句话都默认调用父类的<strong>无参数构造函数</strong>super()，除非子类的构造函数第一句话是super，而且super语句必须放在第一条。</p>
</li>
<li><p>多态的作用：<br>(1)以统一的接口来操纵某一类中不同的对象的动态行为，每一个对象的行为由自己来决定；<br>(2)对象之间的解耦，基于接口，利用转型和多态，不影响真正方法的调用，可以将调用类和被调用类解耦。<br>多态中成员访问特点：<br>成员变量：编译看左边，执行看左边；成员方法：编译看左边，执行看右边。解释一下，以Animal a = new Cat()为例，假设Animal类中有变量age=20和方法“动物吃东西”，Cat类继承于Animal类，变量有age=40和name，方法有“猫吃鱼”和“猫捉老鼠”。此时a.age可以，输出的是20，a.name报错；a.eat()可以，输出“猫吃鱼”，a.play()报错。原因是因为成员方法有重写，但是成员变量没有。如果想使用a.play()。需要用到转型，上述Animal a = new Cat()是父类引用指向子类对象，称为向上转型，反之，父类引用转为子类对象称为向下转型，即Cat c = (Cat)a。</p>
</li>
<li><p>在Java中，一个没有方法体的方法应该被定义为抽象方法，使用abstract关键字，而类中如果有抽象方法，该类必须定义为抽象类。抽象类不能直接创建对象，创建对象参照多态的方法即可，但是抽象类的子类要不重写抽象类的方法，要不同样将自己定义为抽象类。</p>
</li>
<li><p>接口：新建Inferface，定义接口使用关键字interface，例如public interface Eating{…抽象方法…}再定义类实现方法需要用到关键字implement，例如public class Cat implement Eating{…重写方法…}，注意接口中定义的常量默认是被public static final修饰的，也就是默认静态常量；另外接口中没有构造方法，也没有非抽象方法。</p>
</li>
<li><p>权限修饰符：private/默认/protecte/public<br>状态修饰符：final/static</p>
<p><img src="https://i.loli.net/2019/09/10/jKMZB34fEyl1F27.png" alt=""></p>
</li>
<li><p>final关键字：final的类，不能被继承；父类中如果有final的方法，子类中不能改写此方法；final的变量，不能再次赋值（如果是基本类型的变量，不能修改其值；如果是对象实例，不能修改其指针，但是可以改值）<br>static变量只依赖于类存在，不依赖于实例对象存在，也就是如果有一个静态变量，那么一个类的所有对象实例都共享存储在一个共同的空间；static方法无需通过对象来引用，直接通过类名即可，在静态方法中，只能引用静态变量，且静态方法不能引用非静态方法。 </p>
</li>
<li><p>单例模式：保证一个类有且只有一个对象<br>-采用static来共享对象实例<br>-采用private构造函数，防止外界new操作</p>
</li>
<li><p>内部类：就是在一个类的内部再定义一个类。<br>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 类名&#123;</span><br><span class="line">	修饰符 class 类名&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类可以直接访问外部类的成员，包括私有；外部类想要访问内部类的成员，必须创建对象。<br>特殊：匿名内部类，也是局部内部类的一种，所以要写在外部类的方法中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new 类名或接口名() &#123;</span><br><span class="line">	重写方法；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>可见匿名内部类的本质就是一个继承了该类或者实现了该接口的子类匿名对象。所以可以采取以下例子</p>
<p>可见匿名内部类的本质就是一个继承了该类或者实现了该接口的子类匿名对象。所以可以采取以下例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inter i = new Inter() &#123;</span><br><span class="line">	public void 方法名()&#123;</span><br><span class="line">	…方法体…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br><span class="line">i.方法名();</span><br></pre></td></tr></table></figure>

<p>内部类可以直接访问外部类的成员，包括私有；外部类想要访问内部类的成员，必须创建对象。<br>特殊：匿名内部类，也是局部内部类的一种，所以要写在外部类的方法中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new 类名或接口名() &#123;</span><br><span class="line">	重写方法；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>可见匿名内部类的本质就是一个继承了该类或者实现了该接口的子类匿名对象。所以可以采取以下例子</p>
<p>可见匿名内部类的本质就是一个继承了该类或者实现了该接口的子类匿名对象。所以可以采取以下例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Inter i = <span class="keyword">new</span> Inter() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> 方法名()&#123;</span><br><span class="line">	…方法体…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br><span class="line">i.方法名();</span><br><span class="line">i.方法名();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="16">
<li><p>package<br>在Java类文件的第一句话给出包的名称，类似com.edu.nssc.PackageExample，在这里引用类的时候，必须采用全称引用，程序正文可以采用PackageExample短名称，而且必须严格放置在com/edu/nssc目录下。package name尽量唯一，因此常用域名逆序。</p>
</li>
<li><p>import<br>import必须全部放在package之后，定义类之前。</p>
</li>
</ol>
<ol start="18">
<li><p><img src="https://i.loli.net/2019/09/10/rKuGX5E1kBDwxml.png" alt=""></p>
<p>异常处理<br>(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	可能存在异常的代码；</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名) &#123;</span><br><span class="line">	异常的处理代码；</span><br><span class="line">	如e.printStackTrace();System.out.println(e.getMessage());System.out.println(e.toString());等</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	最终执行的模块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>执行流程：程序从try里面的代码开始执行，出现异常会自动生成一个异常类对象提交给JVM，当JVM接收到提交时，会到catch中找匹配的异常，找到后进行异常的处理，因此catch块可以有多个，每个有不同的入口形参，当已发生的异常和某一个catch块中的形参类型一致，那么将执行该catch块中的代码，如果没有一个匹配，catch也不会被触发，最后都进入finally块。<br>(2)并不是所有的情况都有权限对异常进行处理，因此方法存在可能异常的语句，但不处理，需要使用throws来声明异常：throws 异常类名；这个格式放在方法的括号后面。<br>    (2.1)一个方法被覆盖，覆盖他的方法必须抛出相同的异常或者异常的子类；<br>    (2.2)如果父类的方法抛出多个异常，那么重写的子类方法必须抛出那么异常的子类，也就是不能抛出新的异常；<br>    (2.3)throws只是抛出或者说延后这个异常，并没有处理，处理还得用try…catch…<br>(3)自定义异常：需要继承Exception类及其子类<br>-继承自Exception，就变成Checked Exception<br>-继承自RuntimeException，就变成Unchecked Exception<br>自定义异常重点在于构造函数：<br>-可以调用父类Exception的message构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 自定义Exception()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> 自定义Exception(String message)&#123;</span><br><span class="line">	<span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名() **<span class="keyword">throws</span>** 自定义Exception &#123;</span><br><span class="line">	<span class="comment">//throw new 自定义Exception();</span></span><br><span class="line">	**<span class="keyword">throw</span>** <span class="keyword">new</span> 自定义Exception(<span class="string">"xxxxxxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-可以自定义自己的成员变量</p>
<p>-可以自定义自己的成员变量</p>
<p>其他方法调用<br>public void 方法名() <strong>throws</strong> 自定义Exception {<br>    //throw new 自定义Exception();<br>    <strong>throw</strong> new 自定义Exception(“xxxxxxx”);<br>}<br>-可以自定义自己的成员变量</p>
<ol start="19">
<li><p>泛型：<br>它提供了编译时类型安全检测机制，该机制允许再编译时检测到非法的类型，它的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。换个说法，其实就是将类型由原来的类型参数化，然后再使用/调用时传入具体的类型。<br>泛型定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类型1，类型2，……&gt;：指定多种类型的格式，多种类型之间用逗号隔开，这里的类型可以看作是形参。</span><br><span class="line">泛型类定义：public class Generic&lt; T &gt;&#123;</span><br><span class="line">	public void show(T t)&#123;</span><br><span class="line">	方法体</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型方法定义：</p>
<p>泛型方法定义：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Generic&#123;</span><br><span class="line">	public &lt; T &gt; void show&lt; T t &gt;&#123;</span><br><span class="line">	方法体	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>泛型接口定义：
修饰符 interface 接口名&lt;类型&gt;{}

泛型接口定义：
修饰符 interface 接口名&lt;类型&gt;{}</code></pre><ol start="20">
<li><p>类型通配符<br>为了标识各种类型List的父类，可以使用类型通配符&lt;?&gt;；<br>List&lt; ? &gt;表示元素类型未知的List，它的元素可以匹配任何的元素；如果不希望List&lt; ? &gt;是任何类型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限，如List&lt; ?extends Number &gt;：它表示的类型是Number或其子类型；也可以指定类型通配符的下限，如List&lt;?super Number&gt;：它表示的类型是Number或者其父类型。</p>
</li>
<li><p>个数可变参数<br>格式：修饰符 返回值类型 方法名(数据类型…变量名){ }，如public static int sum(int b, int… a){ } 注意：如果一个方法有多个参数，包含可变参数，可变参数要放在最后。</p>
</li>
<li><p>反射<br>若通过反射去使用一个类，首先要获取该类的字节码文件对象，也就是类型为Class类型的对象，三种方法获取Class类的对象。（此部分内容帮助文档搜索Class即可）<br>(1)使用类的class属性来获取该类对应的Class对象。举例，Class<Student> c1 = Student.class;<br>(2)调用对象的getClass()方法，返回该对象所属类对应的Class对象，举例，Student s = new Student()；Class<? extends Student> c2 = s.getClass();
(3)使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径。举例，Class<?> c4 = Class.forName(“com.xxxx.Student”);<br>获取Class类的对象之后，使用c.getConstructors();c.getDeclaredConstructors();等方法获取构造方法；使用c.getFields();c.getDeclaredFields();等方法获取成员变量；使用c.getMethods();c.getDeclaredMethods();等方法获取成员变量；</p>
</li>
<li><p>内省introspector：<br>(1)内省主要是用来操作Javabean属性的，那么什么是Javabean呢？这里举例说明比较好：<br>定义了一个类Person，里面有age,name,sex等，其实这个Person就是一个Javabean，里面的age,name,sex等是字段还不是属性，如何成为属性呢？只有对age,name,sex这些定义了set,get方法才能成为Javabean属性，也就是说是不是Javabean属性取决于set或get方法。<br>(2)使用内省操作：首先，获得操作Javabean，BeanInfo info = introspector.getBeanInfo(Person.class);然后，获得属性描述器，PropertyDescriptor[] pds = info.getPropertyDescriptors();接下来可以对增强for循环对pds中的每一个进行pd.getName()可以看到属性名；若针对某一个属性进行操作，PropertyDescriptor pd = new PropertyDescriptor(“age”, Person.class);  然后使用Method method = pd.getWriteMethod();得到属性的写方法，相当于set，method.invoke(p,45)即可完成设置属性，读取属性pd.getReadMethod();同理。</p>
</li>
<li><p>beanUtils操作bean属性：<br>相比于内省，beanUtils在开发中更常用，beanUtils是一个第三方jar包，需要导入。<br>使用起来比内省简单许多，BeanUtils.setProperty(bean,name,value)即可。</p>
</li>
<li><p>模块化<br>Java9正式推出了模块化，模块基本使用步骤：<br>(1)创建模块，按照之前的方式创建模块，创建包，创建类，定义方法即可；<br>(2)在模块的src目录下新建一个module-info.java的描述文件，（Eclipse在工程名右键-Configure）该文件专门定义模块名，访问权限，模块依赖等信息；<br>(3)模块中所有未导出的包都是模块私有的，他们是不能在模块外被访问的，模块导出格式：experts 包名；<br>(4)一个模块要访问其他模块，必须明确指定依赖哪些模块，未明确指定依赖的模块不能访问，模块依赖格式：requires 模块名；</p>
</li>
<li><p>JCF(这部分内容学习的不是很详细，需要时再来认真学)<br>JCF主要的数据结构实现类：<br>-列表:List,ArrayList,LinkedList<br>-集合:Set,HashSet,TreeSet,LinkedHashSet<br>-映射:Map,HashMap,TreeMap,LinkedHashMap<br>JCF主要的算法类（工具类）：<br>-Arrays:对数组进行查找和排序等操作<br>-Collections：对Collection及其子类进行排序和查找等操作</p>
</li>
<li><p>ArrayList：<br>ArrayList&lt; E &gt;：<br>(1)可调整大小的数组实现；<br>(2)&lt; E &gt;是一种特殊的数据类型，泛型，也就是在出现E的地方使用引用的数据类型替换即可；</p>
</li>
<li><ul>
<li><p>快速修复，ctrl+1</p>
</li>
<li><p>Eclipse自动生成返回值对象的快捷键：ctrl+1</p>
</li>
<li><p>快速生成main函数，输入main，alt+/</p>
</li>
<li><p>快速生成System.out.println()，输入syso，alt+/</p>
</li>
<li><p>内容提示，alt+/</p>
</li>
<li><p>自动import ，Ctrl + Shift + O</p>
</li>
<li><p>格式化代码，Ctrl + Shift + F</p>
</li>
<li><p>查看源码，ctrl+鼠标左键</p>
</li>
<li><p>向前向后，alt+左右</p>
</li>
<li><p>查看类的继承关系，ctrl+T</p>
</li>
<li><p>查看接口的实现类：ctrl+T</p>
</li>
<li><p>查看Eclipse所有快捷键，Ctrl + Shift + L</p>
</li>
<li><p>新版本的Eclipse已经默认支持取消“=”等号和空格自动输入，开启方法如下<code>Windows</code>→<code>Preferences</code>→<code>java</code>→<code>Content</code>→<code>Assist</code><br>勾选 Disable insertion triggers except ‘Enter’ 即可</p>
</li>
</ul>
</li>
</ol>
<ol start="29">
<li>Junit测试工具<br>(1)方法前加注解@Test，导入Juit包，右侧Outline工具框，选中要测试的方法，右键，Run As–&gt;JUit Test；<br>(2)测试类中最前和最后可以写两个方法，分别加注解@Before和@After或者@BeforeClass和@AfterClass，用于初始化和销毁；<br>(3)断言Assert，判断期望的实际的是否相同，相同则通过测试，否则不通过；</li>
</ol>
<hr>
<p>2019年10月27日</p>
<ol start="30">
<li>类加载器：每个编写的”.java”拓展名类文件都存储着需要执行的程序逻辑，这些”.java”文件经过Java编译器编译成拓展名为”.class”的文件，”.class”文件中保存着Java代码经转换后的虚拟机指令，当需要使用某个类时，虚拟机将会加载它的”.class”文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程称为类加载。</li>
<li>关于java中的classpath，请参考此处，<a href="https://my.oschina.net/zjllovecode/blog/916927" target="_blank" rel="noopener">戳戳戳</a>。</li>
</ol>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>QT学习</title>
    <url>/2019/09/01/2019-09-01-Qt%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<ol>
<li><p>定义宏</p>
<p><img src="https://i.loli.net/2019/09/10/cCQvDPKMqlYVTGI.png" alt=""></p>
</li>
<li><p>.exe无法直接运行：打包或者添加环境变量</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windeployqt HelloWorld.exe	//打包命令</span><br></pre></td></tr></table></figure>





<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架搭建</title>
    <url>/2019/08/31/2019-08-31-Spring%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>包括JDK的下载安装、eclipse的安装、Spring插件的安装、Spring开发环境的搭建</p>
</blockquote>
<h1 id="一、JDK的下载安装"><a href="#一、JDK的下载安装" class="headerlink" title="一、JDK的下载安装"></a>一、JDK的下载安装</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载链接：<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>我这里下载了Java SE 12.0.2，下载安装即可，可以装到其他盘符。但是在安装完成之后，安装目录下会有jre(Java Runtime Environment )文件夹，这里并没有，解决方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以管理员身份进入powershell，进入安装目录</span><br><span class="line">输入 bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</span><br></pre></td></tr></table></figure>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>这里有点坑，以后需要及时躲避。一般情况下配置环境变量比较简单，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建JAVA_HOME：jdk的绝对路径</span><br><span class="line">编辑Path： 增加%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</span><br><span class="line">新建Classpath： %JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure>

<p>但是我参照这种方法配置之后，cmd输入Java -version发现并没有配置成功，最后发现问题所在，这好像是win10的毛病，也就是添加环境变量的时候不能使用上述比较安全的方法，只能使用目前JDK安装的绝对路径直接添加到PATH中。也就是说JDK的安装路径以后不可以移动或者改变。</p>
<h1 id="二、eclipse的安装"><a href="#二、eclipse的安装" class="headerlink" title="二、eclipse的安装"></a>二、eclipse的安装</h1><p>这一步就很简单了，直接去<a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">官网</a>下载即可。下载之后打开注意去Help-&gt;About Eclipes IDE查看一下自己安装的版本号，我这里安装的是4.12.0，版本号接下来会用到。</p>
<h1 id="三、Spring插件的安装"><a href="#三、Spring插件的安装" class="headerlink" title="三、Spring插件的安装"></a>三、Spring插件的安装</h1><p>官网下载地址：<a href="https://spring.io/tools/sts/all" target="_blank" rel="noopener">https://spring.io/tools/sts/all</a></p>
<p><img src="https://i.loli.net/2019/08/31/WhkmQiFHw9Mx7Sj.png" alt=""></p>
<p>请看清楚刚才查看的的<strong>eclipse版本</strong>和对应的<strong>springsource-tool-suite版本</strong>，下载对应的版本。</p>
<h1 id="四、Spring插件的安装"><a href="#四、Spring插件的安装" class="headerlink" title="四、Spring插件的安装"></a>四、Spring插件的安装</h1><p>打开eclipse，选择 “Help” –&gt; “Install New Software” –&gt; “add” –&gt;”Archive” –&gt; 选择刚才下载好的springsource-tool-suite “打开”–&gt; “OK”。</p>
<p>选择要安装的组件：选定<strong>4个标有“IDE”的组件</strong>：</p>
<p><img src="https://i.loli.net/2019/08/31/cIDCvxFgwBs71qA.png" alt=""></p>
<p>接着一直点“Next”，最后“Finish”。等待其安装，右下角会提示进度。安装完之后会弹出对话框问是否<strong>重启eclipse</strong>，点“yes”重启。重启之后Window-&gt;Preferences，如在弹出的对话框出现如下内容，则安装成功。</p>
<p><img src="https://i.loli.net/2019/08/31/IrKA8YfgEsvbCwp.png" alt=""></p>
<h1 id="五、Spring开发环境的搭建"><a href="#五、Spring开发环境的搭建" class="headerlink" title="五、Spring开发环境的搭建"></a>五、Spring开发环境的搭建</h1><ol>
<li>左边窗口空白处右键–&gt;”New”–&gt;”Java Project”–&gt; 输入项目名称 –&gt;”Finish”；</li>
<li>右击刚才创建的项目，”New”–&gt;”Folder”新建文件夹，并命名为“lib”,”Finish”；</li>
</ol>
<p>注意在工程目录下可以看到jre的版本，不同版本的软件和组件之间有不同的兼容性，如果安装或使用过程中出现错误，请考虑是否需要更换版本。</p>
<ol start="3">
<li>获取以下五个jar包：</li>
</ol>
<p>具体获取方法如下：</p>
<ul>
<li><p>第一个，commons-logging-1.2 官网下载地址：</p>
<p><a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-logging/download_logging.cgi</a></p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/08/31/oJ6zZqUWNH9OiCv.png" alt=""></p>
<p>下载，解压，找到第一个jar包。</p>
<ul>
<li><p>下面四个jar包的 官网下载地址：</p>
<p><a href="https://maven.springframework.org/release/org/springframework/spring/4.3.8.RELEASE/" target="_blank" rel="noopener">https://maven.springframework.org/release/org/springframework/spring/4.3.8.RELEASE/</a></p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/08/31/pXWdClHoxP82GSI.png" alt=""></p>
<p>将<strong>第一个</strong>也下载下来，解压，在“lib”目录下找到另外四个jar包。</p>
<ol start="4">
<li><p>将这5个jar包复制到eclipse里你新建的spring项目下的“lib”里面：</p>
<p>选中jar包，ctrl+c，到eclipse里点击”lib”，ctrl+v 即可。现在的eclipse左侧窗口是这样的：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/08/31/E3qVTI74zk5LKeQ.png" alt=""></p>
<p>​        然后选中5个jar包，右键–&gt;”bulid path”–&gt;”add to build path”；</p>
<p>​        现在的左侧窗口是这样的：</p>
<p><img src="https://i.loli.net/2019/08/31/Of1zSG3bWVFHgIk.png" alt=""></p>
<p>​        到这里Spring的开发环境就搭建完成了。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下安装MySQL及连接</title>
    <url>/2019/08/30/2019-08-30-CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85MySQL%E5%8F%8A%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<blockquote>
<p>前段时间在闲置的电脑上装了centos7，打算先装个MySQL试试。在此记录一下。</p>
</blockquote>
<h1 id="一、添加yum源"><a href="#一、添加yum源" class="headerlink" title="一、添加yum源"></a>一、添加yum源</h1><p>MySQL官网：<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a></p>
<p>进入官网去选择合适的rpm包，包的作用是添加MySQL yum源，我在这里下载的是 mysql80-community-release-el7-3.noarch.rpm。下载之后通过XFTP上传文件到服务器，然后在rpm文件目录下执行yum localinstall 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum localinstall mysql80-community-release-el7-3.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>如果权限不够请使用sudo执行，执行完毕过后我们可以使用 cd /etc/yum.repos.d进入到目录中查看文件，发现会有如下两个文件：</p>
<ul>
<li>mysql-community.repo</li>
<li>mysql-community-source.repo</li>
</ul>
<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>当我们添加好yum源之后就可以执行安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure>

<h1 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h1><p>安装完成之后使用 systemctl start 执行启动MySQL命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure>

<p>使用  systemctl status mysqld.service  可以查看MySQL的运行状态。</p>
<p><img src="https://i.loli.net/2019/08/30/t37pmNBPezIiOXW.png" alt=""></p>
<p>关闭命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure>

<p>重启命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<h1 id="四、修改密码"><a href="#四、修改密码" class="headerlink" title="四、修改密码"></a>四、修改密码</h1><p>当MySQL服务启动之后我们就需要对密码进行更改：MySQL 默认创建了 root 用户的密码，这个密码打印在 MySQL 的日志文件<code>/var/log/mysqld.log</code>中，可以通过<code>temporary password</code>关键字来找出这个临时的密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>找到密码之后使用改密码连接数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>然后修改密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;NewPassword&apos;;</span><br></pre></td></tr></table></figure>

<p>执行上述命令密码将被修改为：NewPassword</p>
<p>PS：新版本的MySQL对密码强度有限制，执行到上一步的时候，会提示密码强度不够，则应更改为更高强度的密码。</p>
<p>密码更改完成之后重启MySQL服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>



<h1 id="五、开放远程连接"><a href="#五、开放远程连接" class="headerlink" title="五、开放远程连接"></a>五、开放远程连接</h1><p>MySQL默认只对本机开放连接，我们则需要对mysql表的host字段进行修改以支持其他主机连接,%表示所有。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先连接数据库</span><br><span class="line">use mysql;</span><br><span class="line">update user set host = &apos;%&apos; where user = &apos;root&apos;;</span><br></pre></td></tr></table></figure>

<p>更改完成之后刷新权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>然后在navicat新建连接：</p>
<p><img src="https://i.loli.net/2019/08/30/XnKBdbcOxWtPizu.png" alt=""></p>
<p>问题解决步骤：</p>
<p>发现是防火墙未关闭，有两种方法去解决。</p>
<ol>
<li>关闭防火墙</li>
<li>设置防火墙开放端口</li>
</ol>
<p>第一种方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//停止</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">//禁止开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<p>第二种方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这里发现防火墙是开启的，再来查看防火墙控制的端口</span><br><span class="line">systemctl status firewalld</span><br><span class="line">//查看防火墙控制的端口，发现我想要监听的8081端口没有开启</span><br><span class="line">firewall-cmd --list-all</span><br><span class="line">//永久开启3306端口</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">//重载防火墙</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>



<p>我使用了第一种</p>
<p><img src="https://i.loli.net/2019/08/30/geVp1iWMNvorOXU.png" alt=""></p>
<p>再次实验，成功</p>
<p><img src="https://i.loli.net/2019/08/30/bFtJRPHxdwViOyz.png" alt=""></p>
<p><strong>注：</strong>在用正版navicat连接MySQL8+时没问题，但使用破解版会出现2059错误，这是由于新版本的MySQL使用的是caching_sha2_password验证方式，但此时的navicat还没有支持这种验证方式。解决方法就是将验证方式改为以前版本(5.7及以下)使用的验证方式mysql_native_password。</p>
<hr>
<h1 id="后续："><a href="#后续：" class="headerlink" title="后续："></a>后续：</h1><p>2019.09.12</p>
<p>后期在安装mysql5.7时遇到了不少大坑，在此记录一下。</p>
<h2 id="1、安装mysql5-7"><a href="#1、安装mysql5-7" class="headerlink" title="1、安装mysql5.7"></a>1、安装mysql5.7</h2><p>CentOS 7之后的版本yum的默认源中使用MariaDB替代原先MySQL，因此安装方式较为以往有一些改变：</p>
<p>下载mysql的源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>安装yum库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum localinstall -y mysql57-community-release-el7-7.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>安装MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y mysql-community-server</span><br></pre></td></tr></table></figure>

<p>启动MySQL服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure>

<h2 id="2、修改MySQL的root密码"><a href="#2、修改MySQL的root密码" class="headerlink" title="2、修改MySQL的root密码"></a>2、修改MySQL的root密码</h2><p>MySQL5.7加强了root用户的安全性，因此在第一次安装后会初始化一个随机密码，以下为查看初始随机密码的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>进入mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p>完成之后进入，首先修改密码策略，然后修改密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password.policy=0;  // 有时为validate_password_policy</span><br><span class="line">set global validate_password.length=1;  // 有时为validate_password_length</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456789&apos;;</span><br></pre></td></tr></table></figure>

<p>然后退出后即可用新密码登录。</p>
<h2 id="3、远程连接授权"><a href="#3、远程连接授权" class="headerlink" title="3、远程连接授权"></a>3、远程连接授权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>授权之后，用nevicat检查一下是否可以连接，如果不可以，可能是防火墙限制了。需要在防火墙里面加开放数据库端口的规则。</p>
<h2 id="4、防火墙开放数据库端口（默认3306，可以在-etc-my-cnf中修改）"><a href="#4、防火墙开放数据库端口（默认3306，可以在-etc-my-cnf中修改）" class="headerlink" title="4、防火墙开放数据库端口（默认3306，可以在/etc/my.cnf中修改）"></a>4、防火墙开放数据库端口（默认3306，可以在/etc/my.cnf中修改）</h2><p>【1】查看目前防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all   // 若提示firewallD is not running,systemctl start firewalld开启</span><br></pre></td></tr></table></figure>

<p>【2】开放3306端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=3306/tcp</span><br></pre></td></tr></table></figure>

<p>【3】重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service firewalld restart</span><br></pre></td></tr></table></figure>

<p>【4】查看3306端口是否开放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port=3306/tcp</span><br></pre></td></tr></table></figure>

<p>【5】再次查看现在防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<p>【6】再次测试是否可以远程连接，成功。</p>
<h2 id="5、设置开机自启"><a href="#5、设置开机自启" class="headerlink" title="5、设置开机自启"></a>5、设置开机自启</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(2)-JavaScript核心DOM BOM1</title>
    <url>/2019/08/23/2019-08-23-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(2)-JavaScript%E6%A0%B8%E5%BF%83DOM%20BOM1/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。<br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 2：JavaScript，此部分涉及许多计算机及编程基础知识，这里略过不做记录，只记录之前用的比较少的部分。</p>
</blockquote>
<h1 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h1><h2 id="Web-API介绍"><a href="#Web-API介绍" class="headerlink" title="Web API介绍"></a>Web API介绍</h2><h3 id="API的概念"><a href="#API的概念" class="headerlink" title="API的概念"></a>API的概念</h3><p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p>
<ul>
<li>任何开发语言都有自己的API</li>
<li>API的特征输入和输出(I/O)</li>
<li>API的使用方法(console.log())</li>
</ul>
<h3 id="Web-API的概念"><a href="#Web-API的概念" class="headerlink" title="Web API的概念"></a>Web API的概念</h3><p>浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM)</p>
<p>此处的Web API特指浏览器提供的API(一组方法)，Web API在后面的课程中有其它含义</p>
<h3 id="掌握常见的浏览器提供的API的调用方式"><a href="#掌握常见的浏览器提供的API的调用方式" class="headerlink" title="掌握常见的浏览器提供的API的调用方式"></a>掌握常见的浏览器提供的API的调用方式</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="noopener">MDN-Web API</a></p>
<h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h3><p>![1496912475691](D:/Study/02-JavaScript-WEB-API-第1天/01教学资料/02-Web API/media/1496912475691.png)</p>
<h4 id="ECMAScript-JavaScript的核心"><a href="#ECMAScript-JavaScript的核心" class="headerlink" title="ECMAScript - JavaScript的核心"></a>ECMAScript - JavaScript的核心</h4><p>定义了javascript的语法规范</p>
<p>JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关</p>
<h4 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM - 浏览器对象模型"></a>BOM - 浏览器对象模型</h4><p>一套操作浏览器功能的API</p>
<p>通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等</p>
<h4 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM - 文档对象模型"></a>DOM - 文档对象模型</h4><p>一套操作页面元素的API</p>
<p>DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作</p>
<h1 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h1><p><img src="https://i.loli.net/2019/08/23/guHfc9jkz6JmOwM.png" alt=""></p>
<ul>
<li>文档：一个页面就是一个文档，DOM 中使用 document 表示</li>
<li>元素：页面中的所有标签都是元素，DOM 中使用 element 表示</li>
<li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 node 表示</li>
</ul>
<p><strong>DOM 把以上内容都看做是对象</strong></p>
<h2 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h2><h3 id="根据ID获取"><a href="#根据ID获取" class="headerlink" title="根据ID获取"></a>根据ID获取</h3><p>使用 getElementById() 方法可以获取带有ID 的元素对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'id'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="根据标签名获取"><a href="#根据标签名获取" class="headerlink" title="根据标签名获取"></a>根据标签名获取</h3><p>使用 getElementsByTagName() 方法可以返回带有指定标签名的对象的集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'标签名'</span>);</span><br></pre></td></tr></table></figure>

<p>注意： </p>
<p>1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。</p>
<p>2.得到元素对象是动态的</p>
<p>3.如果获取不到元素,则返回为空的伪数组(因为获取不到对象)</p>
<p>还可以获取某个元素(父元素)内部所有指定标签名的子元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.getElementsByTagName(<span class="string">'标签名'</span>);</span><br></pre></td></tr></table></figure>

<p>注意：父元素必须是单个对象(必须指明是哪一个元素对象)，获取的时候不包括父元素自己。</p>
<h3 id="Html5新增的获取方法"><a href="#Html5新增的获取方法" class="headerlink" title="Html5新增的获取方法"></a>Html5新增的获取方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">document</span>.getElementsByClassName(‘类名’)；<span class="comment">// 根据类名返回元素对象集合</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">document</span>.querySelector(<span class="string">'选择器'</span>);        <span class="comment">// 根据指定选择器返回第一个元素对象</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">document</span>.querySelectorAll(<span class="string">'选择器'</span>);     <span class="comment">// 根据指定选择器返回</span></span><br></pre></td></tr></table></figure>

<p>注意：querySelector 和 querySelectorAll里面的选择器需要加符号,比如:document.querySelector(‘#nav’); </p>
<h3 id="特殊元素（body-html获取）"><a href="#特殊元素（body-html获取）" class="headerlink" title="特殊元素（body/html获取）"></a>特殊元素（body/html获取）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> doucumnet.body  <span class="comment">// 返回body元素对象</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">document</span>.documentElement  <span class="comment">// 返回html元素对象</span></span><br></pre></td></tr></table></figure>

<h2 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h2><h3 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h3><p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p>
<p>简单理解： 触发— 响应机制。</p>
<p>网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。</p>
<h3 id="事件执行步骤"><a href="#事件执行步骤" class="headerlink" title="事件执行步骤"></a>事件执行步骤</h3><ol>
<li><p>获取事件源</p>
</li>
<li><p>注册事件（绑定事件）</p>
</li>
<li><p>添加事件处理程序（采取函数赋值形式）</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/08/23/BYRD13zFGnq5dmw.png" alt=""></p>
<h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><h3 id="改变元素内容"><a href="#改变元素内容" class="headerlink" title="改变元素内容"></a>改变元素内容</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.innerText</span><br></pre></td></tr></table></figure>

<p>从起始位置到终止位置的内容, 但它去除 html 标签，同时空格和换行也会去掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.innerHTML</span><br></pre></td></tr></table></figure>

<p>起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行。</p>
<h3 id="常用元素的属性操作"><a href="#常用元素的属性操作" class="headerlink" title="常用元素的属性操作"></a>常用元素的属性操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> src、href</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> id、alt、title</span><br></pre></td></tr></table></figure>

<p>直接在事件中修改元素.属性即可。</p>
<h3 id="表单元素属性修改"><a href="#表单元素属性修改" class="headerlink" title="表单元素属性修改"></a>表单元素属性修改</h3><p>利用 DOM 可以操作如下表单元素的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  type、value、checked、selected、disabled</span><br><span class="line">- value 用于大部分表单元素的内容获取(option除外)</span><br><span class="line">- type 可以获取input标签的类型(输入框或复选框等)</span><br><span class="line">- disabled 禁用属性</span><br><span class="line">- checked 复选框选中属性</span><br><span class="line">- selected 下拉菜单选中属性</span><br></pre></td></tr></table></figure>

<h3 id="样式属性操作"><a href="#样式属性操作" class="headerlink" title="样式属性操作"></a>样式属性操作</h3><p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> element.style     行内样式操作</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> element.className 类名样式操作</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor</li>
<li>JS 修改 style 样式操作，产生的是行内样式，权重比CSS 高</li>
<li>如果样式修改较多，可以采取操作类名方式更改元素样式。 </li>
<li>class因为是个保留字，因此使用className来操作元素类名属性</li>
<li>className 会直接更改元素的类名，会覆盖原先的类名，如果想要保留原类名，使用多类名选择器，即this.className=’原类名 新类名’。</li>
</ol>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(2)-JavaScript入门与提高2</title>
    <url>/2019/08/22/2019-08-22-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(2)-JavaScript%E5%85%A5%E9%97%A8%E4%B8%8E%E6%8F%90%E9%AB%982/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。<br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 2：JavaScript，此部分涉及许多计算机及编程基础知识，这里略过不做记录，只记录之前用的比较少的部分。</p>
</blockquote>
<h1 id="对象定义"><a href="#对象定义" class="headerlink" title="对象定义"></a>对象定义</h1><p>对象是由属性和方法组成的。</p>
<ul>
<li>属性：事物的<strong>特征，</strong>在对象中用<strong>属性</strong>来表示（常用名词）</li>
<li>方法：事物的<strong>行为，</strong>在对象中用<strong>方法</strong>来表示（常用动词）</li>
</ul>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h2><p>对象字面量：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法。</p>
<p>{ } 里面采取<strong>键值对</strong>的形式表示 </p>
<ul>
<li>键：相当于属性名</li>
<li>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</li>
</ul>
<h3 id="对象的调用"><a href="#对象的调用" class="headerlink" title="对象的调用"></a>对象的调用</h3><ul>
<li>对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”  </li>
<li>对象里面属性的另一种调用方式 : 对象[‘属性名’]<strong>，</strong>注意方括号里面的属性必须加引号</li>
<li>对象里面的方法调用：对象.方法名() <strong>，</strong>注意这个方法名字后面一定加括号 </li>
</ul>
<h2 id="利用new-Object创建对象"><a href="#利用new-Object创建对象" class="headerlink" title="利用new Object创建对象"></a>利用new Object创建对象</h2><ul>
<li>Object() ：第一个字母大写   </li>
<li>new Object() ：需要 new 关键字</li>
<li>使用的格式：对象.属性 =  值;     </li>
</ul>
<h2 id="利用构造函数创建对象"><a href="#利用构造函数创建对象" class="headerlink" title="利用构造函数创建对象"></a>利用构造函数创建对象</h2><p><strong>构造函数 ：</strong>是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p>
<p>在 js 中，使用构造函数要时要注意以下两点：</p>
<ul>
<li>构造函数用于创建某一类对象，其首字母要大写</li>
<li>构造函数要和 new 一起使用才有意义</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'我的名字叫：'</span> + <span class="keyword">this</span>.name + <span class="string">'，年龄：'</span> + <span class="keyword">this</span>.age + <span class="string">'，性别：'</span> + <span class="keyword">this</span>.sex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.sing = <span class="function"><span class="keyword">function</span>(<span class="params">song</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我会唱'</span> + song);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bigbai = <span class="keyword">new</span> Person(<span class="string">'大白'</span>, <span class="number">100</span>, <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">var</span> smallbai = <span class="keyword">new</span> Person(<span class="string">'小白'</span>, <span class="number">21</span>, <span class="string">'男'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bigbai.name);</span><br><span class="line"><span class="built_in">console</span>.log(smallbai.name);</span><br><span class="line">bigbai.sayHi();</span><br><span class="line">smallbai.sing(<span class="string">'爱你一万年'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ol>
<li><p>构造函数约定首字母大写。</p>
</li>
<li><p>函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。</p>
</li>
<li><p>构造函数中不需要 return 返回结果。</p>
</li>
<li><p>当我们创建对象的时候，必须用 new 来调用构造函数。</p>
</li>
</ol>
<p><strong>new在执行时会做四件事情</strong>：</p>
<ol>
<li><p>在内存中创建一个新的空对象。</p>
</li>
<li><p>让 this 指向这个新的对象。</p>
</li>
<li><p>执行构造函数里面的代码，给这个新对象添加属性和方法。</p>
</li>
<li><p>返回这个新对象（所以构造函数里面不需要return）。</p>
</li>
</ol>
<h1 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h1><p>for…in 语句用于对数组或者对象的属性进行循环操作。</p>
<p>其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (变量 <span class="keyword">in</span> 对象名字) &#123;</span><br><span class="line">    <span class="comment">// 在此执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);      <span class="comment">// 这里的 k 是属性名</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[k]); <span class="comment">// 这里的 obj[k] 是属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><h2 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h2><p>Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。</p>
<p>MDN:   <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.</a><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">mozilla.org/zh-CN/</a></p>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p>Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用Math 中的成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.PI		 <span class="comment">// 圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.floor() 	 <span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">Math</span>.ceil()            <span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.round()           <span class="comment">// 四舍五入版 就近取整   注意 -3.5   结果是  -3 </span></span><br><span class="line"><span class="built_in">Math</span>.abs()		 <span class="comment">// 绝对值</span></span><br><span class="line"><span class="built_in">Math</span>.max()/<span class="built_in">Math</span>.min()	 <span class="comment">// 求最大和最小值 </span></span><br><span class="line"><span class="built_in">Math</span>.random()		<span class="comment">//随机返回一个小数，其取值范围是 [0，1)</span></span><br></pre></td></tr></table></figure>

<h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><p>Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用。Date 实例用来处理日期和时间。</p>
<p><strong>Date() 构造函数的参数</strong></p>
<p>如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’，可以写成new Date(‘2019-5-1’)  或者 new Date(‘2019/5/1’)</p>
<ul>
<li>如果Date()不写参数，就返回当前时间</li>
<li>如果Date()里面写参数，就返回括号里面输入的时间 </li>
</ul>
<p><strong>日期格式化</strong></p>
<p><img src="https://i.loli.net/2019/08/23/Okb9uAYSzGscI35.png" alt=""></p>
<p>​        <strong>注意：</strong></p>
<ul>
<li>月份因为返回的是0到11，所以要+1才正确；</li>
<li>星期一到六返回1-6，但是星期日返回的是0而不是7；</li>
</ul>
<p><strong>时间戳</strong></p>
<p>Date 对象是基于1970年1月1日（世界标准时间）起的毫秒数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化Date对象</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 1. 用于获取对象的原始值</span></span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf())	</span><br><span class="line"><span class="built_in">console</span>.log(date.getTime())	</span><br><span class="line"><span class="comment">// 2. 简单写可以这么做</span></span><br><span class="line"><span class="keyword">var</span> date1 = + <span class="keyword">new</span> <span class="built_in">Date</span>();			</span><br><span class="line"><span class="comment">// 3. HTML5中提供的方法，有兼容性问题</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="built_in">Date</span>.now();</span><br></pre></td></tr></table></figure>

<h2 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h2><p><strong>检测是否为数组</strong></p>
<ul>
<li>instanceof 运算符，可以判断一个对象是否属于某种类型</li>
<li>Array.isArray判断一个对象是否为() 5 中提供的方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr));   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(obj));   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>数组增删元素</strong></p>
<p><img src="https://i.loli.net/2019/08/23/b1F8oh9AxB6Yrp3.png" alt=""></p>
<p><strong>数组排序</strong></p>
<p><img src="https://i.loli.net/2019/08/23/lNJcaLtmfzDQv3R.png" alt=""></p>
<p>​        <strong>注意</strong></p>
<p>sort排序会有问题，如[1,4,13,56,43,5]sort排序后结果为[1,13,4,43,5,56]解决方案如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">64</span>, <span class="number">9</span>, <span class="number">6</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;      <span class="comment">// 降a序</span></span><br><span class="line">    <span class="comment">// return a - b;   // 升序</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<p><strong>数组转换为字符串</strong></p>
<p><img src="https://i.loli.net/2019/08/23/oDsI1fW4baF5kxK.png" alt=""></p>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p><strong>基本包装类型</strong></p>
<p>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p>
<p>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'andy'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length);</span><br></pre></td></tr></table></figure>

<p>按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为<br>js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'andy'</span>);</span><br><span class="line"><span class="comment">// 2. 赋值给我们声明的字符变量</span></span><br><span class="line">str = temp;</span><br><span class="line"><span class="comment">// 3. 销毁临时变量</span></span><br><span class="line">temp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>字符串的不可变</strong></p>
<p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span>;</span><br><span class="line">str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// 当重新给 str 赋值的时候，常量'abc'不会被修改，依然在内存中</span></span><br><span class="line"><span class="comment">// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变</span></span><br><span class="line"><span class="comment">// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    str += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串转换为数组</strong></p>
<p>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a,b,c,d'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">','</span>));   <span class="comment">// 返回的是一个数组 [a, b, c, d]</span></span><br></pre></td></tr></table></figure>

<h1 id="简单对象与复杂对象"><a href="#简单对象与复杂对象" class="headerlink" title="简单对象与复杂对象"></a>简单对象与复杂对象</h1><p>简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。</p>
<ul>
<li><p>值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型。</p>
<p>string ，number，boolean，undefined，null</p>
</li>
<li><p>引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型。</p>
<p>通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</p>
</li>
</ul>
<p><strong>堆栈空间分配区别：</strong></p>
<p>　　1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</p>
<p><em>简单数据类型存放到栈里面</em></p>
<p>　　2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p>
<p><em>复杂数据类型存放到堆里面</em></p>
<p><strong>注意：</strong><code>JavaScript</code>中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言。</p>
<p><strong>简单对象内存分配</strong></p>
<ul>
<li>值类型（简单数据类型）： string ，number，boolean，undefined，null</li>
<li>值类型变量的数据直接存放在变量（栈空间）中</li>
</ul>
<p><img src="https://i.loli.net/2019/08/23/I7tC4Tk3pjO8VWr.png" alt=""></p>
<p><strong>复杂对象内存分配</strong></p>
<ul>
<li>引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</li>
<li>引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</li>
</ul>
<p><img src="https://i.loli.net/2019/08/23/FZMg8OEDvKPioIr.png" alt=""></p>
<p><strong>简单对象传参</strong></p>
<p>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//11</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">fn(x);</span><br><span class="line"><span class="built_in">console</span>.log(x)；  <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂对象传参</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// x = p</span></span><br><span class="line">    <span class="built_in">console</span>.log(x.name); <span class="comment">// 2. 这个输出什么 ?   刘德华 </span></span><br><span class="line">    x.name = <span class="string">"张学友"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x.name); <span class="comment">// 3. 这个输出什么 ?   张学友</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"刘德华"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name);    <span class="comment">// 1. 这个输出什么 ?   刘德华</span></span><br><span class="line">f1(p);</span><br><span class="line"><span class="built_in">console</span>.log(p.name);    <span class="comment">// 4. 这个输出什么 ?   张学友</span></span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(2)-JavaScript入门与提高1</title>
    <url>/2019/08/19/2019-08-19-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(2)-JavaScript%E5%85%A5%E9%97%A8%E4%B8%8E%E6%8F%90%E9%AB%981/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。<br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 2：JavaScript，此部分涉及许多计算机及编程基础知识，这里略过不做记录，只记录之前用的比较少的部分。</p>
</blockquote>
<h1 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h1><p>断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。</p>
<p><strong>断点调试可以帮我们观察程序的运行过程</strong></p>
<p>浏览器中按 F12–&gt; sources –&gt;找到需要调试的文件–&gt;在程序的某一行设置断点</p>
<p>Watch: 监视，通过watch可以监视变量的值的变化。</p>
<p>F11: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。</p>
<h1 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h1><p>do… while 语句其实是 while 语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。</p>
<p>do… while 语句的语法结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    // 循环体代码 - 条件表达式为 true 时重复执行循环体代码</span><br><span class="line">&#125; while(条件表达式);</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<p>①先执行一次循环体代码 </p>
<p>②再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码</p>
<p><strong>注意：</strong>先再执行循环体，再判断，我们会发现 do…while<br>循环语句<strong>至少</strong>会执行一次循环体代码。</p>
<h1 id="continue和-break"><a href="#continue和-break" class="headerlink" title="continue和 break"></a>continue和 break</h1><p><strong>continue 关键字</strong></p>
<p>continue 关键字用于立即跳出本次循环<strong>，</strong>继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。</p>
<p>例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个。</p>
<p><strong>break关键字</strong></p>
<p>break关键字用于立即跳出整个循环（循环结束）。</p>
<p>例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><p><strong>利用数组字面量创建数组</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 使用数组字面量方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = []；</span><br><span class="line"><span class="comment">//2. 使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = [<span class="string">'小白'</span>,<span class="string">'小黑'</span>,<span class="string">'大黄'</span>,<span class="string">'瑞奇'</span>];</span><br></pre></td></tr></table></figure>

<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>使用“数组名.length”可以访问数组元素的数量（数组长度）。  </p>
<p>筛选数组案例</p>
<p>要求：将数组 [2, 0,<br>6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">77</span>, <span class="number">0</span>, <span class="number">52</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引号直接用newArr.length</span></span><br><span class="line">        newArr[newArr.length] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure>

<h1 id="函数形参和实参个数匹配"><a href="#函数形参和实参个数匹配" class="headerlink" title="函数形参和实参个数匹配"></a>函数形参和实参个数匹配</h1><p><img src="https://i.loli.net/2019/08/22/tP4MwfpA2yhcxio.png" alt=""></p>
<h1 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h1><ol>
<li><p>return 语句之后的代码不被执行。、</p>
</li>
<li><p><strong>return</strong> <strong>只能返回一个值</strong>。如果用逗号隔开多个值，以最后一个为准。</p>
</li>
<li><p>return若要返回多个值，采取数组等方法。</p>
</li>
<li><p>函数都是有返回值的</p>
<p>1）如果有return 则返回 return 后面的值；</p>
<p>2）如果没有return 则返回 undefined ；</p>
</li>
<li><ul>
<li><p>break ：结束当前的循环体（如 for、while）</p>
</li>
<li><p>continue ：跳出本次循环，继续执行下次循环（如 for、while）</p>
</li>
<li><p>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</p>
</li>
</ul>
</li>
</ol>
<h1 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h1><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。</p>
<p>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p>
<ul>
<li>具有 length 属性</li>
<li>按索引方式储存数据</li>
<li>不具有数组的 push , pop 等方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> max = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (max &lt; <span class="built_in">arguments</span>[i]) &#123;</span><br><span class="line">                    max = <span class="built_in">arguments</span>[i];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">console</span>.log(maxValue(<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(maxValue(<span class="number">12</span>, <span class="number">4</span>, <span class="number">9</span>));</span><br></pre></td></tr></table></figure>

<h1 id="函数两种声明方式"><a href="#函数两种声明方式" class="headerlink" title="函数两种声明方式"></a>函数两种声明方式</h1><ol>
<li><p>自定义函数方式（命名函数）</p>
<p>利用函数关键字 function 自定义函数方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明定义方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 调用  </span></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数表达式方式 （匿名函数）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是函数表达式写法，匿名函数后面跟分号结束</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;；</span><br><span class="line"><span class="comment">// 调用的方式，函数调用必须写到函数体下面</span></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h1><p>在JavaScript中，根据作用域的不同，变量可以分为两种：</p>
<ol>
<li><p>全局变量</p>
<p>全局变量在代码的任何位置都可以使用。只有在浏览器关闭时才会被销毁，因此比较占内存。</p>
<ul>
<li>在全局作用域下 var 声明的变量，是全局变量</li>
<li>特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）</li>
</ul>
</li>
<li><p>局部变量</p>
<p>局部变量只能在该函数内部使用。当代码块运行结束后，就会被销毁，因此更节省内存空间。</p>
<ul>
<li>在函数内部 var 声明的变量是局部变量</li>
<li>函数的形参实际上就是局部变量</li>
</ul>
</li>
</ol>
<p>预解析</p>
<p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。</p>
<p><strong>预解析：</strong>在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。</p>
<p><strong>代码执行：</strong> 从上到下执行JS语句。</p>
<p>预解析只会发生在通过 var 定义的变量和 function 上。</p>
<h2 id="变量预解析（变量提升）"><a href="#变量预解析（变量提升）" class="headerlink" title="变量预解析（变量提升）"></a>变量预解析（变量提升）</h2><p>变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。</p>
<h2 id="函数预解析（函数提升）"><a href="#函数预解析（函数提升）" class="headerlink" title="函数预解析（函数提升）"></a>函数预解析（函数提升）</h2><p>函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经典案例，下面结果是什么？</span></span><br><span class="line">f1();</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = b = c = <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照预解析规则解析以及按照作用域规则执行后，相当于执行以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    a = b = c = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// 相当于 var  a  = 9; b = 9; c = 9; b 和 c 直接赋值 没有var声明 当全局变量看，只有a进行了声明，为局部变量。</span></span><br><span class="line">    <span class="comment">// 集体声明  var a = 9, b = 9, c = 9;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先执行函数内的三个console.log，输出9，9，9，再执行函数外的三个console.log，输出9，9，报错（a为局部变量，全局未定义）。</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高12</title>
    <url>/2019/08/16/2019-08-16-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%9812/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="过渡-CSS3"><a href="#过渡-CSS3" class="headerlink" title="过渡(CSS3)"></a>过渡(CSS3)</h1><p>过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p>
<p>在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。</p>
<p>语法格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition: 要过渡的属性  花费时间  运动曲线  何时开始;</span><br><span class="line">如果有多组属性变化，还是用逗号隔开。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>CSS</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
<td>3</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称。</td>
<td>3</td>
</tr>
<tr>
<td>transition-duration</td>
<td>定义过渡效果花费的时间。默认是 0。</td>
<td>3</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线。默认是 “ease”。</td>
<td>3</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始。默认是 0。</td>
<td>3</td>
</tr>
</tbody></table>
<p>如果多个属性都要效果，用逗号隔开即可；如果想要所有的属性都变化过渡， 写一个all 就可以。</p>
<p>运动曲线示意图：</p>
<p><img src="https://i.loli.net/2019/08/16/nW2VBGMACaYmeSR.png" alt=""></p>
<h1 id="2D变形-CSS3-transform"><a href="#2D变形-CSS3-transform" class="headerlink" title="2D变形(CSS3) transform"></a>2D变形(CSS3) transform</h1><p>transform是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、倾斜、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。</p>
<h2 id="移动-translate-x-y"><a href="#移动-translate-x-y" class="headerlink" title="移动 translate(x, y)"></a>移动 translate(x, y)</h2><p><img src="https://i.loli.net/2019/08/18/M3Xa4CQWFiKwoOJ.png" alt=""></p>
<p>可以改变元素的位置，x、y可为负值；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）</span><br><span class="line">translateX(x)仅水平方向移动（X轴移动）</span><br><span class="line">translateY(Y)仅垂直方向移动（Y轴移动）</span><br></pre></td></tr></table></figure>

<h2 id="缩放-scale-x-y"><a href="#缩放-scale-x-y" class="headerlink" title="缩放 scale(x, y)"></a>缩放 scale(x, y)</h2><p><img src="https://i.loli.net/2019/08/18/ZFJwyPhBe6a1WAG.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）</span><br><span class="line">scaleX(x)元素仅水平方向缩放（X轴缩放）</span><br><span class="line">scaleY(y)元素仅垂直方向缩放（Y轴缩放）</span><br></pre></td></tr></table></figure>

<p> scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大。</p>
<h2 id="旋转-rotate-deg"><a href="#旋转-rotate-deg" class="headerlink" title="旋转 rotate(deg)"></a>旋转 rotate(deg)</h2><p><img src="https://i.loli.net/2019/08/18/3PV4dGBDxnF9Mk2.png" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:rotate(45deg)</span>;</span><br></pre></td></tr></table></figure>

<p> 注意单位是 deg 度数      </p>
<p>transform-origin可以调整元素转换变形的原点。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">transform-origin</span>: left top;<span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg); &#125;  <span class="comment">/* 改变元素原点到左上角，然后进行顺时旋转45度 */</span></span><br></pre></td></tr></table></figure>

<p> 如果是4个角，可以用 left top这些，如果想要精确的位置， 可以用  px 像素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">transform-origin</span>: <span class="number">10px</span> <span class="number">10px</span>;<span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg); &#125;  <span class="comment">/* 改变元素原点到x 为10  y 为10，然后进行顺时旋转45度 */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/08/18/5oLbuKF3Iq6TpXV.png" alt=""></p>
<h2 id="倾斜-skew-deg-deg"><a href="#倾斜-skew-deg-deg" class="headerlink" title="倾斜 skew(deg, deg)"></a>倾斜 skew(deg, deg)</h2><p><img src="https://i.loli.net/2019/08/18/Y3yMilbtRao6BKs.png" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:skew(30deg</span>,0<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>

<p>该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。</p>
<p>可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。</p>
<h1 id="3D变形-CSS3-transform"><a href="#3D变形-CSS3-transform" class="headerlink" title="3D变形(CSS3) transform"></a>3D变形(CSS3) transform</h1><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><h3 id="rotateX"><a href="#rotateX" class="headerlink" title="rotateX()"></a>rotateX()</h3><p> 沿着 x 立体旋转。</p>
<h3 id="rotateY"><a href="#rotateY" class="headerlink" title="rotateY()"></a>rotateY()</h3><p>沿着y轴进行旋转。</p>
<h3 id="rotateZ-"><a href="#rotateZ-" class="headerlink" title="rotateZ()"></a>rotateZ()</h3><p>沿着z轴进行旋转。</p>
<h2 id="透视-perspective"><a href="#透视-perspective" class="headerlink" title="透视(perspective)"></a>透视(perspective)</h2><p>电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。</p>
<p>透视可以将一个2D平面，在转换的过程当中，呈现3D效果。</p>
<ul>
<li>透视原理： 近大远小 。</li>
<li>浏览器透视：把近大远小的所有图像，透视在屏幕上。</li>
<li>perspective：视距，表示视点距离屏幕的长短。视点，用于模拟透视效果时人眼的位置</li>
</ul>
<p>注：并非任何情况下需要透视效果，根据开发需要进行设置。</p>
<p>perspective 一般作为一个属性，设置给父元素，作用于所有3D转换的子元素</p>
<p>理解透视距离原理：</p>
<p><img src="https://i.loli.net/2019/08/18/OKtFYf8Az1xhJWw.png" alt=""></p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><h3 id="translateX-x"><a href="#translateX-x" class="headerlink" title="translateX(x)"></a>translateX(x)</h3><p>仅水平方向移动**（X轴移动）</p>
<p><img src="https://i.loli.net/2019/08/18/45YPNsmgDZCR2WX.png" alt=""></p>
<p>主要目的实现移动效果。</p>
<h3 id="translateY-y"><a href="#translateY-y" class="headerlink" title="translateY(y)"></a>translateY(y)</h3><p>仅垂直方向移动（Y轴移动）</p>
<p><img src="https://i.loli.net/2019/08/18/UcuZoiNAwq5nEhR.png" alt=""></p>
<h3 id="translateZ-z"><a href="#translateZ-z" class="headerlink" title="translateZ(z)"></a>translateZ(z)</h3><p>transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。</p>
<h3 id="translate3d-x-y-z"><a href="#translate3d-x-y-z" class="headerlink" title="translate3d(x,y,z)"></a>translate3d(x,y,z)</h3><p>[注意]其中，x和y可以是长度值，也可以是百分比，百分比是相对于其本身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值</p>
<h3 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h3><p>backface-visibility 属性定义当元素不面向屏幕时是否可见。</p>
<h1 id="动画-CSS3-animation"><a href="#动画-CSS3-animation" class="headerlink" title="动画(CSS3) animation"></a>动画(CSS3) animation</h1><p>动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p>
<p>动画调用语法格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>:动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/08/18/jHQsoxCn5ulKfLh.png" alt=""></p>
<p>关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation-iteration-count:infinite;  无限循环播放animation-play-state:paused;   暂停动画</span><br></pre></td></tr></table></figure>

<p>动画定义语法格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> 动画名称 &#123;</span><br><span class="line">  from&#123; 开始位置 &#125;  0%</span><br><span class="line">  to&#123;  结束  &#125;  100%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="伸缩布局-CSS3"><a href="#伸缩布局-CSS3" class="headerlink" title="伸缩布局(CSS3)"></a>伸缩布局(CSS3)</h1><p>CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。</p>
<p>主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向</p>
<p>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的</p>
<p>方向：默认主轴从左向右，侧轴默认从上到下</p>
<p>主轴和侧轴并不是固定不变的，通过flex-direction可以互换。</p>
<p><img src="https://i.loli.net/2019/08/18/CXqchO6JIu8sSwa.png" alt=""></p>
<p>Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多</p>
<h2 id="各属性详解"><a href="#各属性详解" class="headerlink" title="各属性详解"></a>各属性详解</h2><p>1.flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配</p>
<p>min-width  最小值      min-width: 280px  最小宽度  不能小于 280</p>
<p>max-width: 1280px  最大宽度  不能大于 1280</p>
<p>2.flex-direction调整主轴方向（默认为水平方向）</p>
<p>flex-direction: column 垂直排列</p>
<p>flex-direction: row  水平排列</p>
<p>3、justify-content调整主轴对齐（水平对齐）</p>
<p>子盒子如何在父盒子里面水平对齐</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>白话文</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认值。项目位于容器的开头。</td>
<td>让子元素从父容器的开头开始排序但是盒子顺序不变</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
<td>让子元素从父容器的后面开始排序但是盒子顺序不变</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
<td>让子元素在父容器中间显示</td>
</tr>
<tr>
<td>space-between</td>
<td>项目位于各行之间留有空白的容器内。</td>
<td>左右的盒子贴近父盒子，中间的平均分布空白间距</td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
<td>相当于给每个盒子添加了左右margin外边距</td>
</tr>
</tbody></table>
<p>4、align-items调整侧轴对齐（垂直对齐）</p>
<p>子盒子如何在父盒子里面垂直对齐（单行）</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>白话文</th>
</tr>
</thead>
<tbody><tr>
<td>stretch</td>
<td>默认值。项目被拉伸以适应容器。</td>
<td>让子元素的高度拉伸适用父容器（子元素不给高度的前提下)</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
<td>垂直居中</td>
</tr>
<tr>
<td>flex-start</td>
<td>项目位于容器的开头。</td>
<td>垂直对齐开始位置 上对齐</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
<td>垂直对齐结束位置 底对齐</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>5、flex-wrap控制是否换行</p>
<p>当我们子盒子内容宽度多于父盒子的时候如何处理</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nowrap</td>
<td>默认值。规定灵活的项目不拆行或不拆列。  不换行，则 收缩（压缩） 显示  强制一行内显示</td>
</tr>
<tr>
<td>wrap</td>
<td>规定灵活的项目在必要的时候拆行或拆列。</td>
</tr>
<tr>
<td>wrap-reverse</td>
<td>规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。</td>
</tr>
</tbody></table>
<p>6、flex-flow是flex-direction、flex-wrap的简写形式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">flex-direction</span>  <span class="selector-tag">flex-wrap</span>;</span><br></pre></td></tr></table></figure>



<p>白话记：    flex-flow: 排列方向   换不换行; </p>
<p>两个中间用空格</p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line"><span class="comment">/* flex-direction: row;</span></span><br><span class="line"><span class="comment">flex-wrap: wrap;   这两句话等价于下面的这句话*/</span></span><br><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">column</span> <span class="selector-tag">wrap</span>;  <span class="comment">/* 两者的综合 */</span></span><br></pre></td></tr></table></figure>



<p>7、align-content堆栈（由flex-wrap产生的独立行）多行垂直对齐方式齐</p>
<p>align-content是针对flex容器里面多轴(多行)的情况,align-items是针对一行的情况进行排列。</p>
<p>必须对父元素设置自由盒属性display:flex;，并且设置排列方式为横向排列flex-direction:row;并且设置换行，flex-wrap:wrap;这样这个属性的设置才会起作用。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>测试</th>
</tr>
</thead>
<tbody><tr>
<td>stretch</td>
<td>默认值。项目被拉伸以适应容器。</td>
<td></td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
<td></td>
</tr>
<tr>
<td>flex-start</td>
<td>项目位于容器的开头。</td>
<td></td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
<td></td>
</tr>
<tr>
<td>space-between</td>
<td>项目位于各行之间留有空白的容器内。</td>
<td></td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
<td></td>
</tr>
</tbody></table>
<p>8、order控制子项目的排列顺序，正序方式排序，从小到大</p>
<p>用css 来控制盒子的前后顺序。  用order 就可以</p>
<p>用整数值来定义排列顺序，数值小的排在前面。可以为负值。 默认值是 0</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">order</span>: 1;</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高11</title>
    <url>/2019/08/15/2019-08-15-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%9811/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h1><p>在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。</p>
<p>他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！</p>
<h2 id="display-显示"><a href="#display-显示" class="headerlink" title="display 显示"></a>display 显示</h2><p>display 设置或检索对象是否及如何显示。</p>
<p>display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。</p>
<p>特点： 隐藏之后，不再保留位置。</p>
<h2 id="visibility-可见性"><a href="#visibility-可见性" class="headerlink" title="visibility 可见性"></a>visibility 可见性</h2><p>设置或检索是否显示对象。</p>
<p>visible : 　对象可视</p>
<p>hidden : 　对象隐藏</p>
<p>特点： 隐藏之后，继续保留原有位置。（停职留薪）</p>
<h2 id="overflow-溢出"><a href="#overflow-溢出" class="headerlink" title="overflow 溢出"></a>overflow 溢出</h2><p>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</p>
<p>visible : 　不剪切内容也不添加滚动条。</p>
<p>auto : 　 超出自动显示滚动条，不超出不显示滚动条</p>
<p>hidden : 　不显示超过对象尺寸的内容，超出的部分隐藏掉</p>
<p>scroll : 　不管超出内容否，总是显示滚动条</p>
<h1 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h1><p> 所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。 防止表单域拖拽</p>
<h2 id="鼠标样式cursor"><a href="#鼠标样式cursor" class="headerlink" title="鼠标样式cursor"></a>鼠标样式cursor</h2><p> 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cursor :  default  小白 | pointer  小手  | move  移动  |  text  文本</span><br></pre></td></tr></table></figure>

<p> 鼠标放我身上查看效果哦：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"cursor:default"</span>&gt;</span>我是小白<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"cursor:pointer"</span>&gt;</span>我是小手<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"cursor:move"</span>&gt;</span>我是移动<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"cursor:text"</span>&gt;</span>我是文本<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 尽量不要用hand  因为 火狐不支持     pointer ie6以上都支持的尽量用</p>
<h2 id="轮廓-outline"><a href="#轮廓-outline" class="headerlink" title="轮廓 outline"></a>轮廓 outline</h2><p> 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">outline : outline-color ||outline-style || outline-width</span><br></pre></td></tr></table></figure>

<p> 但是我们都不关心可以设置多少，我们平时都是去掉的。</p>
<p>最直接的写法是 ：  outline: 0;   或者  outline: none;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>  <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">style</span>=<span class="string">"outline: 0;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="防止拖拽文本域resize"><a href="#防止拖拽文本域resize" class="headerlink" title="防止拖拽文本域resize"></a>防止拖拽文本域resize</h2><p>resize：none    这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。</p>
<p>右下角可以拖拽： </p>
<p><textarea></textarea></p>
<p>右下角不可以拖拽：  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">style</span>=<span class="string">"resize: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="vertical-align-垂直对齐"><a href="#vertical-align-垂直对齐" class="headerlink" title="vertical-align 垂直对齐"></a>vertical-align 垂直对齐</h2><p><img src="https://i.loli.net/2019/08/16/dr6YyzX5aJ9L2Ee.jpg" alt=""></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">vertical-align : baseline |top |middle |bottom</span><br></pre></td></tr></table></figure>

<p>设置或检索对象内容的垂直对其方式。 </p>
<p>vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， <strong>通常用来控制图片/表单与文字的对齐</strong>。</p>
<h3 id="图片、表单和文字对齐"><a href="#图片、表单和文字对齐" class="headerlink" title="图片、表单和文字对齐"></a>图片、表单和文字对齐</h3><p>可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。</p>
<h3 id="去除图片底侧空白缝隙"><a href="#去除图片底侧空白缝隙" class="headerlink" title="去除图片底侧空白缝隙"></a>去除图片底侧空白缝隙</h3><p>有个很重要特性： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。这样会造成一个问题，就是图片底侧会有一个空白缝隙(较低版本浏览器中常见)。</p>
<p>解决的方法就是：  </p>
<ol>
<li>给img vertical-align:middle | top等等。  让图片不要和基线对齐。</li>
<li>给img 添加 display：block; 转换为块级元素就不会存在问题了。</li>
</ol>
<h2 id="溢出的文字隐藏"><a href="#溢出的文字隐藏" class="headerlink" title="溢出的文字隐藏"></a>溢出的文字隐藏</h2><h3 id="word-break-自动换行"><a href="#word-break-自动换行" class="headerlink" title="word-break:自动换行"></a>word-break:自动换行</h3><p>normal   使用浏览器默认的换行规则。</p>
<p>break-all   允许在单词内换行。</p>
<p>keep-all    只能在半角空格或连字符处换行。</p>
<p>主要处理英文单词</p>
<h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><p>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 </p>
<p>normal : 　默认处理方式<br>nowrap : 　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。</p>
<p>可以处理中文</p>
<h3 id="text-overflow-文字溢出"><a href="#text-overflow-文字溢出" class="headerlink" title="text-overflow 文字溢出"></a>text-overflow 文字溢出</h3><p>text-overflow : clip | ellipsis</p>
<p>设置或检索是否使用一个省略标记（…）标示对象内文本的溢出</p>
<p>clip : 　不显示省略标记（…），而是简单的裁切 </p>
<p>ellipsis : 　当对象内文本溢出时显示省略标记（…）</p>
<p>注意一定要首先强制一行内显示，再次和overflow属性  搭配使用</p>
<h1 id="CSS精灵技术（sprite）"><a href="#CSS精灵技术（sprite）" class="headerlink" title="CSS精灵技术（sprite）"></a>CSS精灵技术（sprite）</h1><h3 id="精灵技术产生的背景"><a href="#精灵技术产生的背景" class="headerlink" title="精灵技术产生的背景"></a>精灵技术产生的背景</h3><p><img src="https://i.loli.net/2019/08/16/4oGBlehRxiXnQLD.png" alt="网页请求原理"></p>
<p>图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。</p>
<p>然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</p>
<h3 id="精灵技术本质"><a href="#精灵技术本质" class="headerlink" title="精灵技术本质"></a>精灵技术本质</h3><p>简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图（雪碧图）。</p>
<h3 id="精灵技术的使用"><a href="#精灵技术的使用" class="headerlink" title="精灵技术的使用"></a>精灵技术的使用</h3><p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。</p>
<h3 id="制作精灵图"><a href="#制作精灵图" class="headerlink" title="制作精灵图"></a>制作精灵图</h3><p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。</p>
<p>大部分情况下，精灵图都是网页美工做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。</span><br><span class="line">我们精灵图的宽度取决于最宽的那个背景。 </span><br><span class="line">我们可以横向摆放也可以纵向摆放，但是每个图片之间，间隔至少隔开偶数像素合适。</span><br><span class="line">在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。</span><br></pre></td></tr></table></figure>

<p>结束语：   小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。</p>
<h1 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h1><p>图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时就需要字体图标（iconfont)。</p>
<h2 id="字体图标优点"><a href="#字体图标优点" class="headerlink" title="字体图标优点"></a>字体图标优点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..</span><br><span class="line">但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...</span><br><span class="line">本身体积更小，但携带的信息并没有削减。</span><br><span class="line">几乎支持所有的浏览器</span><br><span class="line">移动端设备必备良药...</span><br></pre></td></tr></table></figure>

<h2 id="字体图标使用流程"><a href="#字体图标使用流程" class="headerlink" title="字体图标使用流程"></a>字体图标使用流程</h2><p>总体来说，字体图标按照如下流程：</p>
<p><img src="https://i.loli.net/2019/08/16/mSHQIoza7FkWXqj.png" alt=""></p>
<hr>
<h3 id="设计字体图标"><a href="#设计字体图标" class="headerlink" title="设计字体图标"></a>设计字体图标</h3><p>假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标，之后保存为svg格式，然后给我们前端人员就好了。 </p>
<p>其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。</p>
<h3 id="上传生成字体包"><a href="#上传生成字体包" class="headerlink" title="上传生成字体包"></a>上传生成字体包</h3><p>   当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。</p>
<p>​    推荐网站： <a href="http://icomoon.io" target="_blank" rel="noopener">http://icomoon.io</a></p>
<p><strong>icomoon字库</strong></p>
<p>IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。</p>
<p>   推荐网站： <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a></p>
<p><strong>阿里icon font字库</strong></p>
<p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a></p>
<p>这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！</p>
<p><strong>fontello</strong></p>
<p><a href="http://fontello.com/" target="_blank" rel="noopener">http://fontello.com/</a></p>
<p>在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。</p>
<p><strong>Font-Awesome</strong></p>
<p><a href="http://fortawesome.github.io/Font-Awesome/" target="_blank" rel="noopener">http://fortawesome.github.io/Font-Awesome/</a></p>
<p>这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。</p>
<p><strong>Glyphicon Halflings</strong></p>
<p><a href="http://glyphicons.com/" target="_blank" rel="noopener">http://glyphicons.com/</a></p>
<p>这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。</p>
<p><strong>Icons8</strong></p>
<p><a href="https://icons8.com/" target="_blank" rel="noopener">https://icons8.com/</a></p>
<p>提供PNG免费下载，像素大能到500PX</p>
<h3 id="下载兼容字体包"><a href="#下载兼容字体包" class="headerlink" title="下载兼容字体包"></a>下载兼容字体包</h3><p>刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了</p>
<p>当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。</p>
<h2 id="以icomoon使用为例"><a href="#以icomoon使用为例" class="headerlink" title="以icomoon使用为例"></a>以icomoon使用为例</h2><h3 id="选择下载压缩包"><a href="#选择下载压缩包" class="headerlink" title="选择下载压缩包"></a>选择下载压缩包</h3><p><img src="https://i.loli.net/2019/08/16/nPy6cmKClGzjR2Z.png" alt=""></p>
<p><img src="https://i.loli.net/2019/08/16/uEHpce4mNfSL2dr.png" alt=""></p>
<h3 id="字体引入到HTML"><a href="#字体引入到HTML" class="headerlink" title="字体引入到HTML"></a>字体引入到HTML</h3><p>得到压缩包之后，最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。</p>
<p>首先把 以下4个文件放入到工程的 fonts文件夹里面。 </p>
<p><img src="https://i.loli.net/2019/08/16/pfcHDkzsRumAGeB.png" alt=""></p>
<p><strong>第一步：在样式里面声明字体： 告诉别人我们自己定义的字体</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'icomoon'</span>;</span><br><span class="line">  <span class="attribute">src</span>:  <span class="built_in">url</span>(<span class="string">'fonts/icomoon.eot?7kkyc2'</span>);</span><br><span class="line">  <span class="attribute">src</span>:  <span class="built_in">url</span>(<span class="string">'fonts/icomoon.eot?7kkyc2#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'fonts/icomoon.ttf?7kkyc2'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'fonts/icomoon.woff?7kkyc2'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'fonts/icomoon.svg?7kkyc2#icomoon'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：给盒子使用字体</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">		<span class="attribute">font-family</span>: <span class="string">"icomoon"</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：盒子里面添加结构</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">		 <span class="attribute">content</span>: <span class="string">"\e900"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">或者  </span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h3 id="追加新图标到原来库里面"><a href="#追加新图标到原来库里面" class="headerlink" title="追加新图标到原来库里面"></a>追加新图标到原来库里面</h3><p>如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标，但是原来的不能删除，继续使用，此时我们需要这样做</p>
<p>把压缩包里面的selection.json 从新上传，然后，选中自己想要新的图标，从新下载压缩包，替换原来文件即可。</p>
<p><img src="https://i.loli.net/2019/08/16/bTckN37JHQMzaol.png" alt=""></p>
<h1 id="滑动门"><a href="#滑动门" class="headerlink" title="滑动门"></a>滑动门</h1><h3 id="滑动门出现的背景"><a href="#滑动门出现的背景" class="headerlink" title="滑动门出现的背景"></a>滑动门出现的背景</h3><p>制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如各种网站导航栏，最大的问题是里面的字数不一样多。</p>
<p>为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。</p>
<h3 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h3><p>核心技术就是利用CSS精灵（主要是背景位置）和盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p>
<p>一般的经典布局都是这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line">		<span class="attribute">display</span>: inline-block;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">33px</span>;</span><br><span class="line">		<span class="comment">/* 千万不能给宽度 写死宽度是不对滴，我们要推拉门 自由缩放*/</span></span><br><span class="line">		<span class="attribute">background</span>: <span class="built_in">url</span>(images/ao.png) no-repeat;</span><br><span class="line">		<span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">		<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">		<span class="attribute">text-decoration</span>: none;</span><br><span class="line">		<span class="attribute">line-height</span>: <span class="number">33px</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-tag">a</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">		<span class="attribute">display</span>: inline-block;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">33px</span>;</span><br><span class="line">		<span class="attribute">background</span>: <span class="built_in">url</span>(images/ao.png) no-repeat right; </span><br><span class="line">		<span class="comment">/* span 不能给宽度 利用padding挤开  要我要span 右边的圆角  所以 背景位置 右对齐 */</span></span><br><span class="line">		<span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>导航栏内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结： </p>
<ol>
<li>a 设置 背景左侧，padding撑开合适宽度。    </li>
<li>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</li>
<li>之所以a包含span就是因为 整个导航都是可以点击的。</li>
</ol>
<h1 id="before和after伪元素详解"><a href="#before和after伪元素详解" class="headerlink" title="before和after伪元素详解"></a>before和after伪元素详解</h1><p>之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。是伪元素在html代码机构中的展现，可以看出无法伪元素的结构无法审查。</p>
<p><strong>注意</strong></p>
<p>伪元素:before和:after添加的内容默认是inline元素，设置宽高需要转换；这个两个伪元素的<code>content</code>属性，表示伪元素的内容,设置:before和:after时必须设置其<code>content</code>属性，否则伪元素就不起作用。</p>
<p><strong>注</strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高10</title>
    <url>/2019/08/14/2019-08-14-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%9810/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="元素的定位属性"><a href="#元素的定位属性" class="headerlink" title="元素的定位属性"></a>元素的定位属性</h1><p>元素的定位属性主要包括定位模式和边偏移两部分。</p>
<p>1、边偏移</p>
<table>
<thead>
<tr>
<th>边偏移属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>top</td>
<td>顶端偏移量，定义元素相对于其父元素上边线的距离</td>
</tr>
<tr>
<td>bottom</td>
<td>底部偏移量，定义元素相对于其父元素下边线的距离</td>
</tr>
<tr>
<td>left</td>
<td>左侧偏移量，定义元素相对于其父元素左边线的距离</td>
</tr>
<tr>
<td>right</td>
<td>右侧偏移量，定义元素相对于其父元素右边线的距离</td>
</tr>
</tbody></table>
<p>也就说，定位要和边偏移搭配使用， 比如 top: 100px;  left: 30px; 等等</p>
<p>2、定位模式(定位的分类)</p>
<p>在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下：</p>
<p>选择器{position:属性值;}</p>
<p>position属性的常用值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>static</td>
<td>自动定位（默认定位方式）</td>
</tr>
<tr>
<td>relative</td>
<td>相对定位，相对于其原文档流的位置进行定位</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对定位，相对于其上一个已经定位的父元素进行定位</td>
</tr>
<tr>
<td>fixed</td>
<td>固定定位，相对于浏览器窗口进行定位</td>
</tr>
</tbody></table>
<h1 id="静态定位-static"><a href="#静态定位-static" class="headerlink" title="静态定位(static)"></a>静态定位(static)</h1><p>静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。</p>
<p>上面的话翻译成白话：  就是网页中所有元素都默认的是静态定位！ 其实就是标准流的特性。</p>
<p>在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。</p>
<h1 id="相对定位（relative）"><a href="#相对定位（relative）" class="headerlink" title="相对定位（relative）"></a>相对定位（relative）</h1><p>相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。</p>
<p>对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。</p>
<p>注意：   </p>
<ol>
<li>相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。</li>
<li>其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置）</li>
</ol>
<p>就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标）</p>
<h1 id="绝对定位（absolute）"><a href="#绝对定位（absolute）" class="headerlink" title="绝对定位（absolute）"></a>绝对定位（absolute）</h1><p>注意：绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。</p>
<h2 id="父级没有定位"><a href="#父级没有定位" class="headerlink" title="父级没有定位"></a>父级没有定位</h2><p>若所有父元素都没有定位，以浏览器为准对齐(document文档)。</p>
<p><img src="https://i.loli.net/2019/08/15/eWuCXg2hxtaBwoE.png" alt=""></p>
<h2 id="父级有定位"><a href="#父级有定位" class="headerlink" title="父级有定位"></a>父级有定位</h2><p>绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 </p>
<p><img src="https://i.loli.net/2019/08/15/RSyV8PcbkQUaHmL.png" alt=""></p>
<h2 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h2><p>这个“子绝父相”很重要，是我们学习定位的口诀，时时刻刻记住的。</p>
<p>这句话的意思是 子级是绝对定位的话， 父级要用相对定位。</p>
<p>首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。</p>
<p>就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。但是因为子级是绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方。父盒子布局时，需要占有位置，因此父亲只能是相对定位. 所以子绝父相使用最多。</p>
<h2 id="绝对定位的盒子水平-垂直居中"><a href="#绝对定位的盒子水平-垂直居中" class="headerlink" title="绝对定位的盒子水平/垂直居中"></a>绝对定位的盒子水平/垂直居中</h2><p>普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了</p>
<p>定位的盒子也可以水平或者垂直居中，有一个算法。</p>
<ol>
<li>首先left 50%   父盒子的一半大小</li>
<li>然后走自己外边距负的一半值就可以了 margin-left。</li>
</ol>
<h1 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位(fixed)"></a>固定定位(fixed)</h1><p>固定定位是绝对定位的一种特殊形式。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。</p>
<p>当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。</p>
<p>固定定位有两点：</p>
<ol>
<li>固定定位的元素跟父亲没有任何关系，只认浏览器。</li>
<li>固定定位完全脱标，不占有位置，不随着滚动条滚动。</li>
</ol>
<p>ie6等低版本浏览器不支持固定定位。</p>
<h1 id="叠放次序（z-index）"><a href="#叠放次序（z-index）" class="headerlink" title="叠放次序（z-index）"></a>叠放次序（z-index）</h1><p>当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。</p>
<p><img src="https://i.loli.net/2019/08/15/zUBLnr9a34bFgC8.png" alt=""></p>
<p>在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。</p>
<p>比如：  z-index: 2;</p>
<p>注意：</p>
<ol>
<li>z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。</li>
<li>如果取值相同，则根据书写顺序，后来居上。</li>
<li>后面数字一定不能加单位。</li>
<li>只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。</li>
</ol>
<h1 id="四种定位总结"><a href="#四种定位总结" class="headerlink" title="四种定位总结"></a>四种定位总结</h1><table>
<thead>
<tr>
<th>定位模式</th>
<th>是否脱标占有位置</th>
<th>是否可以使用边偏移</th>
<th>移动位置基准</th>
</tr>
</thead>
<tbody><tr>
<td>静态static</td>
<td>不脱标，正常模式</td>
<td>不可以</td>
<td>正常模式</td>
</tr>
<tr>
<td>相对定位relative</td>
<td>不脱标，占有位置</td>
<td>可以</td>
<td>相对自身位置移动（自恋型）</td>
</tr>
<tr>
<td>绝对定位absolute</td>
<td>完全脱标，不占有位置</td>
<td>可以</td>
<td>相对于定位父级移动位置（拼爹型）</td>
</tr>
<tr>
<td>固定定位fixed</td>
<td>完全脱标，不占有位置</td>
<td>可以</td>
<td>相对于浏览器移动位置（认死理型）</td>
</tr>
</tbody></table>
<h1 id="定位模式转换"><a href="#定位模式转换" class="headerlink" title="定位模式转换"></a>定位模式转换</h1><p>跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式，</p>
<p>*<em>因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。 *</em></p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高9</title>
    <url>/2019/08/10/2019-08-10-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%989/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="普通流-normal-flow"><a href="#普通流-normal-flow" class="headerlink" title="普通流(normal flow)"></a>普通流(normal flow)</h1><p>这个单词很多人翻译为 文档流 ， 字面翻译  普通流 或者标准流都可以。</p>
<p>前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？  </p>
<p>CSS的定位机制有3种：普通流（标准流）、浮动和定位。</p>
<p>html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。</p>
<h1 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动(float)"></a>浮动(float)</h1><p>浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了。</p>
<h2 id="什么是浮动？"><a href="#什么是浮动？" class="headerlink" title="什么是浮动？"></a>什么是浮动？</h2><p>元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。</p>
<p>在CSS中，通过float属性来定义浮动，其基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器&#123;float:属性值;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>元素向左浮动</td>
</tr>
<tr>
<td>right</td>
<td>元素向右浮动</td>
</tr>
<tr>
<td>none</td>
<td>元素不浮动（默认值）</td>
</tr>
</tbody></table>
<h2 id="浮动详细内幕特性"><a href="#浮动详细内幕特性" class="headerlink" title="浮动详细内幕特性"></a>浮动详细内幕特性</h2><p>浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找离它最近的父级元素对齐。但是不会超出内边距的范围。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/08/11/pechtG5ruKLln8g.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/08/11/eSr5vFVp8h4ltxn.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。</span><br></pre></td></tr></table></figure>

<p>总结：  浮动 —&gt;    </p>
<p>浮动的目的就是为了让多个块级元素同一行上显示。</p>
<p>float      浮 漏 特   </p>
<p>浮：    加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。<br>漏：    加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。<br>特：    特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。</p>
<h1 id="版心和布局流程"><a href="#版心和布局流程" class="headerlink" title="版心和布局流程"></a>版心和布局流程</h1><p>“版心”(可视区) 是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。</p>
<h2 id="布局流程"><a href="#布局流程" class="headerlink" title="布局流程"></a>布局流程</h2><p>为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下：</p>
<p>1、确定页面的版心（可视区）。</p>
<p>2、分析页面中的行模块，以及每个行模块中的列模块。</p>
<p>3、制作HTML结构 。</p>
<p>4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。</p>
<h2 id="一列固定宽度且居中"><a href="#一列固定宽度且居中" class="headerlink" title="一列固定宽度且居中"></a>一列固定宽度且居中</h2><p><img src="https://i.loli.net/2019/08/12/oqdWEUfi62Z7Dlx.jpg" alt=""></p>
<p>最普通的，最为常用的结构。</p>
<h2 id="两列左窄右宽型"><a href="#两列左窄右宽型" class="headerlink" title="两列左窄右宽型"></a>两列左窄右宽型</h2><p><img src="https://i.loli.net/2019/08/12/NKBJgVjr72OEdtU.jpg" alt=""></p>
<h2 id="通栏平均分布型"><a href="#通栏平均分布型" class="headerlink" title="通栏平均分布型"></a>通栏平均分布型</h2><p><img src="https://i.loli.net/2019/08/12/8S4KYVewypaZzd2.jpg" alt=""></p>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="清除浮动本质"><a href="#清除浮动本质" class="headerlink" title="清除浮动本质"></a>清除浮动本质</h2><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。<br><img src="https://i.loli.net/2019/08/12/jpB6Kd4xltQL1YO.jpg" alt=""></p>
<p><img src="https://i.loli.net/2019/08/12/rSNzU9H4KushGxo.jpg" alt=""></p>
<h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><p>其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。</p>
<p>在CSS中，clear属性用于清除浮动，其基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器&#123;clear:属性值;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
<h3 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">”clear:both”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>，或则其他标签br等亦可。</span><br></pre></td></tr></table></figure>

<p>优点： 通俗易懂，书写方便</p>
<p>缺点： 添加许多无意义的标签，结构化较差。  不推荐。</p>
<h3 id="父级添加overflow属性方法"><a href="#父级添加overflow属性方法" class="headerlink" title="父级添加overflow属性方法"></a>父级添加overflow属性方法</h3><p>可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">可以给父级添加： overflow为 hidden|auto|scroll  都可以实现。</span><br></pre></td></tr></table></figure>
<p>优点：  代码简洁</p>
<p>缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<h3 id="使用after伪元素清除浮动"><a href="#使用after伪元素清除浮动" class="headerlink" title="使用after伪元素清除浮动"></a>使用after伪元素清除浮动</h3><p><strong>:after 方式为空元素的升级版，好处是不用单独加标签了</strong> </p>
<p>使用方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;  <span class="attribute">content</span>: <span class="string">"."</span>; <span class="attribute">display</span>: block; <span class="attribute">height</span>: <span class="number">0</span>; <span class="attribute">clear</span>: both; <span class="attribute">visibility</span>: hidden;  &#125;   </span><br><span class="line"></span><br><span class="line">.clearfix &#123;*zoom: 1;&#125;   /* IE6、7 专有 */</span><br></pre></td></tr></table></figure>

<p>优点： 符合闭合浮动思想  结构语义化正确</p>
<p>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p>
<p>注意： content:”.”  里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。</p>
<h3 id="使用before和after双伪元素清除浮动"><a href="#使用before和after双伪元素清除浮动" class="headerlink" title="使用before和after双伪元素清除浮动"></a>使用before和after双伪元素清除浮动</h3><p>使用方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;  <span class="comment">/* 这句话可以出发BFC BFC可以清除浮动,BFC我们后面讲 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line"> <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：  代码更简洁</p>
<p>缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高8</title>
    <url>/2019/08/05/2019-08-05-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%988/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p>​<br><img src="https://i.loli.net/2019/08/05/7ofCclWuArpPJ6t.png" alt="盒子模型示意图"></p>
<h1 id="盒子边框（border）"><a href="#盒子边框（border）" class="headerlink" title="盒子边框（border）"></a>盒子边框（border）</h1><p>语法： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border : border-width || border-style || border-color</span><br></pre></td></tr></table></figure>

<p>边框属性—设置边框样式（border-style）</p>
<p>边框样式用于定义页面中边框的风格，常用属性值如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">none：没有边框即忽略所有边框的宽度（默认值）</span><br><span class="line"></span><br><span class="line">solid：边框为单实线(最为常用的)</span><br><span class="line"></span><br><span class="line">dashed：边框为虚线  </span><br><span class="line"></span><br><span class="line">dotted：边框为点线</span><br><span class="line"></span><br><span class="line">double：边框为双实线</span><br></pre></td></tr></table></figure>

<h2 id="盒子边框写法总结表"><a href="#盒子边框写法总结表" class="headerlink" title="盒子边框写法总结表"></a>盒子边框写法总结表</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>设置内容</td>
<td>样式属性</td>
<td>常用属性值</td>
</tr>
<tr>
<td>上边框</td>
<td>border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色;</td>
<td></td>
</tr>
<tr>
<td>下边框</td>
<td>border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色;</td>
<td></td>
</tr>
<tr>
<td>左边框</td>
<td>border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色;</td>
<td></td>
</tr>
<tr>
<td>右边框</td>
<td>border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色;</td>
<td></td>
</tr>
<tr>
<td>样式综合设置</td>
<td>border-style:上边 [右边 下边 左边];</td>
<td>none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线</td>
</tr>
<tr>
<td>宽度综合设置</td>
<td>border-width:上边 [右边 下边 左边];</td>
<td>像素值</td>
</tr>
<tr>
<td>颜色综合设置</td>
<td>border-color:上边 [右边 下边 左边];</td>
<td>颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%)</td>
</tr>
<tr>
<td>边框综合设置</td>
<td>border:四边宽度 四边样式 四边颜色;</td>
<td></td>
</tr>
</tbody></table>
<h2 id="表格的细线边框"><a href="#表格的细线边框" class="headerlink" title="表格的细线边框"></a>表格的细线边框</h2><p>table{ border-collapse:collapse; }  collapse 单词是合并的意思</p>
<p>border-collapse:collapse; 表示边框合并在一起。 </p>
<h2 id="圆角边框-CSS3"><a href="#圆角边框-CSS3" class="headerlink" title="圆角边框(CSS3)"></a>圆角边框(CSS3)</h2><p>radius 半径（距离）</p>
<p>语法格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span>: 左上角  右上角  右下角  左下角;</span><br></pre></td></tr></table></figure>

<h1 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h1><p>padding属性用于设置内边距。  是指 边框与内容之间的距离。</p>
<p>padding-top:上内边距</p>
<p>padding-right:右内边距</p>
<p>padding-bottom:下内边距</p>
<p>padding-left:左内边距</p>
<p>注意：  后面跟几个数值表示的意思是不一样的。</p>
<table>
<thead>
<tr>
<th>值的个数</th>
<th>表达意思</th>
</tr>
</thead>
<tbody><tr>
<td>1个值</td>
<td>padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素</td>
</tr>
<tr>
<td>2个值</td>
<td>padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素</td>
</tr>
<tr>
<td>3个值</td>
<td>padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素</td>
</tr>
<tr>
<td>4个值</td>
<td>padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针</td>
</tr>
</tbody></table>
<h1 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h1><p>margin属性用于设置外边距。  设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。</p>
<p>margin-top:上外边距</p>
<p>margin-right:右外边距</p>
<p>margin-bottom:下外边距</p>
<p>margin-left:左外边距</p>
<p>margin:上外边距 右外边距  下外边距  左外边</p>
<p>取值顺序跟内边距相同。</p>
<h2 id="外边距实现盒子居中"><a href="#外边距实现盒子居中" class="headerlink" title="外边距实现盒子居中"></a>外边距实现盒子居中</h2><p>可以让一个盒子实现水平居中，需要满足一下两个条件：</p>
<ol>
<li>必须是块级元素。     </li>
<li>盒子必须指定了宽度（width）</li>
</ol>
<p>然后就给<strong>左右的外边距都设置为auto</strong>，就可使块级元素水平居中。</p>
<p>实际工作中常用这种方式进行网页布局，示例代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span>&#123; <span class="attribute">width</span>:<span class="number">960px</span>; <span class="attribute">margin</span>:<span class="number">0</span> auto;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文字盒子居中图片和背景区别"><a href="#文字盒子居中图片和背景区别" class="headerlink" title="文字盒子居中图片和背景区别"></a>文字盒子居中图片和背景区别</h2><ol>
<li>文字水平居中是  text-align: center</li>
<li>盒子水平居中  左右margin 改为 auto </li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>; <span class="comment">/*  文字居中水平 */</span></span><br><span class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">auto</span>;  <span class="comment">/* 盒子水平居中  左右margin 改为 auto 就阔以了 */</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>插入图片 我们用的最多 比如产品展示类</li>
<li>背景图片我们一般用于小图标背景 或者 超大背景图片</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> <span class="selector-tag">img</span> &#123;  </span><br><span class="line">		<span class="attribute">width</span>: <span class="number">200px</span>;<span class="comment">/* 插入图片更改大小 width 和 height */</span></span><br><span class="line">		<span class="attribute">height</span>: <span class="number">210px</span>;</span><br><span class="line">		<span class="attribute">margin-top</span>: <span class="number">30px</span>;  <span class="comment">/* 插入图片更改位置 可以用margin 或padding  盒模型 */</span></span><br><span class="line">		<span class="attribute">margin-left</span>: <span class="number">50px</span>; <span class="comment">/* 插入当图片也是一个盒子 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">		<span class="attribute">border</span>: <span class="number">1px</span> solid purple;</span><br><span class="line">		<span class="attribute">background</span>: <span class="number">#fff</span> <span class="built_in">url</span>(images/sun.jpg) no-repeat;</span><br><span class="line">	</span><br><span class="line">		<span class="attribute">background-size</span>: <span class="number">200px</span> <span class="number">210px</span>; <span class="comment">/*  背景图片更改大小只能用 background-size */</span></span><br><span class="line">		<span class="attribute">background-position</span>: <span class="number">30px</span> <span class="number">50px</span>; <span class="comment">/* 背景图片更该位置 我用 background-position */</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="清除元素的默认内外边距"><a href="#清除元素的默认内外边距" class="headerlink" title="清除元素的默认内外边距"></a>清除元素的默认内外边距</h1><p>为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">   <span class="attribute">padding</span>:<span class="number">0</span>;         <span class="comment">/* 清除内边距 */</span></span><br><span class="line">   <span class="attribute">margin</span>:<span class="number">0</span>;          <span class="comment">/* 清除外边距 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：  行内元素是只有左右外边距的，是没有上下外边距的。 内边距，在ie6等低版本浏览器也会有问题。</p>
<p>我们尽量不要给行内元素指定上下的内外边距就好了。</p>
<h1 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h1><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。</p>
<h2 id="相邻块元素垂直外边距的合并"><a href="#相邻块元素垂直外边距的合并" class="headerlink" title="相邻块元素垂直外边距的合并"></a>相邻块元素垂直外边距的合并</h2><p>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</p>
<p><img src="https://i.loli.net/2019/08/07/2CKvWhbYl5nMJyU.png" alt=""></p>
<p>解决方案：  避免就好了。</p>
<h2 id="嵌套块元素垂直外边距的合并"><a href="#嵌套块元素垂直外边距的合并" class="headerlink" title="嵌套块元素垂直外边距的合并"></a>嵌套块元素垂直外边距的合并</h2><p>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。</p>
<p><img src="https://i.loli.net/2019/08/07/EgDNQFL9w6l5zy4.png" alt=""></p>
<p>解决方案：</p>
<ol>
<li>可以为父元素定义1像素的上边框或上内边距。</li>
<li>可以为父元素添加overflow:hidden。</li>
</ol>
<h1 id="content宽度和高度"><a href="#content宽度和高度" class="headerlink" title="content宽度和高度"></a>content宽度和高度</h1><p>使用宽度属性width和高度属性height可以对盒子的大小进行控制。</p>
<p>width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。</p>
<p>大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*外盒尺寸计算（元素空间尺寸）*/</span><br><span class="line">Element空间高度 = content height + padding + border + margin</span><br><span class="line">Element 空间宽度 = content width + padding + border + margin</span><br><span class="line">/*内盒尺寸计算（元素实际大小）*/</span><br><span class="line">Element Height = content height + padding + border （Height为内容高度）</span><br><span class="line">Element Width = content width + padding + border （Width为内容宽度）</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。</p>
<p>2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。</p>
<p>3、<strong>如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding 不会影响本盒子大小</strong>。</p>
<h1 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h1><p>开始学习盒子模型，同学们最大的困惑就是， 分不清内外边距的使用，什么情况下使用内边距，什么情况下使用外边距？</p>
<p>答案是：  其实他们大部分情况下是可以混用的。  就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。</p>
<p>但是，总有一个最好用的吧，我们根据稳定性来分，建议如下：</p>
<p>按照 优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）。   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width &gt;  padding  &gt;   margin</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<ol>
<li><p>margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。</p>
</li>
<li><p>padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</p>
</li>
<li><p>width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。</p>
</li>
</ol>
<h1 id="CSS3盒模型"><a href="#CSS3盒模型" class="headerlink" title="CSS3盒模型"></a>CSS3盒模型</h1><p>CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。</p>
<p>可以分成两种情况：</p>
<p>1、box-sizing: content-box  盒子大小为 width + padding + border   content-box:此值为其默认值，其让元素维持W3C的标准Box Mode</p>
<p>2、box-sizing: border-box  盒子大小为 width    就是说  padding 和 border 是包含到width里面的</p>
<p>注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  默认的设置 如果我们添加了 border属性 该容器的大小会发生改变</span></span><br><span class="line"><span class="comment">  因为他要优先保证内部的内容所占区域 不变</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  </span></span><br><span class="line"><span class="comment">  box-sizing  如果不设置 默认的值 就是 </span></span><br><span class="line"><span class="comment">  content-box: 优先保证内容的大小 对盒子进行缩放;</span></span><br><span class="line"><span class="comment">  border-box: 让 盒子 优先保证自己所占区域的大小,对内容进行压缩;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h1><p>语法格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色  内/外阴影；</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/08/07/FlXYd7mz6NVstyU.png" alt=""></p>
<ol>
<li>前两个属性是必须写的。其余的可以省略。</li>
<li>外阴影 (outset) 但是不能写    默认      想要内阴影  inset </li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">10px</span> solid orange;</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="number">3px</span> <span class="number">3px</span> <span class="number">5px</span> <span class="number">4px</span> <span class="built_in">rgba</span>(0,0,0,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高7</title>
    <url>/2019/08/05/2019-08-05-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%987/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="CSS层叠性"><a href="#CSS层叠性" class="headerlink" title="CSS层叠性"></a>CSS层叠性</h1><p>所谓层叠性是指多种CSS样式的叠加。</p>
<p>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉。</p>
<p>比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。</p>
<p>一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。</p>
<ol>
<li>样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。</li>
<li>样式不冲突，不会层叠</li>
</ol>
<h1 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a>CSS继承性</h1><p>所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性）</span><br></pre></td></tr></table></figure>

<h1 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h1><p>定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。</p>
<h2 id="CSS特殊性"><a href="#CSS特殊性" class="headerlink" title="CSS特殊性"></a>CSS特殊性</h2><p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下：</p>
<p>specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 </p>
<table>
<thead>
<tr>
<th>继承或者* 的贡献值</th>
<th>0,0,0,0</th>
</tr>
</thead>
<tbody><tr>
<td>每个元素（标签）贡献值为</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>每个类，伪类贡献值为</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>每个ID贡献值为</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>每个行内样式贡献值</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>每个!important贡献值</td>
<td>∞ 无穷大</td>
</tr>
</tbody></table>
<p>权重是可以叠加的</p>
<p> 比如的例子：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div ul  li   ------&gt;      0,0,0,3</span><br><span class="line"></span><br><span class="line">.nav ul li   ------&gt;      0,0,1,2</span><br><span class="line"></span><br><span class="line">a:hover      -----—&gt;      0,0,1,1</span><br><span class="line"></span><br><span class="line">.nav a       ------&gt;      0,0,1,1   </span><br><span class="line"></span><br><span class="line">#nav p       -----&gt;       0,1,0,1</span><br></pre></td></tr></table></figure>

<p>注意： </p>
<p>1.数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</p>
<ol start="2">
<li>继承的 权重是 0</li>
</ol>
<p>总结优先级：</p>
<ol>
<li>使用了 !important声明的规则。</li>
<li>内嵌在 HTML 元素的 style属性里面的声明。</li>
<li>使用了 ID 选择器的规则。</li>
<li>使用了类选择器、属性选择器、伪元素和伪类选择器的规则。</li>
<li>使用了元素选择器的规则。</li>
<li>只包含一个通用选择器的规则。</li>
<li>同一类选择器则遵循就近原则。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结：权重是优先级的算法，层叠是优先级的表现</span><br></pre></td></tr></table></figure>


<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高6</title>
    <url>/2019/08/01/2019-08-01-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%986/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h1><p>开始就形成良好的书写规范，是你专业化的开始。</p>
<h2 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h2><p>【强制】 选择器 与 { 之间必须包含空格。</p>
<p>示例： .selector { }</p>
<p>【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。</p>
<p>示例：</p>
<p>font-size: 12px;</p>
<h2 id="选择器规范"><a href="#选择器规范" class="headerlink" title="选择器规范"></a>选择器规范</h2><p>【强制】 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* good */</span><br><span class="line">.post,</span><br><span class="line">.page,</span><br><span class="line">.comment &#123;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.post, .page, .comment &#123;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【建议】 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* good */</span><br><span class="line">#username input &#123;&#125;</span><br><span class="line">.comment .avatar &#123;&#125;</span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.page .header .login #username input &#123;&#125;</span><br><span class="line">.comment div * &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性规范"><a href="#属性规范" class="headerlink" title="属性规范"></a>属性规范</h2><p>【强制】 属性定义必须另起一行。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* good */</span><br><span class="line">.selector &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.selector &#123; margin: 0; padding: 0; &#125;</span><br></pre></td></tr></table></figure>

<p>【强制】 属性定义后必须以分号结尾。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* good */</span><br><span class="line">.selector &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.selector &#123;</span><br><span class="line">    margin: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="CSS-背景-background"><a href="#CSS-背景-background" class="headerlink" title="CSS 背景(background)"></a>CSS 背景(background)</h1><p>CSS 可以添加背景颜色和背景图片，以及来进行图片设置。</p>
<table>
<thead>
<tr>
<th>background-color</th>
<th>背景颜色</th>
</tr>
</thead>
<tbody><tr>
<td>background-image</td>
<td>背景图片地址</td>
</tr>
<tr>
<td>background-repeat</td>
<td>是否平铺</td>
</tr>
<tr>
<td>background-position</td>
<td>背景位置</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景固定还是滚动</td>
</tr>
<tr>
<td>背景的合写（复合属性）</td>
<td></td>
</tr>
<tr>
<td>background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置</td>
<td></td>
</tr>
</tbody></table>
<h2 id="背景图片-image"><a href="#背景图片-image" class="headerlink" title="背景图片(image)"></a>背景图片(image)</h2><p>语法： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-image : none | url (url)</span><br></pre></td></tr></table></figure>

<p>参数： </p>
<p>none : 　无背景图（默认的）<br>url : 　使用绝对或相对地址指定背景图像 </p>
<p>background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。</p>
<p>小技巧：  我们提倡 背景图片后面的地址，url不要加引号。</p>
<h2 id="背景平铺（repeat）"><a href="#背景平铺（repeat）" class="headerlink" title="背景平铺（repeat）"></a>背景平铺（repeat）</h2><p>语法： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-repeat : repeat | no-repeat | repeat-x | repeat-y</span><br></pre></td></tr></table></figure>

<p>参数： </p>
<p>repeat : 　背景图像在纵向和横向上平铺（默认的）</p>
<p>no-repeat : 　背景图像不平铺</p>
<p>repeat-x : 　背景图像在横向上平铺</p>
<p>repeat-y : 　背景图像在纵向平铺 </p>
<p>设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。</p>
<h2 id="背景位置-position"><a href="#背景位置-position" class="headerlink" title="背景位置(position)"></a>背景位置(position)</h2><p>语法： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-position : length || length</span><br><span class="line"></span><br><span class="line">background-position : position || position</span><br></pre></td></tr></table></figure>

<p>参数： </p>
<p>length : 　百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位<br>position : 　top | center | bottom | left | center | right </p>
<p>说明： </p>
<p>设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。<br>如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。</p>
<p>注意：</p>
<ol>
<li>position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。</li>
<li>如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top;   则 15px 一定是  x坐标   top是 y坐标。</li>
</ol>
<p>实际工作用的最多的，就是背景图片居中对齐了。</p>
<h2 id="背景附着"><a href="#背景附着" class="headerlink" title="背景附着"></a>背景附着</h2><p>语法： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-attachment : scroll | fixed</span><br></pre></td></tr></table></figure>

<p>参数： </p>
<p>scroll : 　背景图像是随对象内容滚动<br>fixed : 　背景图像固定 </p>
<p>说明： </p>
<p>设置或检索背景图像是随对象内容滚动还是固定的。</p>
<h2 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h2><p>background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：</p>
<p>background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">url</span>(<span class="selector-tag">image</span><span class="selector-class">.jpg</span>) <span class="selector-tag">repeat-y</span>  <span class="selector-tag">scroll</span> 50% 0 ;</span><br></pre></td></tr></table></figure>

<h2 id="背景透明-CSS3"><a href="#背景透明-CSS3" class="headerlink" title="背景透明(CSS3)"></a>背景透明(CSS3)</h2><p>CSS3支持背景半透明的写法语法格式是:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>);</span><br></pre></td></tr></table></figure>

<p>最后一个参数是alpha 透明度  取值范围 0~1之间</p>
<p>注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。</p>
<h2 id="背景缩放-CSS3"><a href="#背景缩放-CSS3" class="headerlink" title="背景缩放(CSS3)"></a>背景缩放(CSS3)</h2><p>通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。</p>
<p>其参数设置如下：</p>
<p>a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）</p>
<p>b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多</p>
<p>c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">background-image: url('images/gyt.jpg');</span><br><span class="line">			<span class="selector-tag">background-size</span>: 300<span class="selector-tag">px</span> 100<span class="selector-tag">px</span>;</span><br><span class="line">			<span class="comment">/* background-size: contain; */</span></span><br><span class="line">			<span class="comment">/* background-size: cover; */</span></span><br></pre></td></tr></table></figure>

<h2 id="多背景-CSS3"><a href="#多背景-CSS3" class="headerlink" title="多背景(CSS3)"></a>多背景(CSS3)</h2><p>以逗号分隔可以设置多背景，可用于自适应布局  做法就是 用逗号隔开就好了。</p>
<ul>
<li>一个元素可以设置多重背景图像。 </li>
<li>每组属性间使用逗号分隔。 </li>
<li>如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。</li>
<li>为了避免背景色将图像盖住，背景色通常都定义在最后一组上，</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px  ,</span><br><span class="line">	   url(test1.jpg) no-repeat scroll 10px 20px/70px 90px ,</span><br><span class="line">	   url(test1.jpg) no-repeat scroll 10px 20px/110px 130px c #aaa;</span><br></pre></td></tr></table></figure>

<h2 id="凹凸文字案例"><a href="#凹凸文字案例" class="headerlink" title="凹凸文字案例"></a>凹凸文字案例</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">        &lt;meta charset="utf-8"&gt;</span><br><span class="line">        &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        <span class="selector-tag">body</span> &#123;</span><br><span class="line">        	<span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="selector-tag">div</span> &#123;</span><br><span class="line">			<span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">			<span class="attribute">font</span>: <span class="number">700</span> <span class="number">80px</span> <span class="string">"微软雅黑"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">			<span class="comment">/* text-shadow: 水平位置  垂直位置  模糊距离 阴影颜色; */</span></span><br><span class="line">			<span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#000</span>, -<span class="number">1px</span> -<span class="number">1px</span> <span class="number">1px</span> <span class="number">#fff</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="selector-tag">div</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">			<span class="comment">/* text-shadow: 水平位置  垂直位置  模糊距离 阴影颜色; */</span></span><br><span class="line">			<span class="attribute">text-shadow</span>: -<span class="number">1px</span> -<span class="number">1px</span> <span class="number">1px</span> <span class="number">#000</span>, <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#fff</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;div&gt;我是凸起的文字&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;我是凹下的文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="导航栏案例"><a href="#导航栏案例" class="headerlink" title="导航栏案例"></a>导航栏案例</h2><h3 id="文本的装饰"><a href="#文本的装饰" class="headerlink" title="文本的装饰"></a>文本的装饰</h3><p>text-decoration   通常我们用于给链接修改装饰效果</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认。定义标准的文本。</td>
</tr>
<tr>
<td>underline</td>
<td>定义文本下的一条线。下划线 也是我们链接自带的</td>
</tr>
<tr>
<td>overline</td>
<td>定义文本上的一条线。</td>
</tr>
<tr>
<td>line-through</td>
<td>定义穿过文本下的一条线。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>使用技巧</strong>：在一行内的盒子内，我们设定行高等于盒子的高度，就可以使文字垂直居中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">		body &#123;</span><br><span class="line"><span class="css">			<span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">		&#125;</span><br><span class="line">		a &#123;</span><br><span class="line">			width: 200px;</span><br><span class="line">			height: 50px;</span><br><span class="line"><span class="css">			<span class="comment">/* background-color: orange; */</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;  <span class="comment">/* 把a 行内元素转换为行内块元素 */</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;  <span class="comment">/* 文字水平居中 */</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">line-height</span>: 50<span class="selector-tag">px</span>;  <span class="comment">/* 我们设定行高等于盒子的高度，就可以使文字垂直居中 */</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">			font-size: 22px;</span><br><span class="line"><span class="css">			<span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>;  <span class="comment">/* 取消下划线 文本装饰 */</span></span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;  <span class="comment">/* 鼠标经过 给我们的链接添加背景图片*/</span></span></span><br><span class="line">			background: url(images/h.png) no-repeat; </span><br><span class="line">		&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>专区说明<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>申请资格<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>兑换奖励<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>下载游戏<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高5</title>
    <url>/2019/07/27/2019-07-27-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%985/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<hr />
> 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。

<h1 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h1><p>交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格。</p>
<p><img src="https://i.loli.net/2019/07/29/5d3e59fa6a64082735.png" alt="交集选择器"></p>
<h1 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h1><p>并集选择器（CSS选择器分组）是各个选择器通过<strong style="color:#f00">逗号</strong>连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。</p>
<p><img src="https://i.loli.net/2019/07/29/5d3e66318a79e75196.png" alt="并集选择器"></p>
<h1 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h1><p>后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。</p>
<p><img src="https://i.loli.net/2019/07/29/5d3e6ccf64f3135737.png" alt="后代选择器"></p>
<h1 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h1><p>子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，符号左右两侧各保留一个空格。</p>
<p><img src="https://i.loli.net/2019/08/01/5d424f8c23e0c54263.png" alt="子元素选择器"></p>
<h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><p>选取标签带有某些特殊属性的选择器 我们成为属性选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取到 拥有 该属性的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class^=font]</span> &#123; <span class="comment">/*  class^=font 表示 font 开始位置就行了 */</span></span><br><span class="line">			<span class="attribute">color</span>: pink;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class$=footer]</span> &#123; <span class="comment">/*  class$=footer 表示 footer 结束位置就行了 */</span></span><br><span class="line">			<span class="attribute">color</span>: skyblue;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class*=tao]</span> &#123; <span class="comment">/* class*=tao 表示tao 在任意位置都可以 */</span></span><br><span class="line">			<span class="attribute">color</span>: green;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font12"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font12"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font24"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font24"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font24"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"24font"</span>&gt;</span>属性选择器123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub-footer"</span>&gt;</span>属性选择器footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jd-footer"</span>&gt;</span>属性选择器footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-tao-nav"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-tao-header"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tao-header"</span>&gt;</span>属性选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="伪元素选择器（CSS3"><a href="#伪元素选择器（CSS3" class="headerlink" title="伪元素选择器（CSS3)"></a>伪元素选择器（CSS3)</h1><ol>
<li>E::first-letter文本的第一个单词或字（如中文、日文、韩文等）</li>
<li>E::first-line 文本第一行；</li>
<li>E::selection 可改变选中文本的样式；</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: hotpink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首行特殊样式 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line">  <span class="comment">/* font-size: 50px; */</span></span><br><span class="line">  <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4、E::before和E::after</p>
<p>在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::befor</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">"开始"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">"结束"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。</p>
<p>E:after、E:before后面的练习中会反复用到，目前只需要有个大致了解</p>
<p>“:” 与 “::” 区别在于区分伪类和伪元素</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高4</title>
    <url>/2019/07/21/2019-07-21-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%984/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="引入CSS样式表（书写位置）"><a href="#引入CSS样式表（书写位置）" class="headerlink" title="引入CSS样式表（书写位置）"></a>引入CSS样式表（书写位置）</h1><p>CSS可以写到那个位置？ 是不是一定写到html文件里面呢？</p>
<h2 id="内部样式表（内嵌式）"><a href="#内部样式表（内嵌式）" class="headerlink" title="内部样式表（内嵌式）"></a>内部样式表（内嵌式）</h2><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/CSS"</span>&gt;</span></span><br><span class="line">    选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。</p>
<h2 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h2><p>是通过标签的style属性来设置元素的样式，其基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;</span><br></pre></td></tr></table></figure>

<p>语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。</p>
<h2 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h2><p>链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"CSS文件的路径"</span> <span class="attr">type</span>=<span class="string">"text/CSS"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：  link 是个单标签哦!!!</p>
<p>该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</span><br><span class="line">type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。</span><br><span class="line">rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</span><br></pre></td></tr></table></figure>

<h2 id="三种样式表总结"><a href="#三种样式表总结" class="headerlink" title="三种样式表总结"></a>三种样式表总结</h2><table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody><tr>
<td>行内样式表</td>
<td>书写方便，权重高</td>
<td>没有实现样式和结构相分离</td>
<td>较少</td>
<td>控制一个标签（少）</td>
</tr>
<tr>
<td>内嵌样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面（中）</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多，强烈推荐</td>
<td>控制整个站点（多）</td>
</tr>
</tbody></table>
<h1 id="标签显示模式（display）"><a href="#标签显示模式（display）" class="headerlink" title="标签显示模式（display）"></a>标签显示模式（display）</h1><p>HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下：</p>
<h2 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h2><p>每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。</span><br></pre></td></tr></table></figure>

<p>块级元素的特点：</p>
<p>（1）总是从新行开始</p>
<p>（2）高度，行高、外边距以及内边距都可以控制。</p>
<p>（3）宽度默认是容器的100%</p>
<p>（4）可以容纳内联元素和其他块元素。</p>
<h2 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素(inline-level)"></a>行内元素(inline-level)</h2><p>行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。</span><br></pre></td></tr></table></figure>

<p>行内元素的特点：</p>
<p>（1）和相邻行内元素在一行上。</p>
<p>（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。</p>
<p>（3）默认宽度就是它本身内容的宽度。</p>
<p>（4）行内元素只能容纳文本或则其他行内元素。（a特殊）</p>
<p>注意：</p>
<ol>
<li>只有文字才能组成段落，因此p里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li>
<li>链接里面不能再放链接。</li>
</ol>
<h2 id="块级元素和行内元素区别"><a href="#块级元素和行内元素区别" class="headerlink" title="块级元素和行内元素区别"></a>块级元素和行内元素区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">块级元素的特点：</span><br><span class="line">（1）总是从新行开始</span><br><span class="line">（2）高度，行高、外边距以及内边距都可以控制。</span><br><span class="line">（3）宽度默认是容器的100%</span><br><span class="line">（4）可以容纳内联元素和其他块元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行内元素的特点：</span><br><span class="line">（1）和相邻行内元素在一行上。</span><br><span class="line">（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。</span><br><span class="line">（3）默认宽度就是它本身内容的宽度。</span><br><span class="line">（4）行内元素只能容纳文本或则其他行内元素。</span><br></pre></td></tr></table></figure>

<h2 id="行内块元素（inline-block）"><a href="#行内块元素（inline-block）" class="headerlink" title="行内块元素（inline-block）"></a>行内块元素（inline-block）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</span><br><span class="line"></span><br><span class="line">行内块元素的特点：</span><br><span class="line">（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。</span><br><span class="line">（2）默认宽度就是它本身内容的宽度。</span><br><span class="line">（3）高度，行高、外边距以及内边距都可以控制。</span><br></pre></td></tr></table></figure>

<h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><p>块转行内：display：inline；</p>
<p>行内转块：display:block；</p>
<p>块、行内转行内块：display:inline-block；</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高3</title>
    <url>/2019/07/20/2019-07-20-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%983/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="color-文本颜色"><a href="#color-文本颜色" class="headerlink" title="color:文本颜色"></a>color:文本颜色</h1><p>color属性用于定义文本的颜色，其取值方式有如下3种：</p>
<p>1.预定义的颜色值，如red，green，blue等。</p>
<p>2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。</p>
<p>3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。</p>
<p>需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。</p>
<h1 id="line-height-行间距"><a href="#line-height-行间距" class="headerlink" title="line-height:行间距"></a>line-height:行间距</h1><p>ine-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px</p>
<p>一般情况下，行距比字号大7.8像素左右就可以了。</p>
<h1 id="text-align-水平对齐方式"><a href="#text-align-水平对齐方式" class="headerlink" title="text-align:水平对齐方式"></a>text-align:水平对齐方式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下：</span><br></pre></td></tr></table></figure>

<p>left：左对齐（默认值）</p>
<p>right：右对齐</p>
<p>center：居中对齐</p>
<h1 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent:首行缩进"></a>text-indent:首行缩进</h1><p>text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。</p>
<p>1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度</p>
<h1 id="letter-spacing-字间距"><a href="#letter-spacing-字间距" class="headerlink" title="letter-spacing:字间距"></a>letter-spacing:字间距</h1><p>letter-spacing属性用于定义字间距，所谓字间距就是字符与字符之间的空白。其属性值可为不同单位的数值，允许使用负值，默认为normal。</p>
<h1 id="word-spacing-单词间距"><a href="#word-spacing-单词间距" class="headerlink" title="word-spacing:单词间距"></a>word-spacing:单词间距</h1><p>word-spacing属性用于定义英文单词之间的间距，对中文字符无效。和letter-spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。</p>
<p>word-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。</p>
<h1 id="颜色半透明-css3"><a href="#颜色半透明-css3" class="headerlink" title="颜色半透明(css3)"></a>颜色半透明(css3)</h1><p>文字颜色到了CSS3我们可以采取半透明的格式了语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">rgba</span>(<span class="selector-tag">r</span>,<span class="selector-tag">g</span>,<span class="selector-tag">b</span>,<span class="selector-tag">a</span>)  <span class="selector-tag">a</span> 是<span class="selector-tag">alpha</span>  透明的意思  取值范围 0~1之间    <span class="selector-tag">color</span>: <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>)</span><br></pre></td></tr></table></figure>

<h1 id="文字阴影-CSS3"><a href="#文字阴影-CSS3" class="headerlink" title="文字阴影(CSS3)"></a>文字阴影(CSS3)</h1><p>以后我们可以给我们的文字添加阴影效果了  Shadow  影子  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>:水平位置 垂直位置 模糊距离 阴影颜色;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/07/20/5d32fe6890f2d89601.png" alt="文字阴影参数"></p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高2</title>
    <url>/2019/07/19/2019-07-19-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%982/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="标签选择器（元素选择器）"><a href="#标签选择器（元素选择器）" class="headerlink" title="标签选择器（元素选择器）"></a>标签选择器（元素选择器）</h1><p>标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;  或者</span><br><span class="line">元素名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure>

<p>标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。</p>
<h1 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h1><p>类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.类名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签调用的时候用 class=“类名”  即可。</span><br></pre></td></tr></table></figure>

<p>类选择器最大的优势是可以为元素对象定义单独或相同的样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.长名称或词组可以使用中横线来为选择器命名。</span><br><span class="line">2.不建议使用“_”下划线来命名CSS选择器。</span><br><span class="line">  输入的时候少按一个shift键;</span><br><span class="line">　浏览器兼容问题 (比如使用_tips的选择器命名，在IE6是无效的)</span><br><span class="line">　能良好区分JavaScript变量命名(JS变量命名是用“_”)</span><br><span class="line">3.不要纯数字、中文等命名， 尽量使用英文字母来表示。</span><br></pre></td></tr></table></figure>

<h1 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h1><p>我们可以给标签指定多个类名，从而达到更多的选择目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。</span><br><span class="line">2. 各个类名中间用空格隔开。</span><br></pre></td></tr></table></figure>

<p>多类名选择器在后期布局比较复杂的情况下，还是较多使用的。</p>
<h1 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h1><p>id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure>

<p>该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。</p>
<p>用法基本和类选择器相同。</p>
<h2 id="id选择器和类选择器区别"><a href="#id选择器和类选择器区别" class="headerlink" title="id选择器和类选择器区别"></a>id选择器和类选择器区别</h2><p>W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。</p>
<p>类选择器（class） 好比人的名字，是可以多次重复使用的；</p>
<p>id选择器好比人的身份证号码，全中国是唯一的，不得重复。只能使用一次。</p>
<p><strong><em>id选择器和类选择器最大的不同在于使用次数上。</em></strong></p>
<h1 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h1><p>通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure>

<p>例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;                    <span class="comment">/* 定义外边距*/</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;                   <span class="comment">/* 定义内边距*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>这个通配符选择器，作用范围太广，所以一般也不用。</p>
<h1 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h1><p>伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">为了和我们刚才学的类选择器相区别，类选择器是一个点，比如 <span class="selector-class">.demo</span> &#123;&#125;   而我们的伪类用2个点，就是冒号 ，比如<span class="selector-pseudo">:link</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h2><ul>
<li>:link      /* 未访问的链接 */</li>
<li>:visited   /* 已访问的链接 */</li>
<li>:hover     /* 鼠标移动到链接上 */</li>
<li>:active    /* 选定的链接 */</li>
</ul>
<p>注意写的时候，他们的顺序尽量不要颠倒。按照 lvha的顺序。    </p>
<h2 id="结构-位置-伪类选择器（CSS3"><a href="#结构-位置-伪类选择器（CSS3" class="headerlink" title="结构(位置)伪类选择器（CSS3)"></a>结构(位置)伪类选择器（CSS3)</h2><ul>
<li>:first-child :选取属于其父元素的首个子元素的指定选择器</li>
<li>:last-child :选取属于其父元素的最后一个子元素的指定选择器</li>
<li>:nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型</li>
<li>:nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。<br>n 可以是数字、关键词或公式，如odd、even、2n、3n等；</li>
</ul>
<h2 id="目标伪类选择器-CSS3"><a href="#目标伪类选择器-CSS3" class="headerlink" title="目标伪类选择器(CSS3)"></a>目标伪类选择器(CSS3)</h2><p> :target目标伪类选择器 :选择器可用于选取当前活动的目标元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">		<span class="attribute">color</span>: red;</span><br><span class="line">		<span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-CSS入门及提高1</title>
    <url>/2019/07/19/2019-07-19-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-CSS%E5%85%A5%E9%97%A8%E5%8F%8A%E6%8F%90%E9%AB%981/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第二部分：CSS入门及提高；</p>
</blockquote>
<h1 id="CSS的发展历程"><a href="#CSS的发展历程" class="headerlink" title="CSS的发展历程"></a>CSS的发展历程</h1><p>从HTML被发明开始，样式就以各种形式存在。不同的浏览器结合它们各自的样式语言为用户提供页面效果的控制。最初的HTML只包含很少的显示属性。<br>随着HTML的成长，为了满足页面设计者的要求，HTML添加了很多显示功能。但是随着这些功能的增加，HTML变的越来越杂乱，而且HTML页面也越来越臃肿。于是CSS便诞生了。</p>
<h1 id="CSS-网页的美容师"><a href="#CSS-网页的美容师" class="headerlink" title="CSS 网页的美容师"></a>CSS 网页的美容师</h1><p>CSS的最大贡献就是：实现了网页结构和样式的相分离。拯救了混乱的HTML，让我们的网页更加丰富多彩，当然更加拯救了我们web开发者。 </p>
<h1 id="CSS定义"><a href="#CSS定义" class="headerlink" title="CSS定义"></a>CSS定义</h1><p>CSS(Cascading Style Sheets)</p>
<p>CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。</p>
<p>CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。</p>
<h1 id="CSS样式规则"><a href="#CSS样式规则" class="headerlink" title="CSS样式规则"></a>CSS样式规则</h1><p>使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，具体格式如下：                                          </p>
<p><img src="https://i.loli.net/2019/07/19/5d3110402ed4e50465.png" alt="CSS样式规则"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在上面的样式规则中:</span><br><span class="line"></span><br><span class="line">1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。</span><br><span class="line">2.属性和属性值以“键值对”的形式出现。</span><br><span class="line">3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。</span><br><span class="line">4.属性和属性值之间用英文“:”连接。</span><br><span class="line">5.多个“键值对”之间用英文“;”进行区分。</span><br><span class="line">可以用段落 和 表格的对齐的演示。</span><br></pre></td></tr></table></figure>

<h1 id="CSS字体样式属性"><a href="#CSS字体样式属性" class="headerlink" title="CSS字体样式属性"></a>CSS字体样式属性</h1><h2 id="font-size-字号大小"><a href="#font-size-字号大小" class="headerlink" title="font-size:字号大小"></a>font-size:字号大小</h2><p>font-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。</p>
<h2 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family:字体"></a>font-family:字体</h2><p>font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑，可以使用如下CSS样式代码：</p>
<p>p{ font-family:”微软雅黑”;}</p>
<p>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。</p>
<blockquote>
<p>常用技巧：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 现在网页中普遍使用14px+。</span><br><span class="line">2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。</span><br><span class="line">3. 各种字体之间必须使用英文状态下的逗号隔开。</span><br><span class="line">4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。</span><br><span class="line">5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。</span><br><span class="line">6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</span><br></pre></td></tr></table></figure>

<h2 id="CSS-Unicode字体"><a href="#CSS-Unicode字体" class="headerlink" title="CSS Unicode字体"></a>CSS Unicode字体</h2><p>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。</p>
<p>方案一： 你可以使用英文来替代。 比如 font-family:”Microsoft Yahei”。</p>
<p>方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。<br>font-family: “\5FAE\8F6F\96C5\9ED1”，表示设置字体为“微软雅黑”。</p>
<p>可以通过escape()  来测试属于什么字体。</p>
<table>
<thead>
<tr>
<th>字体名称</th>
<th>英文名称</th>
<th>Unicode 编码</th>
</tr>
</thead>
<tbody><tr>
<td>宋体</td>
<td>SimSun</td>
<td>\5B8B\4F53</td>
</tr>
<tr>
<td>新宋体</td>
<td>NSimSun</td>
<td>\65B0\5B8B\4F53</td>
</tr>
<tr>
<td>黑体</td>
<td>SimHei</td>
<td>\9ED1\4F53</td>
</tr>
<tr>
<td>微软雅黑</td>
<td>Microsoft YaHei</td>
<td>\5FAE\8F6F\96C5\9ED1</td>
</tr>
<tr>
<td>楷体_GB2312</td>
<td>KaiTi_GB2312</td>
<td>\6977\4F53_GB2312</td>
</tr>
<tr>
<td>隶书</td>
<td>LiSu</td>
<td>\96B6\4E66</td>
</tr>
<tr>
<td>幼园</td>
<td>YouYuan</td>
<td>\5E7C\5706</td>
</tr>
<tr>
<td>华文细黑</td>
<td>STXihei</td>
<td>\534E\6587\7EC6\9ED1</td>
</tr>
<tr>
<td>细明体</td>
<td>MingLiU</td>
<td>\7EC6\660E\4F53</td>
</tr>
<tr>
<td>新细明体</td>
<td>PMingLiU</td>
<td>\65B0\7EC6\660E\4F53</td>
</tr>
</tbody></table>
<p>为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体。</p>
<h2 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight:字体粗细"></a>font-weight:字体粗细</h2><p>字体加粗除了用b和strong标签之外，可以使用CSS来实现，但是CSS是没有语义的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">数字 400 等价于 <span class="selector-tag">normal</span>，而 700 等价于 <span class="selector-tag">bold</span>。  但是我们更喜欢用数字来表示。</span><br></pre></td></tr></table></figure>

<h2 id="font-style-字体风格"><a href="#font-style-字体风格" class="headerlink" title="font-style:字体风格"></a>font-style:字体风格</h2><p>字体倾斜除了用i和em标签之外，可以使用CSS来实现，但是CSS       是没有语     义的。</p>
<p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p>
<p>normal：默认值，浏览器会显示标准的字体样式。</p>
<p>italic：浏览器会显示斜体的字体样式。</p>
<h2 id="font-综合设置字体样式-重点"><a href="#font-综合设置字体样式-重点" class="headerlink" title="font:综合设置字体样式 (重点)"></a>font:综合设置字体样式 (重点)</h2><p>font属性用于对字体样式进行综合设置，其基本语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">font</span>: font-style  font-weight  font-size/line-height  font-family;&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。</span><br><span class="line"></span><br><span class="line">注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。</span><br></pre></td></tr></table></figure>

<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-HTML入门与实践4</title>
    <url>/2019/07/18/2019-07-18-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-HTML%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B54/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第一部分：HTML入门与实践；</p>
</blockquote>
<h1 id="HTML5新标签"><a href="#HTML5新标签" class="headerlink" title="HTML5新标签"></a>HTML5新标签</h1><h2 id="常用新标签"><a href="#常用新标签" class="headerlink" title="常用新标签"></a>常用新标签</h2><p> w3c  手册中文官网     :   <a href="http://w3school.com.cn/" target="_blank" rel="noopener">http://w3school.com.cn/</a></p>
<ul>
<li><p>header：定义文档的页眉 头部</p>
</li>
<li><p>nav：定义导航链接的部分</p>
</li>
<li><p>footer：定义文档或节的页脚 底部</p>
</li>
<li><p>article：定义文章。</p>
</li>
<li><p>section：定义文档中的节（section、区段）</p>
</li>
<li><p>aside：定义其所处内容之外的内容 侧边</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> 语义 :定义页面的头部  页眉<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>  语义 :定义导航栏 <span class="tag">&lt;/<span class="name">nav</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> 语义: 定义 页面底部 页脚<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> 语义:  定义文章<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> 语义： 定义区域<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> 语义： 定义其所处内容之外的内容 侧边<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>datalist   标签定义选项列表。请与 input 元素配合使用该元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"输入明星"</span> <span class="attr">list</span>=<span class="string">"star"</span>/&gt;</span> <span class="comment">&lt;!--  input里面用 list --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"star"</span>&gt;</span>   <span class="comment">&lt;!-- datalist 里面用 id  来实现和 input 链接 --&gt;</span>  </span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span>&gt;</span>刘德华<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span>&gt;</span>刘若英<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span>&gt;</span>刘晓庆<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span>&gt;</span>郭富城<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span>&gt;</span>张学友<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span>&gt;</span>郭郭<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>fieldset 元素可将表单内的相关元素分组，打包      legend 搭配使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">legend</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">legend</span>&gt;</span>  <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line">    		用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    		密　码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="新增的input-type属性值："><a href="#新增的input-type属性值：" class="headerlink" title="新增的input type属性值："></a>新增的input type属性值：</h2><table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>使用示例</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>email</strong></td>
<td><input type="email"></td>
<td>输入邮箱格式</td>
</tr>
<tr>
<td><strong>tel</strong></td>
<td><input type="tel"></td>
<td>输入手机号码格式</td>
</tr>
<tr>
<td><strong>url</strong></td>
<td><input type="url"></td>
<td>输入url格式</td>
</tr>
<tr>
<td><strong>number</strong></td>
<td><input type="number"></td>
<td>输入数字格式</td>
</tr>
<tr>
<td><strong>search</strong></td>
<td><input type="search"></td>
<td>搜索框（体现语义化）</td>
</tr>
<tr>
<td><strong>range</strong></td>
<td><input type="range"></td>
<td>自由拖动滑块</td>
</tr>
<tr>
<td><strong>time</strong></td>
<td><input type="time"></td>
<td>小时分钟</td>
</tr>
<tr>
<td><strong>date</strong></td>
<td><input type="date"></td>
<td>年月日</td>
</tr>
<tr>
<td><strong>datetime</strong></td>
<td><input type="datetime"></td>
<td>时间</td>
</tr>
<tr>
<td><strong>month</strong></td>
<td><input type="month"></td>
<td>月年</td>
</tr>
<tr>
<td><strong>week</strong></td>
<td><input type="week"></td>
<td>星期 年</td>
</tr>
</tbody></table>
<h2 id="常用新属性"><a href="#常用新属性" class="headerlink" title="常用新属性"></a>常用新属性</h2><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>用法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>placeholder</strong></td>
<td><input type="text" placeholder="请输入用户名"></td>
<td>占位符  当用户输入的时候 里面的文字消失  删除所有文字，自动返回</td>
</tr>
<tr>
<td><strong>autofocus</strong></td>
<td><input type="text" autofocus></td>
<td>规定当页面加载时 input 元素应该自动获得焦点</td>
</tr>
<tr>
<td><strong>multiple</strong></td>
<td><input type="file" multiple></td>
<td>多文件上传</td>
</tr>
<tr>
<td><strong>autocomplete</strong></td>
<td><input type="text" autocomplete="off"></td>
<td>规定表单是否应该启用自动完成功能  有2个值，一个是on 一个是off      on 代表记录已经输入的值  1.autocomplete 首先需要提交按钮 <br/>2.这个表单您必须给他名字</td>
</tr>
<tr>
<td><strong>required</strong></td>
<td><input type="text" required></td>
<td>必填项  内容不能为空</td>
</tr>
<tr>
<td><strong>accesskey</strong></td>
<td><input type="text" accesskey="s"></td>
<td>规定激活（使元素获得焦点）元素的快捷键   采用 alt + s的形式</td>
</tr>
</tbody></table>
<h1 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h1><ul>
<li><p>embed：标签定义嵌入的内容</p>
</li>
<li><p>audio：播放音频</p>
</li>
<li><p>video：播放视频</p>
</li>
</ul>
<h2 id="多媒体-embed"><a href="#多媒体-embed" class="headerlink" title="多媒体 embed"></a>多媒体 embed</h2><p>embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。</p>
<p>因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 </p>
<h2 id="多媒体-audio"><a href="#多媒体-audio" class="headerlink" title="多媒体 audio"></a>多媒体 audio</h2><p>HTML5通过&lt; audio &gt;标签来解决音频播放的问题。可以通过附加属性可以更友好控制音频的播放，如：<br>autoplay 自动播放</p>
<p>controls 是否显不默认播放控件</p>
<p>loop 循环播放   loop = 2 就是循环2次   loop  或者  loop = “-1”   无限循环</p>
<h2 id="多媒体-video"><a href="#多媒体-video" class="headerlink" title="多媒体 video"></a>多媒体 video</h2><p>HTML5通过&lt; video &gt;标签来解决视频播放的问题。</p>
<p>同样，通过附加属性可以更友好的控制视频的播放</p>
<p>autoplay 自动播放</p>
<p>controls 是否显示默认播放控件</p>
<p>loop 循环播放</p>
<p>width 设置播放窗口宽度</p>
<p>height 设置播放窗口的高度</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-HTML入门与实践3</title>
    <url>/2019/07/17/2019-07-17-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-HTML%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B53/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。此部分视频网页没有。具体查看这里：<a href="https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。" target="_blank" rel="noopener">https://pan.baidu.com/s/1exZQc9bXadphQfd3k_vYJQ（提取码：7sk1）。</a><br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第一部分：HTML入门与实践；</p>
</blockquote>
<h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><p>创建表格的基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.table用于定义一个表格。</span><br><span class="line"></span><br><span class="line">2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。</span><br><span class="line"></span><br><span class="line">3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素</span><br></pre></td></tr></table></figure>

<h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><p><img src="https://i.loli.net/2019/07/17/5d2e7ac7dccd934808.png" alt="表格属性"></p>
<h2 id="表头标签"><a href="#表头标签" class="headerlink" title="表头标签"></a>表头标签</h2><p>表头一般位于表格的第一行或第一列，其文本加粗居中，即为设置了表头的表格。需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。</p>
<h2 id="表格结构"><a href="#表格结构" class="headerlink" title="表格结构"></a>表格结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。</span><br><span class="line">必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。</span><br><span class="line">位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。</span><br></pre></td></tr></table></figure>
<h2 id="表格标题"><a href="#表格标题" class="headerlink" title="表格标题"></a>表格标题</h2><p><strong>表格的标题： caption</strong></p>
<p><strong>定义和用法</strong></p>
<p>caption 元素定义表格标题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">caption</span>&gt;</span>我是表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>caption 标签必须紧随 table 标签之后。只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。</p>
<h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><p>跨行合并：rowspan    跨列合并：colspan</p>
<p>合并的顺序：跨行合并从上到下合并，跨列合并从左到右合并。 </p>
<h2 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h2><ol>
<li><p>表格提供了HTML 中定义表格式数据的方法。</p>
</li>
<li><p>表格中由行中的单元格组成。</p>
</li>
<li><p>表格中没有列元素，列的个数取决于行的单元格个数。</p>
</li>
<li><p>表格不要纠结于外观，那是CSS 的作用。</p>
</li>
</ol>
<h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><p>在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。</p>
<ol>
<li>表单控件：<br>包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</li>
<li>提示信息：<br>一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</li>
<li>表单域：<br>相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</li>
</ol>
<h2 id="input-控件"><a href="#input-控件" class="headerlink" title="input 控件"></a>input 控件</h2><p>&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input /&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。<br><img src="https://i.loli.net/2019/07/17/5d2e915f6dcf539772.png" alt="input 控件属性"></p>
<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><p>label标签为input元素定义标注(标签)。</p>
<p>作用：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</p>
<h2 id="textarea控件"><a href="#textarea控件" class="headerlink" title="textarea控件"></a>textarea控件</h2><p>如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"每行中的字符数"</span> <span class="attr">rows</span>=<span class="string">"显示的行数"</span>&gt;</span></span><br><span class="line">  文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h2><p>使用select控件定义下拉菜单的基本语法格式如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>&lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。</li>
<li>在option 中定义selected =” selected “时，当前项即为默认选中项。</li>
</ol>
<h2 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h2><p>在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"url地址"</span> <span class="attr">method</span>=<span class="string">"提交方式"</span> <span class="attr">name</span>=<span class="string">"表单名称"</span>&gt;</span></span><br><span class="line">  各种表单控件</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>常用属性：</p>
<ol>
<li>Action<br>在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。</li>
<li>method<br>用于设置表单数据的提交方式，其取值为get或post。</li>
<li>name<br>用于指定表单的名称，以区分同一个页面中的多个表单。</li>
</ol>
<p>注意：每个表单都应该有自己表单域。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-HTML入门与实践2</title>
    <url>/2019/07/16/2019-07-16-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-HTML%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B52/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。<br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第一部分：HTML入门与实践；</p>
</blockquote>
<h1 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h1><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p>单词缩写：  head 头部<br>为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt;</span><br></pre></td></tr></table></figure>
<p>标题标签语义：作为标题使用，并且依据重要性递减</p>
<blockquote>
<p>注意：h1标签因为重要，尽量少用。 一般h1都是给logo使用。</p>
</blockquote>
<h2 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h2><p>单词缩写：paragraph  段落<br>在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>  文本内容  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p>
<h2 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a>水平线标签</h2><p>单词缩写：horizontal 横线<br>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，&#60; hr /&#62;就是创建横跨网页水平线的标签。其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span>   是单标签</span><br></pre></td></tr></table></figure>

<p>在网页中显示默认样式的水平线。</p>
<h2 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h2><p>单词缩写：break   打断 ,换行</p>
<p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="div-span标签"><a href="#div-span标签" class="headerlink" title="div span标签"></a>div span标签</h2><p>div  span是没有语义的，是我们网页布局主要的2个盒子。</p>
<p>div 就是division的缩写，分割，分区的意思。其实有很多div来组合网页。</p>
<p>span, 跨度，跨距；范围    </p>
<p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 这是头部 <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">span</span>&gt;</span>今日价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h1><p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。<br><img src="https://i.loli.net/2019/07/16/5d2d912790ee149390.png" alt="文本格式化标签"></p>
<h1 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h1><p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span> 属性<span class="attr">1</span>=<span class="string">"属性值1"</span> 属性<span class="attr">2</span>=<span class="string">"属性值2"</span> …&gt;</span> 内容 <span class="tag">&lt;/<span class="name">标签名</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的语法中，</p>
<ol>
<li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li>
<li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li>
<li>任何标签的属性都有默认值，省略该属性则取默认值。</li>
</ol>
<h1 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h1><p>单词缩写：image  图像</p>
<p>其基本语法格式如下：</p>
<p>该语法中src属性用于指定图像文件的路径和文件名，它是img标签的必需属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图像URL"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/07/16/5d2db8a5aa0ae94843.png" alt="/img标记属性"></p>
<h1 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h1><h2 id="锚点标签"><a href="#锚点标签" class="headerlink" title="锚点标签"></a>锚点标签</h2><p>单词缩写：anchor 的缩写 。基本解释 锚, 铁锚 的</p>
<p>在HTML中创建超链接只需用标签环绕需要被链接的对象即可，其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"跳转目标"</span> <span class="attr">target</span>=<span class="string">"目标窗口的弹出方式"</span>&gt;</span>文本或图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。  Hypertext Reference的缩写。意思是超文本引用。</p>
<p>target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。</p>
<p>注意：</p>
<ol>
<li>外部链接 需要添加 http:// </li>
<li>内部链接 直接链接内部页面名称即可 比如 &#60; a href=”index.html”&#62; 首页  &#60;/a  &#62;</li>
<li>如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。</li>
<li>不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。</li>
</ol>
<h3 id="锚点定位"><a href="#锚点定位" class="headerlink" title="锚点定位"></a>锚点定位</h3><p>通过创建锚点链接，用户能够快速定位到目标内容。<br>创建锚点链接分为两步：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.使用<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#id名"</span>&gt;</span> "链接文本" <span class="tag">&lt;/<span class="name">a</span>&gt;</span>创建链接文本。</span><br><span class="line"></span><br><span class="line">2.使用相应的“id=id名”标注跳转目标的位置。</span><br></pre></td></tr></table></figure>

<h2 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h2><p>base 可以设置整体链接的打开状态。<br>base 写到 &#60; head &#62;   &#60; /head &#62; 之间。</p>
<h1 id="特殊字符标签"><a href="#特殊字符标签" class="headerlink" title="特殊字符标签"></a>特殊字符标签</h1><p><img src="https://i.loli.net/2019/07/16/5d2dc2d50ddaf51377.png" alt="特殊字符标签"></p>
<h1 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h1><p>基本语法格式如下：      </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 --&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h1><p>路径可以分为： 相对路径和绝对路径</p>
<h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><ol>
<li>图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。</li>
<li>图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。</li>
<li>图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。</li>
</ol>
<h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>“D:\web\img\logo.gif”，或完整的网络地址，例如“<a href="http://www.itcast.cn/images/logo.gif”。" target="_blank" rel="noopener">http://www.itcast.cn/images/logo.gif”。</a></p>
<h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><p>容器里面装载着文字或图表的一种形式，叫列表。</p>
<p>列表最大的特点就是整齐 、整洁、 有序</p>
<h2 id="无序列表ul"><a href="#无序列表ul" class="headerlink" title="无序列表ul"></a>无序列表ul</h2><p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的几点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。</span><br><span class="line">2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。</span><br><span class="line">3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！</span><br></pre></td></tr></table></figure>
<h2 id="有序列表ol"><a href="#有序列表ol" class="headerlink" title="有序列表ol"></a>有序列表ol</h2><p>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><p>定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://i.loli.net/2019/07/16/5d2ddadf1f0e569351.png" alt="总结"></p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发(1)-HTML入门与实践1</title>
    <url>/2019/07/16/2019-07-16-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91(1)-HTML%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B51/</url>
    <content><![CDATA[<blockquote>
<p>系列课程地址：<a href="https://edu.aliyun.com/roadmap/frontend?spm=5176.8764702.aliyun-edu-index-001.6.324e4679APt7uq" target="_blank" rel="noopener">戳这里</a>。<br>系列课程共分为三部分：阶段 1：HTML+CSS；阶段 2：JavaScript；阶段 3：开发工具；阶段 4：前端框架；阶段 5：移动及服务端开发。<br>这里介绍阶段 1：HTML+CSS中的第一部分：HTML入门与实践；</p>
</blockquote>
<h1 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h1><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><ol>
<li><p>Trident(IE内核)<br>国内许多双核浏览器其中一核便是Trident，美名其曰“兼容模式”。代表：IE、傲游、世界之窗、猎豹、360极速、百度……Windows10发布之后，IE将其内置浏览器命名为Edge，最显著特点就是其新内核EdgeHTML。</p>
</li>
<li><p>Gecko(firefox)<br>火狐浏览器采用该内核，特点是代码完全公开，因此开发程序较高，可惜遇到了猪一样的队友flash，神一样的对手chrome，故这几年已经没落。</p>
</li>
<li><p>Webkit(safari)<br>代表：safari、傲游3、Android4.4之前默认浏览器。</p>
</li>
<li><p>Chromium/Bink(chrome)<br>内置于chrome浏览器中，大部分国产浏览器最新版都采用Bink内核，以及Android4.4之后默认浏览器。</p>
</li>
</ol>
<h2 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h2><p>Web标准是由W3C和其他标准化组织制定的一系列标准的集合，主要包括结构、表现和行为三个方面。</p>
<ol>
<li>结构标准：用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分；</li>
<li>样式标准：用于设置网页元素的版式、大小、颜色等外观形式，主要指CSS；</li>
<li>行为标准：指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分。</li>
</ol>
<p>理想状态的源码：.html .css .js</p>
<h1 id="HTML入门"><a href="#HTML入门" class="headerlink" title="HTML入门"></a>HTML入门</h1><h2 id="html骨架"><a href="#html骨架" class="headerlink" title="html骨架"></a>html骨架</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="标签及分类"><a href="#标签及分类" class="headerlink" title="标签及分类"></a>标签及分类</h2><p>在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素。</p>
<p>1.双标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span>&gt;</span> 内容 <span class="tag">&lt;/<span class="name">标签名</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">比如 <span class="tag">&lt;<span class="name">body</span>&gt;</span>我是文字  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>2.单标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">比如  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="开发工具sublime"><a href="#开发工具sublime" class="headerlink" title="开发工具sublime"></a>开发工具sublime</h2><p>在页面中输入 以下2个单词</p>
<ol>
<li>html: 5   </li>
<li>!</li>
</ol>
<p>在sublime里面然后按下tab键盘即可生成HTML骨架。<br>注意：我这里在官网下载安装sublime text3之后，上述功能并不能使用，解决办法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Preference ==&gt; Browser Packages，打开文件夹，发现只有一个User文件夹；</span><br><span class="line">2.下载emmet-sublime-master.zip，解压，下载地址：https://github.com/sergeche/emmet-sublime/archive/master.zip</span><br><span class="line">，将解压好的文件夹——复制到第一步所提到的文件夹中；</span><br><span class="line">3.重启sublime，PyV8文件夹自动加载；</span><br><span class="line">4.打开sublime，用command + shift + p调出命令窗口，输入install,选中package control：install package，等待1-2秒，下拉选中emmet回车，等待2-3秒，重启sublime。</span><br></pre></td></tr></table></figure>

<h2 id="文档类型-lt-DOCTYPE-gt"><a href="#文档类型-lt-DOCTYPE-gt" class="headerlink" title="文档类型&lt;!DOCTYPE&gt;"></a>文档类型&lt;!DOCTYPE&gt;</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure>

<p>这句话就是告知我们使用的是 html 5 的版本。html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。</p>
<!DOCTYPE><p> 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><meta charset="UTF-8">

<p>utf-8是目前最常用的字符集编码方式，使用utf-8这样就避免出现字符集不统一而引起乱码的情况了。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkDevelop阿里云物联网应用开发方案</title>
    <url>/2019/07/15/2019-07-15-%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%89%A9%E8%81%94%E7%BD%91%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<blockquote>
<p>关于阿里云物联网平台的介绍前边已涉及，在这里不再做太多介绍；<br>学习视频地址：<a href="https://edu.aliyun.com/course/1693?spm=5176.10731542.0.0.55e61b3anm2b7N" target="_blank" rel="noopener">戳这里</a>。</p>
</blockquote>
<h1 id="STM32节点设备接入阿里云物联网平台"><a href="#STM32节点设备接入阿里云物联网平台" class="headerlink" title="STM32节点设备接入阿里云物联网平台"></a>STM32节点设备接入阿里云物联网平台</h1><h1 id="服务端应用开发"><a href="#服务端应用开发" class="headerlink" title="服务端应用开发"></a>服务端应用开发</h1><h2 id="服务端软件架构介绍"><a href="#服务端软件架构介绍" class="headerlink" title="服务端软件架构介绍"></a>服务端软件架构介绍</h2><p>这一节的内容主要基于物联网架构中的应用层。<br><img src="https://i.loli.net/2019/07/15/5d2c446c3325c85531.png" alt="应用层在系统中定位"></p>
<p><img src="https://i.loli.net/2019/07/15/5d2c54875389695455.png" alt="应用层系统技术体系"></p>
<h2 id="后端服务开发"><a href="#后端服务开发" class="headerlink" title="后端服务开发"></a>后端服务开发</h2><h3 id="认识后端框架"><a href="#认识后端框架" class="headerlink" title="认识后端框架"></a>认识后端框架</h3><p>-前端是软件系统中直接和用户交互的部分，后端控制着软件的输出。前端的JavaScript代码通过ajsx等技术向后端进行网络请求，后端收到请求后对数据库进行操作，返回给前端JSON数据，前端把相应数据战士在页面上；</p>
<p>-后端常用语言包括Java、MySQL、XML等；</p>
<p>-本例程基于以下框架进行开发：MySQL、Mybatis、SpringBoot；<br><img src="https://i.loli.net/2019/07/15/5d2c57ff4536991340.png" alt="后端框架"></p>
<h3 id="应用系统开发"><a href="#应用系统开发" class="headerlink" title="应用系统开发"></a>应用系统开发</h3><p><img src="https://i.loli.net/2019/07/15/5d2c6d8d14c9879064.png" alt=""></p>
<h3 id="应用调试与部署"><a href="#应用调试与部署" class="headerlink" title="应用调试与部署"></a>应用调试与部署</h3><h2 id="前端服务开发"><a href="#前端服务开发" class="headerlink" title="前端服务开发"></a>前端服务开发</h2><h3 id="认识前端框架"><a href="#认识前端框架" class="headerlink" title="认识前端框架"></a>认识前端框架</h3><p>-前端的开发语言：HTML、JavaScript、CSS；</p>
<ol>
<li>HTML即超文本标记语言，用来描述网页的一种语言，与编程语言不同，它用来记录信息而非执行逻辑处理，HTML语言的内容被各类标签所包裹；</li>
<li>JavaScript是一种直译试的脚本语言，是一种动态的解释形语言，它不需要经过编辑为机器码再运行，而是直接可以由解释器（称为JavaScript引擎，内置再各类浏览器中）运行；</li>
<li>CSS是指层叠样式表，定义如何显示HTML元素，一般存储在.css后缀的文件中，通过HTML标签中的className以及id属性来进行绑定；</li>
</ol>
<p>-前端框架：React框架、Umi.js框架、Ant Design UI组件、Dva.js数据流方案；</p>
<ol>
<li>React框架提供底层技术支撑，是一个为数据提供渲染为HTML视图的开源JavaScript库，React技术方案-虚拟DOM，React核心思想-组件；</li>
<li>Umi.js框架集成了页面路由、项目打包等工具，简化开发者配置和繁杂的操作；</li>
<li>Ant Design UI组件提供丰富的页面UI组件库，Umi在初始化时选择antd插件即可集成，也可以通过命令行执行npm install -g antd进行安装；</li>
<li>Dva.js数据流方案，将UI和数据解耦，提高前端的开发效率，Umi在初始化时选择dva插件即可集成，也可以通过命令行执行npm install -g dva进行安装；</li>
</ol>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>ECS</tag>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkDevelop阿里云物联网应用开发方案</title>
    <url>/2019/07/15/2019-07-15-LinkDevelop%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>阿里云的物联网应用开发，即<a href="https://iot.aliyun.com/products/iotstudio" target="_blank" rel="noopener">Link Develop</a>。虽然现在已经不存在，被IoT Studio所取代，但基本框架并没有改变，所以在此仍然简单了解学习一下。<br>学习视频地址：<a href="https://edu.aliyun.com/course/1392/learn?spm=5176.8764728.aliyun-edu-course-header.15.6926319aoN2rnZ#lesson/11620" target="_blank" rel="noopener">戳这里</a>。</p>
</blockquote>
<h1 id="设备开发"><a href="#设备开发" class="headerlink" title="设备开发"></a>设备开发</h1><p>-将设备模型抽象成三类：属性、服务、事件；<br>-实时查看设备上报的数据并进行在线调试；</p>
<h1 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h1><p>-直接使用官方根据物联网需求建好的服务；<br>-做服务的二次开发；</p>
<h1 id="Bone开发框架"><a href="#Bone开发框架" class="headerlink" title="Bone开发框架"></a>Bone开发框架</h1><p><a href="https://bone.aliyun.com/" target="_blank" rel="noopener">Bone开发框架</a>分为两部分：Bone Moblie和Bone Web。<br>Bone Web是一个基于react+redux封装的Web开发框架，在使用上进行了简化并且提供了一些常用的UI组件。<br>可以在此下载模板进行三元组的修改之后打包上传，进行构建，实现简单功能的实现。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>ECS</tag>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_9</title>
    <url>/2019/06/26/2019-06-26-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_9/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="从数据处理到人工智能"><a href="#从数据处理到人工智能" class="headerlink" title="从数据处理到人工智能"></a>从数据处理到人工智能</h1><p>数据表示 ==&gt; 数据清洗 ==&gt; 数据统计 ==&gt; 数据可视化 ==&gt; 数据挖掘 ==&gt; 人工智能 </p>
<h2 id="Python库之数据分析"><a href="#Python库之数据分析" class="headerlink" title="Python库之数据分析"></a>Python库之数据分析</h2><p>Numpy:表达N维数组的最基本库；<br>Pandas:Python数据分析高层次应用；<br>SciPy：数学、科学和工程计算功能库；</p>
<h2 id="Python库之数据可视化"><a href="#Python库之数据可视化" class="headerlink" title="Python库之数据可视化"></a>Python库之数据可视化</h2><p>Matpoltlib:高质量的二维数据可视化库；<br>Seaborn:统计类数据可视化功能库；<br>Mayavi：三维科学数据可视化功能库；</p>
<h2 id="Python库之文本处理"><a href="#Python库之文本处理" class="headerlink" title="Python库之文本处理"></a>Python库之文本处理</h2><p>PyPDF2:用来处理PDF文件的工具集；<br>NLTK:自然语言处理第三方库；<br>Python-docx：创建或更新Microsoft Word文件的第三方库；</p>
<h2 id="Python库之机器学习"><a href="#Python库之机器学习" class="headerlink" title="Python库之机器学习"></a>Python库之机器学习</h2><p>Scikit-learn:机器学习方法工具集；<br>TensorFlow:AlphaGO背后的机器学习计算框架；<br>MXNet：基于神经网络的深度学习计算框架；</p>
<h1 id="实例：霍兰德人格分析雷达图"><a href="#实例：霍兰德人格分析雷达图" class="headerlink" title="实例：霍兰德人格分析雷达图"></a>实例：霍兰德人格分析雷达图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#HollandRadarDraw</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import matplotlib</span><br><span class="line">matplotlib.rcParams[&apos;font.family&apos;]=&apos;SimHei&apos;</span><br><span class="line">radar_labels = np.array([&apos;研究型(I)&apos;,&apos;艺术型(A)&apos;,&apos;社会型(S)&apos;,\</span><br><span class="line">                         &apos;企业型(E)&apos;,&apos;常规型(C)&apos;,&apos;现实型(R)&apos;]) #雷达标签</span><br><span class="line">nAttr = 6</span><br><span class="line">data = np.array([[0.40, 0.32, 0.35, 0.30, 0.30, 0.88],</span><br><span class="line">                 [0.85, 0.35, 0.30, 0.40, 0.40, 0.30],</span><br><span class="line">                 [0.43, 0.89, 0.30, 0.28, 0.22, 0.30],</span><br><span class="line">                 [0.30, 0.25, 0.48, 0.85, 0.45, 0.40],</span><br><span class="line">                 [0.20, 0.38, 0.87, 0.45, 0.32, 0.28],</span><br><span class="line">                 [0.34, 0.31, 0.38, 0.40, 0.92, 0.28]]) #数据值</span><br><span class="line">data_labels = (&apos;艺术家&apos;, &apos;实验员&apos;, &apos;工程师&apos;, &apos;推销员&apos;, &apos;社会工作者&apos;,&apos;记事员&apos;)</span><br><span class="line">angles = np.linspace(0, 2*np.pi, nAttr, endpoint=False)</span><br><span class="line">data = np.concatenate((data, [data[0]]))</span><br><span class="line">angles = np.concatenate((angles, [angles[0]]))</span><br><span class="line">fig = plt.figure(facecolor=&quot;white&quot;)</span><br><span class="line">plt.subplot(111, polar=True)</span><br><span class="line">plt.plot(angles,data,&apos;o-&apos;, linewidth=1, alpha=0.2)</span><br><span class="line">plt.fill(angles,data, alpha=0.25)</span><br><span class="line">plt.thetagrids(angles*180/np.pi, radar_labels,frac = 1.2)</span><br><span class="line">plt.figtext(0.52, 0.95, &apos;霍兰德人格分析&apos;, ha=&apos;center&apos;, size=20)</span><br><span class="line">legend = plt.legend(data_labels, loc=(0.94, 0.80), labelspacing=0.1)</span><br><span class="line">plt.setp(legend.get_texts(), fontsize=&apos;large&apos;)</span><br><span class="line">plt.grid(True)</span><br><span class="line">plt.savefig(&apos;holland_radar.jpg&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>运行程序会发现，所有中文字体都变成了方框，网上找到了不少方法，在此记录自己成功的方案，总体来讲就是为系统安装需要的SimHei字体并增加到matplotlib中。</p>
<p>(1)下载一个ttf中文字体，并在系统中安装。可在此下载 <a href="https://github.com/dolbydu/font" target="_blank" rel="noopener">https://github.com/dolbydu/font</a>, 我这里下载好后放在了桌面。</p>
<p>(2)在 /usr/share/fonts 路径下创建存放此字体的文件夹myfonts，并下载的ttf文件复制到此文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/share/fonts</span><br><span class="line">sudo mkdir myfonts</span><br><span class="line">cd myfonts/</span><br><span class="line">sudo cp /home/hpf/桌面/SimHei.ttf  /usr/share/fonts/myfonts/</span><br></pre></td></tr></table></figure>

<p>(3)给系统安装这个字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#生成字体索引信息. 会显示字体的font-family</span><br><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">#更新字体缓存：</span><br><span class="line">fc-cache</span><br></pre></td></tr></table></figure>
<p>此时在终端运行:fc-list :lang=zh，会发现系统已经安装。</p>
<p>(4)修改matplotlibrc文件<br>找到路径/home/hpf/anaconda3/lib/python3.6/site-packages/matplotlib/mpl-data/matplotlibrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 去掉这一行注释</span><br><span class="line">font.family         : sans-serif        </span><br><span class="line"># 去掉这一行注释，并新增我们刚下载的中文字体　</span><br><span class="line">font.sans-serif     : DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif,SimHei</span><br></pre></td></tr></table></figure>
<p>下面这句注释要去掉，不然中文减号也显示方块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axes.unicode_minus  : False</span><br></pre></td></tr></table></figure>

<p>(5)为matplotlib增加中文字体<br>将下载的字体文件复制一份到步骤4找到的配置文件的同级文件夹fonts/ttf中。</p>
<p>(6) 清除本地matplotlib中的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~/.cache/matplotlib</span><br></pre></td></tr></table></figure>


<h1 id="从Web解析到网络空间"><a href="#从Web解析到网络空间" class="headerlink" title="从Web解析到网络空间"></a>从Web解析到网络空间</h1><h2 id="Python库之网络爬虫"><a href="#Python库之网络爬虫" class="headerlink" title="Python库之网络爬虫"></a>Python库之网络爬虫</h2><p>Requests:最友好的网络爬虫功能库；<br>Scrapy:优秀的网络爬虫框架；<br>pyspider：强大的Web页面爬取系统；</p>
<h2 id="Python库之Web信息提取"><a href="#Python库之Web信息提取" class="headerlink" title="Python库之Web信息提取"></a>Python库之Web信息提取</h2><p>Beautiful Soup:HTML和XL的解析库；<br>Re:正则表达式解析和处理功能库；<br>Python-Goose：提取文章类型Web页面的功能库；</p>
<h2 id="Python库之Web网站开发"><a href="#Python库之Web网站开发" class="headerlink" title="Python库之Web网站开发"></a>Python库之Web网站开发</h2><p>Django:最流行的Web应用框架；<br>Pyramid:规模适中的Web应用框架；<br>Flask：Web应用开发微框架；</p>
<h2 id="Python库之网络应用开发"><a href="#Python库之网络应用开发" class="headerlink" title="Python库之网络应用开发"></a>Python库之网络应用开发</h2><p>WeRoBot:微信公众号开发框架；<br>aip:百度AI开放平台接口；<br>MyQR：二维码生成第三方库；</p>
<h1 id="从人机交互到艺术设计"><a href="#从人机交互到艺术设计" class="headerlink" title="从人机交互到艺术设计"></a>从人机交互到艺术设计</h1><h2 id="Python库之图形用户界面"><a href="#Python库之图形用户界面" class="headerlink" title="Python库之图形用户界面"></a>Python库之图形用户界面</h2><p>PyQt5:Qt开发框架的Python接口；<br>wxPython:跨平台GUI开发框架；<br>PyGObject：使用GTK+开发GUI的功能库；</p>
<h2 id="Python库之游戏开发"><a href="#Python库之游戏开发" class="headerlink" title="Python库之游戏开发"></a>Python库之游戏开发</h2><p>PyGame:简单的游戏开发功能库；<br>Panda3D:开源、跨平台的3D渲染和游戏开发库；<br>cocos2D：构建2D游戏和图形界面交互式应用的框架；</p>
<h2 id="Python库之虚拟现实"><a href="#Python库之虚拟现实" class="headerlink" title="Python库之虚拟现实"></a>Python库之虚拟现实</h2><p>VR Zero:在树莓派上开发VR应用的Python库；<br>pyvor:Oculus Rift的Python开发接口；<br>Vizard：基于Python的通用VR开发引擎；</p>
<h2 id="Python库之图形艺术"><a href="#Python库之图形艺术" class="headerlink" title="Python库之图形艺术"></a>Python库之图形艺术</h2><p>Quads：迭代的艺术；<br>ascii_art:ASCII艺术库；<br>turtle：海龟绘图体系；</p>
<h1 id="实例：玫瑰花绘制"><a href="#实例：玫瑰花绘制" class="headerlink" title="实例：玫瑰花绘制"></a>实例：玫瑰花绘制</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#RoseDraw.py</span><br><span class="line">import turtle as t</span><br><span class="line"># 定义一个曲线绘制函数</span><br><span class="line">def DegreeCurve(n, r, d=1):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        t.left(d)</span><br><span class="line">        t.circle(r, abs(d))</span><br><span class="line"># 初始位置设定</span><br><span class="line">s = 0.2 # size</span><br><span class="line">t.setup(450*5*s, 750*5*s)</span><br><span class="line">t.pencolor(&quot;black&quot;)</span><br><span class="line">t.fillcolor(&quot;red&quot;)</span><br><span class="line">t.speed(100)</span><br><span class="line">t.penup()</span><br><span class="line">t.goto(0, 900*s)</span><br><span class="line">t.pendown()</span><br><span class="line"># 绘制花朵形状</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(200*s,30)</span><br><span class="line">DegreeCurve(60, 50*s)</span><br><span class="line">t.circle(200*s,30)</span><br><span class="line">DegreeCurve(4, 100*s)</span><br><span class="line">t.circle(200*s,50)</span><br><span class="line">DegreeCurve(50, 50*s)</span><br><span class="line">t.circle(350*s,65)</span><br><span class="line">DegreeCurve(40, 70*s)</span><br><span class="line">t.circle(150*s,50)</span><br><span class="line">DegreeCurve(20, 50*s, -1)</span><br><span class="line">t.circle(400*s,60)</span><br><span class="line">DegreeCurve(18, 50*s)</span><br><span class="line">t.fd(250*s)</span><br><span class="line">t.right(150)</span><br><span class="line">t.circle(-500*s,12)</span><br><span class="line">t.left(140)</span><br><span class="line">t.circle(550*s,110)</span><br><span class="line">t.left(27)</span><br><span class="line">t.circle(650*s,100)</span><br><span class="line">t.left(130)</span><br><span class="line">t.circle(-300*s,20)</span><br><span class="line">t.right(123)</span><br><span class="line">t.circle(220*s,57)</span><br><span class="line">t.end_fill()</span><br><span class="line"># 绘制花枝形状</span><br><span class="line">t.left(120)</span><br><span class="line">t.fd(280*s)</span><br><span class="line">t.left(115)</span><br><span class="line">t.circle(300*s,33)</span><br><span class="line">t.left(180)</span><br><span class="line">t.circle(-300*s,33)</span><br><span class="line">DegreeCurve(70, 225*s, -1)</span><br><span class="line">t.circle(350*s,104)</span><br><span class="line">t.left(90)</span><br><span class="line">t.circle(200*s,105)</span><br><span class="line">t.circle(-500*s,63)</span><br><span class="line">t.penup()</span><br><span class="line">t.goto(170*s,-30*s)</span><br><span class="line">t.pendown()</span><br><span class="line">t.left(160)</span><br><span class="line">DegreeCurve(20, 2500*s)</span><br><span class="line">DegreeCurve(220, 250*s, -1)</span><br><span class="line"># 绘制一个绿色叶子</span><br><span class="line">t.fillcolor(&apos;green&apos;)</span><br><span class="line">t.penup()</span><br><span class="line">t.goto(670*s,-180*s)</span><br><span class="line">t.pendown()</span><br><span class="line">t.right(140)</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(300*s,120)</span><br><span class="line">t.left(60)</span><br><span class="line">t.circle(300*s,120)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.penup()</span><br><span class="line">t.goto(180*s,-550*s)</span><br><span class="line">t.pendown()</span><br><span class="line">t.right(85)</span><br><span class="line">t.circle(600*s,40)</span><br><span class="line"># 绘制另一个绿色叶子</span><br><span class="line">t.penup()</span><br><span class="line">t.goto(-150*s,-1000*s)</span><br><span class="line">t.pendown()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.rt(120)</span><br><span class="line">t.circle(300*s,115)</span><br><span class="line">t.left(75)</span><br><span class="line">t.circle(300*s,100)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.penup()</span><br><span class="line">t.goto(430*s,-1070*s)</span><br><span class="line">t.pendown()</span><br><span class="line">t.right(30)</span><br><span class="line">t.circle(-600*s,35)</span><br><span class="line">t.done()</span><br></pre></td></tr></table></figure>


<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_8</title>
    <url>/2019/06/25/2019-06-25-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_8/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="实例：体育竞技分析"><a href="#实例：体育竞技分析" class="headerlink" title="实例：体育竞技分析"></a>实例：体育竞技分析</h1><p>程序框架及步骤：<br>-步骤一pirntInfo()：打印程序的介绍性信息式；<br>-步骤二getInputs()：获得程序运行参数：proA，proB，n；<br>-步骤三simNGames()：获得球员A和球员B的能力值，模拟n局比赛；<br>-步骤四printSummary()：输出球员A和B获胜比赛的场次及概率；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#MatchAnalysis.py</span><br><span class="line">from random import random</span><br><span class="line">def printIntro():</span><br><span class="line">    print(&quot;这个程序模拟两个选手A和B的某种竞技比赛&quot;)</span><br><span class="line">    print(&quot;程序运行需要A和B的能力值（以0到1之间的小数表示）&quot;)</span><br><span class="line">def getInputs():</span><br><span class="line">    a = eval(input(&quot;请输入选手A的能力值(0-1): &quot;))</span><br><span class="line">    b = eval(input(&quot;请输入选手B的能力值(0-1): &quot;))</span><br><span class="line">    n = eval(input(&quot;模拟比赛的场次: &quot;))</span><br><span class="line">    return a, b, n</span><br><span class="line">def simNGames(n, probA, probB):</span><br><span class="line">    winsA, winsB = 0, 0</span><br><span class="line">    for i in range(n):</span><br><span class="line">        scoreA, scoreB = simOneGame(probA, probB)</span><br><span class="line">        if scoreA &gt; scoreB:</span><br><span class="line">            winsA += 1</span><br><span class="line">        else:</span><br><span class="line">            winsB += 1</span><br><span class="line">    return winsA, winsB</span><br><span class="line">def gameOver(a,b):</span><br><span class="line">    return a==15 or b==15</span><br><span class="line">def simOneGame(probA, probB):</span><br><span class="line">    scoreA, scoreB = 0, 0</span><br><span class="line">    serving = &quot;A&quot;</span><br><span class="line">    while not gameOver(scoreA, scoreB):</span><br><span class="line">        if serving == &quot;A&quot;:</span><br><span class="line">            if random() &lt; probA:</span><br><span class="line">                scoreA += 1</span><br><span class="line">            else:</span><br><span class="line">                serving=&quot;B&quot;</span><br><span class="line">        else:</span><br><span class="line">            if random() &lt; probB:</span><br><span class="line">                scoreB += 1</span><br><span class="line">            else:</span><br><span class="line">                serving=&quot;A&quot;</span><br><span class="line">    return scoreA, scoreB</span><br><span class="line">def printSummary(winsA, winsB):</span><br><span class="line">    n = winsA + winsB</span><br><span class="line">    print(&quot;竞技分析开始，共模拟&#123;&#125;场比赛&quot;.format(n))</span><br><span class="line">    print(&quot;选手A获胜&#123;&#125;场比赛，占比&#123;:0.1%&#125;&quot;.format(winsA, winsA/n))</span><br><span class="line">    print(&quot;选手B获胜&#123;&#125;场比赛，占比&#123;:0.1%&#125;&quot;.format(winsB, winsB/n))</span><br><span class="line">def main():</span><br><span class="line">    printIntro()</span><br><span class="line">    probA, probB, n = getInputs()</span><br><span class="line">    winsA, winsB = simNGames(n, probA, probB)</span><br><span class="line">    printSummary(winsA, winsB)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h1 id="Python程序设计思维"><a href="#Python程序设计思维" class="headerlink" title="Python程序设计思维"></a>Python程序设计思维</h1><h2 id="计算思维和程序设计"><a href="#计算思维和程序设计" class="headerlink" title="计算思维和程序设计"></a>计算思维和程序设计</h2><p>计算思维（抽象+自动化）：以设计和构造为特点，计算机为代表，基于计算机强大的算力及海量数据；</p>
<h2 id="计算生态和Python语言"><a href="#计算生态和Python语言" class="headerlink" title="计算生态和Python语言"></a>计算生态和Python语言</h2><p>计算生态以开源项目为组织形式，充分利用“共识原则”和“社会利他”组织人员，在竞争发展、相互依存和迅速更迭中完成信息技术的更新换代，形成了技术的自我演化之路。</p>
<p>Python:以开源项目为代表的大量第三方库；社区庞大，技术更新很快。</p>
<h2 id="用户体验和软件产品"><a href="#用户体验和软件产品" class="headerlink" title="用户体验和软件产品"></a>用户体验和软件产品</h2><p>-用户体验指用户对产品建立的主观感受和认识。</p>
<p>-编程只是手段，不是目的，程序最终为人类服务。</p>
<h2 id="基本的程序设计模式"><a href="#基本的程序设计模式" class="headerlink" title="基本的程序设计模式"></a>基本的程序设计模式</h2><p>IPO、自顶向下设计、模块化设计、配置化设计</p>
<h1 id="Python第三方库安装"><a href="#Python第三方库安装" class="headerlink" title="Python第三方库安装"></a>Python第三方库安装</h1><h2 id="看见更大的Python世界"><a href="#看见更大的Python世界" class="headerlink" title="看见更大的Python世界"></a>看见更大的Python世界</h2><p>Python全球社区: <a href="https://pypi.org" target="_blank" rel="noopener">https://pypi.org</a></p>
<h2 id="第三方库的pip安装方法"><a href="#第三方库的pip安装方法" class="headerlink" title="第三方库的pip安装方法"></a>第三方库的pip安装方法</h2><p>使用pip安装工具： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装</span><br><span class="line">pip install &lt;第三方库名&gt;</span><br><span class="line">#更新</span><br><span class="line">pip install -U &lt;第三方库名&gt;</span><br><span class="line">#卸载</span><br><span class="line">pip uninstall &lt;第三方库名&gt;</span><br><span class="line">#列出目前系统已安装的第三方库</span><br><span class="line">pip list</span><br></pre></td></tr></table></figure>

<h2 id="第三方库的集成安装方法"><a href="#第三方库的集成安装方法" class="headerlink" title="第三方库的集成安装方法"></a>第三方库的集成安装方法</h2><p>Anaconda（主要用于数据分析） : <a href="https://www.continuum.io" target="_blank" rel="noopener">https://www.continuum.io</a></p>
<h2 id="第三方库的文件安装方法"><a href="#第三方库的文件安装方法" class="headerlink" title="第三方库的文件安装方法"></a>第三方库的文件安装方法</h2><p>windows下UCI页面的“补丁”安装方法。</p>
<h1 id="OS库的基本使用"><a href="#OS库的基本使用" class="headerlink" title="OS库的基本使用"></a>OS库的基本使用</h1><p>os库提供了通用的、基本的操作系统交互功能，包括路径操作、进程管理、环境参数等几大功能。</p>
<h2 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h2><p>os.path子库以path为入口，用于操作和处理文件路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os.path</span><br><span class="line">import os.path as op</span><br></pre></td></tr></table></figure>
<p>os.path.abspath(path):返回path在当前系统中的绝对路径；<br>os.path.relpath(path):返回path与当前程序之间的相对路径；<br>os.path.exists(path):判断path对应文件或目录是否存在，返回True或False;<br>…………</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>os.system（command）</p>
<h1 id="实例：第三方库自动安装脚本"><a href="#实例：第三方库自动安装脚本" class="headerlink" title="实例：第三方库自动安装脚本"></a>实例：第三方库自动安装脚本</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#BatchInstall.py</span><br><span class="line">import os</span><br><span class="line">libs = &#123;&quot;numpy&quot;,&quot;matplotlib&quot;,&quot;pillow&quot;,&quot;sklearn&quot;,&quot;requests&quot;,\</span><br><span class="line">        &quot;jieba&quot;,&quot;beautifulsoup4&quot;,&quot;wheel&quot;,&quot;networkx&quot;,&quot;sympy&quot;,\</span><br><span class="line">        &quot;pyinstaller&quot;,&quot;django&quot;,&quot;flask&quot;,&quot;werobot&quot;,&quot;pyqt5&quot;,\</span><br><span class="line">        &quot;pandas&quot;,&quot;pyopengl&quot;,&quot;pypdf2&quot;,&quot;docopt&quot;,&quot;pygame&quot;&#125;</span><br><span class="line">try:</span><br><span class="line">    for lib in libs:</span><br><span class="line">        os.system(&quot;pip3 install &quot;+lib)</span><br><span class="line">    print(&quot;Successful&quot;)        </span><br><span class="line">except:</span><br><span class="line">    print(&quot;Failed Somehow&quot;)</span><br></pre></td></tr></table></figure>


<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_7</title>
    <url>/2019/06/23/2019-06-23-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_7/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h1><h2 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h2><p>-文件是存储在辅助存储器上的数据序列，是数据存储的一种形式。<br>-文件展现形态：文本文件、二进制文件（本质上，所有文件都是以二进制形式存储）</p>
<h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><p>-由单一特定编码组成的文件，如UTF-8编码；<br>-由于存在编码，也被看作是存储着的长字符串；<br>-适用于例如：.txt文件、.py文件；</p>
<h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>-直接由比特0和1组成，没有统一编码；<br>-一般存在二进制0和1的组织结构，即文件格式；<br>-适用于例如：.png文件、.avi文件；</p>
<h2 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h2><p>文件处理步骤：打开-操作-关闭；</p>
<h3 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h3><p>&lt; 变量名 &gt; = open(&lt;文件名&gt;，&lt;打开模式&gt;)</p>
<p>1.”r”:只读模式，默认值，文件不存在返回ERROR；<br>2.”w”:覆盖写模式，文件不存在则创建，存在则完全覆盖；<br>3.”x”:创建写模式，文件不存在则创建，存在则返回ERROR；<br>4.”a”:追加写模式，文件不存在则创建，存在则在文件最后追加内容；<br>5.”b”:以二进制形式打开文件；<br>6.”t”:以文本形式打开文件，默认值；<br>7.”+”:与r/w/x/a一同使用，在原功能基础上增加同时读写功能；</p>
<h3 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h3><p>&lt; 变量名 &gt;.close()</p>
<h2 id="文件内容的读取"><a href="#文件内容的读取" class="headerlink" title="文件内容的读取"></a>文件内容的读取</h2><p>&lt; f &gt;.read(size=-1):读入全部内容，如果给出参数，读入前size长度；<br>&lt; f &gt;.readline(size=-1):读入一行内容，如果给出参数，读入该行前size长度；<br>&lt; f &gt;.readlines(hint=-1):读入文件所有行，以每行为元素形成列表，如果给出参数，读入前hint行；</p>
<h2 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h2><p>&lt; f &gt;.write(s):向文件写入一个字符串或者字节流；<br>&lt; f &gt;.writelines(lines):将一个元素全为字符串的列表写入文件；<br>&lt; f &gt;.seek(offset):改变当前文件操作指针的位置，offse含义如下：0-文件开头，1-当前位置，2-文件结尾；</p>
<h1 id="实例：自动轨迹绘制"><a href="#实例：自动轨迹绘制" class="headerlink" title="实例：自动轨迹绘制"></a>实例：自动轨迹绘制</h1><p>根据脚本来绘制图形，不是写代码而是写数据绘制轨迹。<br>-步骤1：定义数据文件格式（接口）；<br>-步骤2：编写程序，根据文件接口解析参数绘制图形；<br>-步骤3：编制数据文件；</p>
<p><img src="https://i.loli.net/2019/06/23/5d0f97280320c94185.jpg" alt="data.txt"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#AutoTraceDraw.py</span><br><span class="line">import turtle as t</span><br><span class="line">t.title(&apos;自动轨迹绘制&apos;)</span><br><span class="line">t.setup(800, 600, 0, 0)</span><br><span class="line">t.pencolor(&quot;red&quot;)</span><br><span class="line">t.pensize(5)</span><br><span class="line">#数据读取</span><br><span class="line">datals = []</span><br><span class="line">f = open(&quot;data.txt&quot;)</span><br><span class="line">for line in f:</span><br><span class="line">    line = line.replace(&quot;\n&quot;,&quot;&quot;)</span><br><span class="line">    datals.append(list(map(eval, line.split(&quot;,&quot;))))</span><br><span class="line">f.close()</span><br><span class="line">#自动绘制</span><br><span class="line">for i in range(len(datals)):</span><br><span class="line">    t.pencolor(datals[i][3],datals[i][4],datals[i][5])</span><br><span class="line">    t.fd(datals[i][0])</span><br><span class="line">    if datals[i][1]:</span><br><span class="line">        t.rt(datals[i][2])</span><br><span class="line">    else:</span><br><span class="line">        t.lt(datals[i][2])</span><br></pre></td></tr></table></figure>

<h1 id="一维数据的格式化和处理"><a href="#一维数据的格式化和处理" class="headerlink" title="一维数据的格式化和处理"></a>一维数据的格式化和处理</h1><h2 id="数据组织的维度"><a href="#数据组织的维度" class="headerlink" title="数据组织的维度"></a>数据组织的维度</h2><p>一维数据：由对等关系的有序或无序数据组成，采用线性方式组织，对应列表、数组、集合等概念；<br>二维数据：由多个一维数据组成，是一维数据 的组合形式，对应表格等；<br>多维数据、高维数据……</p>
<h2 id="一维数据的表示"><a href="#一维数据的表示" class="headerlink" title="一维数据的表示"></a>一维数据的表示</h2><p>如果数据间有序：使用列表类型；<br>如果数据间无序：使用集合类型；</p>
<h2 id="一维数据的存储"><a href="#一维数据的存储" class="headerlink" title="一维数据的存储"></a>一维数据的存储</h2><p>方式一：空格分隔；<br>方式二：逗号分隔；<br>方式三：其他特殊符号分隔；</p>
<h2 id="一维数据的处理"><a href="#一维数据的处理" class="headerlink" title="一维数据的处理"></a>一维数据的处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从特殊符号分隔的文件中读入数据</span><br><span class="line">#中国$美国$日本$德国$法国</span><br><span class="line">txt = open(fname).read()</span><br><span class="line">ls = txt.split(&quot;$&quot;)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;ls</span><br><span class="line">[&apos;中国&apos;,&apos;美国&apos;,&apos;日本&apos;,&apos;德国&apos;,&apos;法国&apos;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#采用特殊符号分隔将数据写入文件中</span><br><span class="line">ls = [&apos;中国&apos;,&apos;美国&apos;,&apos;日本&apos;,&apos;德国&apos;,&apos;法国&apos;]</span><br><span class="line">f = open(fname,&apos;w&apos;)</span><br><span class="line">f.write(&quot;$&quot;.join(ls))</span><br><span class="line">f.close</span><br><span class="line"></span><br><span class="line">中国$美国$日本$德国$法国</span><br></pre></td></tr></table></figure>

<h1 id="二维数据的格式化和处理"><a href="#二维数据的格式化和处理" class="headerlink" title="二维数据的格式化和处理"></a>二维数据的格式化和处理</h1><h2 id="二维数据的表示"><a href="#二维数据的表示" class="headerlink" title="二维数据的表示"></a>二维数据的表示</h2><p>使用二维列表表示。<br>使用两层for循环遍历每个元素，第一层遍历每个列表，第二层遍历列表中每个元素。</p>
<h2 id="CSV数据存储格式"><a href="#CSV数据存储格式" class="headerlink" title="CSV数据存储格式"></a>CSV数据存储格式</h2><p>CSV:Comma-Separated Values逗号分隔的值</p>
<p><img src="https://i.loli.net/2019/06/24/5d101bea17e7229812.png" alt="CSV数据格式存储"></p>
<h2 id="二维数据的存储"><a href="#二维数据的存储" class="headerlink" title="二维数据的存储"></a>二维数据的存储</h2><p>一般索引习惯：ls[row][column]，先行后列。所以一般按行存储，外层列表每个元素是一行。</p>
<h2 id="二维数据的处理"><a href="#二维数据的处理" class="headerlink" title="二维数据的处理"></a>二维数据的处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从CSV文件中读入数据</span><br><span class="line">fo = open(fname)</span><br><span class="line">ls = []</span><br><span class="line">for line in fo:</span><br><span class="line">	line = line.replace(&quot;\n&quot;,&quot;&quot;)</span><br><span class="line">	ls.append(line.split(&quot;,&quot;))</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从数据写入CSV文件中</span><br><span class="line">ls = [[],[],[]] #二维列表</span><br><span class="line">f = open(fname，&apos;w&apos;)</span><br><span class="line">for item in ls:</span><br><span class="line">	f.write(&apos;,&apos;.join(item)+&apos;\n&apos;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#遍历每一个元素</span><br><span class="line">ls = [[1,2],[3,4],[5,6]]</span><br><span class="line">for row in ls:</span><br><span class="line">	for column in row:</span><br><span class="line">		print(column)</span><br></pre></td></tr></table></figure>

<h1 id="wordcloud库的使用"><a href="#wordcloud库的使用" class="headerlink" title="wordcloud库的使用"></a>wordcloud库的使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>-wordcloud库是优秀的词云展示第三方库;<br>-pip install wordcloud;<br>-wordcloud库把词云当作一个WordCloud对象，wordcloud.WordCloud()代表一个文本对应的词云;</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>w.generate(txt):向WordCloud对象w中加载文件txt;<br>w.to_file(filename):将词云输出为图像文件，.png或.jpg格式;<br>这里介绍一个有意思的参数mask:<br><img src="https://i.loli.net/2019/06/24/5d1022aa9a8d692217.png" alt="参数mask"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>-步骤一：配置对象参数；<br>-步骤二：加载词云文本；<br>-步骤三：输出词云文件；</p>
<h1 id="实例：政府工作报告词云"><a href="#实例：政府工作报告词云" class="headerlink" title="实例：政府工作报告词云"></a>实例：政府工作报告词云</h1><p>资源：<a href="https://python123.io/resources/pye/新时代中国特色社会主义.txt" target="_blank" rel="noopener">https://python123.io/resources/pye/新时代中国特色社会主义.txt</a><br>资源：<a href="https://python123.io/resources/pye/关于实施乡村振兴战略的意见.txt" target="_blank" rel="noopener">https://python123.io/resources/pye/关于实施乡村振兴战略的意见.txt</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#常见矩形词云</span><br><span class="line">   #GovRptWordCloudv1.py</span><br><span class="line">   import jieba</span><br><span class="line">   import wordcloud</span><br><span class="line">   f = open(&quot;新时代中国特色社会主义.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">    </span><br><span class="line">   t = f.read()</span><br><span class="line">   f.close()</span><br><span class="line">   ls = jieba.lcut(t)</span><br><span class="line">    </span><br><span class="line">   txt = &quot; &quot;.join(ls)</span><br><span class="line">   w = wordcloud.WordCloud( \</span><br><span class="line">       width = 1000, height = 700,\</span><br><span class="line">       background_color = &quot;white&quot;,</span><br><span class="line">       font_path = &quot;msyh.ttc&quot;    </span><br><span class="line">       )</span><br><span class="line">   w.generate(txt)</span><br><span class="line">   w.to_file(&quot;grwordcloud.png&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#不规则图形词云</span><br><span class="line">   #GovRptWordCloudv2.py</span><br><span class="line">   import jieba</span><br><span class="line">   import wordcloud</span><br><span class="line">   from scipy.misc import imread</span><br><span class="line">   mask = imread(&quot;chinamap.jpg&quot;)</span><br><span class="line">   excludes = &#123; &#125;</span><br><span class="line">   f = open(&quot;新时代中国特色社会主义.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">   t = f.read()</span><br><span class="line">   f.close()</span><br><span class="line">   ls = jieba.lcut(t)</span><br><span class="line">   txt = &quot; &quot;.join(ls)</span><br><span class="line">   w = wordcloud.WordCloud(\</span><br><span class="line">       width = 1000, height = 700,\</span><br><span class="line">       background_color = &quot;white&quot;,</span><br><span class="line">       font_path = &quot;msyh.ttc&quot;, mask = mask</span><br><span class="line">       )</span><br><span class="line">   w.generate(txt)</span><br><span class="line">   w.to_file(&quot;grwordcloudm.png&quot;)</span><br></pre></td></tr></table></figure>

<p>注意几个问题：<br>1、当使用电脑中不存在的字体时，运行程序会报错OSError: cannot open resourse；<br>2、当不定义参数font_path时，制作中文词云会出现乱码；</p>
<p><img src="https://i.loli.net/2019/06/24/5d10a4b0b15df77889.png" alt="字体乱码"></p>
<p>3、Linux系统在终端运行:fc-list :lang=zh查看电脑系统所带字体；</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云物联网平台</title>
    <url>/2019/06/19/2019-06-19-%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>对于电磁加热系统，从硬件模块调试到入网、数据上传云端再到调用分析，整个工程比较庞大，而且考虑瞬时流量可能比较大，服务器带宽要求较大，价格较高，所以考虑利用阿里云或者百度云的物联网IOT平台，其实基本都差不多，在此记录。<br>本篇基于阿里云官方的阿里云大学教学视频以及IOT平台参考文档。<br>比较详细的一篇<a href="https://www.yuque.com/cloud-dev/iot-tech/gvttbm" target="_blank" rel="noopener">教程</a>可以参考。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/06/21/5d0c50535b70d13308.png" alt="物联网开发体系"></p>
<h1 id="IoT开发步骤"><a href="#IoT开发步骤" class="headerlink" title="IoT开发步骤"></a>IoT开发步骤</h1><p>IoT云端开发（产品创建、设备注册）==&gt; 设备端开发（安装mqtt库、应用程序编码）==&gt; 联机运行（设备上线、数据查看处理）</p>
<h1 id="云端开发"><a href="#云端开发" class="headerlink" title="云端开发"></a>云端开发</h1><p>简单来讲，在阿里云IoT平台操作相对简单，首先创建产品（可选高级版或者基础版），然后定义物模型-属性，然后在产品下注册一个或多个设备。</p>
<h2 id="产品与设备"><a href="#产品与设备" class="headerlink" title="产品与设备"></a>产品与设备</h2><p>产品是设备的集合，指一组具有相同功能的设备。物联网平台为每个产品颁发全局唯一的productKey。设备是归属于某个产品下的具体设备，物联网平台为每个设备颁发产品内唯一的devlceName。</p>
<h1 id="设备基于MQTT协议接入阿里云IOT平台"><a href="#设备基于MQTT协议接入阿里云IOT平台" class="headerlink" title="设备基于MQTT协议接入阿里云IOT平台"></a>设备基于MQTT协议接入阿里云IOT平台</h1><h2 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h2><p>订阅者：某些设备对特定信息感兴趣，并希望订阅它，这些设备叫做订阅者；<br>发布者：负责为其他设备生成数据的叫做发布者；<br>代理：负责将来自发布者的消息进行存储处理，并将这些消息发送到正确的订阅者中去。<br>发布者和订阅者通过Topic来进行信息传输，Topic是相对于设备的概念，设备可以往Topic中发布信息，也可以在Topic中订阅信息。Topic类是相对于产品的概念，产品定义Topic类，其下设备会自动生成对应的Topic。</p>
<h2 id="物模型"><a href="#物模型" class="headerlink" title="物模型"></a>物模型</h2><p>物模型指将物理空间中的实体数字化，并在云端构建该物体的数据模型。在物联网平台，定义物模型即定义功能，完成下述三类功能定义后，将自动生成该产品的物模型。物模型描述产品是什么、能做什么、能对外提供哪些服务。<br><img src="https://i.loli.net/2019/06/21/5d0c57408477030408.png" alt="定义物模型"></p>
<h2 id="连接域名"><a href="#连接域名" class="headerlink" title="连接域名"></a>连接域名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(productKey).iot-as-mqtt.$(regionID).aliyuncs.com:1883</span><br></pre></td></tr></table></figure>
<h2 id="MQTT的Connect报文"><a href="#MQTT的Connect报文" class="headerlink" title="MQTT的Connect报文"></a>MQTT的Connect报文</h2><p>设备端与阿里云IOT平台建立MQTT通道的Connect报文有三个关键参数：客户端标识符（ClientID）、用户名（UserName）、密码（Password），这三个参数由设备三元组（productKey、devlceName、deviceSecret）按照阿里云IOT签名规则生成。</p>
<h2 id="设备端开发"><a href="#设备端开发" class="headerlink" title="设备端开发"></a>设备端开发</h2><p>简单来讲，在利用npm安装好mqtt库之后，需要进行的操作包括修改设备身份三元组、建立连接、上报数据到指定topic、接受云端订阅topic的指令。</p>
<h1 id="数据通过规则引擎流转到OTS"><a href="#数据通过规则引擎流转到OTS" class="headerlink" title="数据通过规则引擎流转到OTS"></a>数据通过规则引擎流转到OTS</h1><p>数据根据Topic的不同有不同的处理方式：自定义Topic直接推到规则引擎；物模型Topic会流转进行物模型解析再推到规则引擎；<br>规则引擎的作用就是将数据转储到自己的数据库、消息队列、实时云计算等中，方便下一步处理。这里以流转到表格存储OTS为例。</p>
<p>阿里云规则引擎的数据处理采用SQL方式,处理之后得到一个规则化的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT contextData,payLoadData FROM TOPIC WHERE FILTER</span><br></pre></td></tr></table></figure>

<h1 id="数据通过规则引擎流转到函数计算FC"><a href="#数据通过规则引擎流转到函数计算FC" class="headerlink" title="数据通过规则引擎流转到函数计算FC"></a>数据通过规则引擎流转到函数计算FC</h1><p>首先在平台选择编程语言，创建函数，然后在规则引擎中添加流转到函数计算FC，选择刚才创建的函数，在函数计算中可以选择将数据通过钉钉、短信等方式推送到运营人员。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>ECS</tag>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云建站初试</title>
    <url>/2019/06/18/2019-06-18-%E9%98%BF%E9%87%8C%E4%BA%91%E5%BB%BA%E7%AB%99%E5%88%9D%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>电磁加热系统前端后端的工作也拖了许久，之前开始了前端网页的尝试，后来考试复习等等也暂停了下来，建站工作更是一拖再拖，现在着手开始一步步工作，在此记录。</p>
<p>需要用到SSH工具<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">putty</a>、FTP文件传输工具<a href="https://www.netsarang.com/zh/xftp/" target="_blank" rel="noopener">xftp</a>，去相应官网下载即可。</p>
</blockquote>
<h1 id="云服务器及域名"><a href="#云服务器及域名" class="headerlink" title="云服务器及域名"></a>云服务器及域名</h1><p>就云服务器来说，AWS一家独大，但在国内而言，还是<a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云</a>的天下。可以自己先买一个服务器搭着试试，在本科时候进行过学生认证但是过期了，导致这次认证时出现失败，所以申请了一个工单，进行人工认证，传学信网-手持身份证-手持学生证照片一系列操作，终于成功，可以享受云翼计划的9.5/月，1核2Git1Mbps带宽对于入门来说已经够了。</p>
<p>关于<a href="https://wanwang.aliyun.com/domain/1yuan?spm=5176.8075371.850118.top1yuan.3b6166d2Lve7Vw" target="_blank" rel="noopener">域名注册</a> ，这里注册了.top，新用户首年只需要1元，你值得拥有。<br>关于域名解析，需要在域名实名认证通过之后再进行解析，解析按照阿里云解析页面右上角“新手引导”，添加记录值，也就是IP即可。</p>
<p>关于备案，阿里云提供<a href="https://beian.aliyun.com/" target="_blank" rel="noopener">代备案</a>，整个过程用时较长。</p>
<h1 id="搭建lnmp集成开发环境"><a href="#搭建lnmp集成开发环境" class="headerlink" title="搭建lnmp集成开发环境"></a>搭建lnmp集成开发环境</h1><p>关于LNMP介绍及下载，在<a href="https://lnmp.org/" target="_blank" rel="noopener">官网</a>比较具体，可以查看。<br>在这里阐述一下具体步骤：</p>
<ol>
<li>粘贴服务器公网IP，用putty进行连接，输入账号密码之后出现Welcome to Alibaba Cloud Elastic Compute Service !字样，说明连接服务器成功；</li>
<li>命令行：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; cd lnmp1.6 &amp;&amp; ./install.sh lnmp</span><br></pre></td></tr></table></figure>
随着版本号更新，命令会有不同。</li>
<li>选择MYSQL版本及设置密码，版本选默认即可；</li>
<li>选择PHP版本，这里选择了最新版；</li>
<li>询问是否需要启用MySQL InnoDB，InnoDB引擎默认为开启，一般建议开启；</li>
<li>选择是否安装内存的三个优化，选择默认不优化即可；</li>
<li>提示”Press any key to install…or Press Ctrl+c to cancel”后，按回车键确认开始安装。LNMP脚本就会自动安装编译Nginx、MySQL、PHP、phpMyAdmin等软件及相关的组件，用时大概半个小时。</li>
<li>如果显示Nginx: OK，MySQL: OK，PHP: OK。并且Nginx、MySQL、PHP都是running，80和3306端口都存在，并提示安装使用的时间及Install lnmp V1.6 completed! enjoy it.的话，说明已经安装成功。<br>某些系统可能会一直卡在Install lnmp V1.5 completed! enjoy it.不自动退出，可以按Ctrl+c退出。</li>
<li>此时浏览器访问公网IP地址，就发现可以成功（安全组打开了80端口）；</li>
<li>在命令行 cd /home/wwwroot会发现有一个default文件夹，上述网页的全部内容都在这个文件夹中；</li>
</ol>
<h1 id="利用宝塔搭建集成开发环境"><a href="#利用宝塔搭建集成开发环境" class="headerlink" title="利用宝塔搭建集成开发环境"></a>利用宝塔搭建集成开发环境</h1><p>除了上述外，还有一种利用宝塔搭建集成开发环境的方法，具体步骤为：</p>
<ol>
<li><p>登陆<a href="http://www.bt.cn/download/linux.html" target="_blank" rel="noopener">官网</a>，可以找到下载linux免费版的脚本，这里服务器为Centos，所以脚本为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器输入公网IP:8888，第一次进入会出现安装LNMP集成环境的提示，按照提示选择配置开始安装即可，安装较快；</p>
</li>
<li><p>安装完成之后进入面板，在“面板设置”菜单修改安全入口、面板用户、面板密码，绑定宝塔官网密码等；</p>
</li>
<li><p>在面板“网站”菜单中，添加站点，即绑定域名并进行管理；</p>
</li>
<li><p>在面板“FTP”、“数据库”菜单中可进行管理；</p>
</li>
<li><p>此刻浏览器输入服务器IP，发现会是宝塔的欢迎界面；</p>
</li>
<li><p>之后再进入，IP:8888/baota，账号密码为之前设定的；</p>
</li>
</ol>
<h1 id="wordpress"><a href="#wordpress" class="headerlink" title="wordpress"></a>wordpress</h1><p>建站初始就用wordpress为例：</p>
<ol>
<li>首先进入<a href="https://cn.wordpress.org/" target="_blank" rel="noopener">中文官网</a>，下载zi安装包，注意最新版可能没有中文解析包，如用中文可下载之前版本；</li>
<li>解压之后将文件夹下全部文件都通过xftp上传到/www/wwwroot目录下已自己域名命名的文件夹下（注意提前删掉index.php）；</li>
<li>此刻浏览器输入服务器IP，按照步骤往下即可，服务器和FTP账号密码即为刚才在宝塔设置的；</li>
<li>登陆进去发现有更新，需要ftp账号密码等，所以需要跳过这步，具体操作为：<br>1）修改wordpress安装目录的权限：chmod -R 777 wordpress；<br>2）在wordpress的根目录下找到wp-config.php文件，在wp-config.php中添加以下代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 更新需要ftp地址的解决方法 */</span><br><span class="line">define(&quot;FS_METHOD&quot;,&quot;direct&quot;);</span><br><span class="line">define(&quot;FS_CHMOD_DIR&quot;, 0777);</span><br><span class="line">define(&quot;FS_CHMOD_FILE&quot;, 0777);</span><br></pre></td></tr></table></figure>
保存文件，并刷新wordpress后台。</li>
<li>以后在浏览器输入域名/wp-admin或者IP/wp-admin即可进入wordpress控制台；</li>
</ol>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>ECS</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_6</title>
    <url>/2019/06/13/2019-06-13-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_6/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="集合类型及操作"><a href="#集合类型及操作" class="headerlink" title="集合类型及操作"></a>集合类型及操作</h1><h2 id="集合类型定义"><a href="#集合类型定义" class="headerlink" title="集合类型定义"></a>集合类型定义</h2><p>-与数学中的集合概念一致，是多个元素的无序组合，每个元素唯一，不存在相同元素。<br>-集合用大括号{}表示，元素间用逗号分隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; A = &#123;&quot;python&quot;, 123, (&quot;python&quot;, 123)&#125;</span><br><span class="line">&gt;&gt;&gt; B = set(&quot;pypy123&quot;)</span><br><span class="line">&#123;&apos;1&apos;, &apos;p&apos;, &apos;2&apos;, &apos;3&apos;, &apos;y&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>-建立集合类型用{}或set()；建立空集合类型必须使用 set()。</p>
<h2 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h2><p>S|T:包含集合S和T中的所有元素；<br>S-T:包含在集合S但不在T中的元素；<br>S&amp;T:包含同时在集合S和T中的元素；<br>S^T:包含集合S和T中的非相同元素；<br>S &lt;= T/S &lt; T:返回True/False，判断S和T的子集关系；<br>S &gt;= T/S &gt; T:返回True/False，判断S和T的包含关系；</p>
<h2 id="集合处理方法"><a href="#集合处理方法" class="headerlink" title="集合处理方法"></a>集合处理方法</h2><p>S.add(x):如果x不在集合S中，将x增加到S<br>S.discard(x)：移除S中元素x，如果x不在集合S中，不报错<br>S.remove(x):同上，如不在，产生keyerror异常<br>S.clear():移除S中所有元素<br>S.pop():随机返回S的一个元素，更新S<br>len(S)：返回集合S的元素个数</p>
<h2 id="集合类型应用场景"><a href="#集合类型应用场景" class="headerlink" title="集合类型应用场景"></a>集合类型应用场景</h2><p>数据去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;ls = [&quot;p&quot;, &quot;p&quot;, &quot;y&quot;, &quot;y&quot;, &quot;&quot;,123]</span><br><span class="line">&gt;&gt;&gt;s = set(ls)</span><br><span class="line">&#123;&apos;p&apos;, &apos;y&apos;, 123&#125;</span><br><span class="line">&gt;&gt;&gt;ls = list(s)</span><br><span class="line">[&apos;p&apos;, &apos;y&apos;, 123]</span><br></pre></td></tr></table></figure>
<h1 id="序列类型及操作"><a href="#序列类型及操作" class="headerlink" title="序列类型及操作"></a>序列类型及操作</h1><h2 id="序列类型定义"><a href="#序列类型定义" class="headerlink" title="序列类型定义"></a>序列类型定义</h2><p>序列是具有先后关系的一组一维元素向量，元素类型可以不同。<br>序列：字符串类型、元组类型、列表类型</p>
<h2 id="序列处理函数及方法"><a href="#序列处理函数及方法" class="headerlink" title="序列处理函数及方法"></a>序列处理函数及方法</h2><p>s+t:连接两个序列s和t；<br>s*n:将序列s复制n次；</p>
<h2 id="元组类型及操作"><a href="#元组类型及操作" class="headerlink" title="元组类型及操作"></a>元组类型及操作</h2><p>元组是序列类型的一种扩展，一旦创建就不能被修改。使用小括号（）或tuple()创建，元素间用逗号分隔。</p>
<h2 id="列表类型及操作"><a href="#列表类型及操作" class="headerlink" title="列表类型及操作"></a>列表类型及操作</h2><p>元组是序列类型的一种扩展，创建后可以被随意修改。使用方括号[]或list()创建，元素间用逗号分隔。注意使用=赋值并不是真正的创建，只是将同一个列表贴了另一个标签。<br>ls[i]=x:替换列表ls的第i个元素为x；<br>ls[i: j :k]=lt:用列表lt替换ls切片后所对应的元素子列表；<br>del ls[i]:删除列表ls中第i个元素；<br>ls+=lt:更新列表ls，将列表lt元素增加到列表ls中；<br>ls.insert(i,x):在列表ls的第i个位置增加元素x;<br>ls.pop(i):在列表ls中第i个位置元素取出并删除；<br>ls.remove(x):将列表ls中出现的第一个元素x删除；<br>ls.reverse():将列表ls中的元素反转；</p>
<h2 id="序列类型应用场景"><a href="#序列类型应用场景" class="headerlink" title="序列类型应用场景"></a>序列类型应用场景</h2><p>数据表示：表示一组有序数据，进而操作它们；<br>数据保护，不希望数据被程序修改，转换为元组类型；</p>
<h1 id="实例：基本统计值计算"><a href="#实例：基本统计值计算" class="headerlink" title="实例：基本统计值计算"></a>实例：基本统计值计算</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalStatisticsV1.py</span><br><span class="line">def getNum():       #获取用户不定长度的输入</span><br><span class="line">    nums = []</span><br><span class="line">    iNumStr = input(&quot;请输入数字(回车退出): &quot;)</span><br><span class="line">    while iNumStr != &quot;&quot;:</span><br><span class="line">        nums.append(eval(iNumStr))</span><br><span class="line">        iNumStr = input(&quot;请输入数字(回车退出): &quot;)</span><br><span class="line">    return nums</span><br><span class="line"> </span><br><span class="line">def mean(numbers):  #计算平均值</span><br><span class="line">    s = 0.0</span><br><span class="line">    for num in numbers:</span><br><span class="line">        s = s + num</span><br><span class="line">    return s / len(numbers)</span><br><span class="line"> </span><br><span class="line">def dev(numbers, mean): #计算方差</span><br><span class="line">    sdev = 0.0</span><br><span class="line">    for num in numbers:</span><br><span class="line">        sdev = sdev + (num - mean)**2</span><br><span class="line">    return pow(sdev / (len(numbers)-1), 0.5)</span><br><span class="line"> </span><br><span class="line">def median(numbers):    #计算中位数</span><br><span class="line">    sorted(numbers)</span><br><span class="line">    size = len(numbers)</span><br><span class="line">    if size % 2 == 0:</span><br><span class="line">        med = (numbers[size//2-1] + numbers[size//2])/2</span><br><span class="line">    else:</span><br><span class="line">        med = numbers[size//2]</span><br><span class="line">    return med</span><br><span class="line"> </span><br><span class="line">n =  getNum() #主体函数</span><br><span class="line">m =  mean(n)</span><br><span class="line">print(&quot;平均值:&#123;&#125;,方差:&#123;:.2&#125;,中位数:&#123;&#125;.&quot;.format(m, dev(n,m),median(n)))</span><br></pre></td></tr></table></figure>
<h1 id="字典类型及操作"><a href="#字典类型及操作" class="headerlink" title="字典类型及操作"></a>字典类型及操作</h1><h2 id="字典类型定义"><a href="#字典类型定义" class="headerlink" title="字典类型定义"></a>字典类型定义</h2><p>字典中的映射是一种键（用户自定义索引）和值（数据）的对应。字典是键值对的集合，键值对之间无序，采用大括号{}或者dict()创建，键值对用冒号：表示。</p>
<h2 id="字典处理函数及方法"><a href="#字典处理函数及方法" class="headerlink" title="字典处理函数及方法"></a>字典处理函数及方法</h2><p>del d[k]:删除字典d中键k对应的数据值；<br>d.keys():返回字典d中所有的键信息；<br>d.values():返回字典d中所有的值信息；<br>d.items():返回字典d中所有的键值对信息；<br>d.get(k,<default>)：键k存在，返回相应值，不存在则返回<default>值；<br>d.pop(k,<default>)：键k存在，取出相应值，不存在则返回<default>值；</p>
<h1 id="jieba库的使用"><a href="#jieba库的使用" class="headerlink" title="jieba库的使用"></a>jieba库的使用</h1><p>-jieba是优秀的中文分词第三方库。<br>-利用一个中文词库，确定汉字之间的关联概率，概率大的组成词组，形成分词结果。</p>
<h2 id="jieba分词三种模式"><a href="#jieba分词三种模式" class="headerlink" title="jieba分词三种模式"></a>jieba分词三种模式</h2><h3 id="精确模式"><a href="#精确模式" class="headerlink" title="精确模式"></a>精确模式</h3><p>把文本精确的切分开，不存在冗余单词。<br>jieba.lcut(s):精确模式，返回一个列表类型的分词结果。</p>
<h3 id="全模式"><a href="#全模式" class="headerlink" title="全模式"></a>全模式</h3><p>把文本中所有可能的词语都扫描出来，有冗余。</p>
<h3 id="搜索引擎模式"><a href="#搜索引擎模式" class="headerlink" title="搜索引擎模式"></a>搜索引擎模式</h3><p>在精确模式基础上，对长词在此切分。</p>
<h1 id="实例：文本字频统计"><a href="#实例：文本字频统计" class="headerlink" title="实例：文本字频统计"></a>实例：文本字频统计</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalHamletV1.py</span><br><span class="line">def getText():</span><br><span class="line">    txt = open(&quot;hamlet.txt&quot;, &quot;r&quot;).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    for ch in &apos;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_‘&#123;|&#125;~&apos;:</span><br><span class="line">        txt = txt.replace(ch, &quot; &quot;)   #将文本中特殊字符替换为空格</span><br><span class="line">    return txt</span><br><span class="line"> </span><br><span class="line">hamletTxt = getText()</span><br><span class="line">words  = hamletTxt.split()</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for word in words:           </span><br><span class="line">    counts[word] = counts.get(word,0) + 1</span><br><span class="line">items = list(counts.items())</span><br><span class="line">items.sort(key=lambda x:x[1], reverse=True) </span><br><span class="line">for i in range(10):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    print (&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word, count))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalThreeKingdomsV1.py</span><br><span class="line">import jieba</span><br><span class="line">txt = open(&quot;threekingdoms.txt&quot;, &quot;r&quot;, encoding=&apos;utf-8&apos;).read()</span><br><span class="line">words  = jieba.lcut(txt)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for word in words:</span><br><span class="line">    if len(word) == 1:</span><br><span class="line">        continue</span><br><span class="line">    else:</span><br><span class="line">        counts[word] = counts.get(word,0) + 1</span><br><span class="line">items = list(counts.items())</span><br><span class="line">items.sort(key=lambda x:x[1], reverse=True) </span><br><span class="line">for i in range(15):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    print (&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word, count))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalThreeKingdomsV2.py</span><br><span class="line">import jieba</span><br><span class="line">excludes = &#123;&quot;将军&quot;,&quot;却说&quot;,&quot;荆州&quot;,&quot;二人&quot;,&quot;不可&quot;,&quot;不能&quot;,&quot;如此&quot;&#125;</span><br><span class="line">txt = open(&quot;threekingdoms.txt&quot;, &quot;r&quot;, encoding=&apos;utf-8&apos;).read()</span><br><span class="line">words  = jieba.lcut(txt)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line">for word in words:</span><br><span class="line">    if len(word) == 1:</span><br><span class="line">        continue</span><br><span class="line">    elif word == &quot;诸葛亮&quot; or word == &quot;孔明曰&quot;:</span><br><span class="line">        rword = &quot;孔明&quot;</span><br><span class="line">    elif word == &quot;关公&quot; or word == &quot;云长&quot;:</span><br><span class="line">        rword = &quot;关羽&quot;</span><br><span class="line">    elif word == &quot;玄德&quot; or word == &quot;玄德曰&quot;:</span><br><span class="line">        rword = &quot;刘备&quot;</span><br><span class="line">    elif word == &quot;孟德&quot; or word == &quot;丞相&quot;:</span><br><span class="line">        rword = &quot;曹操&quot;</span><br><span class="line">    else:</span><br><span class="line">        rword = word</span><br><span class="line">    counts[rword] = counts.get(rword,0) + 1</span><br><span class="line">for word in excludes:</span><br><span class="line">    del counts[word]</span><br><span class="line">items = list(counts.items())</span><br><span class="line">items.sort(key=lambda x:x[1], reverse=True) </span><br><span class="line">for i in range(10):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    print (&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word, count))</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_5</title>
    <url>/2019/06/09/2019-06-09-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_5/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h1><h2 id="函数的理解与定义"><a href="#函数的理解与定义" class="headerlink" title="函数的理解与定义"></a>函数的理解与定义</h2><p>两个作用：<br>-降低编码难度；<br>-代码复用；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def &lt;函数名&gt;(&lt;参数(0个或多个)&gt;):</span><br><span class="line">	&lt;函数体&gt;</span><br><span class="line">	return &lt;返回值&gt;</span><br></pre></td></tr></table></figure>
<h2 id="函数的使用及调用过程"><a href="#函数的使用及调用过程" class="headerlink" title="函数的使用及调用过程"></a>函数的使用及调用过程</h2><p>-调用时要给出实际参数；<br>-实际参数替换定义中的参数；<br>-函数调用后得到返回值；</p>
<h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>-参数可有可无，但必须保留括号；<br>-非可选参数（必选参数）要放在可选参数前边；<br>-函数参数可以为可变数量参数，即不确定参数总数量；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def &lt;函数名&gt;(&lt;参数&gt;，*b):</span><br></pre></td></tr></table></figure>

<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>-return保留字用来传递返回值；<br>-函数可以有返回值，也可以没有，即可以有return，也可以没有；<br>-return可以返回一个，也可以返回多个；</p>
<h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>-函数外部定义的为全局变量，函数内部定义的为局部变量，在函数内部可以使用保留字global定义全局变量。<br>-对于组合数据类型，如列表等，如果局部变量为真实创建，且函数内变量名与全局定义的变量相同，则它就是全局变量（原因：组合数据类型定义的是指针，在函数内部操作的也是指针）；</p>
<h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><p>-lambda函数使用lambda保留字定义，是一种匿名函数，即没有名字的函数，返回函数名作为结果；<br>-用于定义简单的、能够在一行内表示的函数；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;函数名&gt; = lambda&lt;参数&gt;:&lt;表达式&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lambda x,y:x+y</span><br><span class="line">&gt;&gt;&gt; f(10,15)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; f = lambda:&quot;lambda函数&quot;</span><br><span class="line">&gt;&gt;&gt; print(f())</span><br><span class="line">lambda函数</span><br></pre></td></tr></table></figure>

<h1 id="实例：-七段数码管绘制"><a href="#实例：-七段数码管绘制" class="headerlink" title="实例： 七段数码管绘制"></a>实例： 七段数码管绘制</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#SevenDigitsDrawV1.py</span><br><span class="line">import turtle</span><br><span class="line">def drawLine(draw):   #绘制单段数码管</span><br><span class="line">    turtle.pendown() if draw else turtle.penup()</span><br><span class="line">    turtle.fd(40)</span><br><span class="line">    turtle.right(90)</span><br><span class="line">def drawDigit(digit): #根据数字绘制七段数码管</span><br><span class="line">    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if digit in [0,2,6,8] else drawLine(False)</span><br><span class="line">    turtle.left(90)</span><br><span class="line">    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)</span><br><span class="line">    turtle.left(180)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(20) </span><br><span class="line">def drawDate(date):  #获得要输出的数字</span><br><span class="line">    for i in date:</span><br><span class="line">        drawDigit(eval(i))  #通过eval()函数将数字变为整数</span><br><span class="line">def main():</span><br><span class="line">    turtle.setup(800, 350, 200, 200)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(-300)</span><br><span class="line">    turtle.pensize(5)</span><br><span class="line">    drawDate(&apos;20181010&apos;)</span><br><span class="line">    turtle.hideturtle()</span><br><span class="line">    turtle.done()</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#SevenDigitsDrawV2.py</span><br><span class="line">import turtle, time</span><br><span class="line">def drawGap(): #绘制数码管间隔</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(5)</span><br><span class="line">def drawLine(draw):   #绘制单段数码管</span><br><span class="line">    drawGap()</span><br><span class="line">    turtle.pendown() if draw else turtle.penup()</span><br><span class="line">    turtle.fd(40)</span><br><span class="line">    drawGap()</span><br><span class="line">    turtle.right(90)</span><br><span class="line">def drawDigit(d): #根据数字绘制七段数码管</span><br><span class="line">    drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if d in [0,2,6,8] else drawLine(False)</span><br><span class="line">    turtle.left(90)</span><br><span class="line">    drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False)</span><br><span class="line">    drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False)</span><br><span class="line">    turtle.left(180)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(20)</span><br><span class="line">def drawDate(date):</span><br><span class="line">    turtle.pencolor(&quot;red&quot;)</span><br><span class="line">    for i in date:</span><br><span class="line">        if i == &apos;-&apos;:</span><br><span class="line">            turtle.write(&apos;年&apos;,font=(&quot;Arial&quot;, 18, &quot;normal&quot;))</span><br><span class="line">            turtle.pencolor(&quot;green&quot;)</span><br><span class="line">            turtle.fd(40)</span><br><span class="line">        elif i == &apos;=&apos;:</span><br><span class="line">            turtle.write(&apos;月&apos;,font=(&quot;Arial&quot;, 18, &quot;normal&quot;))</span><br><span class="line">            turtle.pencolor(&quot;blue&quot;)</span><br><span class="line">            turtle.fd(40)</span><br><span class="line">        elif i == &apos;+&apos;:</span><br><span class="line">            turtle.write(&apos;日&apos;,font=(&quot;Arial&quot;, 18, &quot;normal&quot;))</span><br><span class="line">        else:</span><br><span class="line">            drawDigit(eval(i))</span><br><span class="line">def main():</span><br><span class="line">    turtle.setup(800, 350, 200, 200)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(-350)</span><br><span class="line">    turtle.pensize(5)</span><br><span class="line">#    drawDate(&apos;2018-10=10+&apos;)</span><br><span class="line">    drawDate(time.strftime(&apos;%Y-%m=%d+&apos;,time.gmtime()))</span><br><span class="line">    turtle.hideturtle()</span><br><span class="line">    turtle.done()</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h1 id="代码复用和函数递归"><a href="#代码复用和函数递归" class="headerlink" title="代码复用和函数递归"></a>代码复用和函数递归</h1><h2 id="代码复用与模块化设计"><a href="#代码复用与模块化设计" class="headerlink" title="代码复用与模块化设计"></a>代码复用与模块化设计</h2><p>-函数和对象是代码复用的两种主要形式。<br>-模块化设计：分而治之。具体包括主程序、子程序和子程序之间的关系。</p>
<h2 id="函数递归的理解"><a href="#函数递归的理解" class="headerlink" title="函数递归的理解"></a>函数递归的理解</h2><p>-函数定义中调用函数自身的形式。</p>
<h2 id="函数递归的调用过程"><a href="#函数递归的调用过程" class="headerlink" title="函数递归的调用过程"></a>函数递归的调用过程</h2><p>函数+分支语句<br>-递归本身是一个函数，需要函数定义方式描述；<br>-函数内部，采用分支语句对输入参数进行判断；<br>-基例和链条，分别编写对应代码；</p>
<h2 id="函数递归实例解析"><a href="#函数递归实例解析" class="headerlink" title="函数递归实例解析"></a>函数递归实例解析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#字符串反转</span><br><span class="line">def rvs(s):</span><br><span class="line">	if s==&quot;&quot;:</span><br><span class="line">		return s</span><br><span class="line">	else:</span><br><span class="line">		return rvs(s[1:]+s[0])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#斐波那契数列</span><br><span class="line">def f(n):</span><br><span class="line">	if n==1 or n==2</span><br><span class="line">		return 1</span><br><span class="line">	else:</span><br><span class="line">		return f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#汉诺塔</span><br><span class="line">count = 0</span><br><span class="line">#n号小圆盘从src到dst,mid作为过渡</span><br><span class="line">def hanoi(n,src,dst,mid):</span><br><span class="line">	global count</span><br><span class="line">	if n==1:</span><br><span class="line">		print(&quot;&#123;&#125;:&#123;&#125;-&gt;&#123;&#125;&quot;.format(1,src,dst))</span><br><span class="line">		countt +=1</span><br><span class="line">	else:</span><br><span class="line">		hanoi(n-1,src,mid,dst)</span><br><span class="line">		print(&quot;&#123;&#125;:&#123;&#125;-&gt;&#123;&#125;&quot;.format(n,src,dst))</span><br><span class="line">		count +=1</span><br><span class="line">		hanoi(n-1,mid,dst,src)</span><br></pre></td></tr></table></figure>
<h1 id="PyInstall库使用"><a href="#PyInstall库使用" class="headerlink" title="PyInstall库使用"></a>PyInstall库使用</h1><h2 id="PyInstall库概述"><a href="#PyInstall库概述" class="headerlink" title="PyInstall库概述"></a>PyInstall库概述</h2><p>将 .py源代码转换成无需源代码的可执行文件，是一个第三方库。</p>
<h2 id="PyInstall库使用-1"><a href="#PyInstall库使用-1" class="headerlink" title="PyInstall库使用"></a>PyInstall库使用</h2><p>在文件目录下进入命令行： pyinstaller -F &lt;文件名.py&gt;</p>
<h1 id="实例：科赫雪花小包裹"><a href="#实例：科赫雪花小包裹" class="headerlink" title="实例：科赫雪花小包裹"></a>实例：科赫雪花小包裹</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#科赫曲线绘制</span><br><span class="line">    #KochDrawV1.py</span><br><span class="line">    import turtle</span><br><span class="line">    def koch(size, n):</span><br><span class="line">        if n == 0:</span><br><span class="line">            turtle.fd(size)</span><br><span class="line">        else:</span><br><span class="line">            for angle in [0, 60, -120, 60]:</span><br><span class="line">               turtle.left(angle)</span><br><span class="line">               koch(size/3, n-1)</span><br><span class="line">    def main():</span><br><span class="line">        turtle.setup(800,400)</span><br><span class="line">        turtle.penup()</span><br><span class="line">        turtle.goto(-300, -50)</span><br><span class="line">        turtle.pendown()</span><br><span class="line">        turtle.pensize(2)</span><br><span class="line">        koch(600,3)     # 0阶科赫曲线长度，阶数</span><br><span class="line">        turtle.hideturtle()</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#科赫雪花绘制</span><br><span class="line">    #KochDrawV2.py</span><br><span class="line">    import turtle</span><br><span class="line">    def koch(size, n):</span><br><span class="line">        if n == 0:</span><br><span class="line">            turtle.fd(size)</span><br><span class="line">        else:</span><br><span class="line">            for angle in [0, 60, -120, 60]:</span><br><span class="line">               turtle.left(angle)</span><br><span class="line">               koch(size/3, n-1)</span><br><span class="line">    def main():</span><br><span class="line">        turtle.setup(600,600)</span><br><span class="line">        turtle.penup()</span><br><span class="line">        turtle.goto(-200, 100)</span><br><span class="line">        turtle.pendown()</span><br><span class="line">        turtle.pensize(2)</span><br><span class="line">        level = 3      # 3阶科赫雪花，阶数</span><br><span class="line">        koch(400,level)     </span><br><span class="line">        turtle.right(120)</span><br><span class="line">        koch(400,level)</span><br><span class="line">        turtle.right(120)</span><br><span class="line">        koch(400,level)</span><br><span class="line">        turtle.hideturtle()</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_4</title>
    <url>/2019/06/06/2019-06-06-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_4/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h1><h2 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h2><p>根据判断条件结果而选择不同向前路径的运行方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &lt;条件&gt;：</span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure>
<h2 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h2><p>根据判断条件结果而选择不同向前路径的运行方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &lt;条件&gt;：</span><br><span class="line">    &lt;语句块1&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;语句块2&gt;</span><br></pre></td></tr></table></figure>
<p>紧凑形式：适用于简单表达式的二分支结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;</span><br></pre></td></tr></table></figure>
<h2 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &lt;条件&gt;：</span><br><span class="line">    &lt;语句块1&gt;</span><br><span class="line">elif:</span><br><span class="line">    &lt;语句块2&gt;</span><br><span class="line">    ……</span><br><span class="line">else:</span><br><span class="line">    &lt;语句块n&gt;</span><br></pre></td></tr></table></figure>
<h2 id="条件判断及组合"><a href="#条件判断及组合" class="headerlink" title="条件判断及组合"></a>条件判断及组合</h2><p>用于条件组合的三个保留字：and、or、not</p>
<h2 id="程序的异常处理"><a href="#程序的异常处理" class="headerlink" title="程序的异常处理"></a>程序的异常处理</h2><p>异常处理的基本使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    &lt;语句块1&gt;</span><br><span class="line">except:</span><br><span class="line">    &lt;语句块2&gt;</span><br></pre></td></tr></table></figure>
<p>高级使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    &lt;语句块1&gt;</span><br><span class="line">except:</span><br><span class="line">    &lt;语句块2&gt;</span><br><span class="line">#不发生异常时执行语句块3</span><br><span class="line">else:</span><br><span class="line">    &lt;语句块3&gt;</span><br><span class="line">#语句块4一定会执行</span><br><span class="line">finally：</span><br><span class="line">    &lt;语句块4&gt;</span><br></pre></td></tr></table></figure>

<h1 id="实例：-身体质量指数BMI"><a href="#实例：-身体质量指数BMI" class="headerlink" title="实例： 身体质量指数BMI#"></a>实例： 身体质量指数BMI#</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalBMIv1.py</span><br><span class="line">height, weight = eval(input(&quot;请输入身高(米)和体重(公斤)[逗号隔开]: &quot;))</span><br><span class="line">bmi = weight / pow(height, 2)</span><br><span class="line">print(&quot;BMI 数值为：&#123;:.2f&#125;&quot;.format(bmi))</span><br><span class="line">who = &quot;&quot;</span><br><span class="line">if bmi &lt; 18.5:</span><br><span class="line">    who = &quot;偏瘦&quot;</span><br><span class="line">elif 18.5 &lt;= bmi &lt; 25:</span><br><span class="line">    who = &quot;正常&quot;</span><br><span class="line">elif 25 &lt;= bmi &lt; 30:</span><br><span class="line">    who = &quot;偏胖&quot;</span><br><span class="line">else:</span><br><span class="line">    who = &quot;肥胖&quot;</span><br><span class="line">print(&quot;BMI 指标为:国际&apos;&#123;0&#125;&apos;&quot;.format(who))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalBMIv2.py</span><br><span class="line">height, weight = eval(input(&quot;请输入身高(米)和体重\(公斤)[逗号隔开]: &quot;))</span><br><span class="line">bmi = weight / pow(height, 2)</span><br><span class="line">print(&quot;BMI 数值为：&#123;:.2f&#125;&quot;.format(bmi))</span><br><span class="line">nat = &quot;&quot;</span><br><span class="line">if bmi &lt; 18.5:</span><br><span class="line">    nat = &quot;偏瘦&quot;</span><br><span class="line">elif 18.5 &lt;= bmi &lt; 24:</span><br><span class="line">    nat = &quot;正常&quot;</span><br><span class="line">elif 24 &lt;= bmi &lt; 28:</span><br><span class="line">    nat = &quot;偏胖&quot;</span><br><span class="line">else:</span><br><span class="line">    nat = &quot;肥胖&quot;</span><br><span class="line">print(&quot;BMI 指标为:国内&apos;&#123;0&#125;&apos;&quot;.format(nat))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalBMIv3.py</span><br><span class="line">height, weight = eval(input(&quot;请输入身高(米)和体重(公斤)[逗号隔开]: &quot;))</span><br><span class="line">bmi = weight / pow(height, 2)</span><br><span class="line">print(&quot;BMI 数值为：&#123;:.2f&#125;&quot;.format(bmi))</span><br><span class="line">who, nat = &quot;&quot;, &quot;&quot;</span><br><span class="line">if bmi &lt; 18.5:</span><br><span class="line">    who, nat = &quot;偏瘦&quot;, &quot;偏瘦&quot;</span><br><span class="line">elif 18.5 &lt;= bmi &lt; 24:</span><br><span class="line">    who, nat = &quot;正常&quot;, &quot;正常&quot;</span><br><span class="line">elif 24 &lt;= bmi &lt; 25:</span><br><span class="line">    who, nat = &quot;正常&quot;, &quot;偏胖&quot;</span><br><span class="line">elif 25 &lt;= bmi &lt; 28:</span><br><span class="line">    who, nat = &quot;偏胖&quot;, &quot;偏胖&quot;</span><br><span class="line">elif 28 &lt;= bmi &lt; 30:</span><br><span class="line">    who, nat = &quot;偏胖&quot;, &quot;肥胖&quot;</span><br><span class="line">else:</span><br><span class="line">    who, nat = &quot;肥胖&quot;, &quot;肥胖&quot;</span><br><span class="line">print(&quot;BMI 指标为:国际&apos;&#123;0&#125;&apos;, 国内&apos;&#123;1&#125;&apos;&quot;.format(who, nat))</span><br></pre></td></tr></table></figure>
<h1 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h1><h2 id="遍历循环"><a href="#遍历循环" class="headerlink" title="遍历循环"></a>遍历循环</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for&lt;循环变量&gt; in &lt;遍历结构&gt;：</span><br><span class="line">	&lt;语句块&gt;</span><br></pre></td></tr></table></figure>
<p>-计数循环<br>-字符串遍历循环<br>-列表遍历循环<br>-文件遍历循环<br>-………………</p>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while &lt;条件&gt;：</span><br><span class="line">	&lt;语句块&gt;</span><br></pre></td></tr></table></figure>
<h2 id="循环控制保留字"><a href="#循环控制保留字" class="headerlink" title="循环控制保留字"></a>循环控制保留字</h2><p>-break:跳出并结束当前（最内层）整个循环，执行循环后的语句；<br>-continue:结束当此循环，继续执行后续次数循环；</p>
<h2 id="循环高级用法"><a href="#循环高级用法" class="headerlink" title="循环高级用法"></a>循环高级用法</h2><p>循环与else搭配，当循环没有被break语句退出时，执行else语句块，可以看作是作为”正常”完成循环的奖励。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for&lt;循环变量&gt; in &lt;遍历结构&gt;：</span><br><span class="line">	&lt;语句块1&gt;</span><br><span class="line">else:</span><br><span class="line">	&lt;语句块2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while &lt;条件&gt;：</span><br><span class="line">	&lt;语句块1&gt;</span><br><span class="line">else:</span><br><span class="line">	&lt;语句块2&gt;</span><br></pre></td></tr></table></figure>

<h1 id="random库使用"><a href="#random库使用" class="headerlink" title="random库使用"></a>random库使用</h1><h2 id="random库概述"><a href="#random库概述" class="headerlink" title="random库概述"></a>random库概述</h2><p>-random库是使用随机数的python标准库。<br>-import random</p>
<h2 id="基本随机函数"><a href="#基本随机函数" class="headerlink" title="基本随机函数"></a>基本随机函数</h2><p>-产生过程：随机数种子–&gt;梅森旋转矩阵–&gt;产生随机序列<br>-seed(a):初始化给定随机数种子，默认为当前系统时间，给定种子后，random产生的随机数确定，之后可以再现；<br>-random():生成一个[0.0,1.0]之间的随机小数；</p>
<h2 id="扩展随机函数"><a href="#扩展随机函数" class="headerlink" title="扩展随机函数"></a>扩展随机函数</h2><p>-random.randint(a,b):生成一个[a,b]之间的整数；<br>-random.randrange(m,n[,k]):生成一个[m,n)之间以k为步长的随机整数；<br>-random.getrandbits(k):生成一个k比特长的随机整数；<br>-random.uniform(a,b):生成一个[a，b]之间的随机小数；<br>-random.choice(seq):从序列seq中随机选择一个元素；<br>-random.shuffle(seq):将序列seq中元素随机排列，返回打乱后的序列；</p>
<h1 id="实例：圆周率的计算"><a href="#实例：圆周率的计算" class="headerlink" title="实例：圆周率的计算"></a>实例：圆周率的计算</h1><h2 id="公式近似方法"><a href="#公式近似方法" class="headerlink" title="公式近似方法"></a>公式近似方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalPiV1.py</span><br><span class="line">pi = 0</span><br><span class="line">N = 100</span><br><span class="line">for k in range(N):</span><br><span class="line">    pi += 1/pow(16,k)*( \</span><br><span class="line">              4/(8*k+1) - 2/(8*k+4) - \</span><br><span class="line">              1/(8*k+5) - 1/(8*k+6) ) </span><br><span class="line">print(&quot;圆周率值是: &#123;&#125;&quot;.format(pi))</span><br></pre></td></tr></table></figure>
<h2 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h2><p>随机给大量散点，会随机出现在区域中的位置，采用比例，用正方形面积可以估算出圆的面积，进而可以得到圆周率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CalPiV2.py</span><br><span class="line">from random import random</span><br><span class="line">from time import perf_counter</span><br><span class="line">DARTS = 1000*1000</span><br><span class="line">hits = 0.0</span><br><span class="line">start = perf_counter()</span><br><span class="line">for i in range(1, DARTS+1):</span><br><span class="line">    x, y = random(), random()</span><br><span class="line">    dist = pow(x ** 2 + y ** 2, 0.5)</span><br><span class="line">    if dist &lt;= 1.0:</span><br><span class="line">        hits = hits + 1</span><br><span class="line">pi = 4 * (hits/DARTS)</span><br><span class="line">print(&quot;圆周率值是: &#123;&#125;&quot;.format(pi))</span><br><span class="line">print(&quot;运行时间是: &#123;:.5f&#125;s&quot;.format(perf_counter() - start))</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_3</title>
    <url>/2019/06/05/2019-06-05-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_3/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="数字类型及操作"><a href="#数字类型及操作" class="headerlink" title="数字类型及操作"></a>数字类型及操作</h1><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>-与数学中整数概念一致，可正可负，没有取值范围限制。<br>-pow(x,y)函数:计算x<sup>y</sup>，想算多大就算多大。<br>-4种进制表示形式：</p>
<ol>
<li>十进制；</li>
<li>二进制，以0b或0B开头；</li>
<li>八进制，以0o或0O开头；</li>
<li>十六进制，以0x或0X开头；</li>
</ol>
<h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>-与数学中实数概念一致，带有小数点及小数的数字。<br>-浮点数间的运算存在不确定尾数，不是bug（原因：计算机二进制表示小数，可以无限接近，但不完全相同）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#浮点数运算及比较用round函数辅助</span><br><span class="line">&gt;&gt;&gt;0.1+0.2 == 0.3</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;round（0.1+0.2，1）== 0.3</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>-使用字母e或E作为幂的符号，以10为基数，格式如下：<br>&lt; a &gt;e&lt; b &gt;表示a*10<sup>b</sup></p>
<h2 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h2><p>-与数学中复数概念一致。<br>-z.real获得实部；z.imag获得虚部。</p>
<h2 id="数值运算操作符"><a href="#数值运算操作符" class="headerlink" title="数值运算操作符"></a>数值运算操作符</h2><p>+、-、<em>、/、 //（整数除） 、%、*</em>（幂运算）<br>-类型间可进行混合运算，生成结果为“最宽”类型，整数–&gt;浮点数–&gt;复数。</p>
<h2 id="数字运算函数"><a href="#数字运算函数" class="headerlink" title="数字运算函数"></a>数字运算函数</h2><p>abs(x)、divmod(x,y)同时输出商和余数、pow(x,y[,z])幂余(x**y)%z、round(x[,d])、max()、min()、int(x)、float（x）</p>
<h1 id="实例：天天向上的力量"><a href="#实例：天天向上的力量" class="headerlink" title="实例：天天向上的力量"></a>实例：天天向上的力量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#DayDayUpQ1.py</span><br><span class="line">dayup = pow(1.001, 365)</span><br><span class="line">daydown = pow(0.999, 365)</span><br><span class="line">print(&quot;向上：&#123;:.2f&#125;，向下：&#123;:.2f&#125;&quot;.format(dayup, daydown))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#DayDayUpQ2.py</span><br><span class="line">dayfactor = 0.005</span><br><span class="line">dayup = pow(1+dayfactor, 365)</span><br><span class="line">daydown = pow(1-dayfactor, 365)</span><br><span class="line">print(&quot;向上：&#123;:.2f&#125;，向下：&#123;:.2f&#125;&quot;.format(dayup, daydown))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#DayDayUpQ3.py</span><br><span class="line">dayup = 1.0</span><br><span class="line">dayfactor = 0.01</span><br><span class="line">for i in range(365):</span><br><span class="line">   if i % 7 in [6,0]:</span><br><span class="line">       dayup = dayup*(1-dayfactor)</span><br><span class="line">   else:</span><br><span class="line">       dayup = dayup*(1+dayfactor)</span><br><span class="line">print(&quot;工作日的力量：&#123;:.2f&#125; &quot;.format(dayup))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#DayDayUpQ4.py</span><br><span class="line">def dayUP(df):</span><br><span class="line">    dayup = 1</span><br><span class="line">    for i in range(365):</span><br><span class="line">       if i % 7 in [6,0]:</span><br><span class="line">           dayup = dayup*(1 - 0.01)</span><br><span class="line">       else:</span><br><span class="line">           dayup = dayup*(1 + df)</span><br><span class="line">    return dayup</span><br><span class="line">dayfactor = 0.01</span><br><span class="line">while dayUP(dayfactor) &lt; 37.78:</span><br><span class="line">    dayfactor += 0.001</span><br><span class="line">print(&quot;工作日的努力参数是：&#123;:.3f&#125; &quot;.format(dayfactor))</span><br></pre></td></tr></table></figure>
<h1 id="字符串类型及操作"><a href="#字符串类型及操作" class="headerlink" title="字符串类型及操作"></a>字符串类型及操作</h1><h2 id="字符串类型的表示"><a href="#字符串类型的表示" class="headerlink" title="字符串类型的表示"></a>字符串类型的表示</h2><p>-由一对单引号或者双引号表示，仅表示单行字符串。<br>-由一对三单引号或三双引号表示，可表示多行字符串。<br>-转义符\，表达特定字符的本意。</p>
<h2 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h2><p>x+y;n*x;x in s</p>
<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><p>len(x)、str(x)、hen(x)或oct(x)转换为十六进制和八进制、chr(u)u为Unicode编码、ord(x)与前一相反</p>
<h2 id="字符串处理方法"><a href="#字符串处理方法" class="headerlink" title="字符串处理方法"></a>字符串处理方法</h2><p>“方法”特指&lt; a &gt;.&lt; b &gt;()风格中的函数&lt; b &gt;()，方法本身也是函数，但与&lt; a &gt;有关。<br>-str.lower()或str.upper()：字符串字符全部大写或者小写；<br>-str.split()：返回一个列表，由str根据sep被分割的部分组成；<br>-str.count(sub)：sub在str中出现的次数；<br>-str.replace(old,new)：所有old子串被替换为new；<br>-str.center(width[，fillchar]):字符串str根据宽度width居中，fillchar可选；<br>-str.strip(chars):从str中去掉在其左侧和右侧chars中列出的字符；<br>-str.join(iter):在iter变量除最后元素外每个元素后增加一个str “,”；</p>
<h2 id="字符串类型的格式化"><a href="#字符串类型的格式化" class="headerlink" title="字符串类型的格式化"></a>字符串类型的格式化</h2><p>-字符串格式化使用.format()方法，用法为：&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)<br>-模板字符串中只用槽{}来占位，与后边format()中参数的顺序一一对应。<br>-槽内部对格式化的配置方式：{&lt;参数序号&gt;：&lt;格式控制标记&gt;}</p>
<p>：| &lt;填充&gt; | &lt;对齐&gt; | &lt;宽度&gt; | &lt;，&gt; |&lt;.精度&gt; | &lt;类型&gt;<br>-|-|-<br>引导符号 | 用于填充的单个字符 | &lt;左对齐 &gt;右对齐 ^居中对齐 | 槽设定的输出宽度 | 数字的千位分隔符 | 浮点数小数精度 或 字符串最大输出长度 | 整数类型 b、c、d、o、x、X 浮点数类型e、E、f、%</p>
<h1 id="模块2：time库的使用"><a href="#模块2：time库的使用" class="headerlink" title="模块2：time库的使用"></a>模块2：time库的使用</h1><h2 id="time库基本情况"><a href="#time库基本情况" class="headerlink" title="time库基本情况"></a>time库基本情况</h2><p>-python中处理时间的标准库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">time.&lt;b&gt;()</span><br></pre></td></tr></table></figure>
<p>-time库包含三类函数：</p>
<ol>
<li>时间获取：time()、ctime()、gmtime()</li>
<li>时间格式化：strtime()、strptime()</li>
<li>程序计时：sleep()、perf_counter()</li>
</ol>
<h2 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h2><p>-time()：获取当前时间戳，及计算机内部时间值，浮点数；<br>-ctime()：获取当前时间并以易读方式表示，字符串；<br>-gmtime():获取当前时间，表示为计算机可处理的时间格式；</p>
<h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>将时间以合理的方式展示出来。<br>-strtime(tpl,ts):tpl是格式化模板字符串，用来定义输出效果；ts是计算机内部时间类型变量；<br>-strptime(str,tpl):与上互补，将时间字符串处理成计算机内部可操作的；</p>
<h2 id="程序计时应用"><a href="#程序计时应用" class="headerlink" title="程序计时应用"></a>程序计时应用</h2><p>-sleep(s):s是休眠时间，单位为秒，可以是浮点数；<br>-perf_counter():返回一个CPU级别的精确时间计数值，单位为秒，由于这个计数值起点不确定，连续调用计算差值才有意义；</p>
<h1 id="实例：文本进度条"><a href="#实例：文本进度条" class="headerlink" title="实例：文本进度条"></a>实例：文本进度条</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#TextProBarV1.py简单的开始</span><br><span class="line">import time</span><br><span class="line">scale = 10</span><br><span class="line">print(&quot;------执行开始------&quot;)</span><br><span class="line">for i in range(scale+1):</span><br><span class="line">    a = &apos;*&apos; * i</span><br><span class="line">    b = &apos;.&apos; * (scale - i)</span><br><span class="line">    c = (i/scale)*100</span><br><span class="line">    print(&quot;&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c,a,b))</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">print(&quot;------执行结束------&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#TextProBarV2.py单行动态刷新</span><br><span class="line">import time</span><br><span class="line">for i in range(101):</span><br><span class="line">    print(&quot;\r&#123;:3&#125;%&quot;.format(i), end=&quot;&quot;)</span><br><span class="line">    time.sleep(0.1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#TextProBarV3.py完整实例</span><br><span class="line">import time</span><br><span class="line">scale = 50</span><br><span class="line">print(&quot;执行开始&quot;.center(scale//2, &quot;-&quot;))</span><br><span class="line">start = time.perf_counter()</span><br><span class="line">for i in range(scale+1):</span><br><span class="line">    a = &apos;*&apos; * i</span><br><span class="line">    b = &apos;.&apos; * (scale - i)</span><br><span class="line">    c = (i/scale)*100</span><br><span class="line">    dur = time.perf_counter() - start</span><br><span class="line">    print(&quot;\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c,a,b,dur),end=&apos;&apos;)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">print(&quot;\n&quot;+&quot;执行结束&quot;.center(scale//2,&apos;-&apos;))</span><br></pre></td></tr></table></figure>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析与展示_3</title>
    <url>/2019/05/16/2019-05-16-Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA_3/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-1001870002?tid=1206192225#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="单元7：Pandas库入门"><a href="#单元7：Pandas库入门" class="headerlink" title="单元7：Pandas库入门"></a>单元7：Pandas库入门</h1><p>Pandas是提供高性能易用数据类型和分析工具的第三方python库，可以说是基于Numpy库。<br>import pandas as pd<br>Pandas提供两个数据类型：Series(一维)、DataFrame(二维及多维)，基于这两种数据类型，可以进行基本操作、运算操作、特征类操作、关联类操作等。</p>
<h2 id="Series数据类型"><a href="#Series数据类型" class="headerlink" title="Series数据类型"></a>Series数据类型</h2><p>Series类型由一组数据及与之相关的数据索引组成，索引与数据一一对应，索引可以自定义。</p>
<h3 id="Series类型的创建"><a href="#Series类型的创建" class="headerlink" title="Series类型的创建"></a>Series类型的创建</h3><ol>
<li>从Python列表创建，index与列表元素个数一致；</li>
<li>从标量值创建，此时不能省略index；</li>
<li>从字典类型创建，将字典直接赋给series；</li>
<li>从adarray类型创建；</li>
</ol>
<h3 id="Series类型的基本操作"><a href="#Series类型的基本操作" class="headerlink" title="Series类型的基本操作"></a>Series类型的基本操作</h3><p>由index和values两部分构成，操作类似于ndarray类型，也类似于Python字典类型。需要注意的是，numpy是基于维度的运算，而series是基于索引的运算。</p>
<h2 id="DataFrame数据类型"><a href="#DataFrame数据类型" class="headerlink" title="DataFrame数据类型"></a>DataFrame数据类型</h2><p>DataFrame类型是由共同相同索引的一组列组成。其实是一个表格型的数据类型，每列值类型可以不同。其中既有行索引（index,axis=0），也有列索引(column,axis=1)。常用来表达二维数据。</p>
<h3 id="DataFrame类型的创建"><a href="#DataFrame类型的创建" class="headerlink" title="DataFrame类型的创建"></a>DataFrame类型的创建</h3><ol>
<li>从二维ndarray创建；</li>
<li>从一维ndarray对象字典创建；</li>
<li>从列表类型的字典创建；</li>
</ol>
<h2 id="Pandas库数据类型操作"><a href="#Pandas库数据类型操作" class="headerlink" title="Pandas库数据类型操作"></a>Pandas库数据类型操作</h2><h3 id="改变Series和DataFrame对象"><a href="#改变Series和DataFrame对象" class="headerlink" title="改变Series和DataFrame对象"></a>改变Series和DataFrame对象</h3><p>增加或者重排：重新索引，通过.reindex()函数实现<br>删除：.drop()</p>
<h2 id="Pandas库数据类型运算"><a href="#Pandas库数据类型运算" class="headerlink" title="Pandas库数据类型运算"></a>Pandas库数据类型运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>算术运算根据行列索引，补齐后运算，补齐时缺项填充NaN(空值)，运算默认产生浮点数，采用+-*/符号进行运算的二元运算将会产生新的对象，还可以使用方法形式进行运算，如.add()、.sub()、.mul()、.div()，这些均可以选择参数。<br>不同维度间的运算采用广播运算，默认在1轴。</p>
<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p>比较运算只能比较相同索引的元素，不进行补齐，采用&gt;&lt;&gt;=&lt;=!=等符号进行运算的二元运算将会产生布尔对象。<br>不同维度间的运算采用广播运算，默认在1轴。</p>
<h1 id="单元8：Pandas数据特征分析"><a href="#单元8：Pandas数据特征分析" class="headerlink" title="单元8：Pandas数据特征分析"></a>单元8：Pandas数据特征分析</h1><h2 id="数据的排序"><a href="#数据的排序" class="headerlink" title="数据的排序"></a>数据的排序</h2><p>.sort_index(axis=0,ascending=True)方法在指定轴上根据<strong>索引</strong>进行排序，默认升序。<br>.sort_values(axis=0,ascending=True)方法在指定轴上根据<strong>数值</strong>进行排序，默认升序。</p>
<h2 id="数据的基本统计分析"><a href="#数据的基本统计分析" class="headerlink" title="数据的基本统计分析"></a>数据的基本统计分析</h2><p>基本同numpy相同。<br>.describe()方法可以针对0轴（各列）做统计汇总，包括非空计数、均值、方差等。</p>
<h2 id="数据的累计统计分析"><a href="#数据的累计统计分析" class="headerlink" title="数据的累计统计分析"></a>数据的累计统计分析</h2><p>.cumsum()、.cumprod()、.cummax()、.cummin()，分别为依次给出前1、2、……、n个数的和、积、最大值、最小值。</p>
<p>滚动计算（窗口计算）：<br>.rolling(w).sum()、.rolling(w).mean()、.rolling(w).var()、.rolling(w).std()、.rolling(w).min()、.rolling(w).max(),分别为依次给出x相邻w个元素的和、平均值、方差、标准差、最大值、最小值。</p>
<h2 id="数据的相关分析"><a href="#数据的相关分析" class="headerlink" title="数据的相关分析"></a>数据的相关分析</h2><p>.cov()，计算协方差矩阵；<br>.corr()，计算相关系数矩阵，Pearson、Spearman、Kendall等系数；</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
        <tag>数据分析与展示</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_1</title>
    <url>/2019/05/16/2019-05-16-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_1/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="编译与解释"><a href="#编译与解释" class="headerlink" title="编译与解释"></a>编译与解释</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>将源代码一次性转换为目标代码的过程。类似英文翻译。<br><img src="https://i.loli.net/2019/05/17/5cde554bd813521498.png" alt="编译"></p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>将源代码逐条转换为目标代码同时逐条运行的过程。类似实时同声传译。<br><img src="https://i.loli.net/2019/05/17/5cde55678fc4c61789.png" alt="解释"></p>
<h1 id="静态语言和脚本语言"><a href="#静态语言和脚本语言" class="headerlink" title="静态语言和脚本语言"></a>静态语言和脚本语言</h1><h2 id="静态语言"><a href="#静态语言" class="headerlink" title="静态语言"></a>静态语言</h2><p>使用编译执行的编程语言，运行速度更快。C/C++/Java等。</p>
<h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><p>使用解释执行的编程语言，维护更方便。Python/JavaScript/Php等。</p>
<h1 id="温度转换实例"><a href="#温度转换实例" class="headerlink" title="温度转换实例"></a>温度转换实例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#TempConvert.py</span><br><span class="line">TempStr = input(&quot;请输入带有符号的温度值: &quot;)</span><br><span class="line">if TempStr[-1] in [&apos;F&apos;, &apos;f&apos;]:</span><br><span class="line">    C = (eval(TempStr[0:-1]) - 32)/1.8</span><br><span class="line">    print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))</span><br><span class="line">elif TempStr[-1] in [&apos;C&apos;, &apos;c&apos;]:</span><br><span class="line">    F = 1.8*eval(TempStr[0:-1]) + 32</span><br><span class="line">    print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))</span><br><span class="line">else:</span><br><span class="line">    print(&quot;输入格式错误&quot;)</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言程序设计_2</title>
    <url>/2019/05/16/2019-05-16-Python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_2/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-268001?tid=1206073223#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="turtle库"><a href="#turtle库" class="headerlink" title="turtle库"></a>turtle库</h1><p>turtle（海龟）是turtle绘图体系的Python实现，是Python的标准库之一，使用RGB色彩模式。</p>
<h2 id="空间坐标系"><a href="#空间坐标系" class="headerlink" title="空间坐标系"></a>空间坐标系</h2><p>画布上以中心为原点的空间坐标系：绝对坐标&amp;海龟坐标。</p>
<h2 id="角度坐标系"><a href="#角度坐标系" class="headerlink" title="角度坐标系"></a>角度坐标系</h2><p>画布上以空间x轴为0度的角度坐标系：绝对角度&amp;海龟角度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#PythonDraw.py，绘制“蟒蛇”</span><br><span class="line">import turtle</span><br><span class="line">turtle.setup(650, 350, 200, 200)</span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.fd(-250)</span><br><span class="line">turtle.pendown()</span><br><span class="line">turtle.pensize(25)</span><br><span class="line">turtle.pencolor(&quot;purple&quot;)</span><br><span class="line">turtle.seth(-40)</span><br><span class="line">for i in range(4):</span><br><span class="line">    turtle.circle(40, 80)</span><br><span class="line">    turtle.circle(-40, 80)</span><br><span class="line">turtle.circle(40, 80/2)</span><br><span class="line">turtle.fd(40)</span><br><span class="line">turtle.circle(16, 180)</span><br><span class="line">turtle.fd(40 * 2/3)</span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<h1 id="库引用"><a href="#库引用" class="headerlink" title="库引用"></a>库引用</h1><p>扩充Python程序功能的方式。</p>
<ol>
<li>使用import保留字完成</li>
</ol>
<pre><code>import &lt;库名&gt;
&lt;库名&gt;.&lt;函数名&gt;（&lt;函数参数&gt;）</code></pre><ol start="2">
<li>使用from和import保留字完成</li>
</ol>
<pre><code>from &lt;库名&gt; import &lt;函数名&gt;
from &lt;库名&gt; import *
&lt;函数名&gt;（&lt;函数参数&gt;）</code></pre><ol start="3">
<li>使用as和import保留字完成</li>
</ol>
<pre><code>import &lt;库名&gt; as &lt;库别名&gt;
&lt;库别名&gt;.&lt;函数名&gt;（&lt;函数参数&gt;）</code></pre><p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析与展示_2</title>
    <url>/2019/05/15/2019-05-15-Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA_2/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-1001870002?tid=1206192225#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="单元4：matplotlib库入门"><a href="#单元4：matplotlib库入门" class="headerlink" title="单元4：matplotlib库入门"></a>单元4：matplotlib库入门</h1><p>matplotlib是python优秀的数据可视化第三方库，想法源于matlab(所以个人感觉用法也很像)。<br>matplotlib.pyplot是绘制各类可视化图像的命令子库，相当于快捷方式。import matplotlib.pyplot as plt。</p>
<h2 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a>plot函数</h2><p>plt.plot(x,y,format_string,**kwargs)<br>x:X轴数据，列表或数组，可选。<br>y:Y轴数据，列表或数组.<br>format_string:控制曲线的格式化字符串，可选，由颜色字符color、风格字符linestyle、标记字符marker组成。</p>
<p>**kwargs：第二组或者多组(x,y,format_string）</p>
<h2 id="pyplot的中文显示"><a href="#pyplot的中文显示" class="headerlink" title="pyplot的中文显示"></a>pyplot的中文显示</h2><p>pyplot默认并不支持中文显示，</p>
<ol>
<li>改变全局字体，需要rcParams修改字体实现。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">matplotlib.rcParams[&apos;font.family&apos;]=&apos;SimHei&apos;</span><br><span class="line">matplotlib.rcParams[&apos;font.size&apos;]=20</span><br><span class="line">plt.xlabel(&apos;横轴：时间&apos;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>font.family:字体名称；<br>font.style:字体风格，斜体’italie’;<br>font.size:字体大小，整数字号或者’large’、’x-small’;</p>
<ol start="2">
<li>改变局部字体，在有中文输出的地方，增加一个属性：fontproperties<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.xlabel(&apos;横轴：时间&apos;，fontproperties=&apos;SimHei&apos;,fontsize=20)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="pyplot的文本显示"><a href="#pyplot的文本显示" class="headerlink" title="pyplot的文本显示"></a>pyplot的文本显示</h2><p>plt.xlable/plt.ylable/plt.title/plt.text/plt.annotate(在图形中增加戴箭头的注释)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.annotate(s,xy=arrow_crd,xytext=text_crd,arrowprops=dict)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/05/15/5cdb7cc11ecc069534.png" alt="annotate"></p>
<h2 id="pyplot的子绘图区域"><a href="#pyplot的子绘图区域" class="headerlink" title="pyplot的子绘图区域"></a>pyplot的子绘图区域</h2><p><img src="https://i.loli.net/2019/05/15/5cdb8182cc74b24680.png" alt="subplot2gird"></p>
<p><img src="https://i.loli.net/2019/05/15/5cdb81c122aee50154.png" alt="girdspec"></p>
<h1 id="单元5：matplotlib库基础绘图函数示例"><a href="#单元5：matplotlib库基础绘图函数示例" class="headerlink" title="单元5：matplotlib库基础绘图函数示例"></a>单元5：matplotlib库基础绘图函数示例</h1><h2 id="pyplot饼图的绘制"><a href="#pyplot饼图的绘制" class="headerlink" title="pyplot饼图的绘制"></a>pyplot饼图的绘制</h2><p>函数：plt.pie<br><img src="https://i.loli.net/2019/05/15/5cdbc2efb6e9181159.png" alt="饼图"></p>
<h2 id="pyplot直方图的绘制"><a href="#pyplot直方图的绘制" class="headerlink" title="pyplot直方图的绘制"></a>pyplot直方图的绘制</h2><p>函数：plt.hist<br><img src="https://i.loli.net/2019/05/15/5cdbc63b4486b28677.png" alt="直方图"></p>
<h2 id="pyplot极坐标图的绘制"><a href="#pyplot极坐标图的绘制" class="headerlink" title="pyplot极坐标图的绘制"></a>pyplot极坐标图的绘制</h2><p><img src="https://i.loli.net/2019/05/15/5cdbc69b4bc6355879.png" alt="极坐标图"></p>
<h2 id="pyplot散点图的绘制"><a href="#pyplot散点图的绘制" class="headerlink" title="pyplot散点图的绘制"></a>pyplot散点图的绘制</h2><p><img src="https://i.loli.net/2019/05/15/5cdbc6e79836f32001.png" alt="散点图"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
        <tag>数据分析与展示</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_10</title>
    <url>/2019/05/14/2019-05-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h1><p>查找对象时，静态查找可以用二分查找，动态查找可以建树，但是比对的过程是数的话可以，如果是字符串的话就比较费时，那么能否把字符串映射为数字呢？这就是散列表。</p>
<p>查找的本质：已知对象找位置。</p>
<ul>
<li>有序安排对象：全序、半序；</li>
<li>直接”算出”对象位置：散列；</li>
</ul>
<p>散列查找的两项基本工作：</p>
<ul>
<li>计算位置：构造散列函数确定关键词存储位置；</li>
<li>解决冲突：应用某种策略解决多个关键字位置相同的问题；</li>
</ul>
<p>“散列（Hashing）”的基本思想：<br>1）以关键字key为自变量，通过一个确定的函数h计算出对应的函数值h(key)，作为数据对象的存储地址。<br>2）可能不同的关键字会映射到同一个散列地址上，称为”冲突”，需要冲突解决策略。</p>
<h1 id="散列函数构造方法"><a href="#散列函数构造方法" class="headerlink" title="散列函数构造方法"></a>散列函数构造方法</h1><p>考虑因素：</p>
<ol>
<li>计算简单，以便提高转换效率</li>
<li>关键字对应的地址空间分布均匀，以尽量减少冲突</li>
</ol>
<h2 id="数字关键字"><a href="#数字关键字" class="headerlink" title="数字关键字"></a>数字关键字</h2><ol>
<li>直接定制法</li>
<li>除留余数法</li>
<li>数字分析法</li>
<li>折叠法</li>
<li>平方取中法</li>
</ol>
<h2 id="字符关键字"><a href="#字符关键字" class="headerlink" title="字符关键字"></a>字符关键字</h2><ol>
<li>简单方法-ASCII码加和法</li>
<li>简单改进法-前三个字符移位法</li>
<li>好的方法-全部字符移位法</li>
</ol>
<h1 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h1><p>常见思路：</p>
<ul>
<li>换个位置：开放地址法</li>
<li>同一位置的冲突对象组织在一起：链地址法</li>
</ul>
<h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><ol>
<li>线性探测法</li>
<li>平方探测法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAXTABLESIZE 100000 /* 允许开辟的最大散列表长度 */</span><br><span class="line">typedef int ElementType;    /* 关键词类型用整型 */</span><br><span class="line">typedef int Index;          /* 散列地址类型 */</span><br><span class="line">typedef Index Position;     /* 数据所在位置与散列地址是同一类型 */</span><br><span class="line">/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */</span><br><span class="line">typedef enum &#123; Legitimate, Empty, Deleted &#125; EntryType;</span><br><span class="line"> </span><br><span class="line">typedef struct HashEntry Cell; /* 散列表单元类型 */</span><br><span class="line">struct HashEntry&#123;</span><br><span class="line">    ElementType Data; /* 存放元素 */</span><br><span class="line">    EntryType Info;   /* 单元状态 */</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">typedef struct TblNode *HashTable; /* 散列表类型 */</span><br><span class="line">struct TblNode &#123;   /* 散列表结点定义 */</span><br><span class="line">    int TableSize; /* 表的最大长度 */</span><br><span class="line">    Cell *Cells;   /* 存放散列单元数据的数组 */</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int NextPrime( int N )</span><br><span class="line">&#123; /* 返回大于N且不超过MAXTABLESIZE的最小素数 */</span><br><span class="line">    int i, p = (N%2)? N+2 : N+1; /*从大于N的下一个奇数开始 */</span><br><span class="line"> </span><br><span class="line">    while( p &lt;= MAXTABLESIZE ) &#123;</span><br><span class="line">        for( i=(int)sqrt(p); i&gt;2; i-- )</span><br><span class="line">            if ( !(p%i) ) break; /* p不是素数 */</span><br><span class="line">        if ( i==2 ) break; /* for正常结束，说明p是素数 */</span><br><span class="line">        else  p += 2; /* 否则试探下一个奇数 */</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">HashTable CreateTable( int TableSize )</span><br><span class="line">&#123;</span><br><span class="line">    HashTable H;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    H = (HashTable)malloc(sizeof(struct TblNode));</span><br><span class="line">    /* 保证散列表最大长度是素数 */</span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">    /* 声明单元数组 */</span><br><span class="line">    H-&gt;Cells = (Cell *)malloc(H-&gt;TableSize*sizeof(Cell));</span><br><span class="line">    /* 初始化单元状态为“空单元” */</span><br><span class="line">    for( i=0; i&lt;H-&gt;TableSize; i++ )</span><br><span class="line">        H-&gt;Cells[i].Info = Empty;</span><br><span class="line"> </span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Position Find( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position CurrentPos, NewPos;</span><br><span class="line">    int CNum = 0; /* 记录冲突次数 */</span><br><span class="line"> </span><br><span class="line">    NewPos = CurrentPos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */</span><br><span class="line">    /* 当该位置的单元非空，并且不是要找的元素时，发生冲突 */</span><br><span class="line">    while( H-&gt;Cells[NewPos].Info!=Empty &amp;&amp; H-&gt;Cells[NewPos].Data!=Key ) &#123;</span><br><span class="line">                                           /* 字符串类型的关键词需要 strcmp 函数!! */</span><br><span class="line">        /* 统计1次冲突，并判断奇偶次 */</span><br><span class="line">        if( ++CNum%2 )&#123; /* 奇数次冲突 */</span><br><span class="line">            NewPos = CurrentPos + (CNum+1)*(CNum+1)/4; /* 增量为+[(CNum+1)/2]^2 */</span><br><span class="line">            if ( NewPos &gt;= H-&gt;TableSize )</span><br><span class="line">                NewPos = NewPos % H-&gt;TableSize; /* 调整为合法地址 */</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; /* 偶数次冲突 */</span><br><span class="line">            NewPos = CurrentPos - CNum*CNum/4; /* 增量为-(CNum/2)^2 */</span><br><span class="line">            while( NewPos &lt; 0 )</span><br><span class="line">                NewPos += H-&gt;TableSize; /* 调整为合法地址 */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NewPos; /* 此时NewPos或者是Key的位置，或者是一个空单元的位置（表示找不到）*/</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool Insert( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position Pos = Find( H, Key ); /* 先检查Key是否已经存在 */</span><br><span class="line"> </span><br><span class="line">    if( H-&gt;Cells[Pos].Info != Legitimate ) &#123; /* 如果这个单元没有被占，说明Key可以插入在此 */</span><br><span class="line">        H-&gt;Cells[Pos].Info = Legitimate;</span><br><span class="line">        H-&gt;Cells[Pos].Data = Key;</span><br><span class="line">        /*字符串类型的关键词需要 strcpy 函数!! */</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;键值已存在&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>双散列探测法</li>
<li>再散列</li>
</ol>
<h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>将相同位置上冲突的所有关键词存储在同一个单链表中。</p>
<h1 id="散列表性能分析"><a href="#散列表性能分析" class="headerlink" title="散列表性能分析"></a>散列表性能分析</h1><p>指标：平均查找长度（ASL）用来衡量散列表的查找效率：成功、不成功<br>关键词的比较次数，取决于产生冲突的多少，影响产生冲突多少有以下三个因素：</p>
<ol>
<li>散列函数是否均匀</li>
<li>处理冲突的方法</li>
<li>散列表的装填因子α，应在0.5-0.85之间</li>
</ol>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_9</title>
    <url>/2019/05/13/2019-05-13-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。<br>这里只讨论内部排序，即默认内存空间足够大，可以存放下所有需要排序的数据。</p>
</blockquote>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>策略：分而治之<br>步骤：从待排数组中找一个主元pivot，按照比主元大和比主元小将数组分为两个数集再分别递归调用，进行排序。<br>最好情况：每次选的主元都正好是中分，T(N)=O(N logN)<br>选主元：方法很多，例如取头中尾三个数的中位数等<br>适用情况：大规模数据，如果是小规模数据，使用递归可能更费时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 快速排序 - 直接调用库函数 */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">/*---------------简单整数排序--------------------*/</span><br><span class="line">int compare(const void *a, const void *b)</span><br><span class="line">&#123; /* 比较两整数。非降序排列 */</span><br><span class="line">    return (*(int*)a - *(int*)b);</span><br><span class="line">&#125;</span><br><span class="line">/* 调用接口 */ </span><br><span class="line">qsort(A, N, sizeof(int), compare);</span><br><span class="line">/*---------------简单整数排序--------------------*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*/</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key1, key2;</span><br><span class="line">&#125; A[MAXN];</span><br><span class="line">  </span><br><span class="line">int compare2keys(const void *a, const void *b)</span><br><span class="line">&#123; /* 比较两种键值：按key1非升序排列；如果key1相等，则按key2非降序排列 */</span><br><span class="line">    int k;</span><br><span class="line">    if ( ((const struct Node*)a)-&gt;key1 &lt; ((const struct Node*)b)-&gt;key1 )</span><br><span class="line">        k = 1;</span><br><span class="line">    else if ( ((const struct Node*)a)-&gt;key1 &gt; ((const struct Node*)b)-&gt;key1 )</span><br><span class="line">        k = -1;</span><br><span class="line">    else &#123; /* 如果key1相等 */</span><br><span class="line">        if ( ((const struct Node*)a)-&gt;key2 &lt; ((const struct Node*)b)-&gt;key2 )</span><br><span class="line">            k = -1;</span><br><span class="line">        else</span><br><span class="line">            k = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">/* 调用接口 */ </span><br><span class="line">qsort(A, N, sizeof(struct Node), compare2keys);</span><br><span class="line">/*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 快速排序 */</span><br><span class="line"> </span><br><span class="line">ElementType Median3( ElementType A[], int Left, int Right )</span><br><span class="line">&#123; </span><br><span class="line">    int Center = (Left+Right) / 2;</span><br><span class="line">    if ( A[Left] &gt; A[Center] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Center] );</span><br><span class="line">    if ( A[Left] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Right] );</span><br><span class="line">    if ( A[Center] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Center], &amp;A[Right] );</span><br><span class="line">    /* 此时A[Left] &lt;= A[Center] &lt;= A[Right] */</span><br><span class="line">    Swap( &amp;A[Center], &amp;A[Right-1] ); /* 将基准Pivot藏到右边*/</span><br><span class="line">    /* 只需要考虑A[Left+1] … A[Right-2] */</span><br><span class="line">    return  A[Right-1];  /* 返回基准Pivot */</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Qsort( ElementType A[], int Left, int Right )</span><br><span class="line">&#123; /* 核心递归函数 */ </span><br><span class="line">     int Pivot, Cutoff, Low, High;</span><br><span class="line">       </span><br><span class="line">     if ( Cutoff &lt;= Right-Left ) &#123; /* 如果序列元素充分多，进入快排 */</span><br><span class="line">          Pivot = Median3( A, Left, Right ); /* 选基准 */ </span><br><span class="line">          Low = Left; High = Right-1;</span><br><span class="line">          while (1) &#123; /*将序列中比基准小的移到基准左边，大的移到右边*/</span><br><span class="line">               while ( A[++Low] &lt; Pivot ) ;</span><br><span class="line">               while ( A[--High] &gt; Pivot ) ;</span><br><span class="line">               if ( Low &lt; High ) Swap( &amp;A[Low], &amp;A[High] );</span><br><span class="line">               else break;</span><br><span class="line">          &#125;</span><br><span class="line">          Swap( &amp;A[Low], &amp;A[Right-1] );   /* 将基准换到正确的位置 */ </span><br><span class="line">          Qsort( A, Left, Low-1 );    /* 递归解决左边 */ </span><br><span class="line">          Qsort( A, Low+1, Right );   /* 递归解决右边 */  </span><br><span class="line">     &#125;</span><br><span class="line">     else InsertionSort( A+Left, Right-Left+1 ); /* 元素太少，用简单排序 */ </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void QuickSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 统一接口 */</span><br><span class="line">     Qsort( A, 0, N-1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h1><p>表排序是一种间接排序算法，定义一个指针数组作为“表”（table）<br><img src="https://i.loli.net/2019/05/14/5cda2bcef36b512015.png" alt="表排序"></p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p><img src="https://i.loli.net/2019/05/14/5cda2dfbcc17e29869.png" alt="基数排序"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 基数排序 - 次位优先 */</span><br><span class="line"> </span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"> </span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line">  </span><br><span class="line">int GetDigit ( int X, int D )</span><br><span class="line">&#123; /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line">     </span><br><span class="line">    for (i=1; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void LSDRadixSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 基数排序 - 次位优先 */</span><br><span class="line">     int D, Di, i;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = NULL; </span><br><span class="line">      </span><br><span class="line">     for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">         B[i].head = B[i].tail = NULL;</span><br><span class="line">     for (i=0; i&lt;N; i++) &#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">         tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面开始排序 */ </span><br><span class="line">     for (D=1; D&lt;=MaxDigit; D++) &#123; /* 对数据的每一位循环处理 */</span><br><span class="line">         /* 下面是分配的过程 */</span><br><span class="line">         p = List;</span><br><span class="line">         while (p) &#123;</span><br><span class="line">             Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */</span><br><span class="line">             /* 从List中摘除 */</span><br><span class="line">             tmp = p; p = p-&gt;next;</span><br><span class="line">             /* 插入B[Di]号桶尾 */</span><br><span class="line">             tmp-&gt;next = NULL;</span><br><span class="line">             if (B[Di].head == NULL)</span><br><span class="line">                 B[Di].head = B[Di].tail = tmp;</span><br><span class="line">             else &#123;</span><br><span class="line">                 B[Di].tail-&gt;next = tmp;</span><br><span class="line">                 B[Di].tail = tmp;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         /* 下面是收集的过程 */</span><br><span class="line">         List = NULL; </span><br><span class="line">         for (Di=Radix-1; Di&gt;=0; Di--) &#123; /* 将每个桶的元素顺序收集入List */</span><br><span class="line">             if (B[Di].head) &#123; /* 如果桶不为空 */</span><br><span class="line">                 /* 整桶插入List表头 */</span><br><span class="line">                 B[Di].tail-&gt;next = List;</span><br><span class="line">                 List = B[Di].head;</span><br><span class="line">                 B[Di].head = B[Di].tail = NULL; /* 清空桶 */</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 将List倒入A[]并释放空间 */</span><br><span class="line">     for (i=0; i&lt;N; i++) &#123;</span><br><span class="line">        tmp = List;</span><br><span class="line">        List = List-&gt;next;</span><br><span class="line">        A[i] = tmp-&gt;key;</span><br><span class="line">        free(tmp);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 基数排序 - 主位优先 */</span><br><span class="line"> </span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line"> </span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"> </span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line">  </span><br><span class="line">int GetDigit ( int X, int D )</span><br><span class="line">&#123; /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line">     </span><br><span class="line">    for (i=1; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X%Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MSD( ElementType A[], int L, int R, int D )</span><br><span class="line">&#123; /* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */</span><br><span class="line">     int Di, i, j;</span><br><span class="line">     Bucket B;</span><br><span class="line">     PtrToNode tmp, p, List = NULL; </span><br><span class="line">     if (D==0) return; /* 递归终止条件 */</span><br><span class="line">      </span><br><span class="line">     for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">         B[i].head = B[i].tail = NULL;</span><br><span class="line">     for (i=L; i&lt;=R; i++) &#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">         tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">         tmp-&gt;key = A[i];</span><br><span class="line">         tmp-&gt;next = List;</span><br><span class="line">         List = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面是分配的过程 */</span><br><span class="line">     p = List;</span><br><span class="line">     while (p) &#123;</span><br><span class="line">         Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */</span><br><span class="line">         /* 从List中摘除 */</span><br><span class="line">         tmp = p; p = p-&gt;next;</span><br><span class="line">         /* 插入B[Di]号桶 */</span><br><span class="line">         if (B[Di].head == NULL) B[Di].tail = tmp;</span><br><span class="line">         tmp-&gt;next = B[Di].head;</span><br><span class="line">         B[Di].head = tmp;</span><br><span class="line">     &#125;</span><br><span class="line">     /* 下面是收集的过程 */</span><br><span class="line">     i = j = L; /* i, j记录当前要处理的A[]的左右端下标 */</span><br><span class="line">     for (Di=0; Di&lt;Radix; Di++) &#123; /* 对于每个桶 */</span><br><span class="line">         if (B[Di].head) &#123; /* 将非空的桶整桶倒入A[], 递归排序 */</span><br><span class="line">             p = B[Di].head;</span><br><span class="line">             while (p) &#123;</span><br><span class="line">                 tmp = p;</span><br><span class="line">                 p = p-&gt;next;</span><br><span class="line">                 A[j++] = tmp-&gt;key;</span><br><span class="line">                 free(tmp);</span><br><span class="line">             &#125;</span><br><span class="line">             /* 递归对该桶数据排序, 位数减1 */</span><br><span class="line">             MSD(A, i, j-1, D-1);</span><br><span class="line">             i = j; /* 为下一个桶对应的A[]左端 */</span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MSDRadixSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 统一接口 */</span><br><span class="line">    MSD(A, 0, N-1, MaxDigit); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h1><p><img src="https://i.loli.net/2019/05/14/5cda2f24f15e577385.png" alt="排序算法比较"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>R-CNN系列</title>
    <url>/2019/05/12/2019-05-12-R-CNN%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>在解析Mask R-CNN之前，不得不告诉大家一个事实，Mask R-CNN是继承于Faster R-CNN (2016)的，Mask R-CNN只是在Faster R-CNN上面加了一个Mask Prediction Branch (Mask 预测分支)，并且改良了ROI Pooling，提出了ROI Align。所以，在解析Mask R-CNN之前，先给大家分析一下Faster R-CNN。<br>在给大家解析Faster R-CNN之前，又要告诉大家，Faster R-CNN是继承于Fast R-CNN (2015)，Fast R-CNN继承于R-CNN (2014)。因此，索性破釜沉舟，在本篇博文中，就按照R-CNN, Fast R-CNN，Faster R-CNN再到Mask R-CNN的发展顺序全部解析。</p>
</blockquote>
<h1 id="1-R-CNN"><a href="#1-R-CNN" class="headerlink" title="1. R-CNN"></a>1. R-CNN</h1><p>简单来说，R-CNN首先模型输入为一张图片，然后在图片上提出了约2000个待检测区域，然后这2000个待检测区域一个一个地(串联方式)通过卷积神经网络提取特征，然后这些被提取的特征通过一个支持向量机(SVM)进行分类，得到物体的类别，并通过一个bounding box regression调整目标包围框的大小。<br>具体步骤分为四步：</p>
<ol>
<li>候选区域提出阶段（Proposal）：采用selective-search方法，从一幅图像生成1K~2K个候选区域；</li>
<li>特征提取：对每个候选区域，使用CNN进行特征提取；</li>
<li>分类：每个候选区域的特征放入分类器SVM，得到该候选区域的分类结果；</li>
<li>回归：候选区域的特征放入回归器，得到bbox的修正量。</li>
</ol>
<h2 id="1-1-候选区域提出阶段所产生的结果尺寸不同？"><a href="#1-1-候选区域提出阶段所产生的结果尺寸不同？" class="headerlink" title="1.1 候选区域提出阶段所产生的结果尺寸不同？"></a>1.1 候选区域提出阶段所产生的结果尺寸不同？</h2><p>由于RCNN特征提取阶段采用的是AlexNet，其最后两层是全连接层fc6和fc7，所以必须保证输入的图片尺寸相同。</p>
<p>而候选区域所产生的结果尺寸是不相同的。为此，论文中作者采用了多种方式对图片进行放缩（各向同性、各向异性、加padding），最后经过对比实验确定各向异性加padding的放缩方式效果最好。各向同性、各向异性、加padding的具体效果可以看上面链接中的文章。</p>
<h2 id="1-2-分类器SVM使用的是二分类？"><a href="#1-2-分类器SVM使用的是二分类？" class="headerlink" title="1.2 分类器SVM使用的是二分类？"></a>1.2 分类器SVM使用的是二分类？</h2><p>论文中，单个SVM实现的是二分类，分类器阶段由多个SVM组合而成。比如总共有20种不同的物体（加1种背景），那么分类阶段必须要有21个SVM：第1个SVM的输出是该候选区域属于分类1的概率；第2个SVM的输出是该候选区域属于分类2的概率；……；第21个SVM的输出是该候选区域属于背景的概率。</p>
<p>对21个SVM的输出结果进行排序，哪个输出最大，候选区域就属于哪一类。比如，对于某个候选区域，第21个SVM的输出最大，那么就将该候选区域标为背景。</p>
<h2 id="1-3-分类器的输入是？回归器的输入是？"><a href="#1-3-分类器的输入是？回归器的输入是？" class="headerlink" title="1.3 分类器的输入是？回归器的输入是？"></a>1.3 分类器的输入是？回归器的输入是？</h2><p>分类器的输入是特征提取器AlexNet的fc6的输出结果，回归器的输入是特征提取器AlexNet的pool5的输出结果。</p>
<p>之所以这样取输入，是因为，分类器不依赖坐标信息，所以取fc6全连接层的结果是没有问题的。但是回归器依赖坐标信息（要输出坐标的修正量），必须取坐标信息还没有丢失前的层。而fc6全连接层已经丢失了坐标信息。</p>
<h2 id="1-4-正负样本的选择？"><a href="#1-4-正负样本的选择？" class="headerlink" title="1.4 正负样本的选择？"></a>1.4 正负样本的选择？</h2><p>正负样本是必须要考虑的问题。论文的做法是每个batch所采样的正负样本比为1：3。当然这个比例是可以变化的，这个系列的后续改进就把正负样本比变为了1：1。</p>
<p>如果之前没有接触过类似问题的话，是比较容易想当然地认为训练特征提取器、分类器、回归器时，就是把候选区域生成阶段的所有候选区域都放入训练。这样的思路是错的。一张图片中，背景占了绝大多数地方，这样就导致训练用的正样本远远少于负样本，对训练不利。</p>
<p>正确的做法是对所有候选区域进行随机采样，要求采样的结果中正样本有x张，负样本y张，且保证x与y在数值上相近。（对于一些问题，不大容易做到x:y = 1:1，但至少x与y应该在同一数量级下）</p>
<h2 id="1-5-如何训练？"><a href="#1-5-如何训练？" class="headerlink" title="1.5 如何训练？"></a>1.5 如何训练？</h2><p>RCNN的网络架构，注定了它不能像其他网络那样进行端到端（end-to-end）的训练。</p>
<p>前面提到RCNN分为4个阶段：Proposal阶段、特征提取阶段、分类阶段、回归阶段。这4个阶段都是相互独立训练的。</p>
<p>首先，特征提取器是AlexNet，将它的最后一层fc7进行改造，使得fc7能够输出分类结果。Proposal阶段对每张图片产生了1k~2k个候选区域，把这些图片依照正负样本比例喂给特征提取器，特征提取器fc7输出的分类结果与标签结果进行比对，完成特征提取器的训练。特征提取器的训练完成后，fc7层的使命也完成了，后面的分类器和回归器只会用到fc6、pool5的输出。</p>
<p>然后，Proposal和特征提取器已经训练完毕了。把它们的结果fc6，输入到分类器SVM中，SVM输出与标签结果比对，完成SVM的训练。</p>
<p>最后，回归器的训练也和SVM类似，只不过回归器取的是pool5的结果。</p>
<p>为什么不能同时进行上面3步的训练？因为特征提取器是CNN，分类器是SVM，回归器是脊回归器，不属于同一体系，无法共同训练。甚至在测试时，也需要把每一阶段的结果先保存到磁盘，再喂入下一阶段。这是非常麻烦的一件事。</p>
<p>聪明的你可能已经想到了：CNN不就能完成分类器和回归器的任务嘛？为什么不只用CNN？这就是RCNN系列后续做的改进之一，我们在下面会讲到。但由于某些原因，在RCNN这篇论文发表时，采用的是特征提取、分类器、回归器相互独立的结构。</p>
<h2 id="1-6-Proposal的每个候选区域单独提取特征，是不是很慢？"><a href="#1-6-Proposal的每个候选区域单独提取特征，是不是很慢？" class="headerlink" title="1.6 Proposal的每个候选区域单独提取特征，是不是很慢？"></a>1.6 Proposal的每个候选区域单独提取特征，是不是很慢？</h2><p>是的，很慢。Proposal阶段会产生1k<del>2k个候选区域，每个候选区域都独立提取特征的话，那相当于每幅图片都要进行1k</del>2k次CNN。（当然由于有正负样本采样，实际并没有有这么多）</p>
<p>有没有什么好方法？聪明的你应该能想到：既然候选区域都是图片的一部分，那么先对整张图片进行特征提取，然后根据每个候选区域在原图上的位置选择相应的特征不就行了。</p>
<p>这种方式正是RCNN系列的后续改进之一，只不过在实现上要动点脑筋。（这种方式得到的每个区域的特征数目是不同的，如何把不同特征数目变为相同数目？）</p>
<h1 id="2-Fast-RCNN"><a href="#2-Fast-RCNN" class="headerlink" title="2. Fast-RCNN"></a>2. Fast-RCNN</h1><p>首先还是采用selective search提取2000个候选框，然后，使用一个神经网络对全图进行特征提取。接着，使用一个RoI Pooling Layer在全图特征上摘取每一个RoI对应的特征，再通过全连接层(FC Layer)进行分类与包围框的修正。Fast R-CNN的贡献可以主要分为两个方面：</p>
<p>1) 取代R-CNN的串行特征提取方式，直接采用一个神经网络对全图提取特征(这也是为什么需要RoI Pooling的原因)。<br>2) 除了selective search，其他部分都可以合在一起训练。</p>
<h2 id="2-1-为什么叫Fast？"><a href="#2-1-为什么叫Fast？" class="headerlink" title="2.1 为什么叫Fast？"></a>2.1 为什么叫Fast？</h2><p>将特征提取器、分类器、回归器合并，使得训练过程不需要再将每阶段结果保存磁盘单独训练，可以一次性完成训练，加快了训练速度。这是Fast之一。</p>
<p>对整张图片进行特征提取，用ROI层处理候选区域的特征，使得原本每一个候选区域都要做一次特征提取，变为了现在一整张图片做一次特征提取。训练速度（8.8倍）和测试速度（146倍）都大大加快，这是Fast之二。</p>
<h2 id="2-2-分类器和回归器的实现细节？"><a href="#2-2-分类器和回归器的实现细节？" class="headerlink" title="2.2 分类器和回归器的实现细节？"></a>2.2 分类器和回归器的实现细节？</h2><p>分类器应该都能想到，用的softmax代替SVM。</p>
<p>回归器求出（x,y,w,h）4个量，分别代表定位框左上角的坐标xy、宽度w、高度h，损失函数用的是Smooth-L1。</p>
<h2 id="2-3-Proposal阶段看上去有点违和？"><a href="#2-3-Proposal阶段看上去有点违和？" class="headerlink" title="2.3 Proposal阶段看上去有点违和？"></a>2.3 Proposal阶段看上去有点违和？</h2><p>发展到Fast-RCNN，后续3个阶段都是CNN完成的了，只剩下Proposal阶段还没有用CNN方式解决。Proposal阶段的结果还是需要先保存到磁盘，再喂入后续阶段，有点违和。</p>
<p>RCNN系列后续的改进，将把Proposal阶段也用CNN实现，真正做到端到端（end-to-end）。</p>
<h1 id="3-Faster-RCNN"><a href="#3-Faster-RCNN" class="headerlink" title="3.Faster-RCNN"></a>3.Faster-RCNN</h1><p>Faster-RCNN引入了RPN网络（region proposal network）来代替selective-search。这使得整个网络实现了端到端。</p>
<h2 id="3-1-RPN网络是如何工作的？"><a href="#3-1-RPN网络是如何工作的？" class="headerlink" title="3.1 RPN网络是如何工作的？"></a>3.1 RPN网络是如何工作的？</h2><p>整张图片经过特征提取，得到FeatureMap；将FeatureMap中的每一点按照视野域找到原图中对应的位置，称为Anchor；每个Anchor生成不同大小不同长宽比的多个候选区域。</p>
<p>回忆下selective-search的候选区域生成方式，它是按照颜色和纹理不断合并得到候选区域的，候选区域的产生没有规律，而RPN是每个Anchor都有对应的固定数量的候选区域，规律很明显。</p>
<p>理论上说，selective-search生成候选区域的方式更符合我们的直觉，而实验结果，在Faster-RCNN中RPN并不比selective-search差</p>
<h2 id="3-2-为什么是Faster？"><a href="#3-2-为什么是Faster？" class="headerlink" title="3.2 为什么是Faster？"></a>3.2 为什么是Faster？</h2><p>容易想到，现在RPN网络可以与其他3个阶段共用同一个特征提取结果了，省掉了selective-search的时间。而事实上，selective-search是非常慢的，所以叫Faster。</p>
<h1 id="4-Mask-RCNN"><a href="#4-Mask-RCNN" class="headerlink" title="4.Mask-RCNN"></a>4.Mask-RCNN</h1><h2 id="4-1-为什么叫mask？"><a href="#4-1-为什么叫mask？" class="headerlink" title="4.1 为什么叫mask？"></a>4.1 为什么叫mask？</h2><p>Faster-RCNN网络的最后分别是分类网络和回归网络两条路并行，Mask-RCNN则是再加一条Mask网络与它们并行。</p>
<p>Mask网络的实现是FCN网络，这也是语义分割领域中非常经典的网络结构。</p>
<p>由于Mask网络的加入，Mask-RCNN不仅能处理物体检测问题，还能处理语义分割问题。</p>
<h2 id="4-2-还有哪些细节上的变化？"><a href="#4-2-还有哪些细节上的变化？" class="headerlink" title="4.2 还有哪些细节上的变化？"></a>4.2 还有哪些细节上的变化？</h2><p>首先是ROI层变为了ROIAlign，目的是一样的。那为什么要加入ROIAlign呢？这是因为ROI层会有对齐问题，对齐问题在分类和框选时影响不大，但在语义分割需要严格依赖每个像素点的坐标时，影响会很大。ROIAlign能够解决对齐问题。</p>
<p>然后是特征提取网络改为了ResNet101+FPN；FPN建议对语义分割或者关键点定位感兴趣的同学了解下，FPN是这两个领域中非常经典的结构。</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Mask R-CNN总结</title>
    <url>/2019/05/07/2019-05-07-Mask%20R-CNN%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">https://arxiv.org/abs/1703.06870</a><br>目前找到了非常好的一位博客：<a href="https://blog.csdn.net/WZZ18191171661/article/details/79453780，" target="_blank" rel="noopener">https://blog.csdn.net/WZZ18191171661/article/details/79453780，</a> 感谢！<br><a href="https://blog.csdn.net/jiongnima/article/details/79094159，" target="_blank" rel="noopener">https://blog.csdn.net/jiongnima/article/details/79094159，</a> 这个也不错。<br>相关知识介绍：<br>R-CNN-<a href="https://www.jianshu.com/p/5056e6143ed5" target="_blank" rel="noopener">https://www.jianshu.com/p/5056e6143ed5</a>;<br>Faster R-CNN-<a href="https://blog.csdn.net/qq_17448289/article/details/52871461" target="_blank" rel="noopener">https://blog.csdn.net/qq_17448289/article/details/52871461</a><br><a href="https://blog.csdn.net/u011974639/article/details/78053203" target="_blank" rel="noopener">https://blog.csdn.net/u011974639/article/details/78053203</a>, 个人感觉这两篇讲的很好。</p>
</blockquote>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul>
<li>Mask RCNN可以看做是一个通用实例分割架构。</li>
<li>Mask RCNN以Faster RCNN原型，增加了一个分支用于分割任务。</li>
<li>Mask RCNN比Faster RCNN速度慢一些，达到了5fps。</li>
<li>可用于人的姿态估计等其他任务</li>
</ul>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><ul>
<li>实例分割不仅要正确的找到图像中的objects，还要对其精确的分割。所以Instance Segmentation可以看做object dection和semantic segmentation的结合。</li>
<li>Mask RCNN是Faster RCNN的扩展，对于Faster RCNN的每个Proposal Box都要使用FCN进行语义分割，分割任务与定位、分类任务是同时进行的。</li>
<li>引入了RoI Align代替Faster RCNN中的RoI Pooling。因为RoI Pooling并不是按照像素一一对齐的（pixel-to-pixel alignment），也许这对bbox的影响不是很大，但对于mask的精度却有很大影响。使用RoI Align后mask的精度从10%显著提高到50%，第3节将会仔细说明。</li>
<li>引入语义分割分支，实现了mask和class预测的关系的解耦，mask分支只做语义分割，类型预测的任务交给另一个分支。这与原本的FCN网络是不同的，原始的FCN在预测mask时还用同时预测mask所属的种类。</li>
<li>没有使用什么花哨的方法，Mask RCNN就超过了当时所有的state-of-the-art模型。</li>
<li>使用8-GPU的服务器训练了两天。</li>
</ul>
<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2.Related Work"></a>2.Related Work</h1><ul>
<li>相比于FCIS，FCIS使用全卷机网络，同时预测物体classes、boxes、masks，速度更快，但是对于重叠物体的分割效果不好。</li>
</ul>
<h1 id="3-Mask-R-CNN"><a href="#3-Mask-R-CNN" class="headerlink" title="3.Mask R-CNN"></a>3.Mask R-CNN</h1><ul>
<li>Mask R-CNN基本结构：与Faster RCNN采用了相同的two-state步骤：首先是找出RPN，然后对RPN找到的每个RoI进行分类、定位、并找到binary mask。这与当时其他先找到mask然后在进行分类的网络是不同的。</li>
<li>Mask R-CNN的损失函数：L = L<sub>cls</sub> + L<sub>box</sub> + L<sub>mask</sub></li>
<li>Mask的表现形式(Mask Representation)：因为没有采用全连接层并且使用了RoIAlign，可以实现输出与输入的像素一一对应。</li>
<li>RoIAlign：RoIPool的目的是为了从RPN网络确定的ROI中导出较小的特征图(a small feature map，eg 7x7)，ROI的大小各不相同，但是RoIPool后都变成了7x7大小。RPN网络会提出若干RoI的坐标以[x,y,w,h]表示，然后输入RoI Pooling，输出7x7大小的特征图供分类和定位使用。问题就出在RoI Pooling的输出大小是7x7上，如果RON网络输出的RoI大小是8*8的，那么无法保证输入像素和输出像素是一一对应，首先他们包含的信息量不同（有的是1对1，有的是1对2），其次他们的坐标无法和输入对应起来（1对2的那个RoI输出像素该对应哪个输入像素的坐标？）。这对分类没什么影响，但是对分割却影响很大。RoIAlign的输出坐标使用插值算法得到，不再量化；每个grid中的值也不再使用max，同样使用差值算法。</li>
<li>Network Architecture: 为了表述清晰，有两种分类方法</li>
</ul>
<ol>
<li>使用了不同的backbone：resnet-50，resnet-101，resnext-50，resnext-101；</li>
<li>使用了不同的head Architecture：Faster RCNN使用resnet50时，从CONV4导出特征供RPN使用，这种叫做ResNet-50-C4</li>
<li>作者使用除了使用上述这些结构外，还使用了一种更加高效的backbone——FPN</li>
</ol>
<h2 id="3-1-Implementation-Details"><a href="#3-1-Implementation-Details" class="headerlink" title="3.1.Implementation Details"></a>3.1.Implementation Details</h2><p>使用Fast/Faster相同的超参数，同样适用于Mask RCNN</p>
<ul>
<li>Training:<br>1、与之前相同，当IoU与Ground Truth的IoU大于0.5时才会被认为有效的RoI，L{_{mask}}只把有效RoI计算进去。<br>2、采用image-centric training，图像短边resize到800，每个GPU的mini-batch设置为2，每个图像生成N个RoI，对于C4 backbone的N=64，对于FPN作为backbone的，N=512。作者服务器中使用了8块GPU，所以总的minibatch是16，迭代了160k次，初始lr=0.02，在迭代到120k次时，将lr设定到 lr=0.002，另外学习率的weight_decay=0.0001，momentum = 0.9。如果是resnext，初始lr=0.01,每个GPU的mini-batch是1。<br>3、RPN的anchors有5种scale，3种ratios。为了方便剥离、如果没有特别指出，则RPN网络是单独训练的且不与Mask R-CNN共享权重。但是在本论文中，RPN和Mask R-CNN使用一个backbone，所以他们的权重是共享的。<br>（Ablation Experiments 为了方便研究整个网络中哪个部分其的作用到底有多大，需要把各部分剥离开）</li>
</ul>
<ul>
<li>Inference：<br>在测试时，使用C4 backbone情况下proposal number=300，使用FPN时proposal number=1000。然后在这些proposal上运行bbox预测，接着进行非极大值抑制。mask分支只应用在得分最高的100个proposal上。顺序和train是不同的，但这样做可以提高速度和精度。mask 分支对于每个roi可以预测k个类别，但是我们只要背景和前景两种，所以只用k-th mask，k是根据分类分支得到的类型。然后把k-th mask resize成roi大小，同时使用阈值分割(threshold=0.5)二值化</li>
</ul>
<h1 id="4-Experiments-Instance-Segmentation"><a href="#4-Experiments-Instance-Segmentation" class="headerlink" title="4.Experiments: Instance Segmentation"></a>4.Experiments: Instance Segmentation</h1><h2 id="4-1-Main-Results"><a href="#4-1-Main-Results" class="headerlink" title="4.1.Main Results"></a>4.1.Main Results</h2><p>在下图中可以明显看出，FCIS的分割结果中都会出现一条竖着的线(systematic artifacts)，这线主要出现在物体重的部分，作者认为这是FCIS架构的问题，无法解决的。但是在Mask RCNN中没有出现。<br><img src="https://i.loli.net/2019/04/29/5cc65cc9ecfc3.png" alt="figure6&amp;table2"></p>
<h2 id="4-2-Ablation-Experiments"><a href="#4-2-Ablation-Experiments" class="headerlink" title="4.2. Ablation Experiments"></a>4.2. Ablation Experiments</h2><ul>
<li>Architecture:<br>从table 2a中看出，Mask RCNN随着增加网络的深度、采用更先进的网络，都可以提高效果。注意：并不是所有的网络都是这样。</li>
<li>Multinomial vs. Independent Masks:(mask分支是否进行类别预测)                                                                                    从table 2b中可以看出，使用sigmoid(二分类)和使用softmax(多类别分类)的AP相差很大，证明了分离类别和mask的预测是很有必要的</li>
<li>Class-Specific vs. Class-Agnostic Masks:                                                                                                                            目前使用的mask rcnn都使用class-specific masks，即每个类别都会预测出一个mxm的mask，然后根据类别选取对应的类别的mask。但是使用Class-Agnostic Masks，即分割网络只输出一个mxm的mask，可以取得相似的成绩29.7vs30.3</li>
<li>RoIAlign:                                                                                                                                                                                    tabel 2c证明了RoIAlign的性能</li>
<li>Mask Branch:<br>tabel 2e，FCN比MLP性能更好</li>
</ul>
<h2 id="4-3-Bounding-Box-Detection-Results"><a href="#4-3-Bounding-Box-Detection-Results" class="headerlink" title="4.3.Bounding Box Detection Results"></a>4.3.Bounding Box Detection Results</h2><ul>
<li>Mask RCNN精度高于Faster RCNN</li>
<li>Faster RCNN使用RoI Align的精度更高</li>
<li>Mask RCNN的分割任务得分与定位任务得分相近，说明Mask RCNN已经缩小了这部分差距。</li>
</ul>
<h2 id="4-4-Timing"><a href="#4-4-Timing" class="headerlink" title="4.4.Timing"></a>4.4.Timing</h2><ul>
<li>Inference：195ms一张图片，显卡Nvidia Tesla M40。其实还有速度提升的空间，比如减少proposal的数量等。</li>
<li>Training：ResNet-50-FPN on COCO trainval35k takes 32 hours  in our synchronized 8-GPU implementation (0.72s per 16-image mini-batch)，and 44 hours with ResNet-101-FPN。</li>
</ul>
<h1 id="5-Mask-R-CNN-for-Human-Pose-Estimation"><a href="#5-Mask-R-CNN-for-Human-Pose-Estimation" class="headerlink" title="5. Mask R-CNN for Human Pose Estimation"></a>5. Mask R-CNN for Human Pose Estimation</h1><p>让Mask R-CNN预测k个masks，每个mask对应一个关键点的类型，比如左肩、右肘，可以理解为one-hot形式。</p>
<ul>
<li>使用cross entropy loss，可以鼓励网络只检测一个关键点;</li>
<li>ResNet-FPN结构</li>
<li>训练了90k次，最开始lr=0.02，在迭代60k次时，lr=0.002,80k次时变为0.0002</li>
</ul>
<p><img src="https://i.loli.net/2019/04/29/5cc65f4085801.png" alt="figure7"><br><em>图7.使用Mask R-CNN（ResNet-50-FPN）在COCO测试中的关键点检测结果，以及从相同模型预测的人分割掩码。该模型的关键点AP为63.1，运行速度为5 fps。</em></p>
<p><img src="https://i.loli.net/2019/04/29/5cc6605e29496.png" alt="table4/5/6"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Mask R-CNN</title>
    <url>/2019/04/29/2019-04-29-Mask%20R-CNN/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">https://arxiv.org/abs/1703.06870</a><br>Mask R-CNN是ICCV 2017的best paper，彰显了机器学习计算机视觉领域在2017年的最新成果。在机器学习2017年的最新发展中，单任务的网络结构已经逐渐不再引人瞩目，取而代之的是集成，复杂，一石多鸟的多任务网络模型。Mask R-CNN就是典型的代表。本篇大作的一作是何凯明，在该篇论文发表的时候，何凯明已经去了FaceBook。</p>
</blockquote>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p><em>我们提出了一个概念上简单，灵活和通用的对象实例分割框架。我们的方法有效地检测图像中的对象，同时为每个实例生成高质量的分割蒙版。这种称为Mask R-CNN的方法通过添加一个用于预测对象掩码的分支来扩展更快的R-CNN，该分支与现有的用于边界框识别的分支并行。掩码R-CNN训练简单，只增加了一小部分开销，以更快的R-CNN，以5fps运行。此外，Mask R-CNN很容易推广到其他任务，例如允许我们在相同的框架中估计人的姿势。我们在COCO全套挑战的所有三个轨道中展示了最佳结果，包括实例分段，边界盒对象检测和人员关键点检测。Mask R-CNN无需花费大量时间就可胜任所有现有的单一模型作品，包括COCO 2016挑战获胜者。我们希望我们简单有效的方法将成为一个坚实的基线，并有助于缓解未来实例级别识别的研究。代码已在：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> facebookresearch / Detectron上提供。</em></p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><p>视觉社区在短时间内迅速改进了对象检测和语义分割结果。在很大程度上，这些进步是由强大的基线系统驱动的，例如分别用于对象检测和语义分割的快速/更快RCNN [12,36]和全卷积网络（FCN）[30]框架。这些方法在概念上是直观的，并且具有灵活性和鲁棒性，以及快速训练和推理时间。我们在这项工作中的目标是为实例分割开发一个相对有利的框架。实例分割具有挑战性，因为它需要正确检测图像中的所有对象，同时也精确地分割每个实例。因此，它将经典的目标检测计算机视觉任务的元素进行了组合，其目标是对各个对象进行分类并使用边界框对每个对象进行本地化，然后进行语义分割，其目的是将每个像素分类为固定的一组类别，而不区分对象实例.1鉴于此，人们可能期望需要一个复杂的方法才能取得好的结果。然而，我们表明，一个令人惊讶的简单，灵活和快速的系统可以超越先前的最新实例分割结果。<br>我们的方法称为Mask R-CNN，可以使R-CNN更快。<br><img src="https://i.loli.net/2019/04/29/5cc657a3425e5.png" alt="figure1"><br><em>图1.用于实例分段的Mask R-CNN框架。</em></p>
<p>[36]通过添加一个分支来预测每个感兴趣区域（RoI）上的分割掩模，并与现有分支进行分类和边界框回归（图1）。掩模分支是应用于每个RoI的小FCN，以像素 - 顶像素方式预测分割掩模。由于R-CNN框架更加快速，面罩R-CNN的实施和训练变得非常简单，这有助于广泛的灵活架构设计。另外，掩码分支只会增加一个小的计算开销，从而实现快速系统和快速实验。<br>原则上，Mask R-CNN是R-CNN的直观扩展，但正确构建掩模分支对于获得好的结果至关重要。最重要的是，更快的RCNN并非针对网络输入和输出之间的像素对像素对齐而设计的。RoIPool [18,12]是参与实例的事实核心操作，为特征提取执行粗略的空间量化，这一点最为明显。为了找到错位，我们提出了一个简单的，无量化的图层，称为RoIAlign，忠实地保留了确切的空间位置。尽管1遵循通用术语，但我们使用对象检测来表示通过边界框而不是掩码进行检测，并使用语义分割来表示每像素分类而不区分实例。但是我们注意到，实例分割既是语义的，也是一种检测形式。<br><img src="https://i.loli.net/2019/04/29/5cc658728ff4e.png" alt="figure2"><br><em>图2.掩盖COCO测试集上的R-CNN结果。这些结果基于ResNet-101 [19]，实现了35.7的掩模AP，并以5 fps运行。面具以彩色显示，还显示了边界框，类别和置信度。</em></p>
<p>一个看似微小的变化，RoIAlign具有很大的影响：它将掩模精度提高了10％到50％，在更严格的本地化指标下显示出更大的收益。其次，我们发现解耦模板和类别预测至关重要：我们独立预测每个类别的二进制掩码，而不需要在类别间进行竞争，并依靠网络的RoI分类分支来预测类别。相比之下，FCNs通常执行每像素多类别分类，结合分割和分类，并基于我们的实验在分割实例方面效果不佳。<br>没有花里胡哨之力，Mask R-CNN超越了COCO实例分割任务中所有先前的最新单模型结果[28]，其中包括来自2016年竞赛冠军的大量工程项目。作为副产品，我们的方法也擅长COCO物体检测任务。在消融实验中，我们评估了多个基本实例，这使我们能够展示其强大性并分析核心因素的影响。<br>我们的模型可以在GPU上以每帧200毫秒的速度运行，并且在单个8 GPU计算机上进行COCO培训需要一到两天。我们相信，快速训练和测试速度，以及框架的灵活性和准确性，将会对实例分割的未来研究起到一定的作用。<br>最后，我们通过COCO关键点数据集上的人体姿态估计任务展示了我们框架的一般性[28]。通过将每个关键点视为一个热门的二进制掩码，只需进行最少的修改Mask R-CNN可用于检测实例特定的姿势。Mask R-CNN超越2016年COCO关键点竞赛的冠军，同时运行速度为5 fps。因此，面膜R-CNN可以更广泛地视为实例级别识别的灵活框架，并且可以很容易地扩展到更复杂的任务。<br>我们已发布代码以促进未来的研究。</p>
<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2.Related Work"></a>2.Related Work</h1><p>R-CNN：基于区域的CNN（R-CNN）方法[13]对边界框对象进行检测是为了关注可管理数量的候选目标区域[42,20]并独立评估卷积网络[25,24]在每个RoI上。R-CNN得到了扩展[18,12]，允许使用RoIPool在功能地图上参与RoI，从而实现更快的速度和更高的准确性。更快的R-CNN [36]通过学习区域建议网络（RPN）的注意机制来推进这一流程。更快速的R-CNN灵活性强，适用于许多后续改进（例如[38,27,21]），并且是几个基准测试中的当前领先框架。<br>实例细分：在RCNN的有效性的推动下，许多实例细分的方法都基于细分提案。早期的方法[13,15,16,9]采用了自下而上的方法[42,2]。DeepMask [33]和以下着作[34,8]学会提出片段候选者，然后由Fast R-CNN进行分类。在这些方法中，分割先于识别，这是缓慢的并且不太准确。同样，戴等人。 [10]提出了一个复杂的多级级联，从包围盒提议中预测段提议，然后进行分类。相反，我们的方法基于面具和类标签的并行预测，它更简单，更灵活。<br>最近，李等人。 [26]将[8]中的段提议系统和[11]中的对象检测系统合并为“完全卷积实例分段”（FCIS）。[8,11,26]中的共同想法是预测一组完全卷积的位置敏感输出通道。这些通道同时处理对象类，框和掩码，使系统更快。但是FCIS在重叠实例上表现出系统性错误并产生虚假边缘（图6），表明它受到分割实例的根本困难的挑战。<br>另一个解决方案家族[23,4,3,29]实例分割是由语义分割的成功驱动的。从每像素分类结果（例如，FCN输出）开始，这些方法试图将相同类别的像素切割成不同的实例。与这些方法的分段第一策略相比，Mask R-CNN基于实例第一策略。我们预计未来将研究更深入的两种战略。</p>
<h1 id="3-Mask-R-CNN"><a href="#3-Mask-R-CNN" class="headerlink" title="3.Mask R-CNN"></a>3.Mask R-CNN</h1><p>掩码R-CNN在概念上是简单的：更快的R-CNN对于每个候选对象具有两个输出，一个类别标签和一个边界框偏移;为此，我们添加一个输出对象掩码的第三个分支。面具R-CNN因此是一个自然而直观的想法。但是额外的掩码输出与类和盒输出不同，需要提取对象的更精细的空间布局。接下来，我们介绍Mask R-CNN的关键元素，包括像素对像素对齐，这是Fast / Faster R-CNN的主要缺失部分。<br>更快的R-CNN：我们首先回顾一下更快的R-CNN探测器[36]。更快的R-CNN由两个阶段组成。第一阶段称为区域提议网络（RPN），提出候选对象边界框。第二阶段本质上是Fast R-CNN [12]，使用每个候选框中的RoIPool提取特征，并执行分类和边界框回归。两个阶段使用的功能可以共享以加快推断速度。我们引用读者[21]对Faster R-CNN和其他框架进行最新，全面的比较。<br>掩码R-CNN：掩码R-CNN采用相同的两阶段过程，具有相同的第一阶段（即RPN）。在第二阶段，与预测类和盒子偏移并行，Mask R-CNN也为每个RoI输出一个二进制掩码。这与大多数最近的系统形成对比，其中分类依赖于掩模预测（例如[33,10,26]）。我们的方法遵循Fast R-CNN [12]的精神，它并行地应用了边界框分类和回归（其原来大大简化了原始R-CNN的多级流水线[13]）。<br>形式上，在训练期间，我们将每个抽样的RoI的多任务丢失定义为L = Lcls + Lbox + Lmask。分类损失Lcls和边界框损失Lbox与[12]中定义的相同。掩码分支对每个RoI都有一个Km<sup>2</sup>维输出，它编码分辨率为m * m的K个二进制掩码，每个K类一个掩码。为此，我们应用每像素S形，并将Lmask定义为平均二叉交叉熵损失。对于与地面实况类别k相关的RoI，Lmask仅在第k个掩模上定义（其他掩模输出不会造成损失）。<br>我们对Lmask的定义允许网络为每个班级生成口罩，而不需要在班级间进行竞争;我们依靠专用分类分支来预测用于选择输出掩码的类别标签。这样可以将掩码和类别预测分开。这与将FCN [30]应用于语义分割时的常见做法不同，后者通常使用每像素softmax和多项叉熵损失。在这种情况下，跨班级的面具竞争;在我们的例子中，每像素S形和二进制丢失，他们不。我们通过实验显示这个公式对于良好的实例分割结果是关键的。<br><img src="https://i.loli.net/2019/04/29/5cc65a2a8366b.png" alt="figure3"></p>
<p>掩码表示法：掩码编码输入对象的空间布局。因此，与通过完全连接（fc）层不可避免地折叠成短输出矢量的类标签或框偏移不同，提取掩模的空间结构可以通过卷积提供的像素到像素对应自然地解决。<br>具体而言，我们使用FCN预测每个RoI的m * m掩码[30]。这允许掩码分支中的每个层保持显式m * m对象空间布局，而不将其折叠成缺少空间维度的向量表示。与之前采用fc层进行掩模预测的方法不同[33,34,10]，我们的完全卷积表示需要更少的参数，并且如实验所证明的那样更精确。<br>这种像素到像素的行为要求我们的RoI特征（它们本身是小特征图）能够很好地对齐以忠实地保留显式的每像素空间对应关系。这促使我们开发了以下RoAlign图层，该图层在遮罩预测中发挥关键作用。<br>RoIlign：RoIPool [12]是从每个RoI提取小特征映射（例如7×7）的标准操作。RoIPool首先将浮点数RoI量化为特征映射的离散粒度，然后将这个量化的RoI细分为自身量化的空间仓，最后汇总每个仓所涵盖的特征值（通常通过最大池）。例如，通过计算在连续坐标x上执行量化，其中16是特征映射步长并且是舍入;同样地，当分成分箱（例如，7×7）时执行量化。这些量化引入了RoI和提取的特征之间的错位。虽然这可能不会影响分类，这对于小型翻译很有用，但它对预测像素精确的蒙版有很大的负面影响。<br>为了解决这个问题，我们提出一个RoIlign层，它可以消除RoIPool的严格量化，正确地将提取的特征与输入对齐。我们提出的改变很简单：我们避免任何RoI边界或分区的量化（即，我们使用x/16而不是|x/16|）。我们使用双线性插值[22]来计算每个RoI bin中四个有规律采样位置的输入特征的精确值，并汇总结果（使用最大值或平均值），详细信息请参见图3。我们注意到，只要未执行量化，结果对精确的采样位置不敏感，或者采样了多少个点。<br>正如我们在§4.2中所展示的，RoIAlign带来了巨大的改进。我们也比较了[10]中提出的RoIWarp操作。与RoIlign不同，RoIWarp忽略了对齐问题，并在[10]中将RoI与RoIPool一样量化为RoI。所以即使RoIWarp也采用[22]激励的双线性重采样，它可以像RoIPool一样实验（表2c中的更多细节），证明了对齐的关键作用。<br>网络体系结构：为了演示我们的方法的一般性，我们实例化具有多种体系结构的Mask R-CNN。为了清楚起见，我们区分：（i）用于整个图像上的特征提取的卷积骨干架构，以及（ii）用于边界框识别（分类和回归）的网络头和分别应用于每个RoI的掩模预测。我们用命名网络深度特征来表示骨干架构。我们评估深度为50或101层的ResNet [19]和ResNeXt [45]网络。带ResNets的更快的R-CNN的原始实施。<br>[19]从第四阶段的最后卷积层提取特征，我们称之为C4。例如，ResNet-50的骨干用ResNet-50-C4表示。这是[19,10,21,39]中常用的选择。<br>我们还探索了Lin等人最近提出的另一种更有效的骨干。 [27]，称为特征金字塔网络（FPN）。FPN使用具有横向连接的自顶向下架构从单一比例输入构建网络内特征金字塔。更快的R-CNN和FPN骨干网根据其规模从不同层次的特征金字塔中提取RoI特征，但其他方法与vanilla ResNet类似。使用ResNet-FPN主干进行MaskNRCNN特征提取，可以提高精度和速度。有关FPN的更多详细信息，请参阅[27]。<br>对于网络负责人，我们密切关注以前工作中提出的架构，并在其中添加完全卷积掩码预测分支。具体而言，我们从ResNet [19]和FPN [27]论文中扩展了更快的R-CNN盒头。详细情况如图4所示。ResNet-C4主干上包含ResNet的第5级（即9层’res5’[19]），它是计算密集型的。对于FPN，骨干已经包含res5，因此可以使用更少的滤波器来提高效率。我们注意到我们的面具分支有一个简单的结构。更复杂的设计有提高性能的潜力，但不是这项工作的重点。<br><img src="https://i.loli.net/2019/04/29/5cc65b1069756.png" alt="figure4"><br><em>图4.头架构：我们扩展了两个现有的更快的RCNN头[19,27]。左/右面板分别显示来自[19]和[27]的ResNet C4和FPN骨干的头部，其中添加了掩膜分支。数字表示空间分辨率和频道。箭头表示可以从上下文推断的conv，deconv或fc图层（conv会保留空间维度，而deconv会增加它）。所有的转换都是3×3，除了输出转换为1×1，解压缩为2×2和步长2，并且我们在隐藏层中使用了ReLU [31]。左：res5表示ResNet的第五阶段，为了简单起见，我们改变了第一阶段的第一阶段，以步幅1（而不是14×14 /步幅2，如[19]中的7×7阶段）操作。右：“×4”表示一连串四次转换。</em></p>
<h2 id="3-1-Implementation-Details"><a href="#3-1-Implementation-Details" class="headerlink" title="3.1.Implementation Details"></a>3.1.Implementation Details</h2><p>我们在现有的快速/更快的R-CNN工作之后设置超参数[12,36,27]。尽管这些决策是在原始文件中进行对象检测的[12,36,27]，但我们发现我们的实例分割系统对它们是强健的。<br>培训：与Fast R-CNN一样，如果RoI的IoU的地面实况框至少为0.5，则认为是正面的，否则为负面。掩模损失Lmask仅在正向RoI上定义。掩码目标是RoI与其关联的地面实况蒙版之间的交集。<br>我们采用图像中心训练[12]。调整图像的大小以使其比例（较短的边缘）为800像素[27]。每个微型批次每个GPU有2个图像，每个图像具有N个采样的RoI，比例为1：3的正负极[12]。C4骨架的N为64（如[12,36]），FPN为512（如[27]）。我们在8个GPU（有效小批量大小为16）上进行160k次迭代训练，学习率为0.02，在120k迭代时减少10。我们使用0.0001的重量衰减和0.9的动量。使用ResNeXt [45]，我们每个GPU训练1个图像，迭代次数相同，初始学习率为0.01。RPN锚点跨越5个尺度和3个纵横比，见[27]。为了方便消融，除非另有说明，否则RPN将单独进行培训并且不会与Mask R-CNN共享特征。对于本文中的每个条目，RPN和Mask R-CNN具有相同的主干，因此它们可共享。<br>推论：在测试时，C4主干的提案编号为300（如[36]），FPN的提案编号为1000（如[27]）。我们对这些提议运行盒子预测分支，然后是非最大抑制[14]。然后将掩码分支应用于得分最高的100个检测框。虽然这与训练中使用的并行计算不同，但它加快了推理速度并提高了准确性（由于使用了更少，更准确的RoI）。掩模分支可以预测每个RoI的K个掩模，但我们只使用第k个掩模，其中k是分类分支预测的类。然后将m×m浮点数掩码输出调整为RoI大小，并在阈值0.5下进行二进制化。<br><img src="https://i.loli.net/2019/04/29/5cc65b990f59b.png" alt="figure5"><br><em>图5.在COCO测试图像上使用ResNet-101-FPN并以5 fps运行并带有35.7掩模AP（表1）的Mask R-CNN的更多结果。</em></p>
<p><img src="https://i.loli.net/2019/04/29/5cc65bd2acd59.png" alt="table1"><br><em>表1. COCO test-dev上的实例分段掩码AP。跨国公司[10]和FCIS [26]分别是2015年和2016年分类挑战的赢家。没有花里胡哨的，Mask R-CNN胜过了更复杂的FCIS +++，其中包括多尺度训练/测试，水平测试和OHEM [38]。所有条目都是单模型结果。</em></p>
<p>请注意，由于我们仅计算前100个检测框中的掩码，Mask R-CNN为其较快的R-CNN对象（例如典型模型上的约20％）增加了一个小的开销。</p>
<h1 id="4-Experiments-Instance-Segmentation"><a href="#4-Experiments-Instance-Segmentation" class="headerlink" title="4.Experiments: Instance Segmentation"></a>4.Experiments: Instance Segmentation</h1><p>我们对Mask R-CNN进行了彻底的比较，并对COCO数据集进行了全面的消融[28]。我们报告标准的COCO指标，包括AP（平均在IoU阈值上），AP50，AP75和APS，APM，APL（AP在不同尺度上）。除非另有说明，否则AP正在使用掩膜IoU进行评估。和以前的工作[5,27]一样，我们训练使用80k列车图像和val图像的35k子集（trainval35k）的联合，并报告其余5k val图像（微型）上的消融。我们还在测试开发中报告结果[28]。</p>
<h2 id="4-1-Main-Results"><a href="#4-1-Main-Results" class="headerlink" title="4.1.Main Results"></a>4.1.Main Results</h2><p>我们将Mask R-CNN与表1中实例分割中的最新方法进行了比较。我们模型的所有实例都优于先前最先进的模型的基线变体。其中包括MNC [10]和FCIS [26]，分别是2015年和2016年分类挑战的获胜者。ResNet-101-FPN骨干网掩码R-CNN的性能优于FCIS +++ [26]，其中包括多尺度训练/测试，水平流测试和在线硬示例挖掘（OHEM）[38]。虽然超出了本工作的范围，但我们预计许多此类改进将适用于我们的工作。图2和图5中显示了掩膜R-CNN输出。面具R-CNN即使在具有挑战性的条件下也能取得良好效果。在图6中，我们比较了我们的Mask R-CNN基线和FCIS +++ [26]。FCIS +++在重叠的实例中展现出系统性的人为因素，这表明它受到实例分割根本困难的挑战。掩码R-CNN没有显示这样的文物。<br><img src="https://i.loli.net/2019/04/29/5cc65cc9ecfc3.png" alt="figure6&amp;table2"></p>
<h2 id="4-2-Ablation-Experiments"><a href="#4-2-Ablation-Experiments" class="headerlink" title="4.2. Ablation Experiments"></a>4.2. Ablation Experiments</h2><p>我们运行一些消融来分析Mask R-CNN。结果显示在表2中并在下面详细讨论。<br>架构：表2a显示了具有各种骨架的Mask R-CNN。它受益于更深的网络（50对101）和先进的设计，包括FPN和ResNeXt。我们注意到并非所有框架都自动从更深或更高级的网络中获益（参见[21]中的基准测试）。<br>多项式与独立式掩码：掩码R-CNN分离掩码和类别预测：由于现有的分支预测类别标签，因此我们为每个类别生成一个掩码，而不会在类别间进行竞争（按像素S形和二进制丢失）。在表2b中，我们将其与使用每像素softmax和多项损失（如FCN [30]中常用的）进行比较。这种替代方案将掩模和类别预测的任务相结合，并导致掩模AP（5.5分）的严重损失。这表明一旦实例被整体分类（通过盒子分支），预测二进制掩码就足够了，而不用考虑类别，这使得模型更易于训练。<br>Class-Speci fi c与Class-Agnostic Masks：我们的默认实例化预测了类特定的掩码，即一个m * m每个班级的面具。有趣的是，具有分类掩码的掩码R-CNN（即预测单个m * m输出而不管类别）几乎同样有效：它具有29.7掩码AP，而对于ResNet-50-C4上的类别特定对应字符，掩码AP为30.3。这进一步突出了我们的方法中的分工，这种分工在很大程度上将分类和分割分开。<br>Roialign：我们建议的RoIlign层的评估如表2c所示。在这个实验中，我们使用了跨度为16的ResNet50-C4主干。RoIAlign比RoIPool提高了约3个点，其中很大的收益来自高IoU（AP75）。RoIlign对最大/平均水池不敏感;我们在本文的其余部分使用平均值。另外，我们与在MNC [10]中提出的RoIWarp进行比较，该方法也采用双线性采样。正如§3所讨论的那样，RoIWarp仍然量化了RoI，失去了与输入的一致性。从表2c可以看出，RoIWarp的表现与RoIPool相当，比RoIAlign差很多。这突出表明正确的对齐是关键。<br>我们还用一个ResNet-50-C5骨干来评估RoIlign，这个骨干有32个像素的更大步幅。我们使用与图4（右）相同的头，因为res5头不适用。表2d显示RoIAlign提高了掩模AP的7.3点，掩盖AP75 10.5点（相对提高50％）。此外，我们注意到使用RoIAlign，使用步幅-32 C5功能（30.9 AP）比使用步幅-16 C4功能（30.3 AP，表2c）更准确。RoIAlign在很大程度上解决了使用大步功能进行检测和分割的长期挑战。最后，与FPN一起使用时，RoIAlign显示1.5掩模AP和0.5盒AP的增益，FPN具有更精细的多级步幅。对于需要精细对齐的关键点检测，RoIAlign即使使用FPN也显示出较大的增益（表6）。<br><img src="https://i.loli.net/2019/04/29/5cc65e0ebda46.png" alt="table3"><br><em>遮罩分支：分割是一个像素到像素的任务，我们通过使用FCN来利用遮罩的空间布局。在表2e中，我们使用ResNet-50-FPN主干比较了多层感知器（MLP）和FCN。使用FCN可以提供2.1 Mbps的AP掩码。我们注意到，我们选择了这个骨干，这样FCN头部的conv层没有经过预先训练，与MLP进行公平比较。</em></p>
<h2 id="4-3-Bounding-Box-Detection-Results"><a href="#4-3-Bounding-Box-Detection-Results" class="headerlink" title="4.3.Bounding Box Detection Results"></a>4.3.Bounding Box Detection Results</h2><p>我们将Mask R-CNN与表3中的最新COCO包围盒对象检测进行比较。对于这个结果，即使训练完整的Mask R-CNN模型，只有分类和框输出用于推理（掩码输出被忽略）。使用ResNet-101FPN的面罩R-CNN优于以前所有先进模型的基础变体，其中包括COMI 2016检测挑战赛获胜者GRMI [21]的单模型变体。使用ResNeXt-101-FPN，Mask R-CNN进一步改进了结果，与[39]（使用Inception-ResNet-v2-TDM）的最佳单一模型条目相比，框AP的余量为3.0分。<br>作为进一步的比较，我们训练了一个版本的掩模R-CNN，但没有掩模分支，表3中的“Faster R-CNN，RoIlign”表示。由于RoIlign的原因，该模型的性能比[27]中介绍的模型要好。另一方面，比面具R-CNN低0.9个盒子AP。因此掩模R-CNN在盒子检测上的差距仅仅是由于多任务训练的好处。<br>最后，我们注意到Mask R-CNN在其掩模和盒AP之间获得了一个小间隙：例如，在37.1（掩模，表1）和39.8（框3）之间的2.7个点。这表明我们的方法在很大程度上缩小了对象检测与更具挑战性的实例分割任务之间的差距。</p>
<h2 id="4-4-Timing"><a href="#4-4-Timing" class="headerlink" title="4.4.Timing"></a>4.4.Timing</h2><p>推论：我们训练了一个ResNet-101-FPN模型，该模型在R-CNN更快的四步训练之后训练RPN和Mask R-CNN阶段之间的特征[36]。Nvidia Tesla M40 GPU（加上15ms CPU时间，将输出调整为原始分辨率）时，该模型以195ms的速度运行，并实现与非共享模式相同的掩模AP。我们还报告说ResNet-101-C4变体需要400毫秒，因为它有一个较重的盒子头（图4），所以我们不建议在实践中使用C4变体。<br>尽管掩模R-CNN速度很快，但我们注意到我们的设计并未针对速度进行优化，并且可以实现更好的速度/精度折衷[21]，例如，通过改变图像尺寸和提案编号，这超出了本白皮书的范围。<br>训练：面具R-CNN训练也很快。在COCO trainval35k上使用ResNet-50-FPN进行培训的同步8 GPU实现需要32小时（每16图像微型批次0.72s），使用ResNet-101-FPN需要44小时。实际上，快速原型设计可以在不到一天的时间内在火车上进行训练时完成。我们希望这种快速培训能够消除该领域的一个主要障碍，并鼓励更多的人对这个具有挑战性的话题进行研究。</p>
<h1 id="5-Mask-R-CNN-for-Human-Pose-Estimation"><a href="#5-Mask-R-CNN-for-Human-Pose-Estimation" class="headerlink" title="5. Mask R-CNN for Human Pose Estimation"></a>5. Mask R-CNN for Human Pose Estimation</h1><p>我们的框架可以很容易地扩展到人体姿态估计。我们将一个关键点的位置建模为一个单独的热掩模，并采用掩模R-CNN预测K个掩模，每个K个关键点类型（例如左肩，右肘）各一个。这项任务有助于展示Mask R-CNN的灵活性。我们注意到，我们的系统利用了人类姿态的最小领域知识，因为实验主要是为了展示Mask R-CNN框架的一般性。我们期望领域知识（例如，建模结构[6]）将与我们简单的方法相辅相成。<br>实施细节：对关键点进行调整时，我们对细分系统进行细微修改。对于实例的每个K关键点，训练目标是一个热点二进制掩码，其中只有一个像素标记为前景。在训练过程中，对于每个可见的地面真值关键点，我们将 -way softmax输出的交叉熵损失最小化（鼓励[6]是2016年竞赛获胜者，使用多尺度测试，CPM后处理[使用两种模型（Inception-ResNet-1）对G-RMI进行COCO加MPII [1]（25k图像）的训练，并用目标检测器进行滤波，累加约5个点（在个人通信中加以澄清） v2用于边界框检测，ResNet-101用于关键点）。<br><img src="https://i.loli.net/2019/04/29/5cc65f4085801.png" alt="figure7"><br><em>图7.使用Mask R-CNN（ResNet-50-FPN）在COCO测试中的关键点检测结果，以及从相同模型预测的人分割掩码。该模型的关键点AP为63.1，运行速度为5 fps。</em></p>
<p>单点待检测）。我们注意到，与实例分割一样，K关键点仍然是独立处理的。我们采用ResNet-FPN变体，关键点头结构与图4（右）相似。关键点头由8个3×3 512-d的conv层组成，其后是去卷积层和2倍双线性放大，产生56×56的输出分辨率。我们发现对于关键点级别的定位精度需要相对较高的分辨率输出（与掩模相比）。<br>模型在所有包含注释关键点的COCO trainval35k图像上进行训练。为减少过度训练，由于训练集较小，我们使用从[640,800]像素中随机采样的图像比例进行训练;推断是在800像素的单一尺度上进行的。我们训练90k迭代，从0.02的学习率开始，在60k和80k迭代时将其减少10。我们使用边界框NMS，阈值为0.5。其他细节与§3.1中的相同。<br>主要结果和消融：我们评估人员关键点AP（APkp）并尝试使用ResNet-50-FPN主干;附录中将研究更多骨干。表4显示我们的结果（62.7 APkp）比使用多级处理管道的COCO 2016关键点检测获胜者[6]高0.9个点（见表4的标题）。我们的方法相当简单快捷。<br>更重要的是，我们有一个统一的模型，可以在5 fps下运行时同时预测盒子，分段和关键点。添加段分支（针对人员类别）将test-dev上的APkp值提高到63.1（表4）。表5中更多关于微型多任务学习的消除。将掩码分支添加到仅包装盒（即更快的R-CNN）或仅有关键点的版本可以持续改进这些任务。但是，添加关键点分支会略微减少盒/掩码AP，这表明虽然多任务训练可以实现关键点检测，但它不会帮助其他任务。不过，联合学习所有三项任务可以使统一系统同时有效地预测所有输出（图7）。我们还调查RoIAlign对关键点检测的影响（表6）。尽管ResNet-50-FPN骨干网有很大的进展（例如，在嵌套层面上有4个像素），但RoIAlign仍然显示出比RoIPool有显着的提高，APkp增加4.4点。这是因为关键点检测对定位精度更敏感。这再次表明，对齐对像素级本地化至关重要，包括掩码和关键点。<br><img src="https://i.loli.net/2019/04/29/5cc6605e29496.png" alt="table4/5/6"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_8</title>
    <url>/2019/04/26/2019-04-26-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。<br>这里只讨论内部排序，即默认内存空间足够大，可以存放下所有需要排序的数据。</p>
</blockquote>
<h1 id="简单排序（冒泡、插入）"><a href="#简单排序（冒泡、插入）" class="headerlink" title="简单排序（冒泡、插入）"></a>简单排序（冒泡、插入）</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从上到下比较两个相邻的泡泡，小在上，大在下则不动，否则交换顺序。这为第一趟冒泡，保证将最大的元素放到最下边，然后重复冒泡，直到所有元素均排好序。<br>最好情况：顺序T=O(N)<br>最坏情况：倒序T=O(N<sup>2</sup>)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>类比于打牌时抓牌的过程。<br>最好情况：顺序T=O(N)<br>最坏情况：倒序T=O(N<sup>2</sup>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InsertionSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 插入排序 */</span><br><span class="line">     int P, i;</span><br><span class="line">     ElementType Tmp;</span><br><span class="line">      </span><br><span class="line">     for ( P=1; P&lt;N; P++ ) &#123;</span><br><span class="line">         Tmp = A[P]; /* 取出未排序序列中的第一个元素*/</span><br><span class="line">         for ( i=P; i&gt;0 &amp;&amp; A[i-1]&gt;Tmp; i-- )</span><br><span class="line">             A[i] = A[i-1]; /*依次与已排序序列中元素比较并右移*/</span><br><span class="line">         A[i] = Tmp; /* 放进合适的位置 */</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h2><p>对于下标i&lt;j，如果A[i]&gt;A[j]，则称（i,j）是一对逆序对。<br>冒泡排序和插入排序中需要交换的次数即逆序对数，也就是每次交换消除一个逆序对。</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><img src="https://i.loli.net/2019/04/26/5cc2bed0950e0.png" alt="希尔排序"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 希尔排序 - 用Sedgewick增量序列 */</span><br><span class="line">     int Si, D, P, i;</span><br><span class="line">     ElementType Tmp;</span><br><span class="line">     /* 这里只列出一小部分增量 */</span><br><span class="line">     int Sedgewick[] = &#123;929, 505, 209, 109, 41, 19, 5, 1, 0&#125;;</span><br><span class="line">      </span><br><span class="line">     for ( Si=0; Sedgewick[Si]&gt;=N; Si++ ) </span><br><span class="line">         ; /* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span><br><span class="line"> </span><br><span class="line">     for ( D=Sedgewick[Si]; D&gt;0; D=Sedgewick[++Si] )</span><br><span class="line">         for ( P=D; P&lt;N; P++ ) &#123; /* 插入排序*/</span><br><span class="line">             Tmp = A[P];</span><br><span class="line">             for ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )</span><br><span class="line">                 A[i] = A[i-D];</span><br><span class="line">             A[i] = Tmp;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>在i从0到N的循环里，从A[i]到A[i-1]中找到最小元，并将其位置赋给MinPostion，将未排序部分的最小元换到有序部分的最后位置，即交换A[i]和A[MinPostion]。</p>
<h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><p>将找最小元用最小堆来解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Swap( ElementType *a, ElementType *b )</span><br><span class="line">&#123;</span><br><span class="line">     ElementType t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">void PercDown( ElementType A[], int p, int N )</span><br><span class="line">&#123; /* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span><br><span class="line">  /* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    X = A[p]; /* 取出根结点存放的值 */</span><br><span class="line">    for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2 + 1;</span><br><span class="line">        if( (Child!=N-1) &amp;&amp; (A[Child]&lt;A[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= A[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            A[Parent] = A[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    A[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void HeapSort( ElementType A[], int N ) </span><br><span class="line">&#123; /* 堆排序 */</span><br><span class="line">     int i;</span><br><span class="line">       </span><br><span class="line">     for ( i=N/2-1; i&gt;=0; i-- )/* 建立最大堆 */</span><br><span class="line">         PercDown( A, i, N );</span><br><span class="line">      </span><br><span class="line">     for ( i=N-1; i&gt;0; i-- ) &#123;</span><br><span class="line">         /* 删除最大堆顶 */</span><br><span class="line">         Swap( &amp;A[0], &amp;A[i] ); /* 见代码7.1 */</span><br><span class="line">         PercDown( A, 0, i );</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>核心：有序子列的归并</p>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>分而治之，T(N)=O(NlogN)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 归并排序 - 递归实现 */</span><br><span class="line"> </span><br><span class="line">/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/</span><br><span class="line">void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd )</span><br><span class="line">&#123; /* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */</span><br><span class="line">     int LeftEnd, NumElements, Tmp;</span><br><span class="line">     int i;</span><br><span class="line">      </span><br><span class="line">     LeftEnd = R - 1; /* 左边终点位置 */</span><br><span class="line">     Tmp = L;         /* 有序序列的起始位置 */</span><br><span class="line">     NumElements = RightEnd - L + 1;</span><br><span class="line">      </span><br><span class="line">     while( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) &#123;</span><br><span class="line">         if ( A[L] &lt;= A[R] )</span><br><span class="line">             TmpA[Tmp++] = A[L++]; /* 将左边元素复制到TmpA */</span><br><span class="line">         else</span><br><span class="line">             TmpA[Tmp++] = A[R++]; /* 将右边元素复制到TmpA */</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     while( L &lt;= LeftEnd )</span><br><span class="line">         TmpA[Tmp++] = A[L++]; /* 直接复制左边剩下的 */</span><br><span class="line">     while( R &lt;= RightEnd )</span><br><span class="line">         TmpA[Tmp++] = A[R++]; /* 直接复制右边剩下的 */</span><br><span class="line">          </span><br><span class="line">     for( i = 0; i &lt; NumElements; i++, RightEnd -- )</span><br><span class="line">         A[RightEnd] = TmpA[RightEnd]; /* 将有序的TmpA[]复制回A[] */</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Msort( ElementType A[], ElementType TmpA[], int L, int RightEnd )</span><br><span class="line">&#123; /* 核心递归排序函数 */ </span><br><span class="line">     int Center;</span><br><span class="line">      </span><br><span class="line">     if ( L &lt; RightEnd ) &#123;</span><br><span class="line">          Center = (L+RightEnd) / 2;</span><br><span class="line">          Msort( A, TmpA, L, Center );              /* 递归解决左边 */ </span><br><span class="line">          Msort( A, TmpA, Center+1, RightEnd );     /* 递归解决右边 */  </span><br><span class="line">          Merge( A, TmpA, L, Center+1, RightEnd );  /* 合并两段有序序列 */ </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MergeSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 归并排序 */</span><br><span class="line">     ElementType *TmpA;</span><br><span class="line">     TmpA = (ElementType *)malloc(N*sizeof(ElementType));</span><br><span class="line">      </span><br><span class="line">     if ( TmpA != NULL ) &#123;</span><br><span class="line">          Msort( A, TmpA, 0, N-1 );</span><br><span class="line">          free( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     else printf( &quot;空间不足&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 归并排序 - 循环实现 */</span><br><span class="line">/* 这里Merge函数在递归版本中给出 */</span><br><span class="line"> </span><br><span class="line">/* length = 当前有序子列的长度*/</span><br><span class="line">void Merge_pass( ElementType A[], ElementType TmpA[], int N, int length )</span><br><span class="line">&#123; /* 两两归并相邻有序子列 */</span><br><span class="line">     int i, j;</span><br><span class="line">       </span><br><span class="line">     for ( i=0; i &lt;= N-2*length; i += 2*length )</span><br><span class="line">         Merge( A, TmpA, i, i+length, i+2*length-1 );</span><br><span class="line">     if ( i+length &lt; N ) /* 归并最后2个子列*/</span><br><span class="line">         Merge( A, TmpA, i, i+length, N-1);</span><br><span class="line">     else /* 最后只剩1个子列*/</span><br><span class="line">         for ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Merge_Sort( ElementType A[], int N )</span><br><span class="line">&#123; </span><br><span class="line">     int length; </span><br><span class="line">     ElementType *TmpA;</span><br><span class="line">      </span><br><span class="line">     length = 1; /* 初始化子序列长度*/</span><br><span class="line">     TmpA = malloc( N * sizeof( ElementType ) );</span><br><span class="line">     if ( TmpA != NULL ) &#123;</span><br><span class="line">          while( length &lt; N ) &#123;</span><br><span class="line">              Merge_pass( A, TmpA, N, length );</span><br><span class="line">              length *= 2;</span><br><span class="line">              Merge_pass( TmpA, A, N, length );</span><br><span class="line">              length *= 2;</span><br><span class="line">          &#125;</span><br><span class="line">          free( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     else printf( &quot;空间不足&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>中关村科学城的兴起(1953-1966)</title>
    <url>/2019/04/25/2019-04-25-%E4%B8%AD%E5%85%B3%E6%9D%91%E7%A7%91%E5%AD%A6%E5%9F%8E%E7%9A%84%E5%85%B4%E8%B5%B7/</url>
    <content><![CDATA[<blockquote>
<p>《中关村科学城的兴起(1953-1966)》由胡亚东/郑哲敏/严陆光等口述/杨小林访问整理，湖南教育出版社出版，是20世纪中国科学口述史中其中一部，在此感谢！<br>《中关村科学城的兴起(1953-1966)》选择亲历中国20世纪科学技术发展史的中国著名科学家作为主要访谈对象，本求真之原则，记录其亲历亲闻的史实，并按大致统一的编例整理成书稿。</p>
</blockquote>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本书有意只说1953一1966年这一段，涉及中关村的前史很少，涉及“文革”以后的文字也不多。受访者们，从当年的老乡长到当年的小学生，都曾经是中关衬里的“村民”，是中关村历史变迁约见证人。看访问整理者的编排，书中大体上是循着历史变迁的顺序，讲述一座座科研大楼，一个个研究所，是何时和怎样在这块土地上出现的。其中也讲述了在这里工作和栖居过那些著名的科学家，还捎带着提及与人们日常生活息息相关的基础生活设施的建设，但重点不在系统叙述这里发生过的科研活动和作出的科学贡献。总起来说，是通过亲历者的回忆，让人们认识到科学城中建筑物的布局、研究所的兴革和社区的变迁，以此来展现这座“城“的发展轨迹。</p>
<h1 id="第一篇-村与城"><a href="#第一篇-村与城" class="headerlink" title="第一篇 村与城"></a>第一篇 村与城</h1><h2 id="1-老乡长话中关"><a href="#1-老乡长话中关" class="headerlink" title="1.老乡长话中关"></a>1.老乡长话中关</h2><p>受访人：邓启祥，1954年担任保福寺乡乡长，1955年在中科院化学所工作。<br>主要回顾了保福寺附近区域当年的一些行政、地理情况。</p>
<h2 id="2-蓝图中的科学宫和科学城"><a href="#2-蓝图中的科学宫和科学城" class="headerlink" title="2.蓝图中的科学宫和科学城"></a>2.蓝图中的科学宫和科学城</h2><p>受访人：姜虎文，1954年调入中科院。<br>主要阐述了中科院的选址规划。</p>
<h1 id="第二篇-早期奠基"><a href="#第二篇-早期奠基" class="headerlink" title="第二篇 早期奠基"></a>第二篇 早期奠基</h1><h2 id="3-入住中关村的科学院第一人"><a href="#3-入住中关村的科学院第一人" class="headerlink" title="3.入住中关村的科学院第一人"></a>3.入住中关村的科学院第一人</h2><p>受访人：丘宝剑，中国科学院地理研究所研究员。<br>调入《中华地理志》编辑部，编辑部刚成立时没有地方办公，后来在西郊给社科四所（社会所，近代史所，考古所，语言所）造的房子建好，就搬过去。此地原本叫“中官屯”，编辑部调来一个老文书，负责对外联系，是上海人，听不太懂北京话，问周围老百姓，听成了“中关村”，打印了一批信封、信纸，当时搞“三反”，怕落下“反浪费”罪名，就没改，后来陆续搬来其他所也就都跟着叫了。<br>关于“中官”：有说指太监，有说指中小官员，皇帝在圆明园办公，大员不敢住太远，在附近造房子，剩下的中小官员就在此等着召见，搭个房子之类的。</p>
<h2 id="4-原子能楼"><a href="#4-原子能楼" class="headerlink" title="4.原子能楼"></a>4.原子能楼</h2><p>受访人：叶铭汉，中国工程院院士。<br>清华毕业后在中国科学院近代物理所参加工作，53年改名为物理所，58年改称“原子能研究所”。在中关村建大楼52年开始，53年底54年陆续搬了进来。</p>
<h2 id="5-地球物理研究所"><a href="#5-地球物理研究所" class="headerlink" title="5.地球物理研究所"></a>5.地球物理研究所</h2><p>受访人：朱岗崑，中国科学院地球物理研究所研究员。<br>原为中央研究院气象研究所，气象所在1950年改名为地球物理研究所，所长赵九章，1954年下半年大楼盖好，本部从南京搬来。<br>受访人：吴智诚，曾任中国科学院空间物理研究所党委书记。<br>赵九章先生从事气象、地震、海浪，58年之后主要负责了人造卫星，成立“581”领导小组。<br>空间中心的前身大部分是空间物理所，许多学科骨干都是赵九章带出来的。1997年，42位院士联名为赵九章树立铜像，目前在空间中心大厅内。</p>
<h2 id="6-化学研究所"><a href="#6-化学研究所" class="headerlink" title="6.化学研究所"></a>6.化学研究所</h2><h2 id="7-生物楼：昆虫研究所与动物研究所"><a href="#7-生物楼：昆虫研究所与动物研究所" class="headerlink" title="7.生物楼：昆虫研究所与动物研究所"></a>7.生物楼：昆虫研究所与动物研究所</h2><h2 id="8-力学研究所"><a href="#8-力学研究所" class="headerlink" title="8.力学研究所"></a>8.力学研究所</h2><h1 id="第三篇-“火车头”时代"><a href="#第三篇-“火车头”时代" class="headerlink" title="第三篇 “火车头”时代"></a>第三篇 “火车头”时代</h1><h2 id="9-数学研究所与计算技术研究所"><a href="#9-数学研究所与计算技术研究所" class="headerlink" title="9.数学研究所与计算技术研究所"></a>9.数学研究所与计算技术研究所</h2><p>受访人：许孔时，曾任计算技术研究所副所长，软件研究所所长。<br>数学所筹备处是1950年6月成立的，1952年数学所正式成立，所址在清华园内。1953年数学所成立了一个计算组，1956年在这个组的基础上成立了计算技术研究所，计算所正式成立是1959年，1965年又成立了计算所二部，66年分了出去，成立了微电子学研究所，1985年又有一部分调出，成立了软件所。<br>科学院的头一台就是1958年的103机，苏联援助中国的第一台计算机的资料叫M3，电子管，每秒运算8次，中国人真是聪明，拿过图纸，稍微把电路改进、设计一下，每秒就200次了，这就是103机。</p>
<h2 id="10-化工冶金研究所"><a href="#10-化工冶金研究所" class="headerlink" title="10.化工冶金研究所"></a>10.化工冶金研究所</h2><h2 id="11-电子学研究所"><a href="#11-电子学研究所" class="headerlink" title="11.电子学研究所"></a>11.电子学研究所</h2><h2 id="12-声学研究所"><a href="#12-声学研究所" class="headerlink" title="12.声学研究所"></a>12.声学研究所</h2><h2 id="13-生物物理研究所"><a href="#13-生物物理研究所" class="headerlink" title="13.生物物理研究所"></a>13.生物物理研究所</h2><h2 id="14-微生物研究所"><a href="#14-微生物研究所" class="headerlink" title="14.微生物研究所"></a>14.微生物研究所</h2><h2 id="15-生物物理研究所"><a href="#15-生物物理研究所" class="headerlink" title="15.生物物理研究所"></a>15.生物物理研究所</h2><h2 id="16-自动化研究所"><a href="#16-自动化研究所" class="headerlink" title="16.自动化研究所"></a>16.自动化研究所</h2><h2 id="17-物理研究所"><a href="#17-物理研究所" class="headerlink" title="17.物理研究所"></a>17.物理研究所</h2><h2 id="18-电工研究所"><a href="#18-电工研究所" class="headerlink" title="18.电工研究所"></a>18.电工研究所</h2><h1 id="第四篇-社区与“特楼”"><a href="#第四篇-社区与“特楼”" class="headerlink" title="第四篇 社区与“特楼”"></a>第四篇 社区与“特楼”</h1><h2 id="19-回忆早年的中关村"><a href="#19-回忆早年的中关村" class="headerlink" title="19.回忆早年的中关村"></a>19.回忆早年的中关村</h2><p>受访人：李佩，曾任中科院西郊办公室第一任副主任，中国科学院研究生院英语系主任。<br>当时西郊办公室，都是一些公共事务，管的时期很多。比如请派出所到中关村办公，建粮店，半合作社，建中关村医院等。<br>这一代人，已经走了不少了。活着的也都在八九十岁。我们人与人之间有深厚的感情，对这块地儿也有深厚的感情。住事历历在目，这块地儿住过这么一些人，那么多年发生了那么多的事，若能放到一起，可能够装一个博物馆的。</p>
<h2 id="20-早年中关村的一些服务设施"><a href="#20-早年中关村的一些服务设施" class="headerlink" title="20.早年中关村的一些服务设施"></a>20.早年中关村的一些服务设施</h2><h2 id="21-“特楼”往事"><a href="#21-“特楼”往事" class="headerlink" title="21.“特楼”往事"></a>21.“特楼”往事</h2><p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析与展示_1</title>
    <url>/2019/04/23/2019-04-23-Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA_1/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/BIT-1001870002?tid=1206192225#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢北理授课大佬。</p>
</blockquote>
<h1 id="单元1：NumPy库入门"><a href="#单元1：NumPy库入门" class="headerlink" title="单元1：NumPy库入门"></a>单元1：NumPy库入门</h1><p>数据维度的Python表示：</p>
<ul>
<li>一维数据：列表和集合(无序)类型</li>
<li>多维数据：多维列表类型</li>
<li>高维数据：字典类型或数据表示格式（json,xml.yaml）</li>
</ul>
<p>NumPy是一个开源的Python科学计算基础库。</p>
<ul>
<li>一个强大的N维数组对象 ndarray</li>
<li>广播功能函数</li>
<li>整合C/C++/Fortran代码的工具</li>
<li>线性代数、傅里叶变换、随机生成树等功能</li>
</ul>
<p>NumPy是SciPy、Pandas等数据处理或科学计算库的基础。</p>
<p><strong>引用：</strong> import numpy as np(建议使用上述约定的别名)</p>
<p><strong>ndarray:</strong> 是一个多维数组类型，由两部分构成：1）实际的数据；2）描述这些数据的元数据，如数据维度、数据类型等。ndarray数组一般要求所有元素类型相同，数组下标从0开始。</p>
<p>轴（axis）:保存数据的维度<br>秩（rank）:轴的数量</p>
<ol>
<li>创建</li>
</ol>
<ul>
<li><p>从Python中的列表、元祖等类型创建ndarray数组；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x=np.array(list/tuple)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>使用NumPy中函数创建ndarray数组；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.arange(n)：类似range()函数；</span><br><span class="line">np.ones(shape):根据shape生产一个全1数组；</span><br><span class="line">np.zeros(shape):根据shape生产一个全0数组；</span><br><span class="line">np.full(shape,val):根据shape生产一个数组，每个元素值都是val；</span><br><span class="line">np.eye(n):创建一个n*n的单位矩阵，对角线为1，其余全为0；</span><br><span class="line">np.linspace():根据起止数据等间距的填充数据，形成数组；</span><br><span class="line">np.concatenate():将两个或多个数组合并成一个新的数组；</span><br></pre></td></tr></table></figure>

<ul>
<li>从字节流中创建ndarray数组；</li>
<li>从文件中读取特定格式，创建ndarray数组；</li>
</ul>
<ol start="2">
<li>维度变换<br>.reshape(shape):不改变数组元素，返回一个shape形状的数组，原数组不变；<br>.resize(shape):同上，但修改原数组；<br>.swapaxes(ax1,ax2):将数组n个维度中两个维度进行调换；<br>.flatten():对数组进行降维，返回折叠后的一维数组，原数组不变；</li>
<li>类型转换<br>.astype(new_type):数组的类型转换</li>
<li>数组转为列表<br>.tolist（）</li>
<li>操作：索引、切片</li>
<li>运算<br>数组与标量之间的运算作用于数组中每一个元素。<br>一元函数运算，二元函数运算</li>
</ol>
<h1 id="单元2：NumPy数据存取与函数"><a href="#单元2：NumPy数据存取与函数" class="headerlink" title="单元2：NumPy数据存取与函数"></a>单元2：NumPy数据存取与函数</h1><h2 id="数据的csv文件存取"><a href="#数据的csv文件存取" class="headerlink" title="数据的csv文件存取"></a>数据的csv文件存取</h2><p>csv文件：逗号分隔值文件。只能有效存储一维和二维数据。<br><strong>将ndarray保存为csv：</strong><br>np.savetxt(frame,array,fmt=’%.18e’,delimiter=None)<br>frame:文件、字符串或产生器；<br>array:存入文件的数组；<br>fmt:写入文件的格式；<br>delimiter：分割字符串，默认是空格；<br><strong>将csv写入ndarray：</strong><br>np.loadtxt(frame,dtype=np.float,delimiter=None,unpack=False)<br>unpack:默认False，如为True,读入属性将分别写入不同变量；</p>
<h2 id="多维数据的存取"><a href="#多维数据的存取" class="headerlink" title="多维数据的存取"></a>多维数据的存取</h2><p><strong>生成文件：</strong><br>a.tofile(frame,sep=’’,format=’%s’)<br>sep:数据分割字符串，如为空，则生成一个二进制文件，而不是文本文件；<br>format:写入数据的格式；<br><strong>还原数据：</strong><br>np.fromfile(frame,dtype=float,count=-1,sep=’’)<br>count:读入元素个数，-1表示读入整个文件;<br><strong>NumPy的便捷文件存取：</strong><br>np.save(fname,array)或np.savez(fname,array)<br>frame:文件名，以.npy为扩展名，压缩扩展名为.npz；<br>np.load(fname)</p>
<h2 id="NumPy的随机数函数"><a href="#NumPy的随机数函数" class="headerlink" title="NumPy的随机数函数"></a>NumPy的随机数函数</h2><p>random子库中的的随机数基本函数：rand/randn/randint/seed;<br>random子库中的的随机数高级函数：shuffle/permutation/choice;<br>带有分布的高级函数：uniform/normal/poisson;</p>
<h2 id="NumPy的统计函数"><a href="#NumPy的统计函数" class="headerlink" title="NumPy的统计函数"></a>NumPy的统计函数</h2><p>常用统计函数：sum/mean/average/std/var;<br>其他统计函数：min/max/argmin/argmax/unravel_index/ptp/median;</p>
<h2 id="NumPy的梯度函数"><a href="#NumPy的梯度函数" class="headerlink" title="NumPy的梯度函数"></a>NumPy的梯度函数</h2><p>np.gradient(f):计算数组f中元素的梯度，当f为多维时，返回每个维度梯度，梯度，即斜率；</p>
<h1 id="单元3：实例：图像的手绘效果"><a href="#单元3：实例：图像的手绘效果" class="headerlink" title="单元3：实例：图像的手绘效果"></a>单元3：实例：图像的手绘效果</h1><h2 id="图像的数组表示"><a href="#图像的数组表示" class="headerlink" title="图像的数组表示"></a>图像的数组表示</h2><p>RGB色彩模式，每个通道0-255。<br>PIL,Python Image Library,一个具有强大图像处理能力的第三方库。<br>from PIL import Image:Image是PIL库中代表一个图像的类（对象）<br>图像是一个由像素组成的二维矩阵，每个元素是一个RGB值。</p>
<h2 id="图像的变换"><a href="#图像的变换" class="headerlink" title="图像的变换"></a>图像的变换</h2><p>读入图像，修改RGB值，修改后保存为新的图像。</p>
<h2 id="图像手绘效果实例"><a href="#图像手绘效果实例" class="headerlink" title="图像手绘效果实例"></a>图像手绘效果实例</h2><p>特征：黑白灰色；边界线条较重；相同或相近颜色趋于白色；略有光源效果；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line"> </span><br><span class="line">a = np.asarray(Image.open(&apos;./beijing.jpg&apos;).convert(&apos;L&apos;)).astype(&apos;float&apos;)</span><br><span class="line"> </span><br><span class="line">depth = 10.                      # (0-100)</span><br><span class="line">grad = np.gradient(a)             #取图像灰度的梯度值</span><br><span class="line">grad_x, grad_y = grad               #分别取横纵图像梯度值</span><br><span class="line">grad_x = grad_x*depth/100.</span><br><span class="line">grad_y = grad_y*depth/100.</span><br><span class="line">A = np.sqrt(grad_x**2 + grad_y**2 + 1.)</span><br><span class="line">uni_x = grad_x/A</span><br><span class="line">uni_y = grad_y/A</span><br><span class="line">uni_z = 1./A</span><br><span class="line"> </span><br><span class="line">vec_el = np.pi/2.2                   # 光源的俯视角度，弧度值</span><br><span class="line">vec_az = np.pi/4.                    # 光源的方位角度，弧度值</span><br><span class="line">dx = np.cos(vec_el)*np.cos(vec_az)   #光源对x 轴的影响</span><br><span class="line">dy = np.cos(vec_el)*np.sin(vec_az)   #光源对y 轴的影响</span><br><span class="line">dz = np.sin(vec_el)              #光源对z 轴的影响</span><br><span class="line"> </span><br><span class="line">b = 255*(dx*uni_x + dy*uni_y + dz*uni_z)     #光源归一化</span><br><span class="line">b = b.clip(0,255)</span><br><span class="line"> </span><br><span class="line">im = Image.fromarray(b.astype(&apos;uint8&apos;))  #重构图像</span><br><span class="line">im.save(&apos;./beijingHD.jpg&apos;)</span><br></pre></td></tr></table></figure>



<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>MOOC</tag>
        <tag>数据分析与展示</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_7</title>
    <url>/2019/04/22/2019-04-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li>是一棵树</li>
</ol>
<ul>
<li>无回路</li>
<li>|v|个顶点一定有|v|-1条边</li>
</ul>
<ol start="2">
<li>是生成树</li>
</ol>
<ul>
<li>包含所有顶点</li>
<li>|v|-1条边都在图里</li>
<li>向生成树中任加一条边都一定构成回路</li>
</ul>
<ol start="3">
<li>最小</li>
</ol>
<ul>
<li>边的权重和最小</li>
</ul>
<h2 id="如何构建"><a href="#如何构建" class="headerlink" title="如何构建"></a>如何构建</h2><p>贪心算法：每次找权值最小的边，但有约束：</p>
<ul>
<li>只能用图里有的边</li>
<li>只能正好用掉v-1条边</li>
<li>不能有回路</li>
</ul>
<ol>
<li>Prim算法–让一颗小树长大</li>
</ol>
<p>适合稠密图，时间复杂度O(|V|<sup>2</sup>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 邻接矩阵存储 - Prim最小生成树算法 */</span><br><span class="line">  </span><br><span class="line"> Vertex FindMinDist( MGraph Graph, WeightType dist[] )</span><br><span class="line"> &#123; /* 返回未被收录顶点中dist最小者 */</span><br><span class="line">     Vertex MinV, V;</span><br><span class="line">     WeightType MinDist = INFINITY;</span><br><span class="line">  </span><br><span class="line">     for (V=0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">         if ( dist[V]!=0 &amp;&amp; dist[V]&lt;MinDist) &#123;</span><br><span class="line">             /* 若V未被收录，且dist[V]更小 */</span><br><span class="line">             MinDist = dist[V]; /* 更新最小距离 */</span><br><span class="line">             MinV = V; /* 更新对应顶点 */</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if (MinDist &lt; INFINITY) /* 若找到最小dist */</span><br><span class="line">         return MinV; /* 返回对应的顶点下标 */</span><br><span class="line">     else return ERROR;  /* 若这样的顶点不存在，返回-1作为标记 */</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> int Prim( MGraph Graph, LGraph MST )</span><br><span class="line"> &#123; /* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */</span><br><span class="line">     WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">     Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">     int VCount;</span><br><span class="line">     Edge E;</span><br><span class="line">      </span><br><span class="line">     /* 初始化。默认初始点下标是0 */</span><br><span class="line">        for (V=0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">         /* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY */</span><br><span class="line">            dist[V] = Graph-&gt;G[0][V];</span><br><span class="line">            parent[V] = 0; /* 暂且定义所有顶点的父结点都是初始点0 */ </span><br><span class="line">     &#125;</span><br><span class="line">     TotalWeight = 0; /* 初始化权重和     */</span><br><span class="line">     VCount = 0;      /* 初始化收录的顶点数 */</span><br><span class="line">     /* 创建包含所有顶点但没有边的图。注意用邻接表版本 */</span><br><span class="line">     MST = CreateGraph(Graph-&gt;Nv);</span><br><span class="line">     E = (Edge)malloc( sizeof(struct ENode) ); /* 建立空的边结点 */</span><br><span class="line">             </span><br><span class="line">     /* 将初始点0收录进MST */</span><br><span class="line">     dist[0] = 0;</span><br><span class="line">     VCount ++;</span><br><span class="line">     parent[0] = -1; /* 当前树根是0 */</span><br><span class="line">  </span><br><span class="line">     while (1) &#123;</span><br><span class="line">         V = FindMinDist( Graph, dist );</span><br><span class="line">         /* V = 未被收录顶点中dist最小者 */</span><br><span class="line">         if ( V==ERROR ) /* 若这样的V不存在 */</span><br><span class="line">             break;   /* 算法结束 */</span><br><span class="line">              </span><br><span class="line">         /* 将V及相应的边&lt;parent[V], V&gt;收录进MST */</span><br><span class="line">         E-&gt;V1 = parent[V];</span><br><span class="line">         E-&gt;V2 = V;</span><br><span class="line">         E-&gt;Weight = dist[V];</span><br><span class="line">         InsertEdge( MST, E );</span><br><span class="line">         TotalWeight += dist[V];</span><br><span class="line">         dist[V] = 0;</span><br><span class="line">         VCount++;</span><br><span class="line">          </span><br><span class="line">         for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */</span><br><span class="line">             if ( dist[W]!=0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;</span><br><span class="line">             /* 若W是V的邻接点并且未被收录 */</span><br><span class="line">                 if ( Graph-&gt;G[V][W] &lt; dist[W] ) &#123;</span><br><span class="line">                 /* 若收录V使得dist[W]变小 */</span><br><span class="line">                     dist[W] = Graph-&gt;G[V][W]; /* 更新dist[W] */</span><br><span class="line">                     parent[W] = V; /* 更新树 */</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125; /* while结束*/</span><br><span class="line">     if ( VCount &lt; Graph-&gt;Nv ) /* MST中收的顶点不到|V|个 */</span><br><span class="line">        TotalWeight = ERROR;</span><br><span class="line">     return TotalWeight;   /* 算法执行完毕，返回最小权重和或错误标记 */</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Kruskal算法–将森林合并成树</li>
</ol>
<p>适合稀疏图，时间复杂度最小可为O(|E|Log|E|)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 邻接表存储 - Kruskal最小生成树算法 */</span><br><span class="line"> </span><br><span class="line">/*-------------------- 顶点并查集定义 --------------------*/</span><br><span class="line">typedef Vertex ElementType; /* 默认元素可以用非负整数表示 */</span><br><span class="line">typedef Vertex SetName;     /* 默认用根结点的下标作为集合名称 */</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; /* 假设集合元素下标从0开始 */</span><br><span class="line"> </span><br><span class="line">void InitializeVSet( SetType S, int N )</span><br><span class="line">&#123; /* 初始化并查集 */</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    for ( X=0; X&lt;N; X++ ) S[X] = -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Union( SetType S, SetName Root1, SetName Root2 )</span><br><span class="line">&#123; /* 这里默认Root1和Root2是不同集合的根结点 */</span><br><span class="line">    /* 保证小集合并入大集合 */</span><br><span class="line">    if ( S[Root2] &lt; S[Root1] ) &#123; /* 如果集合2比较大 */</span><br><span class="line">        S[Root2] += S[Root1];     /* 集合1并入集合2  */</span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                         /* 如果集合1比较大 */</span><br><span class="line">        S[Root1] += S[Root2];     /* 集合2并入集合1  */</span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SetName Find( SetType S, ElementType X )</span><br><span class="line">&#123; /* 默认集合元素全部初始化为-1 */</span><br><span class="line">    if ( S[X] &lt; 0 ) /* 找到集合的根 */</span><br><span class="line">        return X;</span><br><span class="line">    else</span><br><span class="line">        return S[X] = Find( S, S[X] ); /* 路径压缩 */</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )</span><br><span class="line">&#123; /* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 */</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"> </span><br><span class="line">    Root1 = Find( VSet, V1 ); /* 得到V1所属的连通集名称 */</span><br><span class="line">    Root2 = Find( VSet, V2 ); /* 得到V2所属的连通集名称 */</span><br><span class="line"> </span><br><span class="line">    if( Root1==Root2 ) /* 若V1和V2已经连通，则该边不能要 */</span><br><span class="line">        return false;</span><br><span class="line">    else &#123; /* 否则该边可以被收集，同时将V1和V2并入同一连通集 */</span><br><span class="line">        Union( VSet, Root1, Root2 );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*-------------------- 并查集定义结束 --------------------*/</span><br><span class="line"> </span><br><span class="line">/*-------------------- 边的最小堆定义 --------------------*/</span><br><span class="line">void PercDown( Edge ESet, int p, int N )</span><br><span class="line">&#123; /* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span><br><span class="line">  /* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"> </span><br><span class="line">    X = ESet[p]; /* 取出根结点存放的值 */</span><br><span class="line">    for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2 + 1;</span><br><span class="line">        if( (Child!=N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较小者 */</span><br><span class="line">        if( X.Weight &lt;= ESet[Child].Weight ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            ESet[Parent] = ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void InitializeESet( LGraph Graph, Edge ESet )</span><br><span class="line">&#123; /* 将图的边存入数组ESet，并且初始化为最小堆 */</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"> </span><br><span class="line">    /* 将图的边存入数组ESet */</span><br><span class="line">    ECount = 0;</span><br><span class="line">    for ( V=0; V&lt;Graph-&gt;Nv; V++ )</span><br><span class="line">        for ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next )</span><br><span class="line">            if ( V &lt; W-&gt;AdjV ) &#123; /* 避免重复录入无向图的边，只收V1&lt;V2的边 */</span><br><span class="line">                ESet[ECount].V1 = V;</span><br><span class="line">                ESet[ECount].V2 = W-&gt;AdjV;</span><br><span class="line">                ESet[ECount++].Weight = W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    /* 初始化为最小堆 */</span><br><span class="line">    for ( ECount=Graph-&gt;Ne/2; ECount&gt;=0; ECount-- )</span><br><span class="line">        PercDown( ESet, ECount, Graph-&gt;Ne );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int GetEdge( Edge ESet, int CurrentSize )</span><br><span class="line">&#123; /* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 */</span><br><span class="line"> </span><br><span class="line">    /* 将最小边与当前堆的最后一个位置的边交换 */</span><br><span class="line">    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);</span><br><span class="line">    /* 将剩下的边继续调整成最小堆 */</span><br><span class="line">    PercDown( ESet, 0, CurrentSize-1 );</span><br><span class="line"> </span><br><span class="line">    return CurrentSize-1; /* 返回最小边所在位置 */</span><br><span class="line">&#125;</span><br><span class="line">/*-------------------- 最小堆定义结束 --------------------*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int Kruskal( LGraph Graph, LGraph MST )</span><br><span class="line">&#123; /* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; /* 顶点数组 */</span><br><span class="line">    Edge ESet;    /* 边数组 */</span><br><span class="line"> </span><br><span class="line">    InitializeVSet( VSet, Graph-&gt;Nv ); /* 初始化顶点并查集 */</span><br><span class="line">    ESet = (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );</span><br><span class="line">    InitializeESet( Graph, ESet ); /* 初始化边的最小堆 */</span><br><span class="line">    /* 创建包含所有顶点但没有边的图。注意用邻接表版本 */</span><br><span class="line">    MST = CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight = 0; /* 初始化权重和     */</span><br><span class="line">    ECount = 0;      /* 初始化收录的边数 */</span><br><span class="line"> </span><br><span class="line">    NextEdge = Graph-&gt;Ne; /* 原始边集的规模 */</span><br><span class="line">    while ( ECount &lt; Graph-&gt;Nv-1 ) &#123;  /* 当收集的边不足以构成树时 */</span><br><span class="line">        NextEdge = GetEdge( ESet, NextEdge ); /* 从边集中得到最小边的位置 */</span><br><span class="line">        if (NextEdge &lt; 0) /* 边集已空 */</span><br><span class="line">            break;</span><br><span class="line">        /* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */</span><br><span class="line">        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )==true ) &#123;</span><br><span class="line">            /* 将该边插入MST */</span><br><span class="line">            InsertEdge( MST, ESet+NextEdge );</span><br><span class="line">            TotalWeight += ESet[NextEdge].Weight; /* 累计权重 */</span><br><span class="line">            ECount++; /* 生成树中边数加1 */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( ECount &lt; Graph-&gt;Nv-1 )</span><br><span class="line">        TotalWeight = -1; /* 设置错误标记，表示生成树不存在 */</span><br><span class="line"> </span><br><span class="line">    return TotalWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Self-supervised Multi-level Face Model Learning for Monocular Reconstruction at over 250 Hz</title>
    <url>/2019/04/16/2019-04-16-Self-supervised%20Multi-level%20Face%20Model%20Learning%20for%20Monocular%20Reconstruction%20at%20over%20250%20Hz/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="http://gvv.mpi-inf.mpg.de/projects/FML/" target="_blank" rel="noopener">http://gvv.mpi-inf.mpg.de/projects/FML/</a><br>本文由马克斯-普朗克研究所和斯坦福大学等机构合作完成，是 CVPR 2018 的 oral 文章。<br>为了提升单张图片重建 3D 脸部模型的效果，该论文采用了多层次的脸部结构重建方法，作者把传统的基于参数化 3D 可变形模型（3DMM）作为基础模型，在此之上引入纠正模型来增加模型的表达力。实验表明纠正模型使得 3D 脸部重建效果更接近原图，而且能重建出更多细节。<br>基础模型与纠正模型均为线性模型，其中基础模型的基向量通过对训练样本做 PCA 得到（即 3DMM 模型），而纠正模型的基向量由神经网络直接学习得到。脸部的形状与纹理通过基础模型加上纠正模型来拟合。算法使用编码器来学习基础模型和纠正模型的组合参数。随后整合两个模型的结果，通过解码器得到渲染的 3D 脸部模型。然后，算法把 3D 模型成像，对比成像结果与输入图片的差异，目标是使差异变小，因此该方法是自监督的方式进行训练。此外，算法还限制了成像结果与输入图的脸部特征点要对齐。注意该方法中只有编码器是可学习的，而解码器和渲染器都是手工设计的可导层，不是可学习的。为了让模型更加鲁棒和训练过程更加稳定，作者在损失函数上加入额外调节项，用于提升纠正模型的平滑性、纹理的稀疏性和整体一致性。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/20190415173416703.png" alt="figure0"><br>我们的新型单目重建方法高质量地估计了面部几何形状，皮肤反射率(包括面部毛发)和超过250赫兹的入射光。利用前馈反渲染网络，学习了一种可训练的多层人脸表示方法。端到端训练基于自我监督的损失，不需要密集的地面实况。</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p><em>从一张单一的图像中重建密集的人脸几何和外观三维模型是非常具有挑战性和不适定的。为了约束该问题，许多方法依赖于强先验，如从有限的三维扫描数据中学习的参数化人脸模型。然而，先验的模型限制了人脸几何、皮肤反射率和光照的真实多样性的泛化。为了解决这一问题，我们提出了一种联合学习方法1)人脸形状、表情、反射率和光照的回归器的方法。2)基于并行学习的参数化人脸模型。我们的多层人脸模型结合了3D 可变形模型（3DMM）的正则化优势和学习校正空间的空间外泛化。我们的多层人脸模型结合了三维形态模型的正则化优势和学习校正空间的空间外泛化。我们通过在多层细节级别上定义的专家设计的可微渲染器来融合卷积编码器，以及自监督训练损失，在没有密集注释的自然环境图像上进行端到端的训练。我们的方法在重建质量上优于目前的技术水平，可以更好地推广到真实世界的人脸，运行频率超过250赫兹。</em></p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><p>在过去的几十年里，单目人脸重建在计算机视觉和图形学领域引起了极大的关注。我们的目标是从一张照片中估计出一个高质量的个性化人脸模型。这种模型理想地包括几个可解释的语义维度，例如，三维人脸形状和表情以及表面反射率特性。这一领域的研究是由不断增加的人脸图像可用性所推动的，例如，家用摄像头捕捉的人脸图像，以及跨多个领域的广泛重要应用，如面部运动捕捉、游戏和电影的内容创建、虚拟和增强现实以及通信。</p>
<p>从一张照片中重建人脸是一个非常具有挑战性和不适定的逆问题，因为图像的形成过程将多个复杂的物理维度(几何、反射率和光照)卷积成每个像素的单一颜色测量。为了解决这种不适定性，研究人员已经做了额外的先验假设，比如将人脸限制在一个低维子空间中，例如，3D可变形模型(3DMM)从有限尺寸的扫描数据库中学习。许多最先进的基于优化的和基于学习的人脸重建方法严重依赖这些先验。虽然这些算法产生了令人印象深刻的结果，但它们不能很好地推广到除受限低维子空间之外的底层模型。因此，重建的三维人脸可能缺乏重要的面部细节，包含不正确的面部特征，并不能很好地与图像匹配。例如，纯合成数据训练的算法或使用3DMM进行正则化的算法的重构质量的对胡须显示效果会急剧下降。一些方法试图通过启发式来防止这些失败，例如，一个单独的分割方法来消除分离皮肤和头发区域带来的的歧义。最近的方法通过添加精细尺度的细节，或者基于阴影的形状，或者基于预先学习的回归量来细化拟合的先验。然而，这些方法依赖于缓慢的优化，或者需要高质量的带注释的训练语义库。此外，他们没有为中型形状、反射率和动画建立一个的改进子空间，这对泛化来说至关重要。最近，Sela等人的预测了一个单像素深度图，通过在训练中学习去变形和填补有一个有限几何子空间的洞。虽然结果令人印象深刻，但非刚性匹配是离线运行的。此外，他们的方法只捕捉人脸的几何形状，如果人脸与训练语义库有很大差异，就会失败，例如考虑皮肤反射率和面部毛发。理想情况下，人们希望构建更好的先验，用有意义的和可解释的参数解释各种各样的现实世界面孔。用传统方法学习这样的模型需要大量标记密集的真实世界数据，这实际上是不可行的。</p>
<p>我们提出了一种全新的端到端可训练的方法，该方法联合学习1)一个有效的回归因子来估计高质量的身份几何、面部表情和有色皮肤反射率，以及2)一个改进的多级人脸模型的参数化，该模型能更好地概括和解释现实世界中的人脸多样性。我们的方法可以在稀疏标记的自然环境图像上进行端到端的训练，并在超过250赫兹的单目RGB输入中重建人脸和光照。我们的方法利用3DMM进行正则化，并利用学习的校正空间进行空间外泛化。为了使自然环境图像的端到端训练成为可能，我们提出了一种混合卷积自编码器，它将CNN编码器与专家设计的可微渲染层和自监督损失结合起来，两者都定义在多个细节级别。此外，我们加入了一个新的轮廓约束，生成更好的人脸匹配。与Tewari等人的不同，我们的自动编码器学习了一个改进的多级模型，超越了预先定义的低维参数脸部先验。实验结果表明，该方法具有较强的鲁棒性、较好的泛化性，并能较好地估计几何形状、反射率和光照质量。</p>
<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2.Related Work"></a>2.Related Work</h1><p>我们主要讨论基于优化和学习的方法，这些方法使用参数模型。而高质量的多视图三维重建方法已经存在，我们感兴趣的是更难的单眼重建问题。</p>
<p><strong>参数化人脸模型:</strong>应用最广泛的人脸模型是3D可变形模型(3DMM)，这是一种通过高质量扫描学习人脸几何和纹理的仿射参数化人脸模型。【5】中提出了一个相似的人脸动画模型。最近，Booth等人从大约10,000个面部扫描中创建了一个大规模的面部模型(LSFM)，这代表了一个更丰富的形状分布。Booth等人的【9】中，人脸模型被一个“in-the-wild”纹理模型增强。将这种模型拟合到图像上是一个非凸优化问题，类似于基于Active Shape (ASMs) 和<br>Appearance (AAMs) 模型的结构。虽然3DMMs是一种高效的先验，但它们将人脸重构限制在一个有限的低维子空间内，如胡须或特征鼻子无法重构。相反，我们通过共同学习一个修正模型来扩展有限的子空间，该模型可以更好地概括真实数据。</p>
<p><strong>基于优化的方法：</strong>单目人脸重建、基于图像采集的重建以及高质量三维人脸平台的估计，很多方法都是基于能量优化的。从不同的数据源，如照片集、网络照片、视频，得到了令人印象深刻的人脸重建结果。此外，还提出了不依赖于训练过的形状或外观模型的方法，如使用模态分析得到的模型或利用视觉流与消息处理相结合。虽然实时人脸跟踪在一般情况下是可行的，但是基于优化的人脸重建在计算上是昂贵的。此外，基于优化的方法对初始化很敏感，需要2D特征点检测。一些方法允许3D人脸轮廓在预定义的路径上(例如等值线)滑动或迭代固定顶点集，以此来寻找三维轮廓对应。我们的方法既不需要昂贵的优化策略，也不需要参数初始化，但通过在训练过程中考虑轮廓，它可以精确地将3D人脸网格与图像匹配。</p>
<p><strong>基于学习的方法：</strong>除了基于优化的重构方法外，还有许多基于学习的方法。其中，基于卷积神经网络或受限玻尔兹曼机的方法用来学习在图像中高精度地监测基准点。此外，我们还可以发现(弱)监督的深度网络，它集成生成模型来解决像面部表现捕捉这样的任务。<br>Ranja等人提出了一种多用途CNN，用于从人脸图像中恢复语义参数(如年龄、性别、姿势)。理查森等人提出了一种基于学习和优化的混合方法，可以从一张图像重建精细的面部几何形状。在【48】中提出了训练端到端回归器，以恢复粗糙和精细尺度的面部几何形状。在【61】中，对人脸形状和纹理进行回归，进行人脸识别。后一种人脸重建方法对真实世界人脸多样性的推广受到底层低维人脸模型的限制。</p>
<p><strong>基校正和子空间学习：</strong>通过添加中等尺度的细节，可以提高人脸重建的质量。Li等人使用增量PCA对表情基实现实时个性化。Bouaziz等人【11】提出了基于流形谐波的中尺度形状校正方法。最近，Garrido等人提出了一种基于固定校正基础的单目视频学习中尺度形状的方法。Sela等人的【53】直接提出回归深度和单像素对应，从而超越了3DMM受限子空间。然而，它们不能恢复彩色表面反射率，并且需要离线非刚性配准步骤才能获得已知一致拓扑结构的重构。据我们所知，目前还没有一种算法能从自然环境图像中同时学习几何和反射率校正。</p>
<p><strong>生成模型的深度集成：</strong>这是Jaderberg等人的开创性工作【31】，引入了空间转换网络，实现了一个神经网络中的位置不变性。透视转换网络【67】能够从单个二维图像中获得三维对象表示。gvvn库【27】实现了用于这种转换的低级计算机视觉层。最近，一种基于模型的人脸自动编码器(MoFA)【59】被提出用于单目人脸重建，它结合了专家设计的渲染层和可训练的CNN编码器。它们的结果是显著的，但仅限于人脸模型的固定低维子空间。外子空间的变异，如面部细节和个性化的鼻子，没有被重现，严重降低了重建的质量。我们的方法解决了所有这些挑战，在几何和反射率方面实现了更强的鲁棒性和更高的质量。</p>
<h1 id="3-Method-Overview"><a href="#3-Method-Overview" class="headerlink" title="3.Method Overview"></a>3.Method Overview</h1><p>我们全新的人脸重建方法从一个单一的图像高质量地估计几何形状，皮肤反射率和入射光。我们在同时学习多级参数化人脸模型的基础上，联合训练各维度的回归器，如图1所示。<br><img src="https://i.loli.net/2019/04/17/5cb7363754822.jpg" alt="figure1"><br><em>图1所示。我们的方法在超过250赫兹时回归一个低维的潜在人脸表示。前馈CNN是与一个超越当前3DMMs低维子空间的多层次人脸模型共同学习的。可训练图层显示为蓝色，专家设计的图层显示为灰色。训练是基于可微的图像形成，结合自监督损失(橙色)。</em></p>
<p><strong>参数回归：</strong>在测试时(图1，左)，使用一个前馈CNN计算一个低维的，但有表现力和鉴别力，潜在的空间人脸表示花费在4ms以下。如AlexNet【37】或VGG-Face【44】。我们的潜在空间是基于一个新的多层次的人脸模型(第4节)它结合了一个粗糙尺度的3DMM与可训练的单顶点几何和皮肤反射校正。这使我们的方法能够超越有限的低维几何和皮肤反射子空间，通常使用基于3DMM的方法进行人脸拟合。</p>
<p><strong>自监督训练：</strong>我们训练(图1，右)前馈网络和校正空间，基于一种新的CNN架构，不依赖于密集标注的基础几何事实、皮肤反射率和光照训练语义库。为此，我们将多层模型与专家设计的图像形成层(第5节)相结合，得到一个可微计算机图形模块。为了实现多级人脸模型的联合估计，该模块提出了粗糙3DMM模型和中等规模的模型，其中均包括校正。在训练方面，我们使用自监督的损失函数(第6节)，使我们的架构能够在大量自然环境人脸图像上进行有效的端到端训练，而不需要密集地注释基础事实。我们定性和定量地评估我们的方法，并将其与最先进的优化和基于学习的面部重建技术进行比较(第7节)。</p>
<h1 id="4-Trainable-Multi-level-Face-Model"><a href="#4-Trainable-Multi-level-Face-Model" class="headerlink" title="4.Trainable Multi-level Face Model"></a>4.Trainable Multi-level Face Model</h1><p>我们的方法的核心是一个新的多层次的面部模型，确定面部几何形状和皮肤反射率的参数。我们的模型是基于一个流形模板网格与N ~ 30k顶点和每个顶点的皮肤反射率。我们将所有顶点v<sub>i</sub>∈V的x-、y-和z-坐标叠加在一个几何向量v<sup>f</sup>∈R<sup>3n</sup>中，几何与反射率参数化表示如下:<br><img src="https://i.loli.net/2019/04/17/5cb740d84cec8.png" alt="公式1,2"></p>
<p>在基本级别上是参数化面（粗糙）部几何vb和(粗糙)皮肤反射rb通过低维的一组参数(α;β)。<br>此外,我们使用校正加入中等规模的几何Fg和反射率Fr变形,参数化的(δg;Θg)将基准面模型与校正模型结合起来，就得到最终的水平模型，参数化vf和rf。下面，我们将描述多级人脸模型的不同级别。</p>
<h2 id="4-1-Static-Parametric-Base-Model"><a href="#4-1-Static-Parametric-Base-Model" class="headerlink" title="4.1. Static Parametric Base Model"></a>4.1. Static Parametric Base Model</h2><p>底层采用的参数化人脸模型通过两个独立的仿射模型表达了似是而非的人脸几何和反射率空间:<br><img src="https://i.loli.net/2019/04/23/5cbe6c2b369e2.png" alt="公式3,4"><br>反射率变化的子空间由向量b张成，该向量由PCA从200个高质量人脸扫描数据集中创建。<br>几何子空间分为Ms和Me，表示形状和表达式的变化。<br>这些向量是用PCA从[2]和[17]的混合形状子集中生成的。注意，这些混合形状已经使用变形转移[56]转移到我们的拓扑结构中。基捕获了使用的混合形状的99%的方差。我们使用ms = mr = 80个形状和反射向量，me = 64个表达向量。相关的标准差σg和σr。</p>
<h2 id="4-2-Trainable-Shape-and-Reflectance-Corrections"><a href="#4-2-Trainable-Shape-and-Reflectance-Corrections" class="headerlink" title="4.2. Trainable Shape and Reflectance Corrections"></a>4.2. Trainable Shape and Reflectance Corrections</h2><p>许多基于优化和学习的重建技术，如[7,5,60，59]。由于其低维性，4.1节所述的基本模型对面部形状和反射率的高精度建模表达能力有限。一个特殊的问题是皮肤反照率的变化，因为所使用的模型有种族偏见，缺乏面部毛发，例如胡须。<br>这项工作的目的是通过学习一个可训练的纠正模型来改进这一点，该模型可以表示这些空间外的变化。与其他使用固定的预定义校正基础[25]的方法不同，我们学习了校正器的生成模型和最佳校正参数。此外，我们不需要对几何形状、皮肤反射率和入射光照的地面真相注释。<br>与基准水平的关键区别在于，修正水平不使用固定的预训练基础，而是直接从训练数据中学习生成模型和系数。</p>
<h1 id="5-Differentiable-Image-Formation-Model"><a href="#5-Differentiable-Image-Formation-Model" class="headerlink" title="5. Differentiable Image Formation Model"></a>5. Differentiable Image Formation Model</h1><p>为了训练我们新颖的端到端多层人脸重建方法，我们需要一个可微的图像形成模型。下面，我们将描述它的组件。<br><strong>全参相机:</strong>这一部分是求了相机的内参数，相机模型包含内部物理并执行透视划分。<br><strong>光照模型:</strong>利用球谐基函数，建立了远距离照明的假设，并对入射光进行了近似<img src="https://i.loli.net/2019/04/23/5cbe6ddb18d95.png" alt=""><br>我们假设入射光只依赖于表面法向量n:<br><img src="https://i.loli.net/2019/04/23/5cbe6dffa30a5.png" alt="公式5"><br>其中，圈点表示哈达玛乘积，r表示表面反射，B代表球谐基函数带，rb是控制照明的系数。<br>由于入射光足够平滑，平均误差低于1%，可以实现只有B = 3波段独立于照明。这导致了每个颜色通道的变量<img src="https://i.loli.net/2019/04/23/5cbe6e98b5929.png" alt=""><br><strong>图像合成：</strong>我们的可微图像生成层以模型空间的顶点形状和反射率作为输入。这可以是基本级别模型rb和vb，或者最终级别模型vf和rf，其中包括所学习的校正器。<img src="https://i.loli.net/2019/04/23/5cbe6f230022f.png" alt="">表示基面第i个顶点的位置和反射率(l = b)和最后一层(‘l= f)。<br>我们的渲染层接受这些信息，并形成一个基于点的场景渲染，如下所示。<br>首先，它将这些点映射到相机空间，即<img src="https://i.loli.net/2019/04/23/5cbe6f741286a.png" alt="">)然后计算所有顶点的投影像素位置为<img src="https://i.loli.net/2019/04/23/5cbe6f8977b2b.png" alt="">这些像素位置的阴影颜色c ‘ i是根据前面描述的光照模型计算的:<img src="https://i.loli.net/2019/04/23/5cbe6ffe4a354.png" alt="">其中，n是相关联的摄像机空间法线到v. 我们的图像形成模型是可微的，这使得端到端的训练使用反向传播。回归器学习预测的自由变量有: 模型参数<img src="https://i.loli.net/2019/04/23/5cbe701dae588.png" alt="">相机参数R, t和照明参数γ。此外,在训练期间,我们学习纠正形状和反射率基地,Θr。这导致了以下未知向量:<br><img src="https://i.loli.net/2019/04/23/5cbe7048cd56a.png" alt=""></p>
<p><img src="https://i.loli.net/2019/04/19/5cb92b2795684.png" alt="figure2"><br><em>图2所示。我们将固定和移动特征点区分开来。这将使得更好的轮廓对齐。注意外部轮廓如何依赖于刚性头部姿态(左)。在全局反射率恒常性约束中使用了皮肤掩模(右)。</em></p>
<h1 id="6-Self-supervised-Learning"><a href="#6-Self-supervised-Learning" class="headerlink" title="6.Self-supervised Learning"></a>6.Self-supervised Learning</h1><p>我们的人脸回归网络使用一个全新的自监督损失来进行训练，这样使得它能够符合我们的基础模型并且端到端地学习每个像素的校正。我们的损失包括数据拟合以及正则项：<br><img src="https://i.loli.net/2019/04/18/5cb81c54f2c3b.png" alt="公式6"><br>这里E<sub>date</sub>惩罚了模型在输入图像上的偏差，E<sub>reg</sub>对人脸在粗尺度和中等尺度上的先验假设进行编码，ω<sub>reg</sub>是控制正则项的平衡因子。数据拟合项基于稀疏和稠密的一致性约束。<br><img src="https://i.loli.net/2019/04/18/5cb81ec0f13c8.png" alt="公式7"><br>正则化项表示在基础模型和修正模型上的先验假设:<br><img src="https://i.loli.net/2019/04/18/5cb81f54052d0.png" alt="公式8"><br>在下文中，将详细介绍各个部分。</p>
<h2 id="6-1-数据项"><a href="#6-1-数据项" class="headerlink" title="6.1 数据项"></a>6.1 数据项</h2><p><strong>多维稠密光度损失：</strong>我们采用了一个稠密多维光度损失函数，用来衡量粗尺度上的偏差并且更好地拟合输入。V是所有可见顶点的集合，我们的光度项可以定义为：<br><img src="https://i.loli.net/2019/04/18/5cb8214fdef38.png" alt="公式9"><br>这里u<sup>l</sup><sub>i</sub>（x）是屏幕的空间位置，c<sup>l</sup><sub>i</sub>（x）是第i个顶点的阴影颜色，L是当前训练的图像。为了增强鲁棒性，我们使用了l<sub>2,1</sub>-norm，其中l<sub>2</sub>-norm来衡量颜色之间的差距，但是对每个像素的l<sub>2</sub>-norm进行求和促进了稀疏性，因为它对应于l<sub>1</sub>-norm。使用后脸剔除可以计算可见性，这是一个近似值，不过效果很好，因为脸部可以近似看作一个凸面体。</p>
<p><strong>稀疏特征点：</strong>面部包含许多突出的特征点，我们通过一个弱监督自动地检测66个面部标记。面部标记点集可以分为两类：固定的和移动的特征点。固定的特征点，例如眼睛和鼻子，和模板模型上的固定顶点相关联；移动的特征点，例如面部轮廓，基于刚性位姿而改变在模板中的位置，见图2（右），模型可以显式地表达为：<br><img src="https://i.loli.net/2019/04/18/5cb82cffc7cd2.png" alt="公式10"><br>这里，k<sub>f</sub>是目标顶点的索引：对于固定的点，我们将对应网格顶点的索引进行硬编码（把一个本来应该写到配置信息中的信息直接在程序代码中写死），移动特征点的索引通过例如交替方案来计算。在每一步的随机梯度下降中，我们发现网格顶点是最靠近3D线的，通过相机中心和检测到的2D特征点的背投影来定义。我们计算欧式距离的平方并且将k<sub>r</sub>设为最近顶点的索引。</p>
<h2 id="6-2-正则化项"><a href="#6-2-正则化项" class="headerlink" title="6.2 正则化项"></a>6.2 正则化项</h2><p><strong>统计正则化：</strong>我们对基础水平的3DMM模型参数进行统计正则化，以确保重构的合理性。基于模型参数服从零均值高斯分布的假设，我们采用Tikhonov正则化:<br><img src="https://i.loli.net/2019/04/18/5cb8655472c5e.png" alt="公式11"><br>这是在不适定的单目重建场景中防止人脸几何形状和反射率退化的常见约束条件。</p>
<p><strong>平滑性校正：</strong>我们还通过对所有顶点集合V中的顶点位移添加拉普拉斯正则项来增加局部光滑性:<br><img src="https://i.loli.net/2019/04/18/5cb8670434ec8.png" alt="公式12"><br>其中（F<sub>g</sub>(x)）<sub>i</sub>=(F<sub>g</sub>(δ<sub>g</sub>|θ<sub>g</sub>))<sub>i</sub>表示第i个顶点给定参数x的的修正量，并且N<sub>i</sub>是第i个顶点的一环领域。</p>
<p><strong>局部反射稀疏性：</strong>根据最近的内在分解方法，我们加强实施稀疏性，以进一步规范全重构的反射性：<br><img src="https://i.loli.net/2019/04/18/5cb86e96cfd60.png" alt="公式13"><br>其中，<img src="https://i.loli.net/2019/04/18/5cb86ebd7b546.png" alt="">是衡量输入中颜色之间色度相似性的恒权值，这里X<sup>old</sup>是在前一轮迭代中的估值参数。我们假设具有相同色度的像素更有可能具有相同的反射率。l<sub>2,p</sub>-norm对组合反射率估计值添加稀疏性。在所有实验中我们假定α=50，p=0.9。</p>
<p><strong>全局反射恒常性：</strong>我们在一组只覆盖皮肤区域的固定顶点上设定皮肤反射率恒定，见图2（右）<br><img src="https://i.loli.net/2019/04/19/5cb924aa97869.png" alt="公式14"><br>这里，M是每个像素的皮肤掩模，G<sub>i</sub>存储着掩模区域顶点索引的六个随机采样。这样做是为了保证整个皮肤区域有相同的反射率。为了更高效，我们假设同一块皮肤区域中任意一对顶点之间的反射率都近似相同。需要注意的是，这些区域可能有面部的毛发，这是不包含在掩模中的。当组合在一起的时候，局部和全局的反射从反射通道中高效的移除了阴影。</p>
<p><strong>稳定性：</strong>我们还通过强制执行小的顶点位移来确保修正后的几何形状接近于基础重构:<br><img src="https://i.loli.net/2019/04/19/5cb9297b56673.png" alt="公式15"></p>
<h1 id="7-Results"><a href="#7-Results" class="headerlink" title="7.Results"></a>7.Results</h1><p>我们演示了前馈编码器的联合端到端自监督训练和基于野生图像的新型多层次人脸表示，而不需要密集注释。我们的方法是在250赫兹以上的高质量的位置、形状、表达式、反射和照明进行回归，见图3。<br><img src="https://i.loli.net/2019/04/23/5cbe712d1ccdf.png" alt="figure3"><br>对于前馈编码器，我们使用了Alexnet[37]的修改版本，该版本输出我们的人脸模型的参数。请注意，可以使用其他前馈架构。<br>我们使用caffe[32]实现了我们的方法。培训基于批量大小为5的adadelta。我们对我们的网络进行预培训，使其达到20万次迭代的基本水平，学习率为0:01。之后，我们对整个网络进行了190k次迭代的微调，基本级别的学习率为0:001，几何结构的学习率为0:005，反射校正的学习率为0:01。我们的网络的所有组件都在CUDA[43]中实现，以便进行有效的培训，这需要16个小时。我们在所有的实验中都使用常数w。在下面，我们将校正参数的大小c固定为500，用于几何和反射率。我们测试了不同的校正空间（线性和非线性），见图5。线性校正基础给出了最好的结果，因此我们将其用于所有后续实验。详情请参阅补充文件。<br><img src="https://i.loli.net/2019/04/23/5cbe716a8a397.png" alt="figure5"><br>我们的方法是在一个没有密集注释的原始的的面部图像的语料库上训练的。我们结合了四种不同的数据集：Celeba[41]、LFW[28]、Face-Warehouse[16]和300-VW[18、54、62]。稀疏地标注释自动获得[52]，我们使用HAAR级联人脸检测[13]裁剪到240240像素的紧面边界框。检测不良的图像会根据地标置信度自动删除。总的来说，我们使用144K图像，随机分为一组训练（142K图像）和验证（2K图像）。<br>我们将我们的最终输出（“最终”）与从预训练网络获得的基础低维3dmm重建（“基础”）进行比较，以说明我们的多级模型允许我们恢复更高质量的几何体和反射比（图4）。下面，我们将展示更多的结果，评估我们的方法，并与最新技术进行比较。<br><img src="https://i.loli.net/2019/04/23/5cbe719973ff2.png" alt="figure4"></p>
<h2 id="7-1-与最新技术的比较"><a href="#7-1-与最新技术的比较" class="headerlink" title="7.1 与最新技术的比较"></a>7.1 与最新技术的比较</h2><p><strong>基于最优化的技术：</strong>我们将其与基于优化的高质量重建方法进行了比较。[25]，见图6。我们的方法获得了相似的几何质量，但由于我们学习了纠正空间，更好地捕捉了人的特征。由于我们的方法共同学习了一个校正反射空间，它可以离开底层3dmm的受限子空间，从而产生更真实的外观。注意，与Garrido等人不同，我们的方法在测试时不需要标志，运行速度更快（4ms对120s每幅图像）。我们还比较了布斯等人的方法。[9]见图7。我们的方法共同学习一个更好的形状和反射模型，而他们的方法只建立一个’原始图片模型，包含阴影。与我们的方法不同，布斯等人基于优化，需要初始化或标志。<br><strong>基于学习的技术：</strong>我们比较了Tewari等人基于学习的高质量重建方法。[59]（图8），Richardson等人[47，48]（图9）和Sela等人〔53〕（图9）。在使用的合成训练语料库或使用的3dmm模型范围内，这些方法获得了令人印象深刻的结果，但受到了子空间形状和反射变化的影响，例如有胡子的人。我们的方法不仅对面部毛发和化妆都很有效，而且可以根据共同学习的模型自动学习重建这些变化。重建需要4 ms，而[53]需要缓慢的离线非刚性配准，以从预测深度图获得无孔重建。此外，我们还共同获得了彩色反射和照明的重建。由于我们的模型学习，我们的方法能够离开三维空间的低维空间，这导致了一个更现实的面部外观和几何重建。</p>
<h2 id="7-2-数量级上的结果"><a href="#7-2-数量级上的结果" class="headerlink" title="7.2 数量级上的结果"></a>7.2 数量级上的结果</h2><p>我们定量地评估了我们的方法。对于几何图形，我们使用FaceWarehouse[16]数据集并重建180个网格（9个标识，每个表达式20个）。我们比较了不同的方法，在对齐后（刚性变换加上各向同性缩放），以提供的地面真相使用豪斯多夫距离。我们的方法优于Tewari等人的基于学习的技术。[59]和Kim Etal.〔36〕见Tab。1。我们接近Garrido等人的高质量优化方法。[25]虽然速度快了几个数量级（4ms vs.120sec），但在测试时不需要进行特征检测，见图10（上图）。[16]主要包含“干净”的脸，没有化妆或胡须，因为这会导致问题，即使是高质量的离线3D重建方法。我们的兴趣是坚定地处理这种更困难的情况，在这种情况下，我们证明我们的方法明显优于以前的方法，见图。8, 6和9。我们还评估了我们的方法，在一个视频序列（300帧）具有挑战性的表达和特征面，这是在3dmm的跨度之外。Valgaerts等人获得了基本事实。〔63〕。我们的校正方法（平均值：1.77mm，标准差：0.29mm）显著优于基础结果（平均值：2.16mm，标准差：0.29mm），Garrido等人[25]在粗（平均：1.96mm，标准差：0.35mm）和中等（平均：1.97mm，标准差：0.41mm）水平，以及Tewari等人[59]（平均值：2.94mm，标准差：0.28mm），见图10（底部）。我们在验证集上评估我们方法的光度拟合误差，见图11。我们的最终结果（平均值：0.072，标准差：0.020）与基础水平（平均值：0.092，标准差：0.025）相比，误差（RGB空间中的距离，通道在[0；1]中）显著降低。</p>
<h1 id="8-局限性"><a href="#8-局限性" class="headerlink" title="8.局限性"></a>8.局限性</h1><p>我们在250Hz以上的频率下进行了高质量的单目重建，即使是在有面部毛发的情况下，或是在有挑战性的脸上。不过，我们的方法有一些局限性，可以在将来的工作中加以解决：外部遮挡（例如，通过眼镜）被烘烤到我们的校正中，见图12。解决这一问题需要对训练语料库进行语义分割。不能保证封闭面区域的一致重建。对于鲁棒模型学习，我们强制纠正空间的低维性。因此，我们无法恢复细尺度的表面细节。我们认为这是一个正交的研究方向，已经产生了令人印象深刻的结果[47，48，53]。</p>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>我们提出了第一种共同学习人脸模型和参数回归器的方法，用于人脸形状、表情、外观和照明。它结合了3dmm正则化的优点和已知校正空间的超空间泛化。这克服了目前依赖强先验的方法的缺点，提高了泛化性和鲁棒性，并导致250Hz以上的高质量重建。在这项工作中，我们将重点放在人脸重建上，我们的方法不局限于人脸，因为它可以推广到更多的对象类。因此，我们认为这是从原始图像构建三维模型的第一步。</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_6</title>
    <url>/2019/04/10/2019-04-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>图：表示“多对多”的关系<br>包含：</p>
<ul>
<li>一组顶点：通常用V（Vertex）表示顶点集合；</li>
<li>一组边：通常用E（Eege）表示边的集合；<br>边是顶点对：<br>无向边（v,w）∈E，其中v,w∈V<br>有向边&lt;v,w&gt;∈E，其中v,w∈V</li>
</ul>
<h2 id="程序中图的表示"><a href="#程序中图的表示" class="headerlink" title="程序中图的表示"></a>程序中图的表示</h2><ul>
<li><strong>邻接矩阵</strong>:G[N][N]-N个顶点从0到N-1编号<br>G[N][N]=1（&lt; v<sub>i</sub>,v<sub>j</sub>&gt;是G中的边）/0（&lt; v<sub>i</sub>,v<sub>j</sub>&gt;不是G中的边）。<br>对于有N个顶点的无向图，用一个长度为N(N+1)/2的1维数组存储可以省一半空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 图的邻接矩阵表示法 */</span><br><span class="line"> </span><br><span class="line">#define MaxVertexNum 100    /* 最大顶点数设为100 */</span><br><span class="line">#define INFINITY 65535        /* ∞设为双字节无符号整数的最大值65535*/</span><br><span class="line">typedef int Vertex;         /* 用顶点下标表示顶点,为整型 */</span><br><span class="line">typedef int WeightType;        /* 边的权值设为整型 */</span><br><span class="line">typedef char DataType;        /* 顶点存储的数据类型设为字符型 */</span><br><span class="line"> </span><br><span class="line">/* 边的定义 */</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;      /* 有向边&lt;V1, V2&gt; */</span><br><span class="line">    WeightType Weight;  /* 权重 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line">        </span><br><span class="line">/* 图结点的定义 */</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    int Nv;  /* 顶点数 */</span><br><span class="line">    int Ne;  /* 边数   */</span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */</span><br><span class="line">    DataType Data[MaxVertexNum];      /* 存顶点的数据 */</span><br><span class="line">    /* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">MGraph CreateGraph( int VertexNum )</span><br><span class="line">&#123; /* 初始化一个有VertexNum个顶点但没有边的图 */</span><br><span class="line">    Vertex V, W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">     </span><br><span class="line">    Graph = (MGraph)malloc(sizeof(struct GNode)); /* 建立图 */</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = 0;</span><br><span class="line">    /* 初始化邻接矩阵 */</span><br><span class="line">    /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span><br><span class="line">    for (V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        for (W=0; W&lt;Graph-&gt;Nv; W++)  </span><br><span class="line">            Graph-&gt;G[V][W] = INFINITY;</span><br><span class="line">             </span><br><span class="line">    return Graph; </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">void InsertEdge( MGraph Graph, Edge E )</span><br><span class="line">&#123;</span><br><span class="line">     /* 插入边 &lt;V1, V2&gt; */</span><br><span class="line">     Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;    </span><br><span class="line">     /* 若是无向图，还要插入边&lt;V2, V1&gt; */</span><br><span class="line">     Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MGraph BuildGraph()</span><br><span class="line">&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    int Nv, i;</span><br><span class="line">     </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv);   /* 读入顶点个数 */</span><br><span class="line">    Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ </span><br><span class="line">     </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));   /* 读入边数 */</span><br><span class="line">    if ( Graph-&gt;Ne != 0 ) &#123; /* 如果有边 */ </span><br><span class="line">        E = (Edge)malloc(sizeof(struct ENode)); /* 建立边结点 */ </span><br><span class="line">        /* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span><br><span class="line">        for (i=0; i&lt;Graph-&gt;Ne; i++) &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); </span><br><span class="line">            /* 注意：如果权重不是整型，Weight的读入格式要改 */</span><br><span class="line">            InsertEdge( Graph, E );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    /* 如果顶点有数据的话，读入数据 */</span><br><span class="line">    for (V=0; V&lt;Graph-&gt;Nv; V++) </span><br><span class="line">        scanf(&quot; %c&quot;, &amp;(Graph-&gt;Data[V]));</span><br><span class="line"> </span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>邻接表</strong>：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 图的邻接表表示法 */</span><br><span class="line"> </span><br><span class="line">#define MaxVertexNum 100    /* 最大顶点数设为100 */</span><br><span class="line">typedef int Vertex;         /* 用顶点下标表示顶点,为整型 */</span><br><span class="line">typedef int WeightType;        /* 边的权值设为整型 */</span><br><span class="line">typedef char DataType;        /* 顶点存储的数据类型设为字符型 */</span><br><span class="line"> </span><br><span class="line">/* 边的定义 */</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;      /* 有向边&lt;V1, V2&gt; */</span><br><span class="line">    WeightType Weight;  /* 权重 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"> </span><br><span class="line">/* 邻接点的定义 */</span><br><span class="line">typedef struct AdjVNode *PtrToAdjVNode; </span><br><span class="line">struct AdjVNode&#123;</span><br><span class="line">    Vertex AdjV;        /* 邻接点下标 */</span><br><span class="line">    WeightType Weight;  /* 边权重 */</span><br><span class="line">    PtrToAdjVNode Next;    /* 指向下一个邻接点的指针 */</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 顶点表头结点的定义 */</span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    PtrToAdjVNode FirstEdge;/* 边表头指针 */</span><br><span class="line">    DataType Data;            /* 存顶点的数据 */</span><br><span class="line">    /* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */</span><br><span class="line">&#125; AdjList[MaxVertexNum];    /* AdjList是邻接表类型 */</span><br><span class="line"> </span><br><span class="line">/* 图结点的定义 */</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;  </span><br><span class="line">    int Nv;     /* 顶点数 */</span><br><span class="line">    int Ne;     /* 边数   */</span><br><span class="line">    AdjList G;  /* 邻接表 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">LGraph CreateGraph( int VertexNum )</span><br><span class="line">&#123; /* 初始化一个有VertexNum个顶点但没有边的图 */</span><br><span class="line">    Vertex V;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">     </span><br><span class="line">    Graph = (LGraph)malloc( sizeof(struct GNode) ); /* 建立图 */</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = 0;</span><br><span class="line">    /* 初始化邻接表头指针 */</span><br><span class="line">    /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span><br><span class="line">       for (V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        Graph-&gt;G[V].FirstEdge = NULL;</span><br><span class="line">             </span><br><span class="line">    return Graph; </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">void InsertEdge( LGraph Graph, Edge E )</span><br><span class="line">&#123;</span><br><span class="line">    PtrToAdjVNode NewNode;</span><br><span class="line">     </span><br><span class="line">    /* 插入边 &lt;V1, V2&gt; */</span><br><span class="line">    /* 为V2建立新的邻接点 */</span><br><span class="line">    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));</span><br><span class="line">    NewNode-&gt;AdjV = E-&gt;V2;</span><br><span class="line">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">    /* 将V2插入V1的表头 */</span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class="line">         </span><br><span class="line">    /* 若是无向图，还要插入边 &lt;V2, V1&gt; */</span><br><span class="line">    /* 为V1建立新的邻接点 */</span><br><span class="line">    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));</span><br><span class="line">    NewNode-&gt;AdjV = E-&gt;V1;</span><br><span class="line">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">    /* 将V1插入V2的表头 */</span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LGraph BuildGraph()</span><br><span class="line">&#123;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    int Nv, i;</span><br><span class="line">     </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv);   /* 读入顶点个数 */</span><br><span class="line">    Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ </span><br><span class="line">     </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));   /* 读入边数 */</span><br><span class="line">    if ( Graph-&gt;Ne != 0 ) &#123; /* 如果有边 */ </span><br><span class="line">        E = (Edge)malloc( sizeof(struct ENode) ); /* 建立边结点 */ </span><br><span class="line">        /* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span><br><span class="line">        for (i=0; i&lt;Graph-&gt;Ne; i++) &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); </span><br><span class="line">            /* 注意：如果权重不是整型，Weight的读入格式要改 */</span><br><span class="line">            InsertEdge( Graph, E );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    /* 如果顶点有数据的话，读入数据 */</span><br><span class="line">    for (V=0; V&lt;Graph-&gt;Nv; V++) </span><br><span class="line">        scanf(&quot; %c&quot;, &amp;(Graph-&gt;G[V].Data));</span><br><span class="line"> </span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>站在一个路口，看有几条路还没走，选择其中一条往下走，走到下一个路口，继续判断，如没有，则原路返回上一个路口，看上一个路口是否有没走的路，如没有则继续原路返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 邻接表存储的图 - DFS */</span><br><span class="line"> </span><br><span class="line">void Visit( Vertex V )</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;正在访问顶点%d\n&quot;, V);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* Visited[]为全局变量，已经初始化为false */</span><br><span class="line">void DFS( LGraph Graph, Vertex V, void (*Visit)(Vertex) )</span><br><span class="line">&#123;   /* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">     </span><br><span class="line">    Visit( V ); /* 访问第V个顶点 */</span><br><span class="line">    Visited[V] = true; /* 标记V已访问 */</span><br><span class="line"> </span><br><span class="line">    for( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) /* 对V的每个邻接点W-&gt;AdjV */</span><br><span class="line">        if ( !Visited[W-&gt;AdjV] )    /* 若W-&gt;AdjV未被访问 */</span><br><span class="line">            DFS( Graph, W-&gt;AdjV, Visit );    /* 则递归访问之 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>指定一个起点，把它压到队列里，在把它弹出队列时，将与它相连的点一一压到队列里，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 邻接矩阵存储的图 - BFS */</span><br><span class="line"> </span><br><span class="line">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span><br><span class="line">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span><br><span class="line">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span><br><span class="line">bool IsEdge( MGraph Graph, Vertex V, Vertex W )</span><br><span class="line">&#123;</span><br><span class="line">    return Graph-&gt;G[V][W]&lt;INFINITY ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* Visited[]为全局变量，已经初始化为false */</span><br><span class="line">void BFS ( MGraph Graph, Vertex S, void (*Visit)(Vertex) )</span><br><span class="line">&#123;   /* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span><br><span class="line">    Queue Q;     </span><br><span class="line">    Vertex V, W;</span><br><span class="line"> </span><br><span class="line">    Q = CreateQueue( MaxSize ); /* 创建空队列, MaxSize为外部定义的常数 */</span><br><span class="line">    /* 访问顶点S：此处可根据具体访问需要改写 */</span><br><span class="line">    Visit( S );</span><br><span class="line">    Visited[S] = true; /* 标记S已访问 */</span><br><span class="line">    AddQ(Q, S); /* S入队列 */</span><br><span class="line">     </span><br><span class="line">    while ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        V = DeleteQ(Q);  /* 弹出V */</span><br><span class="line">        for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */</span><br><span class="line">            /* 若W是V的邻接点并且未访问过 */</span><br><span class="line">            if ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;</span><br><span class="line">                /* 访问顶点W */</span><br><span class="line">                Visit( W );</span><br><span class="line">                Visited[W] = true; /* 标记W已访问 */</span><br><span class="line">                AddQ(Q, W); /* W入队列 */</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; /* while结束*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Github使用</title>
    <url>/2019/04/09/2019-04-09-Linux%E4%B8%8BGithub%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>python主要用linux，所以在linux下使用Github特意来学习一下。</p>
<h1 id="Linux下Git和GitHub环境的搭建"><a href="#Linux下Git和GitHub环境的搭建" class="headerlink" title="Linux下Git和GitHub环境的搭建"></a>Linux下Git和GitHub环境的搭建</h1><ol>
<li>安装Git， 使用命令sudo apt-get install git；</li>
<li>创建GitHub帐号；</li>
<li>生成ssh key，使用命令 ssh-keygen -t rsa -C “<a href="mailto:your_email@youremail.com" target="_blank" rel="noopener">your_email@youremail.com</a>“，your_email是你的email；</li>
<li>终端输入命令 cd ~/.ssh，之后ls命令，之后vi id_rsa.pub，复制内容；</li>
<li>回到github，进入Account Settings，左边选择SSH Keys，Add SSH Key，粘贴key；</li>
<li>测试ssh key是否成功，使用命令ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，如果出现You’ve successfully ；authenticated, but GitHub does not provide shell access ，这就表示已成功连上github；</li>
<li>配置Git的配置文件：配置用户名：git config –global user.name “your name” ，配置email：git config –global user.email “your email”</li>
</ol>
<h1 id="从GitHub克隆项目到本地"><a href="#从GitHub克隆项目到本地" class="headerlink" title="从GitHub克隆项目到本地"></a>从GitHub克隆项目到本地</h1><ol>
<li>到GitHub的某个仓库，然后复制右边的那个（HTTPS clone url）；</li>
<li>回到要存放的目录下，使用命令 git clone <a href="https://github.com/your_name/yourRepo.git，" target="_blank" rel="noopener">https://github.com/your_name/yourRepo.git，</a> your_name是你的GitHub的用户名，yourRepo是你要clone的仓库；</li>
<li>如果本地的版本不是最新的，可以使用命令 git fetch origin，origin是本地仓库；</li>
<li>把更新的内容合并到本地分支，可以使用命令 git merge origin/master；</li>
<li>如果你不想手动去合并，那么你可以使用： git pull &lt;本地仓库&gt; master 这个命令来拉去最新版本并自动合并；</li>
</ol>
<h1 id="利用Git从本地上传到GitHub"><a href="#利用Git从本地上传到GitHub" class="headerlink" title="利用Git从本地上传到GitHub"></a>利用Git从本地上传到GitHub</h1><ol>
<li>进入要所要上传文件的目录, 输入命令 git init；</li>
<li>创建一个本地仓库origin，使用命令 git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:your_name/yourRepo.git，your_name是你的GitHub的用户名，yourRepo是你要上传到GitHub的仓库；</li>
<li>比如你要添加一个文件xxx到本地仓库，使用命令 git add xxx，可以使用 git add . 自动判断添加哪些文件；</li>
<li>然后把这个添加提交到本地的仓库，使用命令 git commit -m “说明这次的提交”；</li>
<li>最后把本地仓库origin提交到远程的GitHub仓库，使用命令 git push origin master；</li>
</ol>
<h3 id="说明：作者在本地库文件夹下的某一文件夹下进行操作，上传某一文件，一直无法成功，随后回到库文件夹下进行操作，命令分别为："><a href="#说明：作者在本地库文件夹下的某一文件夹下进行操作，上传某一文件，一直无法成功，随后回到库文件夹下进行操作，命令分别为：" class="headerlink" title="说明：作者在本地库文件夹下的某一文件夹下进行操作，上传某一文件，一直无法成功，随后回到库文件夹下进行操作，命令分别为："></a><em>说明：作者在本地库文件夹下的某一文件夹下进行操作，上传某一文件，一直无法成功，随后回到库文件夹下进行操作，命令分别为：</em></h3><blockquote>
<p>git add . //注意.代表全部上传，也可以换为要上传更新的文件</p>
</blockquote>
<blockquote>
<p>git commit -m ‘update’</p>
</blockquote>
<blockquote>
<p>git push</p>
</blockquote>
<p><em>即相当于对要添加的文件所在的整个文件夹进行了更新。</em></p>
<h1 id="GitHub的分支管理"><a href="#GitHub的分支管理" class="headerlink" title="GitHub的分支管理"></a>GitHub的分支管理</h1><p>创建分支</p>
<ol>
<li>创建一个本地分支： git branch &lt;新分支名字&gt;；</li>
<li>将本地分支同步到GitHub上面： git push &lt;本地仓库名&gt; &lt;新分支名&gt;；</li>
<li>切换到新建立的分支： git checkout &lt;新分支名&gt;；</li>
<li>为你的分支加入一个新的远程端： git remote add &lt;远程端名字&gt; &lt;地址&gt;；</li>
<li>查看当前仓库有几个分支: git branch；</li>
</ol>
<p>删除分支</p>
<ol>
<li>从本地删除一个分支： git branch -d &lt;分支名称&gt;；</li>
<li>同步到GitHub上面删除这个分支： git push &lt;本地仓库名&gt; :&lt;GitHub端分支&gt;；</li>
</ol>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Blog</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_5</title>
    <url>/2019/04/03/2019-04-03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="堆heap"><a href="#堆heap" class="headerlink" title="堆heap"></a>堆heap</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>堆的两个特性：</p>
<ul>
<li>结构性：用数组表示的<strong>完全二叉树</strong></li>
<li>有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）</li>
</ul>
<h2 id="堆进行的操作"><a href="#堆进行的操作" class="headerlink" title="堆进行的操作"></a>堆进行的操作</h2><p>创建、插入、删除、判断是否已满是否为空，返回最大值最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct HNode *Heap; /* 堆的类型定义 */</span><br><span class="line">struct HNode &#123;</span><br><span class="line">    ElementType *Data; /* 存储元素的数组 */</span><br><span class="line">    int Size;          /* 堆中当前元素个数 */</span><br><span class="line">    int Capacity;      /* 堆的最大容量 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef Heap MaxHeap; /* 最大堆 */</span><br><span class="line">typedef Heap MinHeap; /* 最小堆 */</span><br><span class="line"> </span><br><span class="line">#define MAXDATA 1000  /* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span><br><span class="line"> </span><br><span class="line">MaxHeap CreateHeap( int MaxSize )</span><br><span class="line">&#123; /* 创建容量为MaxSize的空的最大堆 */</span><br><span class="line"> </span><br><span class="line">    MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode));</span><br><span class="line">    H-&gt;Data = (ElementType *)malloc((MaxSize+1)*sizeof(ElementType));</span><br><span class="line">    H-&gt;Size = 0;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Data[0] = MAXDATA; /* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/</span><br><span class="line"> </span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool IsFull( MaxHeap H )</span><br><span class="line">&#123;</span><br><span class="line">    return (H-&gt;Size == H-&gt;Capacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool Insert( MaxHeap H, ElementType X )</span><br><span class="line">&#123; /* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span><br><span class="line">    int i;</span><br><span class="line">  </span><br><span class="line">    if ( IsFull(H) ) &#123; </span><br><span class="line">        printf(&quot;最大堆已满&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size; /* i指向插入后堆中的最后一个元素的位置 */</span><br><span class="line">    for ( ; H-&gt;Data[i/2] &lt; X; i/=2 )</span><br><span class="line">        H-&gt;Data[i] = H-&gt;Data[i/2]; /* 上滤X */</span><br><span class="line">    H-&gt;Data[i] = X; /* 将X插入 */</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#define ERROR -1 /* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span><br><span class="line"> </span><br><span class="line">bool IsEmpty( MaxHeap H )</span><br><span class="line">&#123;</span><br><span class="line">    return (H-&gt;Size == 0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ElementType DeleteMax( MaxHeap H )</span><br><span class="line">&#123; /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType MaxItem, X;</span><br><span class="line"> </span><br><span class="line">    if ( IsEmpty(H) ) &#123;</span><br><span class="line">        printf(&quot;最大堆已为空&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    MaxItem = H-&gt;Data[1]; /* 取出根结点存放的最大值 */</span><br><span class="line">    /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span><br><span class="line">    X = H-&gt;Data[H-&gt;Size--]; /* 注意当前堆的规模要减小 */</span><br><span class="line">    for( Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2;</span><br><span class="line">        if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line"> </span><br><span class="line">    return MaxItem;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">/*----------- 建造最大堆 -----------*/</span><br><span class="line">void PercDown( MaxHeap H, int p )</span><br><span class="line">&#123; /* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    X = H-&gt;Data[p]; /* 取出根结点存放的值 */</span><br><span class="line">    for( Parent=p; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2;</span><br><span class="line">        if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void BuildHeap( MaxHeap H )</span><br><span class="line">&#123; /* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span><br><span class="line">  /* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span><br><span class="line"> </span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    /* 从最后一个结点的父节点开始，到根结点1 */</span><br><span class="line">    for( i = H-&gt;Size/2; i&gt;0; i-- )</span><br><span class="line">        PercDown( H, i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼树与哈夫曼编码"><a href="#哈夫曼树与哈夫曼编码" class="headerlink" title="哈夫曼树与哈夫曼编码"></a>哈夫曼树与哈夫曼编码</h1><h2 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h2><p>根据结点不同的查找频率来构造更有效的搜索树。</p>
<p><strong>带权路径长度（WPL）</strong>:设二叉树有n个叶子结点，每个叶子结点带有权值w<sub>K</sub>，从根结点到每个叶子结点的长度为l<sub>K</sub>，则每个叶子结点的带权路径长度之和就是:WPL= w<sub>K</sub>*l<sub>K</sub>从i到k的求和。</p>
<p><strong>哈夫曼树（最优二叉树）</strong>：WPL最小的二叉树。</p>
<h2 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h2><p>把权值从小到大进行排序，把权值最小的两个并在一起，形成一棵二叉树，每次把权值最小的两棵二叉树合并。</p>
<h2 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h2><ul>
<li>没有度为1的结点；</li>
<li>n个叶子结点的哈夫曼树共有2n-1个结点；</li>
<li>哈夫曼树的任意非叶子结点的左右子树交换后仍是哈夫曼树；</li>
<li>对于同一组权值，存在不同构的两棵哈夫曼树；</li>
</ul>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>用二叉树进行编码时如何避免二义性：</p>
<ol>
<li>左右分支：0，1</li>
<li>字符只在叶结点上</li>
</ol>
<p>利用哈夫曼树进行编码就是哈夫曼编码。</p>
<h1 id="集合及运算"><a href="#集合及运算" class="headerlink" title="集合及运算"></a>集合及运算</h1><p>集合运算：交、并、补、差<br>并查集：集合并、查某元素属于什么集合</p>
<h2 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h2><p>可以用树结构表示集合，树的每个结点代表一个集合元素</p>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol>
<li>查找某个元素所在的集合；</li>
<li>集合的并运算<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAXN 1000                  /* 集合最大元素个数 */</span><br><span class="line">typedef int ElementType;           /* 默认元素可以用非负整数表示 */</span><br><span class="line">typedef int SetName;               /* 默认用根结点的下标作为集合名称 */</span><br><span class="line">typedef ElementType SetType[MAXN]; /* 假设集合元素下标从0开始 */</span><br><span class="line"> </span><br><span class="line">void Union( SetType S, SetName Root1, SetName Root2 )</span><br><span class="line">&#123; /* 这里默认Root1和Root2是不同集合的根结点 */</span><br><span class="line">    /* 保证小集合并入大集合 */</span><br><span class="line">    if ( S[Root2] &lt; S[Root1] ) &#123; /* 如果集合2比较大 */</span><br><span class="line">        S[Root2] += S[Root1];     /* 集合1并入集合2  */</span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                         /* 如果集合1比较大 */</span><br><span class="line">        S[Root1] += S[Root2];     /* 集合2并入集合1  */</span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SetName Find( SetType S, ElementType X )</span><br><span class="line">&#123; /* 默认集合元素全部初始化为-1 */</span><br><span class="line">    if ( S[X] &lt; 0 ) /* 找到集合的根 */</span><br><span class="line">        return X;</span><br><span class="line">    else</span><br><span class="line">        return S[X] = Find( S, S[X] ); /* 路径压缩 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>静生生物调查所史稿</title>
    <url>/2019/04/03/2019-04-03-%E9%9D%99%E7%94%9F%E7%94%9F%E7%89%A9%E8%B0%83%E6%9F%A5%E6%89%80%E5%8F%B2%E7%A8%BF/</url>
    <content><![CDATA[<blockquote>
<p>《静生生物调查所史稿》由胡宗刚著，山东教育出版社出版，在此感谢！</p>
</blockquote>
<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h2 id="中国生物学之回顾"><a href="#中国生物学之回顾" class="headerlink" title="中国生物学之回顾"></a>中国生物学之回顾</h2><p>中国生物学的发展，大致可分三个时期：第一期，本草研究时期。此时期发展缓慢；第二期，为引进西方生物学时期。自近代中国与西洋海通以来，西方传教士纷纷来华传教，同时也传播了西方的现代自然科学知识；第三期，即现代生物学时期。中国生物学研究机构渐次设立，在研究方法上尽量采取<br>西方的研究方法，而在研究对象上则以“中国的生物”为材料。</p>
<h2 id="中国科学社生物研究所"><a href="#中国科学社生物研究所" class="headerlink" title="中国科学社生物研究所"></a>中国科学社生物研究所</h2><p>1914年6月，留美中国学生组织成立中国科学社。1922年，生物研究所在南京兴办，推定秉志主持。所内设动物部、植物部，分别由秉志、胡先骕各司其事。其时，科学社社长任鸿隽也在东南大学供职，任副校长。他对于生物研究所的贡献，主要在于寻求社会的支持和谅解。主要争取到了利用美国第二次退还庚子赔款成立的“中华教育文化基金董事会”。研究所研究渐有成绩，也渐为学界所注意，以至成为中国现代生物学的摇篮。许多著名的生物学家曾在此研究所接受研究工作的训练，并开始算研究生涯。</p>
<h1 id="第二章-静生生物调查所创办经纬"><a href="#第二章-静生生物调查所创办经纬" class="headerlink" title="第二章 静生生物调查所创办经纬"></a>第二章 静生生物调查所创办经纬</h1><h2 id="酝酿筹设静生生物所调查"><a href="#酝酿筹设静生生物所调查" class="headerlink" title="酝酿筹设静生生物所调查"></a>酝酿筹设静生生物所调查</h2><p>在南京的生物所里的中国生物学家们．认为他们的研究范围，无力伸延至北方，而在有文化中心之称的北京，也应有一生物学研究机构之设立。秉志、胡先骕等人联名呈书中基会干事长范源廉。<br>范源廉(1874—1927)，字静生。素爱自然．业余时暇则治博物之学，十几年不辍，尝往郊外，采集植物，探研名实。当其主持中基会事务，以补助自然科学为职志，因于生物学早有亲缘，故与中国科学社生物研究所多有关顾，与生物学家也有交往。<br>筹设调查所事正在酝酿之中，范静生却突然于1927年12月23日在天津逝世，享年53岁。静生先生为人公正，尽心教育，数十年如一日，由于范先生人格的伟大，在世人心目之中具有较高威望，他的早逝，不仅没有延误调查所的实现，反而加快了调查所的诞生，人们意在以此来纪念静生先生。1928年春，生物调查所于北京成立．并以“静生”名之，以做永久纪念。</p>
<h2 id="合组静生生物调查所经过"><a href="#合组静生生物调查所经过" class="headerlink" title="合组静生生物调查所经过"></a>合组静生生物调查所经过</h2><p>范静生生前主持的中华教育文化基金董事会与尚志学会达成共识，共同组建生物调查所。<br>1928年6月19日，中基会第4次董事会，正式通过接受尚志学会嘱托，组织静生生物调查所，议决秉志为所长。7月，秉志、胡先骕即赴北京，负责组建。<br>静生所在起首时，因受经费的限制，所罗致的人才，名望皆不甚高，却都年轻有为，大都得到巨大发展，成为各个专门学科的人才。</p>
<h1 id="第三章-静生生物调查所事业的开创（1928-1937）"><a href="#第三章-静生生物调查所事业的开创（1928-1937）" class="headerlink" title="第三章 静生生物调查所事业的开创（1928-1937）"></a>第三章 静生生物调查所事业的开创（1928-1937）</h1><p>最初几年，所长秉志每年春秋两次北上，为静生所和生物所奔波于南北<br>两地。其不在北平时，静生所所务由胡先骕代理。秉志主持南北两所，实难兼顾，递交辞呈，胡先骕接任。秉志虽不再担任所长，但他在任几年所表现出的科学精神及对事业的敬谨诚笃的态度，乃具极大魅力，继任者胡先骕皆为之传承。</p>
<h2 id="静生生物调查所的初期事业"><a href="#静生生物调查所的初期事业" class="headerlink" title="静生生物调查所的初期事业"></a>静生生物调查所的初期事业</h2><p>1928年，静生生物开办于范旭东所捐其胞兄静生先生的故居，但面积太小，难以适应静生所事业发展。仅半年时间，便提出新办所址的提议，1931年4月即搬入文津街3号新址。</p>
<ol>
<li>植物部主要人员及研究</li>
</ol>
<ul>
<li>秦仁昌与蕨类植物研究</li>
<li>李良庆与藻类植物研究</li>
<li>唐燿与木材研究</li>
<li>冯澄如与生物绘图</li>
<li>周宗璜与真菌学研究</li>
</ul>
<ol start="2">
<li>动物部主要人员及研究</li>
</ol>
<ul>
<li>寿振黄与鸟类研究</li>
<li>张春霖与鱼类研究</li>
<li>沈嘉瑞与甲壳类研究</li>
</ul>
<ol start="3">
<li>藏书<br>静生所使用之图书，依托国立北平图书馆，因经费充裕，其所购置生物学之文献也甚为齐备。</li>
</ol>
<h2 id="静生生物调查所之采集"><a href="#静生生物调查所之采集" class="headerlink" title="静生生物调查所之采集"></a>静生生物调查所之采集</h2><p>静生生物调查所自成立之初便开始对所采集的标本予以分类化的研究。至1948年，共采集动物标本约30万件；植物标本约15万件；菌类标本约3.5万号。</p>
<ol>
<li>植物部之采集<br>前往山西、四川、吉林等地采集标本，采集旅途之中，不仅只是科学之理性，还有人文之情怀。如《凉山杂诗》一卷。</li>
<li>在云南的植物采集<br>在上述采集之后，事业不断壮大，便把目光投到了植物种类更加向往的地方。不仅非常辛苦，还有生命危险。主要人员蔡希陶，进行了为期三年的采集，1934年返平共得植物标本万余号，新种和新分布极多。静生所于1935年再派王启无等组队前往，为其两年。于1937年再派于德浚再次前往，与英国皇家园艺学会合作。他们所收集的标本，现大多收藏于中科院植物所、昆明植物所、华南植物所等。</li>
<li>动物部的采集<br>同样自建所即开始采集工作，但遗憾的是档案中关于这一部分的材料甚少。</li>
</ol>
<h2 id="庐山森林植物园创建始末"><a href="#庐山森林植物园创建始末" class="headerlink" title="庐山森林植物园创建始末"></a>庐山森林植物园创建始末</h2><p>20世纪初期，随着西学的全面引进，现代植物园作为大学的附设机构已开始建立，但作为正规化科研性质的植物园，则产生于20世纪30年代。此中以静生生物调查所与江西省农业院于1934年合办之庐山森林植物园最为著名。</p>
<ol>
<li>胡先骕与创设植物园之理想<br>1917年，胡先骕学成回国之后事业甚为失意，只得回到江西，被聘为庐山森林局副局长，在与自然之庐山交融中，却得到纯美的情感，在胡先骕以后的工作生涯中发挥了重要作用，为其日后选择庐山创办植物园奠定了基础。</li>
<li>选定庐山创设植物园<br>1931年，胡先骕重上庐山，对庐山植物做科学考察，发现了许多植物特有分布。此行让胡先骕感到，在庐山建一个森林植物园，以实现多年宿愿。选择庐山，自然条件是其次，主要是庐山已形成的文化环境（优越的政治地位，加上便利的交通和宜人的气候，使得一时学者云集，自然形成良好的文化氛围）。胡先骕以其在学界的地位和出色的组织才能说服了静生所委员会的委员们，使得在庐山床架森林植物园成为大家的共识。</li>
<li>委任秦仁昌筹建植物园<br>时任静生所技师兼任植物标本室主任，自告奋勇愿承担建园之责。其后便前往实地勘察，后携家眷正式移居庐山，在此开辟新的事业，为中国植物学史揭开新的一页。</li>
<li>庐山森林植物园之成立及职员<br>1934年8月20日植物园成立，秦仁昌担任主任。研究旨趣分为纯粹植物学研究与应用植物学研究两个方面。</li>
<li>创业初期<br>募集资金、任鸿隽与古青书屋、植物的调查与采集、园林建设及研究设施、陈封怀与庐山森林植物园、勘定界址</li>
</ol>
<h1 id="第四章-抗日战争时期的静生生物调查所（1937-1945）"><a href="#第四章-抗日战争时期的静生生物调查所（1937-1945）" class="headerlink" title="第四章 抗日战争时期的静生生物调查所（1937-1945）"></a>第四章 抗日战争时期的静生生物调查所（1937-1945）</h1><h2 id="北平沦陷后的静生所"><a href="#北平沦陷后的静生所" class="headerlink" title="北平沦陷后的静生所"></a>北平沦陷后的静生所</h2><p>静生所乃民间生物所，与国民政府无涉，所以在北平沦陷前几年，依靠美国在华势力，得以生存。</p>
<ol>
<li>沦陷后的研究工作<br>静生所经过10余年的学术积累，在植物学、动物学等研究成果已进入不断涌现时期，一些重要论文相继发表。</li>
<li>杨惟义代理所长<br>胡先骕准备出国考察之时，即已委任杨惟义代理所长之职。（主持任何一项事业的用人都会出现这样那样的问题，先贤也不能避免）。虽然杨尚乏声望，加之战事，诸多问题无法解决，但总体来说，尚称尽职，在任期间，所中工作能正常进行，为保存静生所，还与日本人周旋，得美国人之照拂。</li>
<li>静生所所址被日军侵占<br>1941年12月，美日交恶，太平洋战争爆发，受美国势力保护的中国文化教育机构被视为美国在中国的财产，被日军强行占领，司徒雷登也在北平被日军羁押，12月8日，日军封闭静生所，所员全被驱逐，图书及动植物标本概未救出。静生所在沦陷之后，因各种事由，最终留在北平的人员，不得已而任事于伪职，以维持生活，苟全性命于乱世，但是他们并没有忘记自己的事业。（因为他们的屈辱被认为是失去民族的气节。抗日战争胜利后，胡先骕在静生所复员时，在人员的安排上，也如当时社会对待在敌伪时期所供职的人员一样，对他们不予考虑：在1949年后，这些在日本人统治之下供过职的人，更被称为民族的叛徒汉奸，得到不同程度的迫害，使他们的人格道受了更大的屈辱。）</li>
</ol>
<h2 id="云南农林植物研究所创办缘起"><a href="#云南农林植物研究所创办缘起" class="headerlink" title="云南农林植物研究所创办缘起"></a>云南农林植物研究所创办缘起</h2><p>中国的西南，生物物种极为丰富，近代以来许多国外人士以各种名义纷纷前住采集，获得大量植物标本，经植物学家的研究，发现极具科学价值和开发价值，遂享誉全球。静生生物所成立之后，也着手调查西南地区的生物资源。</p>
<ol>
<li>筹设原委<br>1937年初，胡先骕致函云南教育厅长龚自知，提出愿与教育厅合作在昆明创设一植物研究所。达成初步意向后，1938年春即派曾在云南进行植物采集的蔡希陶前往昆明，勘察所址及筹备相关其他事宜。蔡希陶最终选址黑龙潭。</li>
<li>初期概况<br>开办起来，其员工自当奋起工作，努力为之。胡先骕十分关心，1940年春亲下云南主持工作，并且请国民政府每年资助。云南政府的经费也得以增加，这些经费使得农林所规模扩大，人员增多，一些研究工程相继落成，野外工作也得以展开。此外还邀请了郑万钧等著名学者来所工作。</li>
<li>研究成就<br>农林所同仁之研究所得，前期大多刊于《静生生物调查所汇报》，其中一些论文颇为重要。静生所被日军占领后，随着农林所研究成绩渐多，遂有编辑出版《云南农林所植物研究所丛刊》。但是随着抗日战争进入艰苦时期，研究工作自然也受到影响，甚至员工生活难以为继，主要人员先后散去。最后所务由蔡希陶主持，其时已是国内战争时期。</li>
</ol>
<h2 id="中正大学静生所办事处"><a href="#中正大学静生所办事处" class="headerlink" title="中正大学静生所办事处"></a>中正大学静生所办事处</h2><p>北平落入日本人之手后，胡先骕前往昆明主持云南农林所，1941年，胡先骕任国立中正大学校长，从而促进了静生所与中正大学的合作事宜。</p>
<ol>
<li>研究工作<br>静生所许多人员来中正大学教学，创办并扩大了中正大学生物系。杨惟义研究了多种杀虫植物；彭鸿绶采集研究当地两栖类及爬虫类动物……</li>
<li>新增人员<br>1943年，胡先骕招收了傅书遐为采集员，1945年日本投降后为静生所复原后的主要人员。复原时更为重要的人员还有张肇骞，也是此时为胡先骕所延揽。</li>
</ol>
<h2 id="庐山森林植物园丽江工作站"><a href="#庐山森林植物园丽江工作站" class="headerlink" title="庐山森林植物园丽江工作站"></a>庐山森林植物园丽江工作站</h2><p>庐山森林植物园成立不几年便以优异成绩令世人瞩目。但遇到抗日战争爆发，庐山被日本人占领，人员不得不走西南，在云南丽江建立工作站。</p>
<ol>
<li>西迁之前<br>“七七事变”之后，庐山森林植物园尚未收到战争直接影响，1938年上半年各类工作仍顺利进行，仍有实验室等施工。</li>
<li>西迁经过<br>抗日战争全面爆发仅1年，庐山就已在铁蹄的威胁之下。1938年10月底，植物园得到西迁的指令，其时拟加入云南农林所。与静生所想法一致，许多物品都寄存在了庐山美国学习，认为日人会礼遇英美。然而最后均被日军霸占，日军获悉植物园与静生所关系后，便把部分物品运往北平静生所，供日军使用。</li>
<li>设立丽江工作站<br>植物园大多员工到达昆明后，即加入农林所工作，然该所人员甚多，房舍容纳不了且植物园本有志于高山花卉研究，遂决定前往丽江设立分所。经费十分吃紧，但任坚持不懈，克服困难，做出许多令后人称艳的业绩。</li>
<li>研究成就<br>秦仁昌继续其蕨类植物研究，研究不断深入，1940年发表的《水龙骨科的自然分类系统》震惊了世界植物学界。<br>植物园前往丽江的首要目的是：收集各种真气森林园艺植物以供繁殖，采集植物腊叶标本以供研究。</li>
<li>绝处逢生<br>秦仁昌谋得政府林业部门建立的“金沙江流域林业管理处”负责人，遂将工作站人员纳入该处；同时，秦仁昌还进行了一些应用技术的研究，用于生产。</li>
</ol>
<h2 id="四川乐山木材实验室创建原委"><a href="#四川乐山木材实验室创建原委" class="headerlink" title="四川乐山木材实验室创建原委"></a>四川乐山木材实验室创建原委</h2><p>唐燿美国留学归来后于1939年秋由静生所与经济部工业试验研究所在四川乐山合办木材试验研究室，由唐燿任主任，该研究室为中国木材学的发展做出了奠基性贡献。</p>
<ol>
<li>唐燿在国外留学与考察<br>1935年，经秉志、胡先骕推荐，唐燿获得中基会资助，赴美耶鲁大学研究院进修。学习结束后，即赴加拿大、欧洲各相关学术机构进行考察。</li>
<li>四川乐山木材试验室<br>唐燿系1939年回国，9月22日即乘飞机前往重庆开辟工作。但正当筹备之时，不幸遭到日军飞机轰炸，遂把木材室迁往乐山。就这样，唐燿筚路蓝缕，开创了中国第一个木材实验室。（李约瑟抗战时在中国考察科学事业时曾视察该室）</li>
<li>研究工作<br>1）培养了一批国内外知名的木材专家。<br>2）编印了《木材试验室特刊》。</li>
</ol>
<h2 id="陷于孤岛中的秉志"><a href="#陷于孤岛中的秉志" class="headerlink" title="陷于孤岛中的秉志"></a>陷于孤岛中的秉志</h2><p>抗日战争爆发之际，秉志夫人病重，在沪就医，长久不能起床，秉志只得坐困沪上。秉志家中5个子女，皆尚幼，经济来源几绝，以秉志的社会名望，日本对他的情况调查的十分清楚，企图拉他出来做事。然而秉志不为所动，隐姓埋名，蓄起胡须，过起隐居生活，潜心研究，长达八年之久。</p>
<ol>
<li>二通旧札<br>在与任鸿隽通信中可以看出来，秉志之所以能够度过此漫长劫难，中基会提供了不可或缺的帮助，但其生活依旧艰难。</li>
<li>潜心研究和著述<br>秉志不时在做内迁的准备，几次即将动身却有突发情况不得成行。秉志在沪上虽有种种危险和困苦，但继续他的研究，其研究细致入微，成绩卓著。</li>
</ol>
<h1 id="第五章-静生生物所的复员（1945-1948）"><a href="#第五章-静生生物所的复员（1945-1948）" class="headerlink" title="第五章 静生生物所的复员（1945-1948）"></a>第五章 静生生物所的复员（1945-1948）</h1><h2 id="北平静生生物调查所的复员"><a href="#北平静生生物调查所的复员" class="headerlink" title="北平静生生物调查所的复员"></a>北平静生生物调查所的复员</h2><p>1945年日本投降，胡先骕饱受战争苦难之后精神已甚衰微，但仍欣喜鼓舞，他视若生命的静生所将得以复员。</p>
<ol>
<li>复员的准备<br>胡先骕致信任鸿隽，他的意见得到任鸿隽的赞同，复函劝胡先骕立即回北平，主持复员工作。</li>
<li>接收静生所<br>其时敌占区所有的文化教育机构已由政府主持办理接受手续，10月17日办理了文津街3号静生所的接收工作，18日接收了石驸马大街83号静生所所属的通俗博物馆。<br>静生所复员后的职员，因经费拮据，商得暂时复员植物部，也仅限于种子植物方面得研究。</li>
<li>复员工作<br>1940年10月，胡先骕终于回到北平，亲临主持静生所，并重新开始在自己得植物分类学研究。自此至1948年底北平解放，短短两年里时局动荡，国家经济迅速崩溃，静生所陷入艰难境地，遂百般寻求社会支持，然收效甚微，复员进展缓慢，研究工作极难展开。<br>在如此艰难时期，研究并未中断，虽学科范围缩小了很多，但战时得工作积累使得成果相机涌现，并取得骄人成绩。胡先骕、郑万钧合著得《水杉新科及生存之水杉新种》震动了当时国际植物学界。静生所其他人员的研究也都在积极进行。但动物部未能复员一直是胡先骕得一块心病，各种合作援助等都是画饼充饥，未见实施。<br>与中央政府主办的林业试验所合作编辑出版了《中国森林树木图志》，但随中华人民共和国成立，一切事业重新开始，10年出版10册的宏大计划仅出版1册即告结束；与林业试验所合作进行滇北赣北森林植物调查，但未有圆满之结果，仅差强人意。</li>
</ol>
<p>总之，静生所虽经历了两年多的复员，但远没有达到战前水准。</p>
<h2 id="庐山森林植物园的复员"><a href="#庐山森林植物园的复员" class="headerlink" title="庐山森林植物园的复员"></a>庐山森林植物园的复员</h2><p>历经战乱的庐山森林植物园景物全非，满目疮痍，陈封怀主持的复员工作自1946年8月1日正式开始。</p>
<ol>
<li>复员进展<br>陈封怀一方面向江西农业院申请经费，另一方面也和任鸿隽沟通，双方为了植物园呕心沥血，费尽心思。</li>
<li>研究和采集工作<br>繁殖试验水杉，结果甚好；由庐山森林植物园代表静生所和中央林业实验所进行湘鄂赣边区森林资源调查。</li>
</ol>
<h2 id="云南农林植物所的生产"><a href="#云南农林植物所的生产" class="headerlink" title="云南农林植物所的生产"></a>云南农林植物所的生产</h2><p>抗日战争胜利之际，云南农林植物研究所经费拮据，人员星散，先未曾有大规模工作，后参与合作调查滇南森林植物。蔡希陶在云南试种烟草，获得丰收，缓解了经济局面。</p>
<h1 id="第六章-静生生物调查所的终结-（1949-1950）"><a href="#第六章-静生生物调查所的终结-（1949-1950）" class="headerlink" title="第六章 静生生物调查所的终结 （1949-1950）"></a>第六章 静生生物调查所的终结 （1949-1950）</h1><p>胡先骕对国民党已感失望，但对共产党又因惧怕而反对，所以政治主张走了第三条道路，积极与北京大学一些知名教授组织独立时论社，还组织成立了社会党，但不仅静生所事业艰难，其个人生活也陷入困境。</p>
<ol>
<li>胡先骕留在大陆的原因<br>对于自己热爱的植物学研究，对于自己终身的事业静生所，对于复员时对旧政府的失望，他把希望寄托在了新政府，期望静生所不仅可以恢复，还可以光大，但没有预料到，他的一系列时政论文已经产生了不可挽回的影响。<br>胡先骕一直希望政府接办静生所，多次致函军管文化接管会。6月，华北人民政府批准接管静生所得决议，将该所纳入华北大学农学院领导。</li>
<li>关于静生生物调查所所址<br>1949年11月1日，中国科学院成立。对于植物学，国内已有诸多研究机构，有组织一统一研究所得设想。静生所由于其骄人的业绩，科学院乐于接管，但须予以改组。（中科院想接收静生所，更想占其房屋作为科学院院址，但胡先骕只同意被纳入科学院，但不同意房屋被占用，中科院郭沫若、严济慈等人成立整理委员会，整理静生所是名，迁走静生所是实，此时的胡先骕面对强大的压力，只好任之，实属无奈，在整理委员会会议上的发言感人至深。）</li>
<li>合组中国科学院植物分类研究所<br>中科院决定将静生所与北平研究院植物研究所合并，重新组建中科院植物分类研究所。静生生物调查所就这样终结了，中科院植物分类研究所成立后，胡先骕曾担任研究员，后改名中国科学院植物研究所。在静生所的动物标本基础上扩建成立了中科院动物研究所。</li>
</ol>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_4</title>
    <url>/2019/04/02/2019-04-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树"></a>什么是二叉搜索树</h2><p>二叉搜索树，也叫二叉查找树或二叉排序树。<br>一棵二叉树，可以为空，如果不为空，则满足一下性质：</p>
<ol>
<li>非空<strong>左</strong>子树的键值<strong>小于</strong>其根节点的键值；</li>
<li>非空<strong>右</strong>子树的键值<strong>大于</strong>其根节点的键值；</li>
<li>左右子树都是二叉搜索树；</li>
</ol>
<h2 id="二叉搜索树进行的操作"><a href="#二叉搜索树进行的操作" class="headerlink" title="二叉搜索树进行的操作"></a>二叉搜索树进行的操作</h2><p>查找某元素、查找最大最小值、插入、删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BinTree Insert( BinTree BST, ElementType X )</span><br><span class="line">&#123;</span><br><span class="line">    if( !BST )&#123; /* 若原树为空，生成并返回一个结点的二叉搜索树 */</span><br><span class="line">        BST = (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; /* 开始找要插入元素的位置 */</span><br><span class="line">        if( X &lt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Left = Insert( BST-&gt;Left, X );   /*递归插入左子树*/</span><br><span class="line">        else  if( X &gt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Right = Insert( BST-&gt;Right, X ); /*递归插入右子树*/</span><br><span class="line">        /* else X已经存在，什么都不做 */</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">BinTree Delete( BinTree BST, ElementType X ) </span><br><span class="line">&#123; </span><br><span class="line">    Position Tmp; </span><br><span class="line"> </span><br><span class="line">    if( !BST ) </span><br><span class="line">        printf(&quot;要删除的元素未找到&quot;); </span><br><span class="line">    else &#123;</span><br><span class="line">        if( X &lt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Left = Delete( BST-&gt;Left, X );   /* 从左子树递归删除 */</span><br><span class="line">        else if( X &gt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Right = Delete( BST-&gt;Right, X ); /* 从右子树递归删除 */</span><br><span class="line">        else &#123; /* BST就是要删除的结点 */</span><br><span class="line">            /* 如果被删除结点有左右两个子结点 */ </span><br><span class="line">            if( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;</span><br><span class="line">                /* 从右子树中找最小的元素填充删除结点 */</span><br><span class="line">                Tmp = FindMin( BST-&gt;Right );</span><br><span class="line">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">                /* 从右子树中删除最小元素 */</span><br><span class="line">                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; /* 被删除结点有一个或无子结点 */</span><br><span class="line">                Tmp = BST; </span><br><span class="line">                if( !BST-&gt;Left )       /* 只有右孩子或无子结点 */</span><br><span class="line">                    BST = BST-&gt;Right; </span><br><span class="line">                else                   /* 只有左孩子 */</span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                free( Tmp );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树#"></a>平衡二叉树#</h1><h2 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h2><p>“平衡因子BF”：BF(T)=h<sub>L</sub> -h<sub>R</sub>,分别为左右子树高度<br>平衡二叉树(AVL树)：空树或者任一结点左右子树高度差的绝对值不超过1，即|BF(T)|&lt;=1</p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol>
<li>设n<sub>h</sub>是高度为h的平衡二叉树的最小结点数，那么有n<sub>h</sub>=n<sub>h-1</sub>+n<sub>h-2</sub>+1，且有n<sub>h</sub>=F<sub>h+2</sub>-1(F为斐波那契数列)</li>
<li>h=O(log<sub>2</sub>n)</li>
</ol>
<h2 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h2><p>在进行插入、删除操作时，会造成二叉树的不平衡，故需要调整。</p>
<ol>
<li>“麻烦结点”在“发现者”右子树的右边，因而叫RR插入，需要RR旋转（右单旋）；</li>
<li>“麻烦结点”在“发现者”左子树的左边，因而叫LL插入，需要LL旋转（左单旋）；</li>
<li>“麻烦结点”在“发现者”左子树的右边，因而叫LR插入，需要LR旋转；</li>
<li>“麻烦结点”在“发现者”右子树的右左边，因而叫RL插入，需要RL旋转；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct AVLNode *Position;</span><br><span class="line">typedef Position AVLTree; /* AVL树类型 */</span><br><span class="line">struct AVLNode&#123;</span><br><span class="line">    ElementType Data; /* 结点数据 */</span><br><span class="line">    AVLTree Left;     /* 指向左子树 */</span><br><span class="line">    AVLTree Right;    /* 指向右子树 */</span><br><span class="line">    int Height;       /* 树高 */</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int Max ( int a, int b )</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">AVLTree SingleLeftRotation ( AVLTree A )</span><br><span class="line">&#123; /* 注意：A必须有一个左子结点B */</span><br><span class="line">  /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */     </span><br><span class="line"> </span><br><span class="line">    AVLTree B = A-&gt;Left;</span><br><span class="line">    A-&gt;Left = B-&gt;Right;</span><br><span class="line">    B-&gt;Right = A;</span><br><span class="line">    A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;</span><br><span class="line">    B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1;</span><br><span class="line">  </span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">AVLTree DoubleLeftRightRotation ( AVLTree A )</span><br><span class="line">&#123; /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */</span><br><span class="line">  /* 将A、B与C做两次单旋，返回新的根结点C */</span><br><span class="line">     </span><br><span class="line">    /* 将B与C做右单旋，C被返回 */</span><br><span class="line">    A-&gt;Left = SingleRightRotation(A-&gt;Left);</span><br><span class="line">    /* 将A与C做左单旋，C被返回 */</span><br><span class="line">    return SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*************************************/</span><br><span class="line">/* 对称的右单旋与右-左双旋请自己实现 */</span><br><span class="line">/*************************************/</span><br><span class="line"> </span><br><span class="line">AVLTree Insert( AVLTree T, ElementType X )</span><br><span class="line">&#123; /* 将X插入AVL树T中，并且返回调整后的AVL树 */</span><br><span class="line">    if ( !T ) &#123; /* 若插入空树，则新建包含一个结点的树 */</span><br><span class="line">        T = (AVLTree)malloc(sizeof(struct AVLNode));</span><br><span class="line">        T-&gt;Data = X;</span><br><span class="line">        T-&gt;Height = 0;</span><br><span class="line">        T-&gt;Left = T-&gt;Right = NULL;</span><br><span class="line">    &#125; /* if (插入空树) 结束 */</span><br><span class="line"> </span><br><span class="line">    else if ( X &lt; T-&gt;Data ) &#123;</span><br><span class="line">        /* 插入T的左子树 */</span><br><span class="line">        T-&gt;Left = Insert( T-&gt;Left, X);</span><br><span class="line">        /* 如果需要左旋 */</span><br><span class="line">        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == 2 )</span><br><span class="line">            if ( X &lt; T-&gt;Left-&gt;Data ) </span><br><span class="line">               T = SingleLeftRotation(T);      /* 左单旋 */</span><br><span class="line">            else </span><br><span class="line">               T = DoubleLeftRightRotation(T); /* 左-右双旋 */</span><br><span class="line">    &#125; /* else if (插入左子树) 结束 */</span><br><span class="line">     </span><br><span class="line">    else if ( X &gt; T-&gt;Data ) &#123;</span><br><span class="line">        /* 插入T的右子树 */</span><br><span class="line">        T-&gt;Right = Insert( T-&gt;Right, X );</span><br><span class="line">        /* 如果需要右旋 */</span><br><span class="line">        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == -2 )</span><br><span class="line">            if ( X &gt; T-&gt;Right-&gt;Data ) </span><br><span class="line">               T = SingleRightRotation(T);     /* 右单旋 */</span><br><span class="line">            else </span><br><span class="line">               T = DoubleRightLeftRotation(T); /* 右-左双旋 */</span><br><span class="line">    &#125; /* else if (插入右子树) 结束 */</span><br><span class="line"> </span><br><span class="line">    /* else X == T-&gt;Data，无须插入 */</span><br><span class="line"> </span><br><span class="line">    /* 别忘了更新树高 */</span><br><span class="line">    T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1;</span><br><span class="line">     </span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_3</title>
    <url>/2019/03/18/2019-03-18-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="树与树的表示"><a href="#树与树的表示" class="headerlink" title="树与树的表示"></a>树与树的表示</h1><h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><p>分层次管理的结构，在管理上有更高的效率。<br><strong>树</strong>：n(n&gt;=0)个结点构成的有限子集。<br>当n=0时，称为空树；当n&gt;0时，具备以下性质：</p>
<ul>
<li>树中有一个特殊结点，称为“根root”；</li>
<li>其余结点可分为m个互不相交的有限集，其中每个集合本身又是一棵树，称为原来树的“子树”，子树是不相交的；</li>
</ul>
<p>以查找为例，查找分为静态查找（集合中记录是固定的，例如查字典）和动态查找（集合中记录是动态变化的）。<br><strong>静态查找</strong>：顺序查找（有哨兵和无哨兵）、二分查找<br>二分查找判定树：判定树上每个结点需要的查找次数刚好为该结点所在的层数===&gt;n个结点的判定树的深度为[log n]+1</p>
<h2 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h2><p>儿子兄弟表示法:每一个结点有两个指针域，FirstChild和NextSibling，分别指向第一个儿子和下一个兄弟。</p>
<h1 id="二叉树及存储结构"><a href="#二叉树及存储结构" class="headerlink" title="二叉树及存储结构#"></a>二叉树及存储结构#</h1><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树T是一个有穷的结点集合，这个集合可以为空；若不为空，则它是由根结点和称为其左子树和右子树的两个不相交的二叉树组成。二叉树的子树有左右顺序之分。<br>完美二叉树==满二叉树=/=完全二叉树<br>将满二叉树的结点按照从上到下，从左到右的顺序进行编号，如果此二叉树中所有结点编号和对应的满二叉树相同，则为完全二叉树，也就是满二叉树去掉最后几个结点即完全二叉树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct TNode *Position;</span><br><span class="line">typedef Position BinTree; /* 二叉树类型 */</span><br><span class="line">struct TNode&#123; /* 树结点定义 */</span><br><span class="line">    ElementType Data; /* 结点数据 */</span><br><span class="line">    BinTree Left;     /* 指向左子树 */</span><br><span class="line">    BinTree Right;    /* 指向右子树 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol>
<li>一个二叉树第i层的最大结点数为2^(i-1)，i&gt;=1。</li>
<li>深度为k的二叉树最大结点总数为(2^k)-1，k&gt;=1。</li>
<li>对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶节点个数，那么有n0=n2+1。</li>
</ol>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>适用于完全二叉树，用数组进行存储。非根结点（序号i&gt;1）的父结点的序号是[i/2]；结点（序号为i）的左孩子结点的序号为2i，右孩子结点序号为2i+1。一般二叉树也可以采取这种方法，补充成完全二叉树，但是会造成空间浪费。</p>
<h3 id="链表存储结构"><a href="#链表存储结构" class="headerlink" title="链表存储结构"></a>链表存储结构</h3><p>适用于一般完全二叉树。三个域，left/data/right。</p>
<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="先序"><a href="#先序" class="headerlink" title="先序"></a>先序</h2><p>递归：根结点-先序遍历左子树-先序遍历右子树<br>堆栈：参照中序</p>
<h2 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h2><p>递归：中序遍历左子树-根结点-中序遍历右子树<br>堆栈：遇到一个结点，就把它压栈，并去遍历它的左子树，当左子树遍历结束后，从栈顶弹出这个结点并访问它，然后按其右指针再去中序遍历该结点的右子树。</p>
<h2 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h2><p>递归：后序遍历左子树-后序遍历右子树-根结点<br>堆栈：参照中序</p>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>从结点访问其左右儿子结点。访问左儿子后，右儿子结点需要用堆栈或队列暂时保存不访问的结点。<br>队列实现：遍历从根节点开始，首先将根节点入列，然后开始执行循环：结点出队、访问该结点、其左右儿子入队。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InorderTraversal( BinTree BT )</span><br><span class="line">&#123;</span><br><span class="line">    if( BT ) &#123;</span><br><span class="line">        InorderTraversal( BT-&gt;Left );</span><br><span class="line">        /* 此处假设对BT结点的访问就是打印数据 */</span><br><span class="line">        printf(&quot;%d &quot;, BT-&gt;Data); /* 假设数据为整型 */</span><br><span class="line">        InorderTraversal( BT-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void PreorderTraversal( BinTree BT )</span><br><span class="line">&#123;</span><br><span class="line">    if( BT ) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, BT-&gt;Data );</span><br><span class="line">        PreorderTraversal( BT-&gt;Left );</span><br><span class="line">        PreorderTraversal( BT-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void PostorderTraversal( BinTree BT )</span><br><span class="line">&#123;</span><br><span class="line">    if( BT ) &#123;</span><br><span class="line">        PostorderTraversal( BT-&gt;Left );</span><br><span class="line">        PostorderTraversal( BT-&gt;Right );</span><br><span class="line">        printf(&quot;%d &quot;, BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void LevelorderTraversal ( BinTree BT )</span><br><span class="line">&#123; </span><br><span class="line">    Queue Q; </span><br><span class="line">    BinTree T;</span><br><span class="line"> </span><br><span class="line">    if ( !BT ) return; /* 若是空树则直接返回 */</span><br><span class="line">     </span><br><span class="line">    Q = CreatQueue(); /* 创建空队列Q */</span><br><span class="line">    AddQ( Q, BT );</span><br><span class="line">    while ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        T = DeleteQ( Q );</span><br><span class="line">        printf(&quot;%d &quot;, T-&gt;Data); /* 访问取出队列的结点 */</span><br><span class="line">        if ( T-&gt;Left )   AddQ( Q, T-&gt;Left );</span><br><span class="line">        if ( T-&gt;Right )  AddQ( Q, T-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript初探_7</title>
    <url>/2019/03/12/2019-03-12-JavaScript%E5%88%9D%E6%8E%A2_7/</url>
    <content><![CDATA[<blockquote>
<p>这一部分主要新增了Setting.vue以及对Form.vue进行了改动。</p>
</blockquote>
<h1 id="Setting-vue"><a href="#Setting-vue" class="headerlink" title="Setting.vue"></a>Setting.vue</h1><p>主要功能有相片的上传（update），主要参照图片列表缩略图，同时加入了一些新的内容，例如判别图片类型是否合乎规范，上传张数是否超额等；另外一个功能为评分（rate），本来想用示例中笑脸的例子，可是当时安装element时没有void-icon-class所需要的库，所以改为了普通的星状，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-row style=&quot;margin-top:20px;margin-bottom:80px&quot;&gt;</span><br><span class="line">      &lt;div&gt;请上传头像!&lt;/div&gt;</span><br><span class="line">      &lt;el-upload class=&quot;upload-demo&quot;</span><br><span class="line">                 action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;</span><br><span class="line">                 :before-upload=&quot;beforeAvatarUpload&quot;</span><br><span class="line">                 :on-success=&quot;handleSuccess&quot;</span><br><span class="line">                 :on-remove=&quot;handleRemove&quot;</span><br><span class="line">                 :before-remove=&quot;beforeRemove&quot;</span><br><span class="line">                 :limit=&quot;3&quot;</span><br><span class="line">                 :on-exceed=&quot;handleExceed&quot;</span><br><span class="line">                 :file-list=&quot;fileList2&quot;</span><br><span class="line">                 list-type=&quot;picture&quot;&gt;</span><br><span class="line">        &lt;el-button size=&quot;small&quot;</span><br><span class="line">                   type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;</span><br><span class="line">        &lt;div slot=&quot;tip&quot;</span><br><span class="line">             class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;</span><br><span class="line">      &lt;/el-upload&gt;</span><br><span class="line">      &lt;el-dialog :visible.sync=&quot;dialogVisible&quot;&gt;</span><br><span class="line">        &lt;img width=&quot;100%&quot;</span><br><span class="line">             :src=&quot;dialogImageUrl&quot;</span><br><span class="line">             alt=&quot;&quot;&gt;</span><br><span class="line">      &lt;/el-dialog&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">    &lt;div&gt;请对本系统进行评分！&lt;/div&gt;</span><br><span class="line">    &lt;el-rate v-model=&quot;value&quot;</span><br><span class="line">             show-text&gt;</span><br><span class="line">    &lt;/el-rate&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      value: null,</span><br><span class="line">      fileList2: [&#123; name: &apos;food.jpeg&apos;, url: &apos;https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100&apos; &#125;, &#123; name: &apos;food2.jpeg&apos;, url: &apos;https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100&apos; &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 判断上传文件类型</span><br><span class="line">    beforeAvatarUpload: function (file) &#123;</span><br><span class="line">      var me = this</span><br><span class="line">      var isJPG = file.type === &apos;image/jpeg&apos;</span><br><span class="line">      var isPNG = file.type === &apos;image/png&apos;</span><br><span class="line">      if (!(isJPG || isPNG)) &#123;</span><br><span class="line">        me.$message.error(&apos;上传的文件只能是 JPG 或者是 PNG 格式的&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">      else me.handlePreview(file)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleRemove(file, fileList) &#123;</span><br><span class="line">      console.log(file, fileList);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 文件超出个数限制时的钩子</span><br><span class="line">    handleExceed(file, fileList) &#123;</span><br><span class="line">      const me = this</span><br><span class="line">      me.$message.warning(&apos;只能上传一个文件&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //确认删除</span><br><span class="line">    beforeRemove(file, fileList) &#123;</span><br><span class="line">      return this.$confirm(`确定移除 $&#123;file.name&#125;？`);</span><br><span class="line">    &#125;,</span><br><span class="line">    //上传成功</span><br><span class="line">    handleSuccess(res, file) &#123;</span><br><span class="line">      this.imageUrl = URL.createObjectURL(file.raw);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Form-vue"><a href="#Form-vue" class="headerlink" title="Form.vue"></a>Form.vue</h1><p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_2</title>
    <url>/2019/03/09/2019-03-09-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="线性表及其实现"><a href="#线性表及其实现" class="headerlink" title="线性表及其实现"></a>线性表及其实现</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>以一元多项式表示及运算为例：</p>
<ol>
<li>顺序存储结构直接表示。数组各分量对应多项式各项，如a[i]表示项x^i的系数ai,表示方法简单，操作也很方便，但有时会造成空间的浪费，例如表示f(x)=x+x^2000，就要开辟一个2001大小的数组来表示；</li>
<li>顺序存储结构表示非零项。每个非零项ai*x^i涉及两个信息：系数ai和指数i，可以将一个多项式看作一个二元数组（ai,i）的集合，每一项按照指数大小顺序存储的话，进行加减操作也比较简单；</li>
<li>链表结构存储非零项。链表中每个结点存储一个非零项，包括系数和指数两个数据域以及一个指针域。</li>
</ol>
<p><strong>线性表</strong>：由同类型数据元素构成<strong>有序序列</strong>的线性结构。</p>
<h2 id="线性表的实现"><a href="#线性表的实现" class="headerlink" title="线性表的实现"></a>线性表的实现</h2><ol>
<li>线性表的顺序存储实现。利用数组的连续存储空间顺序存放线性表的各元素；</li>
<li>线性表的链式存储实现。不要求逻辑上相邻的两个元素物理上也相邻。</li>
</ol>
<p>两种方式都包括移动、查找、插入、删除等操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int Position;</span><br><span class="line">typedef struct LNode *List;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 初始化 */</span><br><span class="line">List MakeEmpty()</span><br><span class="line">&#123;</span><br><span class="line">    List L;</span><br><span class="line"> </span><br><span class="line">    L = (List)malloc(sizeof(struct LNode));</span><br><span class="line">    L-&gt;Last = -1;</span><br><span class="line"> </span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 查找 */</span><br><span class="line">#define ERROR -1</span><br><span class="line"> </span><br><span class="line">Position Find( List L, ElementType X )</span><br><span class="line">&#123;</span><br><span class="line">    Position i = 0;</span><br><span class="line"> </span><br><span class="line">    while( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )</span><br><span class="line">        i++;</span><br><span class="line">    if ( i &gt; L-&gt;Last )  return ERROR; /* 如果没找到，返回错误信息 */</span><br><span class="line">    else  return i;  /* 找到后返回的是存储位置 */</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 插入 */</span><br><span class="line">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="line">bool Insert( List L, ElementType X, Position P ) </span><br><span class="line">&#123; /* 在L的指定位置P前插入一个新元素X */</span><br><span class="line">    Position i;</span><br><span class="line"> </span><br><span class="line">    if ( L-&gt;Last == MAXSIZE-1) &#123;</span><br><span class="line">        /* 表空间已满，不能插入 */</span><br><span class="line">        printf(&quot;表满&quot;); </span><br><span class="line">        return false; </span><br><span class="line">    &#125;  </span><br><span class="line">    if ( P&lt;0 || P&gt;L-&gt;Last+1 ) &#123; /* 检查插入位置的合法性 */</span><br><span class="line">        printf(&quot;位置不合法&quot;);</span><br><span class="line">        return false; </span><br><span class="line">    &#125; </span><br><span class="line">    for( i=L-&gt;Last; i&gt;=P; i-- )</span><br><span class="line">        L-&gt;Data[i+1] = L-&gt;Data[i]; /* 将位置P及以后的元素顺序向后移动 */</span><br><span class="line">    L-&gt;Data[P] = X;  /* 新元素插入 */</span><br><span class="line">    L-&gt;Last++;       /* Last仍指向最后元素 */</span><br><span class="line">    return true; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">/* 删除 */</span><br><span class="line">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="line">bool Delete( List L, Position P )</span><br><span class="line">&#123; /* 从L中删除指定位置P的元素 */</span><br><span class="line">    Position i;</span><br><span class="line"> </span><br><span class="line">    if( P&lt;0 || P&gt;L-&gt;Last ) &#123; /* 检查空表及删除位置的合法性 */</span><br><span class="line">        printf(&quot;位置%d不存在元素&quot;, P ); </span><br><span class="line">        return false; </span><br><span class="line">    &#125;</span><br><span class="line">    for( i=P+1; i&lt;=L-&gt;Last; i++ )</span><br><span class="line">        L-&gt;Data[i-1] = L-&gt;Data[i]; /* 将位置P+1及以后的元素顺序向前移动 */</span><br><span class="line">    L-&gt;Last--; /* Last仍指向最后元素 */</span><br><span class="line">    return true;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct LNode *PtrToLNode;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToLNode Position;</span><br><span class="line">typedef PtrToLNode List;</span><br><span class="line"> </span><br><span class="line">/* 查找 */</span><br><span class="line">#define ERROR NULL</span><br><span class="line"> </span><br><span class="line">Position Find( List L, ElementType X )</span><br><span class="line">&#123;</span><br><span class="line">    Position p = L; /* p指向L的第1个结点 */</span><br><span class="line"> </span><br><span class="line">    while ( p &amp;&amp; p-&gt;Data!=X )</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line"> </span><br><span class="line">    /* 下列语句可以用 return p; 替换 */</span><br><span class="line">    if ( p )</span><br><span class="line">        return p;</span><br><span class="line">    else</span><br><span class="line">        return ERROR;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 带头结点的插入 */</span><br><span class="line">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span><br><span class="line">bool Insert( List L, ElementType X, Position P )</span><br><span class="line">&#123; /* 这里默认L有头结点 */</span><br><span class="line">    Position tmp, pre;</span><br><span class="line"> </span><br><span class="line">    /* 查找P的前一个结点 */        </span><br><span class="line">    for ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            </span><br><span class="line">    if ( pre==NULL ) &#123; /* P所指的结点不在L中 */</span><br><span class="line">        printf(&quot;插入位置参数错误\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; /* 找到了P的前一个结点pre */</span><br><span class="line">        /* 在P前插入新结点 */</span><br><span class="line">        tmp = (Position)malloc(sizeof(struct LNode)); /* 申请、填装结点 */</span><br><span class="line">        tmp-&gt;Data = X; </span><br><span class="line">        tmp-&gt;Next = P;</span><br><span class="line">        pre-&gt;Next = tmp;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 带头结点的删除 */</span><br><span class="line">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span><br><span class="line">bool Delete( List L, Position P )</span><br><span class="line">&#123; /* 这里默认L有头结点 */</span><br><span class="line">    Position tmp, pre;</span><br><span class="line"> </span><br><span class="line">    /* 查找P的前一个结点 */        </span><br><span class="line">    for ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            </span><br><span class="line">    if ( pre==NULL || P==NULL) &#123; /* P所指的结点不在L中 */</span><br><span class="line">        printf(&quot;删除位置参数错误\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; /* 找到了P的前一个结点pre */</span><br><span class="line">        /* 将P位置的结点删除 */</span><br><span class="line">        pre-&gt;Next = P-&gt;Next;</span><br><span class="line">        free(P);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表是线性表的推广，对于线性表而言，n个元素都是基本的单元素，而在广义表中，这些元素不仅可以是单元素也可以是另一个广义表。</p>
<h2 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h2><p>链表中的节点可能同时隶属于多个链，也就是说多重链表中结点的指针域会有多个，但包含两个指针域的链表并不一定是多重链表，例如双向链表不是多重链表。树、图等复杂的数据结构都可以采用多重链表来存储，<br>典型的多重链表：十字链表（用来存储稀疏矩阵等）</p>
<h1 id="堆栈及其实现"><a href="#堆栈及其实现" class="headerlink" title="堆栈及其实现#"></a>堆栈及其实现#</h1><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>堆栈：具有一定操作约束的线性表。<br>只在一端（栈顶，Top）做插入（入栈，Push）、删除（出栈，Pop），后入先出（Last In First Out，LIFO）</p>
<h2 id="堆栈的实现"><a href="#堆栈的实现" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h2><ol>
<li>顺序存储实现。用一个一维数组以及一个一个记录栈顶元素位置的变量组成。</li>
<li>链式存储实现。栈的链式存储结构实际上就是一个单项链，叫做链栈。插入和删除操作只能在链栈的栈顶进行，栈顶指针Top应该在链表的头。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int Position;</span><br><span class="line">struct SNode &#123;</span><br><span class="line">    ElementType *Data; /* 存储元素的数组 */</span><br><span class="line">    Position Top;      /* 栈顶指针 */</span><br><span class="line">    int MaxSize;       /* 堆栈最大容量 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct SNode *Stack;</span><br><span class="line"> </span><br><span class="line">Stack CreateStack( int MaxSize )</span><br><span class="line">&#123;</span><br><span class="line">    Stack S = (Stack)malloc(sizeof(struct SNode));</span><br><span class="line">    S-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));</span><br><span class="line">    S-&gt;Top = -1;</span><br><span class="line">    S-&gt;MaxSize = MaxSize;</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool IsFull( Stack S )</span><br><span class="line">&#123;</span><br><span class="line">    return (S-&gt;Top == S-&gt;MaxSize-1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool Push( Stack S, ElementType X )</span><br><span class="line">&#123;</span><br><span class="line">    if ( IsFull(S) ) &#123;</span><br><span class="line">        printf(&quot;堆栈满&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        S-&gt;Data[++(S-&gt;Top)] = X;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool IsEmpty( Stack S )</span><br><span class="line">&#123;</span><br><span class="line">    return (S-&gt;Top == -1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ElementType Pop( Stack S )</span><br><span class="line">&#123;</span><br><span class="line">    if ( IsEmpty(S) ) &#123;</span><br><span class="line">        printf(&quot;堆栈空&quot;);</span><br><span class="line">        return ERROR; /* ERROR是ElementType的特殊值，标志错误 */</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">        return ( S-&gt;Data[(S-&gt;Top)--] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct SNode *PtrToSNode;</span><br><span class="line">struct SNode &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToSNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToSNode Stack;</span><br><span class="line"> </span><br><span class="line">Stack CreateStack( ) </span><br><span class="line">&#123; /* 构建一个堆栈的头结点，返回该结点指针 */</span><br><span class="line">    Stack S;</span><br><span class="line"> </span><br><span class="line">    S = (Stack)malloc(sizeof(struct SNode));</span><br><span class="line">    S-&gt;Next = NULL;</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool IsEmpty ( Stack S )</span><br><span class="line">&#123; /* 判断堆栈S是否为空，若是返回true；否则返回false */</span><br><span class="line">    return ( S-&gt;Next == NULL );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool Push( Stack S, ElementType X )</span><br><span class="line">&#123; /* 将元素X压入堆栈S */</span><br><span class="line">    PtrToSNode TmpCell;</span><br><span class="line"> </span><br><span class="line">    TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));</span><br><span class="line">    TmpCell-&gt;Data = X;</span><br><span class="line">    TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ElementType Pop( Stack S )  </span><br><span class="line">&#123; /* 删除并返回堆栈S的栈顶元素 */</span><br><span class="line">    PtrToSNode FirstCell;</span><br><span class="line">    ElementType TopElem;</span><br><span class="line"> </span><br><span class="line">    if( IsEmpty(S) ) &#123;</span><br><span class="line">        printf(&quot;堆栈空&quot;); </span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        FirstCell = S-&gt;Next; </span><br><span class="line">        TopElem = FirstCell-&gt;Data;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        free(FirstCell);</span><br><span class="line">        return TopElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="队列及其实现"><a href="#队列及其实现" class="headerlink" title="队列及其实现"></a>队列及其实现</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2>队列：具有一定操作约束的线性表。<br>只在一端插入（入队，AddQ），在另一端删除（出队，DeleteQ），先进先出（FIFO）。<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2></li>
<li>顺序存储实现。由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成。</li>
<li>链式存储实现。队列的链式存储结构实际上也是一个单项链。插入和删除操作在链表的两头进行，队列指针front和rear分别指向链表的头和尾。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int Position;</span><br><span class="line">struct QNode &#123;</span><br><span class="line">    ElementType *Data;     /* 存储元素的数组 */</span><br><span class="line">    Position Front, Rear;  /* 队列的头、尾指针 */</span><br><span class="line">    int MaxSize;           /* 队列最大容量 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line"> </span><br><span class="line">Queue CreateQueue( int MaxSize )</span><br><span class="line">&#123;</span><br><span class="line">    Queue Q = (Queue)malloc(sizeof(struct QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = 0;</span><br><span class="line">    Q-&gt;MaxSize = MaxSize;</span><br><span class="line">    return Q;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool IsFull( Queue Q )</span><br><span class="line">&#123;</span><br><span class="line">    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize == Q-&gt;Front);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool AddQ( Queue Q, ElementType X )</span><br><span class="line">&#123;</span><br><span class="line">    if ( IsFull(Q) ) &#123;</span><br><span class="line">        printf(&quot;队列满&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Q-&gt;Rear = (Q-&gt;Rear+1)%Q-&gt;MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool IsEmpty( Queue Q )</span><br><span class="line">&#123;</span><br><span class="line">    return (Q-&gt;Front == Q-&gt;Rear);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ElementType DeleteQ( Queue Q )</span><br><span class="line">&#123;</span><br><span class="line">    if ( IsEmpty(Q) ) &#123; </span><br><span class="line">        printf(&quot;队列空&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    else  &#123;</span><br><span class="line">        Q-&gt;Front =(Q-&gt;Front+1)%Q-&gt;MaxSize;</span><br><span class="line">        return  Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123; /* 队列中的结点 */</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode Position;</span><br><span class="line"> </span><br><span class="line">struct QNode &#123;</span><br><span class="line">    Position Front, Rear;  /* 队列的头、尾指针 */</span><br><span class="line">    int MaxSize;           /* 队列最大容量 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line"> </span><br><span class="line">bool IsEmpty( Queue Q )</span><br><span class="line">&#123;</span><br><span class="line">    return ( Q-&gt;Front == NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ElementType DeleteQ( Queue Q )</span><br><span class="line">&#123;</span><br><span class="line">    Position FrontCell; </span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">     </span><br><span class="line">    if  ( IsEmpty(Q) ) &#123;</span><br><span class="line">        printf(&quot;队列空&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        FrontCell = Q-&gt;Front;</span><br><span class="line">        if ( Q-&gt;Front == Q-&gt;Rear ) /* 若队列只有一个元素 */</span><br><span class="line">            Q-&gt;Front = Q-&gt;Rear = NULL; /* 删除后队列置为空 */</span><br><span class="line">        else                     </span><br><span class="line">            Q-&gt;Front = Q-&gt;Front-&gt;Next;</span><br><span class="line">        FrontElem = FrontCell-&gt;Data;</span><br><span class="line"> </span><br><span class="line">        free( FrontCell );  /* 释放被删除结点空间  */</span><br><span class="line">        return  FrontElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>文明的滴定</title>
    <url>/2019/03/08/2019-03-08-%E6%96%87%E6%98%8E%E7%9A%84%E6%BB%B4%E5%AE%9A/</url>
    <content><![CDATA[<blockquote>
<p>《文明的滴定》由李约瑟著，张卜天译，商务印书馆出版，在此感谢！<br>注：除<strong>序</strong>外，其余部分均为原作者第一人称</p>
</blockquote>
<p>2019/3/8 18:56:58 </p>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>谈李约瑟的《文明的滴定》，须从其鸿篇巨制《中国的科学与文明》（1954年，<em>Science and Civilisaton in China</em>，缩写SCC）谈起，在这本书首卷的序言中，李约瑟就开宗明义的提出了一串问题，并且在十年后出版的《东西方的科学与社会》一书中，李约瑟将这些问题凝炼为两个：<br>“为什么现在科学没有在中国文明中发展，而只在欧洲发展出来？”、“为什么从公元前1世纪到公元15世纪，在把人类的自然知识应用于人的实际需求方面，中国文明要比西方文明有效的多？”—-这就是“李约瑟问题”。它并不是一个像数学中那样存在定解乃至多解的智力问题，而是一个高度凝练、借以展开宏大叙事的启发式论纲。<br>《文明的滴定》由李约瑟在1944至1966年间陆续发表的八篇论文组成，至于“滴定”一词，原作者本人也给出了清楚交代，它来源于作者的老本行生物化学，用来表达借助分析不同文明在社会或思想中的成分展开宏大叙事的一种历史研究方法或风格。</p>
<h1 id="一、中国科学传统的不足与成就"><a href="#一、中国科学传统的不足与成就" class="headerlink" title="一、中国科学传统的不足与成就"></a>一、中国科学传统的不足与成就</h1><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>先描述一下中国和欧洲传统在自然科学方面的明显差异，再谈谈科学家和工匠在中国古代的社会地位，最后联系哲学、宗教、法律、语言以及具体生产环境和商品交换来探讨科学的某些方面。</p>
<h2 id="传统中国的科技面貌"><a href="#传统中国的科技面貌" class="headerlink" title="传统中国的科技面貌"></a>传统中国的科技面貌</h2><p>在数学、天文学、光学、声学、磁学、地质学、气象学、工程学、军事技术、生物学、医学等各个方面，中国几乎都远远领先于同时期的欧洲。</p>
<h2 id="中国与西方的对比"><a href="#中国与西方的对比" class="headerlink" title="中国与西方的对比"></a>中国与西方的对比</h2><ol>
<li>中国思想家普遍持一种有机论观点，认为现象与现象按照等级秩序彼此关联，而非机械论；</li>
<li>中国数学的思想和做法是代数式的，而非几何式的；</li>
<li>存在着波与粒子的对立；</li>
</ol>
<p>总之，中国人注重实用，不愿重视理论，但这也带来了好处，这也没有影响中国在各个领域的发明创造。</p>
<h2 id="科学家和工匠在传统中国的社会地位"><a href="#科学家和工匠在传统中国的社会地位" class="headerlink" title="科学家和工匠在传统中国的社会地位"></a>科学家和工匠在传统中国的社会地位</h2><p>中国科学，无论是纯粹的还是应用的，都是较为“官方”的。至于社会地位，这很难回答，按照他们的生活史，大致可以分为五类：高级官员；平民；准奴隶；奴隶；小官吏。</p>
<h2 id="封建官僚社会"><a href="#封建官僚社会" class="headerlink" title="封建官僚社会"></a>封建官僚社会</h2><p>在传统中国社会，有些科学是正统的，如天文学、水力学、数学等，这些科学都服务于统治者巩固政权；有些科学是非正统的，如炼丹术，通常道士和隐者才会追求它。</p>
<h2 id="发明与劳动力"><a href="#发明与劳动力" class="headerlink" title="发明与劳动力"></a>发明与劳动力</h2><p>尽管中国似乎有用不尽的劳动力，但这并不妨碍中国人做出一系列“省力”的发明。</p>
<h2 id="哲学和神学的因素"><a href="#哲学和神学的因素" class="headerlink" title="哲学和神学的因素"></a>哲学和神学的因素</h2><p>西方文明认为正如人间的帝王立法者能够颁布法典让人们遵守，天界最高的理性造物者必定也颁布了一系列法典让万物遵守；中国人的世界观则认为万物之所以能够和谐并作，是因为他们都属于一个等级分明的整体，他们服从的乃是自身本性的内在命令。<br>2019/3/9 18:49:14 </p>
<h2 id="语言因素"><a href="#语言因素" class="headerlink" title="语言因素"></a>语言因素</h2><p>通常认为，表意语言是中国发展现代科学的强大阻碍，但我们并不这样认为，中文不但没有构成阻碍，而且富于锦言隽语，适合做最好的哲学思考。</p>
<h2 id="商人的角色"><a href="#商人的角色" class="headerlink" title="商人的角色"></a>商人的角色</h2><p>两千多年的官吏制度使得商人即使拥有大量财富也没有安全保障，只有士大夫阶层才是光明前景。这也决定了中国文化下的商人不可能获得欧洲文艺复兴时期商人在国家中的权势和地位，也就无法发展出商业和工业的资本主义。</p>
<h2 id="新科学在旧世界的起源"><a href="#新科学在旧世界的起源" class="headerlink" title="新科学在旧世界的起源"></a>新科学在旧世界的起源</h2><p>很多观点乃至很多博学的人都片面的认为现代科学乃至科学本身都是欧洲的特色，而且仅仅是欧洲的特色，非欧洲文明的科学不过是技术而已，事实上，应该放弃这些思想上的傲慢，非欧洲文明的高贵和启发性绝不在欧洲文明之下。<br>2019/3/10 10:55:00 </p>
<h1 id="二、科学和中国对世界的影响"><a href="#二、科学和中国对世界的影响" class="headerlink" title="二、科学和中国对世界的影响"></a>二、科学和中国对世界的影响</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>关于中国的“遗产”，必须考虑三种不同的价值：直接有助于产生伽利略式突破的那些东西的价值；后来才合并到现代科学的那些东西的价值；使中国的科学技术和欧洲的科学技术一样值得被赞赏和研究的那些东西的价值。第一条仅限于欧洲，第二条是现代的普遍科学，第三条是全人类。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>中国的成就并非全是技术方面，也有很多在科学方面，但现在有很多欧洲学者都会选择性的忽视这些。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>中国的火药对世界产生的巨大影响。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>中国的磁学研究对世界产生的巨大影响。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>中国的天文坐标、天文仪器、开放的“宇宙论”对世界科学的贡献。</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>颇具独创性的中国人贡献给世界的一些更平凡实用的技术，如畜力的使用以及马镫、有效挽具、独轮车</p>
<h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>中国人对水利的使用以及传送带、龙骨车、曲柄等相关发明。</p>
<h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>钢铁技术、造桥和深钻。</p>
<h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p>航海技术的发明，如船尾舵、纵帆、浆轮船和水密舱。</p>
<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>首先，并非像某些学者的观点一样，中国人没有科学，之所以有这种悖论，是对“科学”的定义出现了混乱，科学不单单指现代科学，古代和中世纪的各个名族都为现代科学的大厦奠定了基础。另外，中国有如此多的发明，可为什么西方还认为中国是“停滞的”，这是由于地理等各方面因素所决定，中国社会有某种自发趋于稳态的倾向，善于自我调节，而欧洲则有一种内在的不稳定性，所以中国一直缓慢而稳定的发展着，但是欧洲由于自己的这种“蠢蠢欲动”，才有了文艺复兴之后指数式的发展。</p>
<h1 id="三、科学与社会变迁"><a href="#三、科学与社会变迁" class="headerlink" title="三、科学与社会变迁"></a>三、科学与社会变迁</h1><h1 id="四、中国古代的科学与社会"><a href="#四、中国古代的科学与社会" class="headerlink" title="四、中国古代的科学与社会"></a>四、中国古代的科学与社会</h1><h1 id="五、论中国科学与技术与社会的关系"><a href="#五、论中国科学与技术与社会的关系" class="headerlink" title="五、论中国科学与技术与社会的关系"></a>五、论中国科学与技术与社会的关系</h1><h1 id="六、东西方的科学与社会"><a href="#六、东西方的科学与社会" class="headerlink" title="六、东西方的科学与社会"></a>六、东西方的科学与社会</h1><p>以上四章针对“李约瑟问题”的回答，从社会方面进行阐述。<br>总体观点：商人阶级掌权以及他们的民主口号是西方现代科学兴起的必要条件。为何商人阶级不能掌权就无法产生科学，李约瑟也承认其“确切关系尚未得到充分阐明，似乎并非所有科学都与商业活动有同样直接的关联”。但他指出，商人需要精确度量，因此与物理学联系特别紧密。此外，只有商人阶级能够打破“理论”与“实践”的对立，将手和脑成功地结合起来。<br>欧洲的资本主义、文艺复兴、宗教改革和现代科学是一体的，中国不存在西方式的封建制度。两千多年的官吏制度使得商人即使拥有大量财富也没有安全保障，只有士大夫阶层才是光明前景。中国文化下的商人不可能获得欧洲文艺复兴时期商人在国家中的权势和地位，也就无法发展出商业和工业的资本主义。<br>在中国，官僚制度导致歧视商人，现代科学之所以没有在中国社会兴起，很可能是因为官僚封建制度有效地阻止了商人阶层掌权或执政。只要“官僚封建制度”没有改变，数学就不可能与经验性的自然观察和实验相结合，从而无法产生某种全新的东西。</p>
<h1 id="七、时间与东方人"><a href="#七、时间与东方人" class="headerlink" title="七、时间与东方人"></a>七、时间与东方人</h1><p>传统自然哲学把时间设想成一格格或一段段的，所以可能更难产生伽利略式的人物把时间均一化为一种抽象的几何坐标、一个可以做数学处理的连续维度。</p>
<h1 id="八、人法与自然法则"><a href="#八、人法与自然法则" class="headerlink" title="八、人法与自然法则"></a>八、人法与自然法则</h1><p>西方文明认为正如人间的帝王立法者能够颁布法典让人们遵守，天界最高的理性造物者必定也颁布了一系列法典让万物遵守；中国人的世界观则认为万物之所以能够和谐并作，是因为他们都属于一个等级分明的整体，他们服从的乃是自身本性的内在命令。</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript初探_6</title>
    <url>/2019/03/08/2019-03-08-JavaScript%E5%88%9D%E6%8E%A2_6/</url>
    <content><![CDATA[<blockquote>
<p>最近几天改动比较大，改bug中间费了不少时间，也没有及时记录，补充一下。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>改动内容包括：</p>
<ol>
<li>改动登陆页面输入框；</li>
<li>Home页面新增页面导航栏；</li>
<li>Home页面新增表格、表单以及在对应页面的相关操作；</li>
</ol>
<h1 id="改动"><a href="#改动" class="headerlink" title="改动"></a>改动</h1><h2 id="Login-vue"><a href="#Login-vue" class="headerlink" title="Login.vue"></a>Login.vue</h2><p>引入scss（删掉node_modules重新cnpm install一下），为登陆页面输入框增加了框形阴影，新增部分具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.login_content &#123;</span><br><span class="line">  /*box-shadow: 0 0px 8px 0 rgba(0, 0, 0, 0.06), 0 1px 0px 0 rgba(0, 0, 0, 0.02);*/</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  background-clip: padding-box;</span><br><span class="line">  margin: 10px auto;</span><br><span class="line">  width: 350px;</span><br><span class="line">  padding: 35px 35px 15px 35px;</span><br><span class="line">  background: #fff;</span><br><span class="line">  border: 1px solid #eaeaea;</span><br><span class="line">  box-shadow: 0 0 25px #cac6c6;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>此页相对简单，作者这里不具体展开。</p>
<h2 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h2><p>页面导航本身还比较好弄，element有相应模板，但是点击导航按钮出现相应界面这部分需要和路由配合，最初的想法在模板基础上进行小改动，click跳转即可，但是始终和路由配合不好，而且click事件发生，导航菜单各级之间的处理也比较混乱，最后还是进行了比较大的改动，注销按钮的位置等也做了调整，具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Home.vue:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-row class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;el-col :span=&quot;24&quot;</span><br><span class="line">            class=&quot;main&quot;&gt;</span><br><span class="line">      &lt;aside :class=&quot;collapsed?&apos;menu-collapsed&apos;:&apos;menu-expanded&apos;&quot;&gt;</span><br><span class="line">        &lt;!--导航菜单--&gt;</span><br><span class="line">        &lt;el-menu :default-active=&quot;$route.path&quot;</span><br><span class="line">                 class=&quot;el-menu-vertical-demo&quot;</span><br><span class="line">                 @open=&quot;handleopen&quot;</span><br><span class="line">                 @close=&quot;handleclose&quot;</span><br><span class="line">                 @select=&quot;handleselect&quot;</span><br><span class="line">                 unique-opened</span><br><span class="line">                 router</span><br><span class="line">                 v-show=&quot;!collapsed&quot;&gt;</span><br><span class="line">          &lt;template v-for=&quot;(item,index) in $router.options.routes&quot;</span><br><span class="line">                    v-if=&quot;!item.hidden&quot;&gt;</span><br><span class="line">            &lt;el-submenu :index=&quot;index+&apos;&apos;&quot;</span><br><span class="line">                        v-if=&quot;!item.leaf&quot;&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;&lt;i :class=&quot;item.iconCls&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;</span><br><span class="line">              &lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item v-for=&quot;child in item.children&quot;</span><br><span class="line">                            :index=&quot;child.path&quot;</span><br><span class="line">                            :key=&quot;child.path&quot;</span><br><span class="line">                            v-if=&quot;!child.hidden&quot;&gt;&#123;&#123;child.name&#125;&#125;</span><br><span class="line">              &lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">            &lt;el-menu-item v-if=&quot;item.leaf&amp;&amp;item.children.length&gt;0&quot;</span><br><span class="line">                          :index=&quot;item.children[0].path&quot;&gt;</span><br><span class="line">              &lt;i :class=&quot;item.iconCls&quot;&gt;</span><br><span class="line">              &lt;/i&gt;&#123;&#123;item.children[0].name&#125;&#125;</span><br><span class="line">            &lt;/el-menu-item&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/el-menu&gt;</span><br><span class="line">        &lt;!--导航菜单-折叠后--&gt;</span><br><span class="line">        &lt;ul class=&quot;el-menu el-menu-vertical-demo collapsed&quot;</span><br><span class="line">            v-show=&quot;collapsed&quot;</span><br><span class="line">            ref=&quot;menuCollapsed&quot;&gt;</span><br><span class="line">          &lt;li v-for=&quot;(item,index) in $router.options.routes&quot;</span><br><span class="line">              v-if=&quot;!item.hidden&quot;</span><br><span class="line">              class=&quot;el-submenu item&quot;&gt;</span><br><span class="line">            &lt;template v-if=&quot;!item.leaf&quot;&gt;</span><br><span class="line">              &lt;div class=&quot;el-submenu__title&quot;</span><br><span class="line">                   style=&quot;padding-left: 20px;&quot;</span><br><span class="line">                   @mouseover=&quot;showMenu(index,true)&quot;</span><br><span class="line">                   @mouseout=&quot;showMenu(index,false)&quot;&gt;</span><br><span class="line">                &lt;i :class=&quot;item.iconCls&quot;&gt;</span><br><span class="line">                &lt;/i&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;ul class=&quot;el-menu submenu&quot;</span><br><span class="line">                  :class=&quot;&apos;submenu-hook-&apos;+index&quot;</span><br><span class="line">                  @mouseover=&quot;showMenu(index,true)&quot;</span><br><span class="line">                  @mouseout=&quot;showMenu(index,false)&quot;&gt;</span><br><span class="line">                &lt;li v-for=&quot;child in item.children&quot;</span><br><span class="line">                    v-if=&quot;!child.hidden&quot;</span><br><span class="line">                    :key=&quot;child.path&quot;</span><br><span class="line">                    class=&quot;el-menu-item&quot;</span><br><span class="line">                    style=&quot;padding-left: 40px;&quot;</span><br><span class="line">                    :class=&quot;$route.path==child.path?&apos;is-active&apos;:&apos;&apos;&quot;</span><br><span class="line">                    @click=&quot;$router.push(child.path)&quot;&gt;&#123;&#123;child.name&#125;&#125;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">              &lt;/ul&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">            &lt;template v-else&gt;</span><br><span class="line">          &lt;li class=&quot;el-submenu&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;el-submenu__title el-menu-item&quot;</span><br><span class="line">                 style=&quot;padding-left: 20px;height: 56px;line-height: 56px;padding: 0 20px;&quot;</span><br><span class="line">                 :class=&quot;$route.path==item.children[0].path?&apos;is-active&apos;:&apos;&apos;&quot;</span><br><span class="line">                 @click=&quot;$router.push(item.children[0].path)&quot;&gt;</span><br><span class="line">              &lt;i :class=&quot;item.iconCls&quot;&gt;</span><br><span class="line">              &lt;/i&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/aside&gt;</span><br><span class="line">&lt;section class=&quot;content-container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;grid-content bg-purple-light&quot;&gt;</span><br><span class="line">    &lt;el-col :span=&quot;24&quot;</span><br><span class="line">            class=&quot;breadcrumb-container&quot;&gt;</span><br><span class="line">      &lt;strong class=&quot;title&quot;&gt;&#123;&#123;$route.name&#125;&#125;</span><br><span class="line">      &lt;/strong&gt;</span><br><span class="line">      &lt;el-breadcrumb separator=&quot;/&quot;</span><br><span class="line">                     class=&quot;breadcrumb-inner&quot;&gt;</span><br><span class="line">        &lt;el-breadcrumb-item v-for=&quot;item in $route.matched&quot;</span><br><span class="line">                            :key=&quot;item.path&quot;&gt;</span><br><span class="line">          &#123;&#123; item.name &#125;&#125;</span><br><span class="line">        &lt;/el-breadcrumb-item&gt;</span><br><span class="line">      &lt;/el-breadcrumb&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">    &lt;el-col :span=&quot;24&quot;</span><br><span class="line">            class=&quot;content-wrapper&quot;&gt;</span><br><span class="line">      &lt;transition name=&quot;fade&quot;</span><br><span class="line">                  mode=&quot;out-in&quot;&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/transition&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;/el-col&gt;</span><br><span class="line">&lt;!--注销按钮--&gt;</span><br><span class="line">&lt;el-row type=&quot;flex&quot;</span><br><span class="line">        justify=&quot;center&quot;</span><br><span class="line">        style=&quot;margin-top:25px&quot;&gt;</span><br><span class="line">  &lt;el-col :span=&quot;1&quot;</span><br><span class="line">          offset=&quot;22&quot;&gt;</span><br><span class="line">    &lt;el-popover placement=&quot;left-start&quot;</span><br><span class="line">                width=&quot;160&quot;</span><br><span class="line">                v-model=&quot;visible&quot;&gt;</span><br><span class="line">      &lt;el-button slot=&quot;reference&quot;&gt;注销&lt;/el-button&gt;</span><br><span class="line">      &lt;p&gt;确定注销并退出吗？&lt;/p&gt;</span><br><span class="line">      &lt;div style=&quot;text-align: right; margin: 0&quot;&gt;</span><br><span class="line">        &lt;el-button size=&quot;mini&quot;</span><br><span class="line">                   type=&quot;text&quot;</span><br><span class="line">                   @click=&quot;visible = false&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                   size=&quot;mini&quot;</span><br><span class="line">                   @click=&quot;logout&quot;&gt;确定&lt;/el-button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-popover&gt;</span><br><span class="line">  &lt;/el-col&gt;</span><br><span class="line">&lt;/el-row&gt;</span><br><span class="line">&lt;/el-row&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    logout() &#123;</span><br><span class="line">      this.$router.replace(&apos;/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleopen() &#123;</span><br><span class="line">      console.log(&apos;handleopen&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleclose() &#123;</span><br><span class="line">      console.log(&apos;handleclose&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleselect: function (a, b) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    //折叠导航栏</span><br><span class="line">    collapse: function () &#123;</span><br><span class="line">      this.collapsed = !this.collapsed;</span><br><span class="line">    &#125;,</span><br><span class="line">    showMenu(i, status) &#123;</span><br><span class="line">      this.$refs.menuCollapsed.getElementsByClassName(&apos;submenu-hook-&apos; + i)[0].style.display = status ? &apos;block&apos; : &apos;none&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      visible: false,  //注销弹出框</span><br><span class="line">      collapsed: false,   //菜单折叠</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0px;</span><br><span class="line">  bottom: 0px;</span><br><span class="line">  width: 95%;</span><br><span class="line"></span><br><span class="line">  .main &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    // background: #324057;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 110px;</span><br><span class="line">    bottom: 0px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    aside &#123;</span><br><span class="line">      flex: 0 0 230px;</span><br><span class="line">      width: 230px;</span><br><span class="line">      // position: absolute;</span><br><span class="line">      // top: 0px;</span><br><span class="line">      // bottom: 0px;</span><br><span class="line">      .el-menu &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      .collapsed &#123;</span><br><span class="line">        width: 60px;</span><br><span class="line">        .item &#123;</span><br><span class="line">          position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        .submenu &#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          top: 0px;</span><br><span class="line">          left: 60px;</span><br><span class="line">          z-index: 99999;</span><br><span class="line">          height: auto;</span><br><span class="line">          display: none;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .menu-collapsed &#123;</span><br><span class="line">      flex: 0 0 60px;</span><br><span class="line">      width: 60px;</span><br><span class="line">    &#125;</span><br><span class="line">    .menu-expanded &#123;</span><br><span class="line">      flex: 0 0 230px;</span><br><span class="line">      width: 230px;</span><br><span class="line">    &#125;</span><br><span class="line">    .content-container &#123;</span><br><span class="line">      // background: #f1f2f7;</span><br><span class="line">      flex: 1;</span><br><span class="line">      // position: absolute;</span><br><span class="line">      // right: 0px;</span><br><span class="line">      // top: 0px;</span><br><span class="line">      // bottom: 0px;</span><br><span class="line">      // left: 230px;</span><br><span class="line">      overflow-y: scroll;</span><br><span class="line">      padding: 20px;</span><br><span class="line">      .breadcrumb-container &#123;</span><br><span class="line">        //margin-bottom: 15px;</span><br><span class="line">        .title &#123;</span><br><span class="line">          width: 200px;</span><br><span class="line">          float: left;</span><br><span class="line">          color: #475669;</span><br><span class="line">        &#125;</span><br><span class="line">        .breadcrumb-inner &#123;</span><br><span class="line">          float: right;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .content-wrapper &#123;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">路由的index.js:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">//import HelloWorld from &apos;@/components/HelloWorld&apos;</span><br><span class="line">import Main from &apos;@/components/Main.vue&apos;</span><br><span class="line">import Login from &apos;@/components/Login.vue&apos;</span><br><span class="line">import Home from &apos;@/components/Home.vue&apos;</span><br><span class="line">import Form from &apos;@/components/Form.vue&apos;</span><br><span class="line">import Table from &apos;@/components/Table.vue&apos;</span><br><span class="line">import Setting from &apos;@/components/Setting.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)   //注册vue-router</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    /*&#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;HelloWorld&apos;,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;,*/</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;Main&apos;,</span><br><span class="line">      component: Main,</span><br><span class="line">      hidden: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/login&apos;,</span><br><span class="line">      name: &apos;Login&apos;,</span><br><span class="line">      component: Login,</span><br><span class="line">      hidden: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/home&apos;,</span><br><span class="line">      name: &apos;Home&apos;,</span><br><span class="line">      component: Home,</span><br><span class="line">      hidden: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      component: Home,</span><br><span class="line">      name: &apos;导航一&apos;,</span><br><span class="line">      iconCls: &apos;el-icon-message&apos;,//图标样式class</span><br><span class="line">      children: [</span><br><span class="line">        &#123; path: &apos;/home/form&apos;, component: Form, name: &apos;表单&apos; &#125;,</span><br><span class="line">        &#123; path: &apos;/home/table&apos;, component: Table, name: &apos;表格&apos; &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      component: Home,</span><br><span class="line">      name: &apos;导航二&apos;,</span><br><span class="line">      iconCls: &apos;el-icon-setting&apos;,//图标样式class</span><br><span class="line">      children: [</span><br><span class="line">        &#123; path: &apos;/home/setting&apos;, component: Setting, name: &apos;设置&apos; &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Form-vue"><a href="#Form-vue" class="headerlink" title="Form.vue"></a>Form.vue</h2><p>在Home.vue和index.js配置好之后，Form.vue这里需要做的事情比较少，作者这里也只是体验一下，直接用了element里的示例，之后在做修改，具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form :model=&quot;ruleForm&quot;</span><br><span class="line">           :rules=&quot;rules&quot;</span><br><span class="line">           ref=&quot;ruleForm&quot;</span><br><span class="line">           label-width=&quot;100px&quot;</span><br><span class="line">           class=&quot;demo-ruleForm&quot;&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;活动名称&quot;</span><br><span class="line">                  prop=&quot;name&quot;&gt;</span><br><span class="line">      &lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;活动区域&quot;</span><br><span class="line">                  prop=&quot;region&quot;&gt;</span><br><span class="line">      &lt;el-select v-model=&quot;ruleForm.region&quot;</span><br><span class="line">                 placeholder=&quot;请选择活动区域&quot;&gt;</span><br><span class="line">        &lt;el-option label=&quot;区域一&quot;</span><br><span class="line">                   value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;</span><br><span class="line">        &lt;el-option label=&quot;区域二&quot;</span><br><span class="line">                   value=&quot;beijing&quot;&gt;&lt;/el-option&gt;</span><br><span class="line">      &lt;/el-select&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;活动时间&quot;</span><br><span class="line">                  required&gt;</span><br><span class="line">      &lt;el-col :span=&quot;11&quot;&gt;</span><br><span class="line">        &lt;el-form-item prop=&quot;date1&quot;&gt;</span><br><span class="line">          &lt;el-date-picker type=&quot;date&quot;</span><br><span class="line">                          placeholder=&quot;选择日期&quot;</span><br><span class="line">                          v-model=&quot;ruleForm.date1&quot;</span><br><span class="line">                          style=&quot;width: 100%;&quot;&gt;&lt;/el-date-picker&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">      &lt;el-col class=&quot;line&quot;</span><br><span class="line">              :span=&quot;2&quot;&gt;-&lt;/el-col&gt;</span><br><span class="line">      &lt;el-col :span=&quot;11&quot;&gt;</span><br><span class="line">        &lt;el-form-item prop=&quot;date2&quot;&gt;</span><br><span class="line">          &lt;el-time-picker type=&quot;fixed-time&quot;</span><br><span class="line">                          placeholder=&quot;选择时间&quot;</span><br><span class="line">                          v-model=&quot;ruleForm.date2&quot;</span><br><span class="line">                          style=&quot;width: 100%;&quot;&gt;&lt;/el-time-picker&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;即时配送&quot;</span><br><span class="line">                  prop=&quot;delivery&quot;&gt;</span><br><span class="line">      &lt;el-switch v-model=&quot;ruleForm.delivery&quot;&gt;&lt;/el-switch&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;活动性质&quot;</span><br><span class="line">                  prop=&quot;type&quot;&gt;</span><br><span class="line">      &lt;el-checkbox-group v-model=&quot;ruleForm.type&quot;&gt;</span><br><span class="line">        &lt;el-checkbox label=&quot;美食/餐厅线上活动&quot;</span><br><span class="line">                     name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;</span><br><span class="line">        &lt;el-checkbox label=&quot;地推活动&quot;</span><br><span class="line">                     name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;</span><br><span class="line">        &lt;el-checkbox label=&quot;线下主题活动&quot;</span><br><span class="line">                     name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;</span><br><span class="line">        &lt;el-checkbox label=&quot;单纯品牌曝光&quot;</span><br><span class="line">                     name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;</span><br><span class="line">      &lt;/el-checkbox-group&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;特殊资源&quot;</span><br><span class="line">                  prop=&quot;resource&quot;&gt;</span><br><span class="line">      &lt;el-radio-group v-model=&quot;ruleForm.resource&quot;&gt;</span><br><span class="line">        &lt;el-radio label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt;</span><br><span class="line">        &lt;el-radio label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt;</span><br><span class="line">        &lt;el-radio label=&quot;无&quot;&gt;&lt;/el-radio&gt;</span><br><span class="line">      &lt;/el-radio-group&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;活动形式&quot;</span><br><span class="line">                  prop=&quot;desc&quot;&gt;</span><br><span class="line">      &lt;el-input type=&quot;textarea&quot;</span><br><span class="line">                v-model=&quot;ruleForm.desc&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                 @click=&quot;submitForm(&apos;ruleForm&apos;)&quot;&gt;立即创建&lt;/el-button&gt;</span><br><span class="line">      &lt;el-button @click=&quot;resetForm(&apos;ruleForm&apos;)&quot;&gt;重置&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ruleForm: &#123;</span><br><span class="line">        name: &apos;&apos;,</span><br><span class="line">        region: &apos;&apos;,</span><br><span class="line">        date1: &apos;&apos;,</span><br><span class="line">        date2: &apos;&apos;,</span><br><span class="line">        delivery: false,</span><br><span class="line">        type: [],</span><br><span class="line">        resource: &apos;&apos;,</span><br><span class="line">        desc: &apos;&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        name: [</span><br><span class="line">          &#123; required: true, message: &apos;请输入活动名称&apos;, trigger: &apos;blur&apos; &#125;,</span><br><span class="line">          &#123; min: 3, max: 5, message: &apos;长度在 3 到 5 个字符&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        region: [</span><br><span class="line">          &#123; required: true, message: &apos;请选择活动区域&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        date1: [</span><br><span class="line">          &#123; type: &apos;date&apos;, required: true, message: &apos;请选择日期&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        date2: [</span><br><span class="line">          &#123; type: &apos;date&apos;, required: true, message: &apos;请选择时间&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        type: [</span><br><span class="line">          &#123; type: &apos;array&apos;, required: true, message: &apos;请至少选择一个活动性质&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        resource: [</span><br><span class="line">          &#123; required: true, message: &apos;请选择活动资源&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        desc: [</span><br><span class="line">          &#123; required: true, message: &apos;请填写活动形式&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].validate((valid) =&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          alert(&apos;创建成功!&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&apos;创建失败!!&apos;);</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    resetForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].resetFields();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Table-vue"><a href="#Table-vue" class="headerlink" title="Table.vue"></a>Table.vue</h2><p>这一部分相对Form.vue而言，相对复杂了一些，表格建立还算简单，时间主要用在了“编辑”、“删除”两个按钮的实现以及对应Dialog的弹出的问题上，对于这两项操作需要对表格中单元的位置进行定位，这里用到了scope的相关内容。在“编辑”按钮的弹窗中，由于忘记了<div>标签耽误了大量时间（也没有报错，就是弹窗不出来）；在“删除”按钮中，如果直接点击即删除将获得的行号直接传给deleteRow函数即可，但是这里添加了确认是否删除的Dialog，所以定义了一个全局变量_index，点击按钮执行handleDelete函数，将获取的行数传给_index，同时打开Dialog，在Dialog中再将_index传给deleteRow函数，具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-table :data=&quot;tableData&quot;</span><br><span class="line">              border</span><br><span class="line">              style=&quot;width: 100%&quot;&gt;</span><br><span class="line">      &lt;el-table-column fixed</span><br><span class="line">                       prop=&quot;date&quot;</span><br><span class="line">                       label=&quot;日期&quot;</span><br><span class="line">                       width=&quot;150&quot;&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">          &lt;i class=&quot;el-icon-time&quot;&gt;&lt;/i&gt;</span><br><span class="line">          &lt;span style=&quot;margin-left: 10px&quot;&gt;&#123;&#123; scope.row.date &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;el-table-column prop=&quot;name&quot;</span><br><span class="line">                       label=&quot;姓名&quot;</span><br><span class="line">                       width=&quot;80&quot;&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">          &lt;el-popover trigger=&quot;hover&quot;</span><br><span class="line">                      placement=&quot;top&quot;&gt;</span><br><span class="line">            &lt;p&gt;姓名: &#123;&#123; scope.row.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;住址: &#123;&#123; scope.row.address &#125;&#125;&lt;/p&gt;</span><br><span class="line">            &lt;div slot=&quot;reference&quot;</span><br><span class="line">                 class=&quot;name-wrapper&quot;&gt;</span><br><span class="line">              &lt;el-tag size=&quot;medium&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          &lt;/el-popover&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column prop=&quot;province&quot;</span><br><span class="line">                       label=&quot;省份&quot;</span><br><span class="line">                       width=&quot;60&quot;&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;el-table-column prop=&quot;city&quot;</span><br><span class="line">                       label=&quot;市区&quot;</span><br><span class="line">                       width=&quot;80&quot;&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;el-table-column prop=&quot;address&quot;</span><br><span class="line">                       label=&quot;地址&quot;</span><br><span class="line">                       width=&quot;300&quot;&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;el-table-column prop=&quot;zip&quot;</span><br><span class="line">                       label=&quot;邮编&quot;</span><br><span class="line">                       width=&quot;80&quot;&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;el-table-column fixed=&quot;right&quot;</span><br><span class="line">                       label=&quot;操作&quot;</span><br><span class="line">                       width=&quot;150&quot;&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">          &lt;el-button @click=&quot;handleEdit(scope.$index, scope.row)&quot;</span><br><span class="line">                     size=&quot;small&quot;&gt;编辑&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button @click=&quot;handleDelete(scope.$index,scope.row)&quot;</span><br><span class="line">                     type=&quot;danger&quot;</span><br><span class="line">                     size=&quot;small&quot;&gt;删除&lt;/el-button&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">    &lt;/el-table&gt;</span><br><span class="line">    &lt;!--删除界面--&gt;</span><br><span class="line">    &lt;el-dialog title=&quot;确认&quot;</span><br><span class="line">               :visible.sync=&quot;deleteFormVisible&quot;</span><br><span class="line">               width=&quot;30%&quot;</span><br><span class="line">               :before-close=&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;span&gt;确认删除改用户？&lt;/span&gt;</span><br><span class="line">      &lt;span slot=&quot;footer&quot;</span><br><span class="line">            class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click=&quot;deleteFormVisible = false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                   @click.native.prevent=&quot;deleteRow(_index, tableData)&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--编辑界面--&gt;</span><br><span class="line">    &lt;el-dialog title=&quot;编辑&quot;</span><br><span class="line">               :visible.sync=&quot;editFormVisible&quot;</span><br><span class="line">               :before-close=&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;el-form :model=&quot;editForm&quot;</span><br><span class="line">               label-width=&quot;80px&quot;</span><br><span class="line">               :rules=&quot;editFormRules&quot;</span><br><span class="line">               ref=&quot;editForm&quot;&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;日期&quot;&gt;</span><br><span class="line">          &lt;el-date-picker type=&quot;date&quot;</span><br><span class="line">                          placeholder=&quot;选择日期&quot;</span><br><span class="line">                          v-model=&quot;editForm.date&quot;&gt;&lt;/el-date-picker&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;姓名&quot;</span><br><span class="line">                      prop=&quot;name&quot;&gt;</span><br><span class="line">          &lt;el-input v-model=&quot;editForm.name&quot;</span><br><span class="line">                    auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;省份&quot;&gt;</span><br><span class="line">          &lt;el-input type=&quot;province&quot;</span><br><span class="line">                    v-model=&quot;editForm.province&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;市区&quot;&gt;</span><br><span class="line">          &lt;el-input type=&quot;city&quot;</span><br><span class="line">                    v-model=&quot;editForm.city&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;地址&quot;&gt;</span><br><span class="line">          &lt;el-input type=&quot;address&quot;</span><br><span class="line">                    v-model=&quot;editForm.address&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;邮编&quot;&gt;</span><br><span class="line">          &lt;el-input type=&quot;zip&quot;</span><br><span class="line">                    v-model=&quot;editForm.zip&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">      &lt;/el-form&gt;</span><br><span class="line">      &lt;div slot=&quot;footer&quot;</span><br><span class="line">           class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click.native=&quot;editFormVisible = false&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                   @click=&quot;editFormVisible = false&quot;&gt;确定&lt;/el-button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleDelete(index, row) &#123;</span><br><span class="line">      this._index = index;</span><br><span class="line">      //console.log(index);</span><br><span class="line">      this.deleteFormVisible = true;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleEdit(index, row) &#123;</span><br><span class="line">      this.editFormVisible = true;</span><br><span class="line">      //console.log(index, row);</span><br><span class="line">      //将每一行的数据赋值给Dialog弹框（这里是重点）</span><br><span class="line">      this.editForm = Object.assign(&#123;&#125;, row);</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteRow(index, rows) &#123;</span><br><span class="line">      rows.splice(index, 1);</span><br><span class="line">      this.deleteFormVisible = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      _index: &apos;&apos;,</span><br><span class="line">      editFormVisible: false,//编辑界面是否显示</span><br><span class="line">      deleteFormVisible: false,//删除确定界面</span><br><span class="line">      editFormRules: &#123;</span><br><span class="line">        name: [</span><br><span class="line">          &#123; required: true, message: &apos;请输入姓名&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      //编辑界面数据</span><br><span class="line">      editForm: &#123;</span><br><span class="line">        name: &apos;&apos;,</span><br><span class="line">        date: &apos;&apos;,</span><br><span class="line">        province: &apos;&apos;,</span><br><span class="line">        city: &apos;&apos;,</span><br><span class="line">        address: &apos;&apos;,</span><br><span class="line">        zip: &apos;&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">      tableData: [&#123;</span><br><span class="line">        date: &apos;2016-05-02&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1519 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        date: &apos;2016-05-04&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1518 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        date: &apos;2016-05-01&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1517 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        date: &apos;2016-05-03&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1516 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        date: &apos;2016-05-03&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1515 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        date: &apos;2016-05-03&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1514 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        date: &apos;2016-05-03&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1513 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        date: &apos;2016-05-03&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1512 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        date: &apos;2016-05-03&apos;,</span><br><span class="line">        name: &apos;王小虎&apos;,</span><br><span class="line">        province: &apos;上海&apos;,</span><br><span class="line">        city: &apos;普陀区&apos;,</span><br><span class="line">        address: &apos;上海市普陀区金沙江路 1511 弄&apos;,</span><br><span class="line">        zip: 200333</span><br><span class="line">      &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_1</title>
    <url>/2019/03/03/2019-03-03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1/</url>
    <content><![CDATA[<blockquote>
<p>学习过程主要依照中国MOOC<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce" target="_blank" rel="noopener">课程</a>，感谢MOOC，感谢浙大授课大佬。</p>
</blockquote>
<h1 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h1><p>首先，何为数据结构？官方目前没有统一的定义，但数据结构常和算法结合在一起，“精心选择的数据结构可以带来最优效率的算法”。</p>
<ol>
<li>图书的摆放：解决问题方法的效率，和数据的组织方式有关。</li>
<li>循环与递归：解决问题方法的效率，和空间的利用效率有关。</li>
<li>多项式计算：解决问题方法的效率，和算法的巧妙程度有关。<br>所以，到底什么是数据结构？数据结构是数据在计算机中的组织方式。数据对象必定与一系列加在其上的操作相关联，这些操作就是“算法”。</li>
</ol>
<ul>
<li>抽象数据类型：首先，数据类型包括数据对象集和相关联的操作集，而抽象指的是只描述数据类型的方法而不涉及具体实现，也就是只描述数据集和操作集“是什么”，而不管“如何实现”。</li>
</ul>
<h1 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h1><ul>
<li>一个<strong>有限</strong>指令集</li>
<li>有或没有输入，但<strong>必须有输出</strong></li>
<li>每一条指令有<strong>明确</strong>目标，在计算机<strong>可处理</strong>范围之内<br>算法衡量指标</li>
<li>空间复杂度S(n)</li>
<li>时间复杂度T(n)</li>
</ul>
<p>2019/3/5 10:56:00 </p>
<h1 id="课后编程题"><a href="#课后编程题" class="headerlink" title="课后编程题"></a>课后编程题</h1><h2 id="最大子序列"><a href="#最大子序列" class="headerlink" title="最大子序列"></a>最大子序列</h2><p>第一题只需要给出最大子序列的和，按照授课视频讲的在线处理方法还是比较简单；第二题在此基础上还要求给出最大子序列的首尾元素，作者的想法就是继续按照刚才在线处理的思想，当ThisSum &gt; MaxSum要更新MaxSum时，这时更新last，同时，只要ThisSum没有被重新置为0，说明当前的最大子序列仍在增长，计数的num继续++，最后last的位置减去num也就是first的位置。另外还有一些如全为负数，存在零等情况需要特殊考虑一下，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// MaxSubSum.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//思想：在线处理</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int K;//输入序列长度</span><br><span class="line">	int num = 0;//最大子序列元素个数统计</span><br><span class="line">	int temp = 0;//负数元素统计</span><br><span class="line">	int first=0,last = 0;//最大子序列起始、结尾序号</span><br><span class="line">	int L[100000];</span><br><span class="line">	int ThisSum=0, MaxSum= 0 ;</span><br><span class="line">	cin &gt;&gt; K;</span><br><span class="line">	for (int i=0; i &lt; K; i++)</span><br><span class="line">		cin &gt;&gt; L[i];</span><br><span class="line">	for (int i = 0; i &lt; K; i++) &#123;</span><br><span class="line">		if (L[i] &lt; 0) temp++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (temp == K) </span><br><span class="line">		printf(&quot;%d %d %d&quot;, 0, L[0], L[K-1]);</span><br><span class="line">	else&#123;</span><br><span class="line">		for (int i = 0; i &lt; K; i++) &#123;</span><br><span class="line">			ThisSum += L[i];</span><br><span class="line">			if (ThisSum &gt; MaxSum) &#123;</span><br><span class="line">				MaxSum = ThisSum;</span><br><span class="line">				last = L[i];</span><br><span class="line">				num += 1;</span><br><span class="line">				first = L[i - num + 1];</span><br><span class="line">			&#125;</span><br><span class="line">			else if (ThisSum &lt;= MaxSum &amp;&amp; ThisSum &gt;= 0) &#123;</span><br><span class="line">				num += 1;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (ThisSum &lt; 0) &#123;</span><br><span class="line">				ThisSum = 0;</span><br><span class="line">				num = 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d %d %d&quot;, MaxSum, first, last);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>这道题已经给出了其他代码，只需要写一个二分查找的函数，由于函数给出的是链表，所以在写的时候绕了一些弯子，这里不表，注意学习一下链表的相关内容，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Position BinarySearch(List Tbl, ElementType K) &#123;</span><br><span class="line">	int left;</span><br><span class="line">	int right;</span><br><span class="line">	if (Tbl-&gt;Last) &#123;</span><br><span class="line">		left = 1;</span><br><span class="line">		right = Tbl-&gt;Last; </span><br><span class="line">		while(left &lt;= right) &#123;</span><br><span class="line">			if (K == Tbl-&gt;Data[(left + right) / 2])</span><br><span class="line">				return (left + right) / 2;</span><br><span class="line">			else &#123;</span><br><span class="line">				if (K &lt; Tbl-&gt;Data[(left + right) / 2])</span><br><span class="line">					right = (left + right) / 2 - 1;</span><br><span class="line">				else </span><br><span class="line">					left = (left + right) / 2 + 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>MOOC</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript初探_5</title>
    <url>/2019/03/02/2019-03-02-JavaScript%E5%88%9D%E6%8E%A2_5/</url>
    <content><![CDATA[<blockquote>
<p>本文主要参考这里：<a href="https://blog.csdn.net/qq_39009348/article/details/81411432#commentsedit" target="_blank" rel="noopener">参考地址</a>，感谢博主。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新增内容包括两部分：</p>
<ol>
<li>登陆成功之后进入home页面，home页面有注销按钮可回到第一页；</li>
<li>登陆页面新增验证码功能</li>
</ol>
<h1 id="注销按钮"><a href="#注销按钮" class="headerlink" title="注销按钮"></a>注销按钮</h1><h2 id="Home-vue"><a href="#Home-vue" class="headerlink" title="Home.vue"></a>Home.vue</h2><p>由于要新增加页面，和之前一样，在src/components下新增Home.vue，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-row type=&quot;flex&quot;</span><br><span class="line">            justify=&quot;center&quot;&gt;</span><br><span class="line">      &lt;el-col :span=&quot;2&quot;&gt;</span><br><span class="line">        &lt;el-popover placement=&quot;top&quot;</span><br><span class="line">                    width=&quot;160&quot;</span><br><span class="line">                    v-model=&quot;visible&quot;&gt;</span><br><span class="line">          &lt;p&gt;确定注销并退出吗？&lt;/p&gt;</span><br><span class="line">          &lt;div style=&quot;text-align: right; margin: 0&quot;&gt;</span><br><span class="line">            &lt;el-button size=&quot;mini&quot;</span><br><span class="line">                       type=&quot;text&quot;</span><br><span class="line">                       @click=&quot;visible = false&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">            &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                       size=&quot;mini&quot;</span><br><span class="line">                       @click=&quot;logout&quot;&gt;确定&lt;/el-button&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;el-button slot=&quot;reference&quot;&gt;注销&lt;/el-button&gt;</span><br><span class="line">        &lt;/el-popover&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    logout() &#123;</span><br><span class="line">      this.$router.replace(&apos;/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      visible: true</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>此页相对简单，只增加了一个注销按钮，并且点击会有Popover弹出框，在element有示例，这里就不具体展开讲了。</p>
<p>具体效果：<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/%E6%B3%A8%E9%94%80.JPG" alt="注销界面"></p>
<h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>验证码这一功能增加过程相对复杂，也比较费时间，最先开始参考了一个最普通的验证码形式，但始终弄不好，后来找到了上述博客，讲解比较详细，经过改动（原博主用到了较为复杂的表单验证，我这里删减了一部分），最后得以实现，首先新建了一个Identify.vue，主要作用是绘制验证码生成图片，具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;s-canvas&quot;&gt;</span><br><span class="line">    &lt;canvas id=&quot;s-canvas&quot;</span><br><span class="line">            :width=&quot;contentWidth&quot;</span><br><span class="line">            :height=&quot;contentHeight&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;SIdentify&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    identifyCode: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &apos;1234&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    fontSizeMin: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 16</span><br><span class="line">    &#125;,</span><br><span class="line">    fontSizeMax: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 40</span><br><span class="line">    &#125;,</span><br><span class="line">    backgroundColorMin: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 180</span><br><span class="line">    &#125;,</span><br><span class="line">    backgroundColorMax: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 240</span><br><span class="line">    &#125;,</span><br><span class="line">    colorMin: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 50</span><br><span class="line">    &#125;,</span><br><span class="line">    colorMax: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 160</span><br><span class="line">    &#125;,</span><br><span class="line">    lineColorMin: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 40</span><br><span class="line">    &#125;,</span><br><span class="line">    lineColorMax: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 180</span><br><span class="line">    &#125;,</span><br><span class="line">    dotColorMin: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    dotColorMax: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 255</span><br><span class="line">    &#125;,</span><br><span class="line">    contentWidth: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 112</span><br><span class="line">    &#125;,</span><br><span class="line">    contentHeight: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 38</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 生成一个随机数</span><br><span class="line">    randomNum(min, max) &#123;</span><br><span class="line">      return Math.floor(Math.random() * (max - min) + min)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 生成一个随机的颜色</span><br><span class="line">    randomColor(min, max) &#123;</span><br><span class="line">      var r = this.randomNum(min, max)</span><br><span class="line">      var g = this.randomNum(min, max)</span><br><span class="line">      var b = this.randomNum(min, max)</span><br><span class="line">      return &apos;rgb(&apos; + r + &apos;,&apos; + g + &apos;,&apos; + b + &apos;)&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    drawPic() &#123;</span><br><span class="line">      var canvas = document.getElementById(&apos;s-canvas&apos;)</span><br><span class="line">      var ctx = canvas.getContext(&apos;2d&apos;)</span><br><span class="line">      ctx.textBaseline = &apos;bottom&apos;</span><br><span class="line">      // 绘制背景</span><br><span class="line">      ctx.fillStyle = this.randomColor(</span><br><span class="line">        this.backgroundColorMin,</span><br><span class="line">        this.backgroundColorMax</span><br><span class="line">      )</span><br><span class="line">      ctx.fillRect(0, 0, this.contentWidth, this.contentHeight)</span><br><span class="line">      // 绘制文字</span><br><span class="line">      for (let i = 0; i &lt; this.identifyCode.length; i++) &#123;</span><br><span class="line">        this.drawText(ctx, this.identifyCode[i], i)</span><br><span class="line">      &#125;</span><br><span class="line">      this.drawLine(ctx)</span><br><span class="line">      this.drawDot(ctx)</span><br><span class="line">    &#125;,</span><br><span class="line">    drawText(ctx, txt, i) &#123;</span><br><span class="line">      ctx.fillStyle = this.randomColor(this.colorMin, this.colorMax)</span><br><span class="line">      ctx.font =</span><br><span class="line">        this.randomNum(this.fontSizeMin, this.fontSizeMax) + &apos;px SimHei&apos;</span><br><span class="line">      var x = (i + 1) * (this.contentWidth / (this.identifyCode.length + 1))</span><br><span class="line">      var y = this.randomNum(this.fontSizeMax, this.contentHeight - 5)</span><br><span class="line">      var deg = this.randomNum(-45, 45)</span><br><span class="line">      // 修改坐标原点和旋转角度</span><br><span class="line">      ctx.translate(x, y)</span><br><span class="line">      ctx.rotate(deg * Math.PI / 180)</span><br><span class="line">      ctx.fillText(txt, 0, 0)</span><br><span class="line">      // 恢复坐标原点和旋转角度</span><br><span class="line">      ctx.rotate(-deg * Math.PI / 180)</span><br><span class="line">      ctx.translate(-x, -y)</span><br><span class="line">    &#125;,</span><br><span class="line">    drawLine(ctx) &#123;</span><br><span class="line">      // 绘制干扰线</span><br><span class="line">      for (let i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        ctx.strokeStyle = this.randomColor(</span><br><span class="line">          this.lineColorMin,</span><br><span class="line">          this.lineColorMax</span><br><span class="line">        )</span><br><span class="line">        ctx.beginPath()</span><br><span class="line">        ctx.moveTo(</span><br><span class="line">          this.randomNum(0, this.contentWidth),</span><br><span class="line">          this.randomNum(0, this.contentHeight)</span><br><span class="line">        )</span><br><span class="line">        ctx.lineTo(</span><br><span class="line">          this.randomNum(0, this.contentWidth),</span><br><span class="line">          this.randomNum(0, this.contentHeight)</span><br><span class="line">        )</span><br><span class="line">        ctx.stroke()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    drawDot(ctx) &#123;</span><br><span class="line">      // 绘制干扰点</span><br><span class="line">      for (let i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        ctx.fillStyle = this.randomColor(0, 255)</span><br><span class="line">        ctx.beginPath()</span><br><span class="line">        ctx.arc(</span><br><span class="line">          this.randomNum(0, this.contentWidth),</span><br><span class="line">          this.randomNum(0, this.contentHeight),</span><br><span class="line">          1,</span><br><span class="line">          0,</span><br><span class="line">          2 * Math.PI</span><br><span class="line">        )</span><br><span class="line">        ctx.fill()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    identifyCode() &#123;</span><br><span class="line">      this.drawPic()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.drawPic()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>Login.vue同样进行了比较大的修改，最后具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;login_content1 &quot;&gt;</span><br><span class="line">    &lt;el-row type=&quot;flex&quot;</span><br><span class="line">            justify=&quot;center&quot;&gt;</span><br><span class="line">      &lt;el-form ref=&quot;loginForm&quot;</span><br><span class="line">               :model=&quot;user&quot;</span><br><span class="line">               :rules=&quot;loginRules&quot;</span><br><span class="line">               status-icon</span><br><span class="line">               label-width=&quot;80px&quot;&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;用户名&quot;</span><br><span class="line">                      prop=&quot;name&quot;&gt;</span><br><span class="line">          &lt;el-input v-model=&quot;user.name&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;密码&quot;</span><br><span class="line">                      prop=&quot;pass&quot;&gt;</span><br><span class="line">          &lt;el-input v-model=&quot;user.pass&quot;</span><br><span class="line">                    type=&quot;password&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;验证码&quot;</span><br><span class="line">                      prop=&quot;verifycode&quot;&gt;</span><br><span class="line">          &lt;!-- 注意：prop与input绑定的值一定要一致，否则验证规则中的value会报undefined，因为value即为绑定的input输入值 --&gt;</span><br><span class="line">          &lt;el-input v-model=&quot;user.verifycode&quot;</span><br><span class="line">                    placeholder=&quot;请输入验证码&quot;</span><br><span class="line">                    class=&quot;identifyinput&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item&gt;</span><br><span class="line">          &lt;div class=&quot;identifybox&quot;&gt;</span><br><span class="line">            &lt;div @click=&quot;refreshCode&quot;&gt;</span><br><span class="line">              &lt;s-identify :identifyCode=&quot;identifyCode&quot;&gt;&lt;/s-identify&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;el-button @click=&quot;refreshCode&quot;</span><br><span class="line">                       type=&apos;text&apos;</span><br><span class="line">                       class=&quot;textbtn&quot;&gt;看不清，换一张&lt;/el-button&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item&gt;</span><br><span class="line">          &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                     icon=&quot;el-icon-upload&quot;</span><br><span class="line">                     @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/el-form&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import SIdentify from &apos;@/components/identify.vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  components: &#123;</span><br><span class="line">    SIdentify</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 验证码初始化</span><br><span class="line">    this.identifyCode = &apos;&apos;</span><br><span class="line">    this.makeCode(this.identifyCodes, 4)</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: [],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login() &#123;</span><br><span class="line">      this.$refs.loginForm.validate((valid) =&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          if (this.user.name === &apos;admin&apos; &amp;&amp; this.user.pass === &apos;123&apos;) &#123;</span><br><span class="line">            this.$notify(&#123;</span><br><span class="line">              type: &apos;success&apos;,</span><br><span class="line">              message: &apos;欢迎你,&apos; + this.user.name + &apos;!&apos;,</span><br><span class="line">              duration: 3000</span><br><span class="line">            &#125;)</span><br><span class="line">            this.$router.replace(&apos;/home&apos;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.$message(&#123;</span><br><span class="line">              type: &apos;error&apos;,</span><br><span class="line">              message: &apos;用户名或密码错误&apos;,</span><br><span class="line">              showClose: true</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          return false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 生成随机数</span><br><span class="line">    randomNum(min, max) &#123;</span><br><span class="line">      return Math.floor(Math.random() * (max - min) + min)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 切换验证码</span><br><span class="line">    refreshCode() &#123;</span><br><span class="line">      this.identifyCode = &apos;&apos;</span><br><span class="line">      this.makeCode(this.identifyCodes, 4)</span><br><span class="line">    &#125;,</span><br><span class="line">    makeCode(o, l) &#123;</span><br><span class="line">      for (let i = 0; i &lt; l; i++) &#123;</span><br><span class="line">        this.identifyCode += this.identifyCodes[</span><br><span class="line">          this.randomNum(0, this.identifyCodes.length)</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(this.identifyCode)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    // 验证码自定义验证规则</span><br><span class="line">    const validateVerifycode = (rule, value, callback) =&gt; &#123;</span><br><span class="line">      if (value === &apos;&apos;) &#123;</span><br><span class="line">        callback(new Error(&apos;验证码不能为空&apos;))</span><br><span class="line">      &#125; else if (value !== this.identifyCode) &#123;</span><br><span class="line">        console.log(&apos;validateVerifycode:&apos;, value)</span><br><span class="line">        callback(new Error(&apos;验证码不正确!&apos;))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback()</span><br><span class="line">        console.log(&apos;validateVerifycode:&apos;, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      fontstyle: &#123;&#125;,</span><br><span class="line">      checked: false,</span><br><span class="line">      identifyCodes: &apos;1234567890&apos;,</span><br><span class="line">      identifyCode: &apos;&apos;,</span><br><span class="line">      user: &#123;&#125;,</span><br><span class="line">      loginRules: &#123;</span><br><span class="line">        name: [</span><br><span class="line">          &#123; required: true, message: &apos;用户名不能为空&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        pass: [</span><br><span class="line">          &#123; required: true, message: &apos;密码不能为空&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        verifycode: [</span><br><span class="line">          &#123; required: true, trigger: &apos;blur&apos;, validator: validateVerifycode &#125;</span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>具体效果：<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/Login3.JPG" alt="验证码登陆"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript初探_4</title>
    <url>/2019/03/01/2019-03-01-JavaScript%E5%88%9D%E6%8E%A2_4/</url>
    <content><![CDATA[<blockquote>
<p>本文主要参考这里：<a href="https://blog.csdn.net/sps900608/article/details/79502171" target="_blank" rel="noopener">参考地址</a>，感谢博主。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Element组件安装配置完成之后，就可以开始利用它来美化界面了。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="Main-vue"><a href="#Main-vue" class="headerlink" title="Main.vue"></a>Main.vue</h2><p>主界面怎么改进一下呢？突发奇想，可以参考平时安装软件，做一个协议，只有同意协议才可以进入登陆界面，最初的想法是界面上加一个文本框，文本框内有协议内容，下边有两个Radio单选框，最后使用的方案是只有一个多选框Checkbox，后边有文字按钮，弹出Dialog对话框，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-row type=&quot;flex&quot;</span><br><span class="line">            justify=&quot;center&quot;</span><br><span class="line">            align=&quot;middle&quot;</span><br><span class="line">            style=&quot;margin-top:100px;margin-bottom:80px&quot;&gt;</span><br><span class="line">      &lt;el-col :span=&quot;5&quot;&gt;</span><br><span class="line">        &lt;div&gt;使用规定&lt;/div&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">      &lt;el-col :span=&quot;4&quot;&gt;</span><br><span class="line">        &lt;el-checkbox v-model=&quot;checked&quot;&gt;我已知晓并同意相关协议。&lt;/el-checkbox&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">      &lt;el-col :span=&quot;8&quot;&gt;</span><br><span class="line">        &lt;el-button type=&quot;text&quot;</span><br><span class="line">                   @click=&quot;dialogVisible = true&quot;&gt;阅读协议&lt;/el-button&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-dialog title=&quot;协议&quot;</span><br><span class="line">                 :visible.sync=&quot;dialogVisible&quot;</span><br><span class="line">                 width=&quot;30%&quot;</span><br><span class="line">                 :before-close=&quot;handleClose&quot;&gt;</span><br><span class="line">        &lt;span&gt;这是一段协议&lt;br&gt;&lt;/br&gt;</span><br><span class="line">          aaaaaaaaaa&lt;br&gt;</span><br><span class="line">          bbbbbbbbb&lt;br&gt;</span><br><span class="line">          ccccccccc&lt;br&gt;&lt;/br&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;span slot=&quot;footer&quot;</span><br><span class="line">              class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">          &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                     @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      &lt;/el-dialog&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">    &lt;el-row type=&quot;flex&quot;</span><br><span class="line">            justify=&quot;center&quot;&gt;</span><br><span class="line">      &lt;el-col :span=&quot;2&quot;&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                   @click=&quot;login&quot;</span><br><span class="line">                   plain</span><br><span class="line">                   :disabled=&quot;!checked&quot;&gt;点此登陆&lt;/el-button&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login() &#123;</span><br><span class="line">      this.$router.replace(&apos;/login&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClose(done) &#123;</span><br><span class="line">      this.$confirm(&apos;确认关闭？&apos;)</span><br><span class="line">        .then(_ =&gt; &#123;</span><br><span class="line">          done();</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(_ =&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      checked: false,</span><br><span class="line">      dialogVisible: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>主要用到的几项：</p>
<ul>
<li>Layout布局-分栏间隔（主要控制了一行中几列之间的左右位置）</li>
<li>Checkbox多选框-禁用状态（利用了Checkbox中checked这个变量来控制“点击登陆”按钮的状态，checkbox不选中时v-model绑定的值，即checked，是其默认值false；选中时v-model绑定的值，即checked，是true，而“点击登陆”按钮的禁用指令为disabled=”!checked”）</li>
<li>Button按钮-基础用法/文字按钮（“点击登陆”按钮以及“阅读协议”按钮）</li>
<li>Dialog对话框-基本用法（弹出协议框以及确认关闭框）</li>
</ul>
<p>具体效果：<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/Main2.JPG" alt="主界面2"></p>
<h2 id="Login-vue"><a href="#Login-vue" class="headerlink" title="Login.vue"></a>Login.vue</h2><p>Login界面相对于之前而言主要是增加了登陆成功的限制条件，如用户名密码不为空且正确（这里只是存了一组）；增加了用户名密码错误的提示框；增加了登陆成功的欢迎提示框等，具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-row type=&quot;flex&quot;</span><br><span class="line">          justify=&quot;center&quot;&gt;</span><br><span class="line">    &lt;el-form ref=&quot;loginForm&quot;</span><br><span class="line">             :model=&quot;user&quot;</span><br><span class="line">             :rules=&quot;rules&quot;</span><br><span class="line">             status-icon</span><br><span class="line">             label-width=&quot;80px&quot;&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;用户名&quot;</span><br><span class="line">                    prop=&quot;name&quot;&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;user.name&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;密码&quot;</span><br><span class="line">                    prop=&quot;pass&quot;&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;user.pass&quot;</span><br><span class="line">                  type=&quot;password&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot;</span><br><span class="line">                   icon=&quot;el-icon-upload&quot;</span><br><span class="line">                   @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">  &lt;/el-row&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login() &#123;</span><br><span class="line">      this.$refs.loginForm.validate((valid) =&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          if (this.user.name === &apos;admin&apos; &amp;&amp; this.user.pass === &apos;123&apos;) &#123;</span><br><span class="line">            this.$notify(&#123;</span><br><span class="line">              type: &apos;success&apos;,</span><br><span class="line">              message: &apos;欢迎你,&apos; + this.user.name + &apos;!&apos;,</span><br><span class="line">              duration: 3000</span><br><span class="line">            &#125;)</span><br><span class="line">            this.$router.replace(&apos;/&apos;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.$message(&#123;</span><br><span class="line">              type: &apos;error&apos;,</span><br><span class="line">              message: &apos;用户名或密码错误&apos;,</span><br><span class="line">              showClose: true</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          return false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: &#123;&#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        name: [</span><br><span class="line">          &#123; required: true, message: &apos;用户名不能为空&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">        ],</span><br><span class="line">        pass: [</span><br><span class="line">          &#123; required: true, message: &apos;密码不能为空&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>具体效果：<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/Login2.JPG" alt="用户名密码错误"><br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/Login_welcome.JPG" alt="登陆成功欢迎"></p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript初探_3</title>
    <url>/2019/02/28/2019-02-28-JavaScript%E5%88%9D%E6%8E%A2_3/</url>
    <content><![CDATA[<blockquote>
<p>本文主要参考这里：<a href="https://blog.csdn.net/sps900608/article/details/79489544" target="_blank" rel="noopener">参考地址</a>，感谢博主。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://gsynf.github.io/2019/02/27/JavaScript%E5%88%9D%E6%8E%A2_2/">上一篇博客</a>中通过“麻将”的实例已经简单了解了vue工程中helloword.vue的结构以及部分vue指令，那么从这篇博客开始，将进行一些小模块的实现，首先是登陆界面的制作。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>新建工程已经讲过，这里需要说明一点的是，由于这里制作登陆界面，登陆跳转需要用到路由功能，也就是vue-router，为了后续不用再手动添加，所以在创建工程时候这一项就设为yes。</p>
<h2 id="添加vue"><a href="#添加vue" class="headerlink" title="添加vue"></a>添加vue</h2><p>在src/components目录下新建两个.vue文件，分别起名为Main.vue和Login.vue，分别用于制作主页面和跳转后的登陆页面。</p>
<h2 id="修改index-js"><a href="#修改index-js" class="headerlink" title="修改index.js"></a>修改index.js</h2><p>在src/router目录下修改index.js文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">//import HelloWorld from &apos;@/components/HelloWorld&apos;</span><br><span class="line">import Main from &apos;@/components/Main.vue&apos;</span><br><span class="line">import Login from &apos;@/components/Login.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)   //注册vue-router</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    /*&#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;HelloWorld&apos;,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;,*/</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;Main&apos;,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/login&apos;,</span><br><span class="line">      name: &apos;Login&apos;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>主要是注销掉工程自带的helloworld相关内容，改为新建的Main和Login相关页面。这样路由就设置好了，再在main.js中引入路由即可（原main.js已引入，故这里无需更改）。</p>
<h2 id="修改vue"><a href="#修改vue" class="headerlink" title="修改vue"></a>修改vue</h2><p>接下来就是修改界面，其实也就是对三个.vue文件的操作，分别为：</p>
<blockquote>
<p>App.vue</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Main.vue</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;主页面&lt;/h1&gt; 欢迎!&lt;b @click=&quot;login&quot;&gt;点这里登录&lt;/b&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login() &#123;</span><br><span class="line">      this.$router.replace(&apos;/login&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Login.vue</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;登录界面&lt;/h1&gt; 用户名：&lt;Input /&gt;&lt;br /&gt; 密码：&lt;Input /&gt;&lt;br /&gt; &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login() &#123;</span><br><span class="line">      this.$router.replace(&apos;/&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>保存运行之后可以看到如下界面：<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/Main1.JPG" alt="主页面"><br>点击黑色粗体字，可跳转到如下页面：<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/Login1.JPG" alt="登陆界面"><br>点击登陆按钮，可跳转回主页面，所以初步实现了页面的跳转。<br>注意一下两个页面的url，可以发现这个和index.js中的设置有关。</p>
<h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>实现了上述跳转功能，但是很明显，页面特点一个字：丑。<br>如何变好看呢？需要用到一个UI框架，Element。</p>
<h2 id="安装Element"><a href="#安装Element" class="headerlink" title="安装Element"></a>安装Element</h2><p>安装指导<a href="http://element-cn.eleme.io/#/zh-CN/component/installation" target="_blank" rel="noopener">Element官网</a>有说明文档，可以参考，但作者建的工程和官网稍有不同，故有些地方有所不同，请自行参考，并且element的使用教程官网也很详细，建议参考。</p>
<ul>
<li>在工程目录下cnpm安装，命令为<br>  <code>npm i element-ui -S</code></li>
<li>在src目录下新建element文件夹，文件夹内新建index.js文件，文件内代码引入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//注意这里的代码和官网的有不同</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import ElementUI from &apos;element-ui&apos;;</span><br><span class="line">import &apos;../../node_modules/element-ui/lib/theme-chalk/index.css&apos;;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>
<ul>
<li>在main.js引入<br>  <code>import &#39;./element&#39;</code></li>
</ul>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript初探_2</title>
    <url>/2019/02/27/2019-02-27-JavaScript%E5%88%9D%E6%8E%A2_2/</url>
    <content><![CDATA[<blockquote>
<p>本文主要参考这里：<a href="https://www.cnblogs.com/rik28/p/6024425.html" target="_blank" rel="noopener">参考地址</a>，感谢博主。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">廖雪峰</a>这里讲JavaScript讲的很详细，长期学习可参考。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先，应该弄清楚vue到底是什么，其实，Vue.js是一个目前应用很广的JavaScript MVVM库，以数据驱动和组件化的思维构建。那么什么是MVVM呢？MVVM是Model-View-ViewModel的简称，由微软最先提出，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离。把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。<strong>ViewModel是Vue.js的核心，它是一个Vue实例。使用Vue的过程就是定义MVVM各个组成部分的过程的过程。</strong>这里不展开多讲，以后在使用过程中会逐渐清晰这个概念。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="先来感受一下"><a href="#先来感受一下" class="headerlink" title="先来感受一下"></a>先来感受一下</h2><p>为了更好的理解，可以先来感受一下实例。<a href="https://gsynf.github.io/2019/02/26/JavaScript%E5%88%9D%E6%8E%A2/">上一篇博客</a>中已经介绍了如何新建一个vue工程，当时已经新建了一个firstVue的工程，我们在VS Code中将整个文件夹加载，修改页面所要进行的工作主要在src–&gt;components–&gt;helloworld.vue中进行。<br>可以打开helloworld.vue看一下，主要分为三部分：template、script、style。这三部分分别有各自的功能，template，这是html部分，用来显示；script，类似js，用来做一些数据绑定和方法；style，就是css部分，用来定义html中元素的样式尺寸大小之类的。（胖丫告我的，有误概不负责）</p>
<blockquote>
<p>此处实例参考：<a href="https://blog.csdn.net/Lisunlight/article/details/81221017" target="_blank" rel="noopener">戳</a>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!--表单的增删和修改--&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">      &lt;caption&gt;麻将&lt;/caption&gt;</span><br><span class="line">      &lt;thead&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;条&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;筒&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;万&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">      &lt;/thead&gt;</span><br><span class="line">      &lt;tbody&gt;</span><br><span class="line">      &lt;tr v-for=&quot;(mj,index) in mjs&quot;&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">          &lt;input type=&quot;text&quot; v-model=&quot;mj.tiao&quot; v-if=&quot;edi===index&quot;&gt;</span><br><span class="line">          &lt;span v-else&gt;&#123;&#123;mj.tiao&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">          &lt;input type=&quot;text&quot; v-model=&quot;mj.tong&quot; v-if=&quot;edi===index&quot;&gt;</span><br><span class="line">          &lt;span v-else&gt;&#123;&#123;mj.tong&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">          &lt;input type=&quot;text&quot; v-model=&quot;mj.wan&quot; v-if=&quot;edi===index&quot;&gt;</span><br><span class="line">          &lt;span v-else&gt;&#123;&#123;mj.wan&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;td&gt;</span><br><span class="line">          &lt;button @click=&quot;mod(index)&quot;&gt;修改&lt;/button&gt;</span><br><span class="line">          &lt;button @click=&quot;save(index)&quot;&gt;确定&lt;/button&gt;</span><br><span class="line">          &lt;button @click=&quot;del(index)&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">      &lt;/tbody&gt;</span><br><span class="line">      &lt;tfoot&gt;</span><br><span class="line">        &lt;td colspan=&quot;4&quot;&gt;</span><br><span class="line">          &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;</span><br><span class="line">          &lt;button @click=&quot;submit&quot;&gt;保存&lt;/button&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">      &lt;/tfoot&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;HelloWorld&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        edi:&apos;&apos;,</span><br><span class="line">        mjs: [</span><br><span class="line">          &#123;tiao:&apos;一条&apos;,tong:&apos;一筒&apos;,wan:&apos;壹万&apos;&#125;,</span><br><span class="line">          &#123;tiao:&apos;二条&apos;,tong:&apos;二筒&apos;,wan:&apos;贰万&apos;&#125;,</span><br><span class="line">          &#123;tiao:&apos;三条&apos;,tong:&apos;三筒&apos;,wan:&apos;叁万&apos;&#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      mod:function(index)&#123;</span><br><span class="line">        this.edi=index;</span><br><span class="line">      &#125;,</span><br><span class="line">      del: function (index) &#123;</span><br><span class="line">        this.mjs.splice(index, 1);</span><br><span class="line">      &#125;,</span><br><span class="line">      save:function(index)&#123;</span><br><span class="line">        this.edi=!index;</span><br><span class="line">      &#125;,</span><br><span class="line">      add:function()&#123;</span><br><span class="line">        this.mjs.push(&#123;tiao:&apos;&apos;,tong:&apos;&apos;,wan:&apos;&apos;&#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      submit:function () &#123;</span><br><span class="line">        this.edi=&apos;&apos;;</span><br><span class="line">        console.log(JSON.stringify(this.mjs))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  input&#123;</span><br><span class="line">    border:none;</span><br><span class="line">    width:150px;</span><br><span class="line">  &#125;</span><br><span class="line">  table&#123;</span><br><span class="line">  border-collapse: collapse;</span><br><span class="line">  border:1px solid black</span><br><span class="line">  &#125;</span><br><span class="line">  td&#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height:30px;</span><br><span class="line">    border:1px solid black</span><br><span class="line">  &#125;</span><br><span class="line">  button&#123;</span><br><span class="line">    border: none;</span><br><span class="line">    background-color:deepskyblue;</span><br><span class="line">    color:white;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>结合上边实例的代码，学习一些vue指令。</p>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>首先出现的指令是v-for指令，v-for指令其实就是遍历，基本语法：<br>v-for=”item in items”,items是一个数组，item是当前被遍历的数组元素。</p>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>v-if是条件渲染指令，根据条件的真假来删除或者插入元素，基本语法：<br>v-if=”expression”,expression是一个返回bool值的表达式，表达式可以是一个bool属性，也可以是一个返回bool的运算式。</p>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>v-show指令也是条件渲染指令，和v-if不同点在于它的元素始终会被渲染到html，只是简单的为元素设置CSS的style类型，若条件为false，元素会被设置了style=”display:none”样式。</p>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>v-else指令为v-if或v-show添加一个“else块”。v-else元素必须立即跟在v-if或v-show元素的后面,否则它不能被识别。<br>v-else元素是否渲染在HTML中，取决于前面使用的是v-if还是v-show指令。这段代码中v-if为true，后面的v-else不会渲染到HTML；v-show为true，但是后面的v-else仍然渲染到HTML。</p>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute），例如：v-bind:class,基本语法：<br>v-bind:argument=”expression”</p>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>v-on指令用于给监听DOM事件，它的用语法和v-bind是类似的，例如监听a元素的点击事件：<br>    <code>&lt;a v-on:click=&quot;doSomething&quot;&gt;</code><br>有两种形式调用方法：绑定一个方法（让事件指向方法的引用），或者使用内联语句。</p>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p>Vue.js为最常用的两个指令v-bind和v-on提供了缩写方式。v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--完整语法--&gt;</span><br><span class="line">&lt;a href=&quot;javascripit:void(0)&quot; v-bind:class=&quot;activeNumber === n + 1 ? &apos;active&apos; : &apos;&apos;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;</span><br><span class="line">&lt;!--缩写语法--&gt;</span><br><span class="line">&lt;a href=&quot;javascripit:void(0)&quot; :class=&quot;activeNumber=== n + 1 ? &apos;active&apos; : &apos;&apos;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--完整语法--&gt;</span><br><span class="line">&lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">&lt;!--缩写语法--&gt;</span><br><span class="line">&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><em>tips：</em><br>补充几点JavaScript和其他语言相比，比较特殊的地方：</p>
<ol>
<li><strong>Number</strong><br>JavaScript不区分整数和浮点数，统一用Number表示。<br>需要注意一下的是NaN(Not a Number，当无法计算结果时用NaN表示)这个特殊的Number与所有其他值都不相等，包括它自己：<br> <code>NaN === NaN; // false</code></li>
<li><strong>相等运算符</strong><br>JavaScript在设计时，有两种比较运算符：<br>第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；<br>第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。<br>由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。</li>
<li><strong>变量申明</strong><br>变量在JavaScript中就是用一个变量名表示，申明一个变量用var语句。需要注意的是如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量，为了防止出现混乱，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。<br>启用strict模式的方法是在JavaScript代码的第一行写上：<br> <code>&#39;use strict&#39;;</code></li>
<li><strong>字符串</strong><br>字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：<pre><code>var s = &apos;Test&apos;;
s[0] = &apos;X&apos;;
alert(s); // s仍然为&apos;Test&apos;</code></pre></li>
</ol>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript初探_1</title>
    <url>/2019/02/26/2019-02-26-JavaScript%E5%88%9D%E6%8E%A2_1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先，感谢<a href="https://github.com/liuqiangh" target="_blank" rel="noopener">小胖丫</a>对我的帮助，毕竟是将来要赚钱养我的女人~</p>
<h1 id="开始JavaScript探索之路了！"><a href="#开始JavaScript探索之路了！" class="headerlink" title="开始JavaScript探索之路了！"></a>开始JavaScript探索之路了！</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要安装node,vue及git,其中node及git需要下载安装文件进行安装,之前已经装过，此处不加赘述，vue可以在命令行中进行安装，具体参考这里，<a href="https://segmentfault.com/a/1190000009871504/" target="_blank" rel="noopener">戳戳戳</a>，按照步骤一步一步的来即可，cmd中一直保持运行，这样就可以实时查看自己修改效果。</p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>编辑器使用<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a>，其中注意为了保证代码格式规范，将文件夹中.eslintrc.js中进行修改，改为如下：</p>
<pre><code>module.exports = {
  &quot;extends&quot;: &quot;standard&quot;
      };</code></pre><p>2019/2/27 15:13:33 一切太过顺利意味着什么？意味着终究要返工。不知道什么神奇的原因，昨天的工程今天再运行就报错<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/eslint--error.png" alt="报错截图"><br>关于eslint的，万般无奈之下就删了工程重新建了一次，之间是在建工程时候就选择了添加eslint，所以这次决定先不选，建好之后运行，是可以的。那么接下来添加eslint，首先在VS Code中搜索添加控件，这个是没问题的，接下来在cmd中添加全局eslint，</p>
<ol>
<li><code>npm install eslint -g</code>这一步是没有问题的；</li>
<li><code>eslint --init</code>哇，这一步真的是一言难尽，别人运行完都是这样的<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/eslint--init.png" alt="eslint--init"><br>而我第一个问题就和别人不一样<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/eslint--init_1.JPG" alt="eslint--init_1"><br>还真是奇葩，全网都没找到同意问题的，翻墙终于找到一个，但也没说每个问题怎么选：<a href="https://dev.to/iamdammak/setting-up-eslint-in-your-javascript-project-with-vs-code-2amf" target="_blank" rel="noopener">戳</a>。既然找不到，那索性按(X)感(J)觉(B)选，到了最后<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/eslint--install_1.png" alt="npm install 出现 error"><br>好吧，重来一次，这次选no，好嘛，直接退了，不过文件夹中已经有了eslintrc.js了，不管了，打开，再把那三行粘进去，再运行一下，可以，OK，那就（假装）没问题了，以后有情况，我还会回来的，希望不要了。。。<br>另外，在编辑器左下角点击齿轮-设置-右上角{}，添加如下代码，同意是为了保证代码缩进等规范。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //使用eslint规则重新格式化代码</span><br><span class="line">    &quot;eslint.enable&quot;: false,</span><br><span class="line">    &quot;eslint.autoFixOnSave&quot;: true,</span><br><span class="line">    &quot;eslint.validate&quot;: [</span><br><span class="line">        &quot;javascript&quot;,</span><br><span class="line">        &quot;javascriptreact&quot;,</span><br><span class="line">        &quot;html&quot;,</span><br><span class="line">        &quot;vue&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;eslint.options&quot;: &#123;</span><br><span class="line">        &quot;plugins&quot;: [</span><br><span class="line">            &quot;html&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    //关闭自动文件自动存储</span><br><span class="line">    &quot;files.autoSave&quot;: &quot;off&quot;,</span><br><span class="line">    &quot;vetur.validation.template&quot;: false,</span><br><span class="line">    &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,</span><br><span class="line">    &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;,</span><br><span class="line">    &quot;vetur.format.defaultFormatterOptions&quot;: &#123;</span><br><span class="line">        &quot;js-beautify-html&quot;: &#123;</span><br><span class="line">            &quot;wrap_attributes&quot;: &quot;force-aligned&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">    //为了符合eslint的两个空格间隔原则</span><br><span class="line">    &quot;editor.tabSize&quot;: 2,</span><br><span class="line">    &quot;git.autofetch&quot;: true,</span><br><span class="line">    &quot;window.zoomLevel&quot;: 0,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下一次将具体阐述vue进阶学习，<a href="https://www.cnblogs.com/rik28/p/6024425.html" target="_blank" rel="noopener">学习参考</a>。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkdownPad试用</title>
    <url>/2019/02/25/2019-02-25-MarkdownPad%E8%AF%95%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>正所谓前人栽树，后人乘凉。</p>
<p>感谢<a href="https://github.com/qiubaiying/qiubaiying.github.io" target="_blank" rel="noopener">BY</a>提供的博客模板</p>
<p><a href="https://www.jianshu.com/p/e68fba58f75c" target="_blank" rel="noopener">博客搭建参考戳这里</a></p>
<p><a href="https://gsynf.github.io/">这是我的博客主页，欢迎访问留言</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尽管参照了博客模板，但在改动过程中仍出现了不少问题，例如界面的改动、评论系统的设置等等，目前博客大致框架已经搭好，所以准备写一些零碎的东西，有空的话将之前CSDN的博客迁移过来。</p>
<p>废话不多说了，开始进入正文。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要做的就是Markdown文件的编写，之前在CSDN上使用的网页版很好，可是和简书一样，都没有办法保存到本地，所以需要一款称心的本地编辑器。首先尝试了小书匠，可是没有办法实时预览，所以最后还是选择了windows下最方便强大的<a href="http://markdownpad.com/download.html" target="_blank" rel="noopener">MarkdownPad</a></p>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>全功能需要破解，在安装完成打开时：<br><img src="https://i.imgur.com/4XONEDR.png" alt=""><br>账户：<code>Soar360@live.com</code></p>
<p>密钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</span><br></pre></td></tr></table></figure>

<h2 id="修改中文"><a href="#修改中文" class="headerlink" title="修改中文"></a>修改中文</h2><p>工具栏Tool-Options-Editor即可。</p>
<h2 id="无法渲染"><a href="#无法渲染" class="headerlink" title="无法渲染"></a>无法渲染</h2><p>安装完成之后，在win10环境下容易出现无法渲染html，也就是无法实时预览，系统崩溃的情况，这一点官网的FAQ中给出了<a href="http://markdownpad.com/faq.html#livepreview-directx" target="_blank" rel="noopener">解决方案</a>。需要安装Awesomium 1.6.6 SDK，点击下载安装之后重启电脑即可。<br><img src="https://raw.githubusercontent.com/Gsynf/BlogImg/master/markdown_crashed.JPG" alt="下载地址"></p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>安装GLPK</title>
    <url>/2018/12/12/2018-12-12-%E5%AE%89%E8%A3%85GLPK/</url>
    <content><![CDATA[<p>写卜老师算法关于LP部分作业，需要用到GLPK，简单安装一下，需要用到VS环境，网上教程比较简单，但是我之前安装VS2017社区版，按照通用教程安装时候，在修改vs安装包下VC路径时一直出问题，弄了挺久一直不行，无奈重装了VS2015，这里简单记录一下过程。</p>
<ul>
<li><p>下载GLPK，<a href="http://ftp.gnu.org/gnu/glpk/" target="_blank" rel="noopener">点这里</a>，下载tar.gz文件即可，下载后解压即可</p>
</li>
<li><p>解压后打开文件夹，进入w64（视自己系统而定），由于我安装的时VS2015，所以修改两个文件Build_GLPK_with_VC14.bat/Build_GLPK_with_VC14_DLL.bat，将其中home地址都改为VS安装包中VC路径，然后双击运行这两个文件即可。<br><img src="https://img-blog.csdnimg.cn/20181212152258673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODY2NjYx,size_16,color_FFFFFF,t_70" alt="这是我的"></p>
</li>
<li><p>判断是否安装成功两种方法：<br>1，运行结果出现OPTIMAL LP SOLUTION FOUND字样<br>2，在w64文件夹中新增加了glpk.lib和glpsol.exe两个文件</p>
</li>
<li><p>此时已经安装成功，但是每次运行都要进入w64这个文件夹，所以配置一下glpsol.exe环境变量<br><img src="https://img-blog.csdnimg.cn/20181212152754771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODY2NjYx,size_16,color_FFFFFF,t_70" alt="配置环境变量">图片参考：<a href="https://blog.csdn.net/flygeda/article/details/78743810?utm_source=blogxgwz6" target="_blank" rel="noopener">https://blog.csdn.net/flygeda/article/details/78743810?utm_source=blogxgwz6</a></p>
</li>
<li><p>使用<br>cmd在命令行使用<br>使用命令：glpsol -m test.mod -o test.sol<br>test.mod 是写好的代求解的文件<br>test.sol 是生成的结果文件</p>
</li>
</ul>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>GLPK</tag>
      </tags>
  </entry>
  <entry>
    <title>《跟老齐学python》学习笔记4</title>
    <url>/2018/09/26/2018-10-28-%E3%80%8A%E8%B7%9F%E8%80%81%E9%BD%90%E5%AD%A6python%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<ul>
<li>全局变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = 2</span><br><span class="line">def funcx():</span><br><span class="line">x = 9</span><br><span class="line">print &quot;this x is in the funcx:--&gt;&quot;, x</span><br><span class="line">funcx()</span><br><span class="line">print &quot;--------------------------&quot;</span><br><span class="line">print &quot;this x is out of funcx:--&gt;&quot;, x</span><br></pre></td></tr></table></figure>
输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this x is in the funcx:--&gt; 9</span><br><span class="line">--------------------------</span><br><span class="line">this x is out of funcx:--&gt; 2</span><br></pre></td></tr></table></figure>
<p>在函数内多了一个global x,这句话的意思是在声明x是全局变量,也就是说这个x跟函数外面的那个x是同一个,接下来通过x=9将x的引用对象变成了9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = 2</span><br><span class="line">def funcx():</span><br><span class="line">global x</span><br><span class="line">#跟上面函数的不同之处</span><br><span class="line">x = 9</span><br><span class="line">print &quot;this x is in the funcx:--&gt;&quot;, x</span><br><span class="line">funcx()</span><br><span class="line">print &quot;--------------------------&quot;</span><br><span class="line">print &quot;this x is out of funcx:--&gt;&quot;,x</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this x is in the funcx:--&gt; 9</span><br><span class="line">--------------------------</span><br><span class="line">this x is out of funcx:--&gt; 9</span><br></pre></td></tr></table></figure>

<ul>
<li>当函数的参数个数不确定的时候，可以通过如下方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(x,*arg):</span><br><span class="line">    print(x)</span><br><span class="line">    result = x</span><br><span class="line">    print(arg)</span><br><span class="line">    for i in arg:</span><br><span class="line">        result += i</span><br><span class="line">    return result</span><br><span class="line">print(func(1,2,3,4,5,6,7,8,9))</span><br></pre></td></tr></table></figure>
结果为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">(2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>从上面例子可以看出,如果输入的参数个数不确定,其他参数全部通过*arg,以元组的形式由arg收集起来。</p>
<ul>
<li>更优（zhuang）雅（b）的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...</span><br><span class="line">return x + y</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bars = (2, 3)</span><br><span class="line">&gt;&gt;&gt; add(*bars)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>先把要传的值放到元组中,赋值给一个变量bars,然后用add(<em>bars)的方式,把值传到函数内。注意,元组中元素的个数要跟函数所要求的变量个数一致。使用一个星号</em>,以元组形式传值,用**的方式,是以字典的形式传值。</p>
<ul>
<li>几个特殊函数，filter、map、reduce、lambda、yield……</li>
<li>函数尽量达到的要求<br>1 尽量不要使用全局变量。<br>2 如果参数是可变类型数据,则在函数内不要修改它。<br>3 每个函数的功能和目标要单纯,不要试图一个函数做很多事情。<br>4 函数的代码行数尽量少。<br>5 函数的独立性越强越好,不要跟其他的外部东西产生关联。</li>
</ul>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《跟老齐学python》学习笔记3</title>
    <url>/2018/09/26/2018-09-26-%E3%80%8A%E8%B7%9F%E8%80%81%E9%BD%90%E5%AD%A6python%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<ul>
<li><p>Python开发者有意让违反了缩排规则的程序不能通过编译，以此来强迫程序员养成良好的编程习惯。并且Python语言利用缩排表示语句块的开始和结束（Off-side规则），而非使用花括号或者某种关键词。增加缩排表示语句块的开始，而减少缩排则表示语句块的结束。<br>哈哈哈，有趣。<br>两个必需的要求：1、必须要通过缩进方式来表示语句块的开始和结束。2、缩进用四个空格（也是必需的，别的方式或许也可以，但不提倡）。</p>
</li>
<li><p>zip()函数：它的参数必须是某种序列数据类型，如果是字典，那么视为序列。然后将序列对应的元素依次组成元组，并单做列表中的元素。</p>
</li>
<li><p>在python2和3中，print默认最后输出换行，如果输出不想换行，在2中 print xxx ,  加一个逗号即可，但在3中python为一个函数，加逗号就不可行，这里需要添加一个end，end表示字符串结尾添加什么字符</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hello=&quot;world&quot;</span><br><span class="line">&gt;&gt;&gt; for i in hello:</span><br><span class="line">	print(i)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">w</span><br><span class="line">o</span><br><span class="line">r</span><br><span class="line">l</span><br><span class="line">d</span><br><span class="line">&gt;&gt;&gt; for i in hello:</span><br><span class="line">	print(i),</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">w</span><br><span class="line">(None,)</span><br><span class="line">o</span><br><span class="line">(None,)</span><br><span class="line">r</span><br><span class="line">(None,)</span><br><span class="line">l</span><br><span class="line">(None,)</span><br><span class="line">d</span><br><span class="line">(None,)</span><br><span class="line">&gt;&gt;&gt; for i in hello:</span><br><span class="line">	print(i,)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">w</span><br><span class="line">o</span><br><span class="line">r</span><br><span class="line">l</span><br><span class="line">d</span><br><span class="line">&gt;&gt;&gt; for i in hello:</span><br><span class="line">	print(i,end=&quot;&quot;)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<ul>
<li>两个值对调，其他语言都是引入一个第三个变量，即</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp</span><br></pre></td></tr></table></figure>
<p>python里简直不要太方便，直接a,b=b,a即可。</p>
<ul>
<li>range函数返回值需要用list来显示，python3中range（）返回的就是一个对象，但2中返回的就是一个列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; range(3,100,3)</span><br><span class="line">range(3, 100, 3)</span><br><span class="line">&gt;&gt;&gt; list(range(3,100,3))</span><br><span class="line">[3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]</span><br></pre></td></tr></table></figure>


<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda环境安装</title>
    <url>/2018/09/25/2018-09-25-Anaconda%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>中秋浪完回来，得弄CCF大赛了，需要跑数据，首先搭平台，决定在linux下搞整一把。</p>
</blockquote>
<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><ol>
<li>首先，安装anaconda,<a href="https://www.anaconda.com/download/#download" target="_blank" rel="noopener">Anaconda 5.2 For Linux Installer</a>，安装3.6版本，点击下载即可。</li>
<li>找到自己下载的目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后一直点击Enter键，然后一直yes</li>
</ol>
<p><img src="https://i.loli.net/2019/07/19/5d31603c2245e47668.png" alt=""></p>
<p>直到出现这张图片，这里可以更改安装目录，Enter选择默认即可，在home/user下</p>
<ol start="4">
<li>安装完成之后电脑重启，在终端输入 anaconda，即可看到安装成功，命令conda list可查看安装的所有包</li>
</ol>
<h1 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h1><p>​    接下来，安装pycharm，懒得破解，安装一个社区版就行了，够用，同样去官网找即可，<a href="http://www.jetbrains.com/pycharm/download/#section=linux" target="_blank" rel="noopener">Pycharm Linux</a>，下载完成之后解压，在bin文件夹下运行 <code>sh pycharm.sh &amp;</code>即可，打开之后在工具栏tools里可以添加desktop快捷方式，回到桌面在搜索里搜到右键“添加到收藏栏“即可。</p>
<p>​    从群里找到了大神写的一个脚本，用pycharm打开脚本之后除了改改字体大小之外首先需要修改环境：fils–&gt;setting–&gt;project pywork–&gt;project interpreter，可以看到此时默认的是pytharm安装的python环境，由于没有什么包，所以需要换刚才安装的anaconda里的python环境，点击齿轮修改即可，大神用到了ligthgbm,需要添加包，在anaconda里添加包即可，ligthgbm官网找到了添加的终端命令：<code>conda install -c conda-forge lightgbm</code>，OK搞定。</p>
<h1 id="Xgboost"><a href="#Xgboost" class="headerlink" title="Xgboost"></a>Xgboost</h1><p>在anaconda下安装xgboost</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install libgcc</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install xgboost</span><br></pre></td></tr></table></figure>



<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《跟老齐学python》学习笔记2</title>
    <url>/2018/09/05/2018-09-05-%E3%80%8A%E8%B7%9F%E8%80%81%E9%BD%90%E5%AD%A6python%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>第一季第一章第六节主要讲述了字符编码的问题，Python2中还有这个问题，但3中几乎不涉及这个问题了，所以这里不多做笔记，仔细看一看，对以前ASCII，Unicode等编码有不错的理解，挺好的。<br>额外记录一点：如果对文件操作,打开文件的时候,最好用codecs.open替代open</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import codecs</span><br><span class="line">codecs.open(&apos;filename&apos;, encoding=&apos;utf8&apos;)</span><br></pre></td></tr></table></figure>
<p>第七节：列表</p>
<ul>
<li>列表list同int,float,str一样，也是python的一种对象类型。</li>
<li>list用[]表示，这同其他语言的数组类似，但是数组中的元素必须是同一种类型，因为数组需要提前声明，说明数组类型，但列表不用，所以里面的元素可以是不同类型。</li>
<li>列表和字符串两种类型都属于序列(都是一些对象按照某个次序排列起来,这是序列的最大特征)</li>
<li>“反转”函数，示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; lst=[1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt; list(reversed(lst))</span><br><span class="line">[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>关于迭代，看完一次有些不懂，建议再看，其实就目前而言，还无法理解迭代和extend函数之间的关系，我对于迭代有待以后更加深入，除了文章中给出的使用函数查看，还可以用“for 元素 in 对象： printf 元素”来检验，如果可以打印出来，那么对象就是可迭代的，不过文章中示例可以看出str类型的对象是不可迭代的，不过通过实验发现是可以迭代的，不知道是文章的错误还是python 2 和3之间的区别。</p>
</li>
<li><p>1.7和1.8 主要讲了列表的一些操作函数，例如反转、插入、删除等以及对于这么函数，列表和字符串的相同和不同，说实话，函数太多具体用法记不住，只能先过一遍，知道有这么个函数，可以实现什么功能，到具体用的时候再来仔细查看。<br>第九节：元组</p>
</li>
<li><p>1.9介绍了一个新的概念：元组。元组是用圆括号括起来的，元素之间用逗号隔开。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>对比</th>
<th>字符串</th>
<th>列表</th>
<th>元组</th>
</tr>
</thead>
<tbody><tr>
<td>是否是序列</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>元素是否可改</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>元素类型</td>
<td>非任意</td>
<td>任意</td>
<td>任意</td>
</tr>
</tbody></table>
<p><strong>特别提醒，如果一个元组中只有一个元素，应该在该元素后面加一个半角的英文逗号。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; a=(1)</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; a=(1,)</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure>
<p>第十节：字典</p>
<ul>
<li>1.10介绍了新概念，字典(dict)。在一个字典中,键是唯一的,不能重复，必须是不可变对象。值则对应于键,且值可以重复。建立字典有三种方法，具体见p123。其中最后一种为使用{}.fromkeys</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person=&#123;&#125;.fromkeys((&quot;one&quot;,&quot;two&quot;),&quot;hpf&quot;)</span><br><span class="line">&gt;&gt;&gt; person</span><br><span class="line">&#123;&apos;one&apos;: &apos;hpf&apos;, &apos;two&apos;: &apos;hpf&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>这里不同的键对应同一个值，如何不同的键对应不同的值呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person=&#123;&#125;.fromkeys((&quot;one&quot;,&quot;two&quot;),(&quot;hpf&quot;,&quot;lqh&quot;))</span><br><span class="line">&gt;&gt;&gt; person</span><br><span class="line">&#123;&apos;one&apos;: (&apos;hpf&apos;, &apos;lqh&apos;), &apos;two&apos;: (&apos;hpf&apos;, &apos;lqh&apos;)&#125;</span><br></pre></td></tr></table></figure>
<p>呃，也不是<br>查了一下，貌似是不可以的<br>类似键值对这种映射方式的数据存储方式十分高效，例如使用列表，python需要从头开始读，直到找到制定的索引值；但是使用字典便不需要，直接通过“键”来找到值，数据规模越大，这种优势越明显，因此也广泛应用于数据库中。</p>
<ul>
<li>Python中的copy为浅拷贝，如何理解浅拷贝。简单讲python只存储基本数据对象，如int、str等，这些对象在复制时，会新建一个内存地址，但是对于其他数据类型，在复制时并不会新辟地址。如果在复制时想全部新建地址，就需要“深复制”，需要导入一个模块，import copy，使用copy.deepcopy进行复制。</li>
<li>对于一个字典</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=&#123;&quot;name&quot;:&quot;hpf&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; a.clear()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; del a</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#42&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    a</span><br><span class="line">NameError: name &apos;a&apos; is not defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>clear为清空，del为删除。<br>第十一节  集合<br>哇，感觉开学之后每天很紧张，好几天没有看老齐了，心中有愧呐，数据库课前看一波</p>
<ul>
<li>集合（set），特点：有的可变，有的不可变；元素无顺序，不可重复</li>
<li>可通过set（）创建，或者通过{}直接创建（不提倡，有时会和字典搞混）</li>
<li>set()创建的是可变的集合，用frozenset()创建的是不可变的集合，也就是可哈希的</li>
<li>其他的交并补等运算自己看</li>
</ul>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《跟老齐学python》学习笔记1</title>
    <url>/2018/09/03/2018-09-03-%E3%80%8A%E8%B7%9F%E8%80%81%E9%BD%90%E5%AD%A6python%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<blockquote>
<p>哈哈哈，前言太有趣，不得不说正是前言才让我选择继续跟着他学。</p>
</blockquote>
<ul>
<li>Ubuntu18.04.1版本默认是安装了Python3，没有装2，那我也不装喽，貌似2已经不怎么维护了。<br>（PS：查看版本号命令  lsb_release  -a）</li>
<li>Python2中print不是一个函数；Python3中print是一个函数，同样输出“Hello World”，2是print   “Hello, World”；3是print   （”Hello, World”）</li>
<li>Python中一个对象的特征：身份，类型，值。所谓“身份”，其实就是对象的内存地址，可以通过内建函数id()查看；所谓“类型”，也就是整形、浮点型这些，可以通过内建函数type()查看；所谓“值”，就是对象本身喽。</li>
<li>Python2中非浮点数准备的有int和long类型，长整型后边会有L；Python3中只有一种整数类型int。</li>
<li>在Python2里面有一个规定,像2/5这样的除法要取整(就是去掉小数,但不是四舍五入)。2除以5,商是0(整数),余数是2(整数)。如果用这种形式:2/5,那么计算结果就是商那个整数。或者可以理解为:整数除以整数,结果是整数(商)。2计算2/5，结果为0；3计算2/5，结果为0.4.</li>
<li>字符串，用单引号或者双引号。但是如果字符串中有单引号或双引号，这时再用相同的符号就会报错，所以有单用双，有双用单；另外还可以在字符串的引号前加一个转义符，使本来计算机不认为是字符串一部分的引号变为字符串一部分，转义符为\，例如&gt;&gt;&gt; ‘What&#39;s your name?’。</li>
<li>由r开头引起的字符串就是声明了后面引号里的东西是原始字符串,在里面放任何字符都表示该字符的原始含义。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dos = r&quot;c:\news&quot;</span><br><span class="line">&gt;&gt;&gt; print dos</span><br><span class="line">c:\news   #这里\n没有表示转义字符换行，而是按照原始格式打印</span><br></pre></td></tr></table></figure>

<ul>
<li>发现一个比较有趣的东东</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=input(&quot;input your old:&quot;)</span><br><span class="line">input your old:12</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; b=print(12)</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; type(b)</span><br><span class="line">&lt;class &apos;NoneType&apos;&gt;</span><br></pre></td></tr></table></figure>


<p> 貌似input的值都是str类型，于是想试一下print，后来发现没法这么试，input函数是把键盘输入的值赋给了a，但print函数很显然并不是把要打印的值赋给b，但 b=print(12)没有报错，所以这句话表示什么呢？有些疑问</p>
<ul>
<li>有一个编写小对话的示例，才发现IDLE一直没用，一直在终端里进python3输命令，在终端输idle，显示未安装，按照提示安装即可。安装完成回到终端，输入idle即可打开，在shell里新建窗口就可以写代码啦。</li>
<li>在leetcode上第一题两数之和看到了index，查了也没完全弄明白，今天看到了，恍然大悟</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=&quot;study&quot;</span><br><span class="line">&gt;&gt;&gt; a[0]</span><br><span class="line">&apos;s&apos;</span><br><span class="line">&gt;&gt;&gt; a.index(&quot;y&quot;)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>不用解释了，一看就明白了</p>
<ul>
<li>有时候字符串的拼接使用join函数更加便捷</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b=&quot;I.love.lqh&quot;</span><br><span class="line">&gt;&gt;&gt; c=b.split(&quot;.&quot;)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[&apos;I&apos;, &apos;love&apos;, &apos;lqh&apos;]</span><br><span class="line">&gt;&gt;&gt; &quot;.&quot;.join(c)</span><br><span class="line">&apos;I.love.lqh&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>python中占位符与后边实际输出的内容通过%连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;  print(&quot;i like %s&quot;,&quot;python&quot;)</span><br><span class="line">SyntaxError: unexpected indent</span><br><span class="line">&gt;&gt;&gt; print(&quot;i like %s&quot;%&quot;python&quot;)</span><br><span class="line">i like python</span><br></pre></td></tr></table></figure>
<p>另外还有一种python推荐的格式化方法string.format()，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I love &#123;0&#125; since &#123;1&#125; years ago.&quot;.format(&quot;lqh&quot;,7))</span><br><span class="line">I love lqh since 7 years ago.</span><br></pre></td></tr></table></figure>
<p>按0，1，2……的顺序（PS：{}里面甚至可以不是标号，写什么都可以）用{}标好占位符，字符串后边.format()写入要输出的内容即可，嘿嘿嘿，美滋滋。</p>
<p>以上。</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>双系统安装</title>
    <url>/2018/09/02/2018-09-02-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>最近打算装个双系统，其实也没有想好具体要做什么，只是觉得学python也方便，以后搞其他开发也方便。绕过了不少坑，在此记录一下。</p>
</blockquote>
<ol>
<li>当然，第一步先从官网下Ubuntu的ISO镜像文件，哇，经历了昨天的网速，今天图书馆的网速简直就是飞起；</li>
<li>下一个小工具<a href="http://rufus.akeo.ie/" target="_blank" rel="noopener">Rufus</a>，准备一个格式化好的U盘；</li>
<li>制作U盘启动盘，注意分区类型选择GPT，目标系统类型为UEFI（非CSM），其他默认就好，文件系统和簇大小不同电脑默认可能会有不同（我和马大姐的就不一样），按照自己的默认就好，之后开始制作即可；</li>
<li>制作过程中给电脑进行分区，可以用电脑自带的磁盘管理，可以下一个分区助手，我这里规划了60个G，电脑自带的只能分出相邻的区，如果要每个盘都割一点出来，最好下一个分区助手；</li>
<li>制作完成之后点击关闭，不要拔出U盘，电脑重启，重启过程中不停按F12进入boot(不同电脑按键可能不同)，选择自己插入的U盘，Enter;</li>
<li>整个安装过程比较简单，唯一需要注意的是在安装类型，选择“其他选项”，在这里对系统进行分区，即将刚才在WINDOWS划分出的60个G进行分配，我的划分为ext4      /     30G;ext4    /home    20G;交换分区swap    8G;efi   启动器  2G；</li>
<li>这里看你创建的“/boot”分区的编号是什么，比如我的是“sda11”（你的不一定是这个，取决于你的“/boot”分区编号）。那么下边的“安装启动引导区的设备”下拉菜单中选择“sda11”，如果这步忽略了，那就是用ubuntu来引导windows了；</li>
<li>之后也就没啥了，用户名，设备名称，密码这些。</li>
</ol>
<p>直到安装完成也没想清楚Ubuntu系统到底要干啥，中午回去看了会《跟老齐学python》，感觉廷不错的，正好书中是以LINUX为例，岂不美哉。不过稍有遗憾的是他主要讲的是Python2，python3就靠自己摸索啦，推荐刷题，领扣就不错<a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">领扣</a></p>
<p>开始吧，骚年！</p>
<p><strong><em>注</em></strong>：转载文章请注明出处，谢谢~</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>为博客添加 Gitalk 评论插件</title>
    <url>/2017/12/19/2017-12-19-%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于 <strong>Disqus</strong> 对于国内网路的支持十分糟糕，很多人反映 Disqus 评论插件一直加载不出来。而我一直是处于翻墙状态的~（话说你们做程序员的都不翻墙用Google的吗😅，哈哈，吐嘈下）</p>
<p>针对这个问题，我添加了<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a> 评论插件。在此，非常感谢 <a href="https://github.com/FeDemo" target="_blank" rel="noopener">@FeDemo</a> 的推荐 。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Gitalk-评论插件"><a href="#Gitalk-评论插件" class="headerlink" title="Gitalk 评论插件"></a>Gitalk 评论插件</h3><p>首先来看看 Gitalk 的界面和功能：</p>
<p><a href="https://gitalk.github.io/" target="_blank" rel="noopener"><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm4u3j0lmj30nk0kl40i.jpg" alt=""></a></p>
<p>gitalk 使用 Github 帐号登录，界面干净整洁，最喜欢的一点是支持 <code>MarkDown语法</code>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Gitalk 是一个利用 Github API,基于 Github issue 和 Preact 开发的评论插件，在 Gitalk 之前还有一个 <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a> 插件也是基于这个原理开发的,不过 gitment 已经很久没人维护了。</p>
<p>可以看到在 gitalk 的评论框进行评论时，其实就是在对应的 issue 上提问题。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm5916av1j30i209rab7.jpg" alt="gitalk评论框"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm596ggkfj30mx0gfjuk.jpg" alt="Github issue"></p>
<h3 id="集成-Gitalk"><a href="#集成-Gitalk" class="headerlink" title="集成 Gitalk"></a>集成 Gitalk</h3><p>到这里，你应该对 Gitalk 有个大致的了解了，现在，开始集成 gitalk 插件吧。</p>
<p>将这段代码插入到你的网站：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- Gitalk 评论 start  --&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> site.gitalk.enable %&#125;</span><br><span class="line">&lt;!-- Link Gitalk 的支持文件  --&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://unpkg.com/gitalk@latest/dist/gitalk.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gitalk的主要参数</span></span><br><span class="line">		clientID: <span class="string">`Github Application clientID`</span>,</span><br><span class="line">		clientSecret: <span class="string">`Github Application clientSecret`</span>,</span><br><span class="line">		repo: <span class="string">`存储你评论 issue 的 Github 仓库名`</span>,</span><br><span class="line">		owner: <span class="string">'Github 用户名'</span>,</span><br><span class="line">		admin: [<span class="string">'Github 用户名'</span>],</span><br><span class="line">		id: <span class="string">'页面的唯一标识，gitalk会根据这个标识自动创建的issue的标签'</span>,</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    gitalk.render(<span class="string">'gitalk-container'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp">&lt;!-- Gitalk end --&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们需要关心的就是配置下面几个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">clientID: <span class="string">`Github Application clientID`</span>,</span><br><span class="line">clientSecret: <span class="string">`Github Application clientSecret`</span>,</span><br><span class="line">repo: <span class="string">`Github 仓库名`</span>,<span class="comment">//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）</span></span><br><span class="line">owner: <span class="string">'Github 用户名'</span>,</span><br><span class="line">admin: [<span class="string">'Github 用户名'</span>], <span class="comment">//这个仓库的管理员，可以有多个，用数组表示，一般写自己,</span></span><br><span class="line">id: <span class="string">'window.location.pathname'</span>, <span class="comment">//页面的唯一标识，gitalk 会根据这个标识自动创建的issue的标签,我们使用页面的相对路径作为标识</span></span><br></pre></td></tr></table></figure>
<p>当然，还有其他很多参数，有兴趣的话可以 <a href="https://github.com/gitalk/gitalk#options" target="_blank" rel="noopener"> 点这里</a>。</p>
<p>比如我就增加了这个全屏遮罩的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distractionFreeMode: true,</span><br></pre></td></tr></table></figure>

<h3 id="创建-Github-Application"><a href="#创建-Github-Application" class="headerlink" title="创建 Github Application"></a>创建 Github Application</h3><p>Gitalk 需要一个 <strong>Github Application</strong>，<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击这里申请</a>。</p>
<p>填写下面参数：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jaib6fj30jo0gaacs.jpg" alt=""></p>
<p>点击创建</p>
<p>获取 <code>Client ID</code> 和 <code>Client Secret</code> 填入你的我们 Gitalk 参数中</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jrzff6j30lc0budhp.jpg" alt=""></p>
<p>当你参数都设置好，将代码推送到 Github 仓库后，没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。</p>
<p>当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 <code>repo</code> 的仓库下创建对应 issue。</p>
<p>比如说这样：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmm867n88cj30l809mjse.jpg" alt=""></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm8a0i0jkj30rr0ct42t.jpg" alt=""></p>
<p>当然，你也可以手动创建issue作为 gitalk评论容器。只要有 <code>Gitalk</code> 标签 和 <code>id</code> 对应标签就可以。比我我自己创建的 <a href="https://github.com/qiubaiying/qiubaiying.github.io/issues/38" target="_blank" rel="noopener">About issue</a> 。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>最后说几句吐嘈几句， Gitalk 需要你点开每篇文章的页面才会创建对应的 issue,对我来说真是个糟糕的体验（文章有点多~）。</p>
<p>当然，也有解决办法，这篇 <a href="https://draveness.me/git-comments-initialize" target="_blank" rel="noopener">自动初始化 Gitalk 和 Gitment 评论</a>，就解决了这个问题。</p>
<p>最后，<a href="https://github.com/qiubaiying/qiubaiying.github.io" target="_blank" rel="noopener">给个 star 吧</a>~</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
